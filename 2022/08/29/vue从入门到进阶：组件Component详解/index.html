<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Vue-什么是组件 | 我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文章目录  一.什么是组件？ 二.注册组件 全局注册 局部注册   三.Prop 使用 Prop 传递数据 动态 Prop 字面量语法 vs 动态语法 单向数据流 Prop 验证   四.非Prop特性 五.自定义事件 使用 v-on 绑定自定义事件 给组件绑定原生事件.native .sync 修饰符(2.3.0+) 使用自定义事件的表单输入组件 自定义组件的 v-model（2.2.0 新增）">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue-什么是组件">
<meta property="og:url" content="https://18821767806wxg.github.io/2022/08/29/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%BB%84%E4%BB%B6Component%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="文章目录  一.什么是组件？ 二.注册组件 全局注册 局部注册   三.Prop 使用 Prop 传递数据 动态 Prop 字面量语法 vs 动态语法 单向数据流 Prop 验证   四.非Prop特性 五.自定义事件 使用 v-on 绑定自定义事件 给组件绑定原生事件.native .sync 修饰符(2.3.0+) 使用自定义事件的表单输入组件 自定义组件的 v-model（2.2.0 新增）">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-29T07:35:54.000Z">
<meta property="article:modified_time" content="2022-08-29T07:35:54.000Z">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/10/">React博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-vue从入门到进阶：组件Component详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%BB%84%E4%BB%B6Component%E8%AF%A6%E8%A7%A3/" class="article-date">
  	<time datetime="2022-08-29T07:35:54.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Vue-什么是组件
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文章目录</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader0">一.什么是组件？</a></li>
<li>二.注册组件<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader2">全局注册</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader3">局部注册</a></li>
</ul>
</li>
<li>三.Prop<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader5">使用 Prop 传递数据</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader6">动态 Prop</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader7">字面量语法 vs 动态语法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader8">单向数据流</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader9">Prop 验证</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader10">四.非Prop特性</a></li>
<li>五.自定义事件<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader12">使用 v-on 绑定自定义事件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader13">给组件绑定原生事件.native</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader14">.sync 修饰符(2.3.0+)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader15">使用自定义事件的表单输入组件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader16">自定义组件的 v-model（2.2.0 新增）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader17">非父子组件的通信</a></li>
</ul>
</li>
<li>六.使用插槽slot分发内容<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader19">单个插槽</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader20">具名插槽</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader21">作用域插槽(2.1.0 新增)</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader22">七.动态组件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader23">keep-alive</a></li>
<li>八.杂项<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader25">编写可复用组件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader26">子组件引用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader27">异步组件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader28">高级异步组件(2.3.0 新增)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader29">组件命名约定</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader30">递归组件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader31">组件间的循环引用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader32">X-Template</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader33">对低开销的静态组件使用 v-once</a></li>
</ul>
</li>
</ul>
<h2 id="一-什么是组件？"><a href="#一-什么是组件？" class="headerlink" title="一.什么是组件？"></a>一.什么是组件？</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用<code>is</code>特性进行了扩展的原生 HTML 元素。</p>
<blockquote>
<p>所有的<code>Vue 组件</code>同时也都是 <code>Vue 的实例</code>，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p>
</blockquote>
<h2 id="二-注册组件"><a href="#二-注册组件" class="headerlink" title="二.注册组件"></a>二.注册组件</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>html代码：</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
</code></pre>
<p>JS代码：</p>
<pre><code>// 注册
Vue.component(&#39;my-component&#39;, &#123;
  template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39;
&#125;)
var vm = new Vue(&#123;
  el: &#39;#example&#39;,
  data: &#123;
       
  &#125; 
&#125;)
</code></pre>
<p>渲染结果为：</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;div&gt;A custom component!&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>或者另外一种注册方式，通过 全局API：<code>Vue.extend()</code><br>代码如下：</p>
<pre><code>// 注册
var MyComponent = Vue.extend(&#123;
  template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39;
&#125;);

// 注册
Vue.component(&#39;my-component&#39;, MyComponent);
var vm = new Vue(&#123;
  el: &#39;#example&#39;,
  data: &#123;
       
  &#125;
&#125;)
</code></pre>
<h4 id="Vue-extend-使用说明"><a href="#Vue-extend-使用说明" class="headerlink" title="Vue.extend()使用说明"></a>Vue.extend()使用说明</h4><p>下面说明下<code>Vue.extend( options )</code>的使用。<br>参数：<code>&#123;Object&#125; options</code><br>用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个<code>包含组件选项的对象</code>。<br><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code>中它必须是<code>函数</code>。</p>
<pre><code>&lt;div id=&quot;mount-point&quot;&gt;&lt;/div&gt;
// 创建构造器
var Profile = Vue.extend(&#123;
  template: &#39;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#39;,
  data: function () &#123;
    return &#123;
      firstName: &#39;Walter&#39;,
      lastName: &#39;White&#39;,
      alias: &#39;Heisenberg&#39;
    &#125;
  &#125;
&#125;)
// 创建 Profile 实例，并挂载到一个元素上。
new Profile().$mount(&#39;#mount-point&#39;)
</code></pre>
<p>结果如下：</p>
<pre><code>&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;
</code></pre>
<p>上面又用到了实例方法<code>vm.$mount()</code>，下面说明下它的使用方式。</p>
<h4 id="vm-mount-elementOrSelector-使用说明"><a href="#vm-mount-elementOrSelector-使用说明" class="headerlink" title="vm.$mount( [elementOrSelector] )使用说明"></a>vm.$mount( [elementOrSelector] )使用说明</h4><p>参数：</p>
<ul>
<li><code>&#123;Element | string&#125; [elementOrSelector]</code></li>
<li><code>&#123;boolean&#125; [hydrating]</code></li>
</ul>
<p>返回值：<code>vm</code> - 实例自身<br>用法：<br>如果 <code>Vue</code> 实例在实例化时没有收到<code>el</code>选项，则它处于“<code>未挂载</code>”状态，没有关联的<code>DOM</code>元素。可以使用<code>vm.$mount()</code>手动地挂载一个未挂载的实例。</p>
<p>如果没有提供 <code>elementOrSelector</code>参数，模板将被渲染为文档之外的的元素，并且你必须使用<code>原生 DOM API</code>把它插入文档中。</p>
<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>
<pre><code>var MyComponent = Vue.extend(&#123;
  template: &#39;&lt;div&gt;Hello!&lt;/div&gt;&#39;
&#125;)

// 创建并挂载到 #app (会替换 #app)
new MyComponent().$mount(&#39;#app&#39;)

// 同上
new MyComponent(&#123; el: &#39;#app&#39; &#125;)

// 或者，在文档之外渲染并且随后挂载
var component = new MyComponent().$mount()
document.getElementById(&#39;app&#39;).appendChild(component.$el)
</code></pre>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>你不必把每个组件都注册到全局。你可以通过某个 Vue 实例/组件的实例选项 components 注册仅在其作用域中可用的组件：</p>
<pre><code>var Child = &#123;
  template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39;
&#125;

new Vue(&#123;
  // ...
  components: &#123;
    // &lt;my-component&gt; 将只在父组件模板中可用
    &#39;my-component&#39;: Child
  &#125;
&#125;)
</code></pre>
<p>这种封装也适用于其它可注册的 Vue 功能，比如<code>指令</code>。</p>
<h4 id="DOM-模板解析注意事项"><a href="#DOM-模板解析注意事项" class="headerlink" title="DOM 模板解析注意事项"></a>DOM 模板解析注意事项</h4><p>像 <code>&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;、&lt;select&gt;</code> 这样的元素里允许包含的元素有限制，而另一些像 <code>&lt;option&gt;</code> 这样的元素只能出现在某些特定元素的内部。</p>
<p>例如：</p>
<pre><code>&lt;table&gt;
  &lt;my-row&gt;...&lt;/my-row&gt;
&lt;/table&gt;
</code></pre>
<p>自定义组件<code>&lt;my-row&gt;</code> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的<code>is</code>特性：</p>
<pre><code>&lt;table&gt;
  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p><strong>应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制：</strong></p>
<ul>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li><code>JavaScript</code> 内联模板字符串</li>
<li><code>.vue</code> 组件</li>
</ul>
<p>因此，请尽可能使用字符串模板。</p>
<h4 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data 必须是函数"></a>data 必须是函数</h4><p>如下代码：</p>
<pre><code>Vue.component(&#39;my-component&#39;, &#123;
  template: &#39;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#39;,
  data: &#123;
    message: &#39;hello&#39;
  &#125;
&#125;)
</code></pre>
<p>那么 Vue 会停止运行，并在控制台发出警告，告诉你在组件实例中 <code>data</code> 必须是一个函数。<br>我们来理解下，看下面代码：</p>
<pre><code>&lt;div id=&quot;example-2&quot;&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
&lt;/div&gt;
var data = &#123; counter: 0 &#125;

Vue.component(&#39;simple-counter&#39;, &#123;
  template: &#39;&lt;button v-on:click=&quot;counter += 1&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&#39;,
  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
  // 但是我们却给每个组件实例返回了同一个对象的引用
  data: function () &#123;
    return data
  &#125;
&#125;)

new Vue(&#123;
  el: &#39;#example-2&#39;
&#125;)
</code></pre>
<p>由于这三个组件实例<code>共享</code>了同一个<code>data</code>对象，因此递增一个 <code>counter</code>会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p>
<pre><code>data: function () &#123;
  return &#123;
    counter: 0
  &#125;
&#125;
</code></pre>
<p>现在每个 counter 都有它自己内部的状态了,不会相互影响。</p>
<h2 id="三-Prop"><a href="#三-Prop" class="headerlink" title="三.Prop"></a>三.Prop</h2><p>最常见的应用就是：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。</p>
<p>在 Vue 中，父子组件的关系可以总结为 <code>prop</code> 向下传递，<code>事件</code>向上传递。父组件通过 <code>prop</code> 给子组件下发数据，子组件通过<code>事件</code>给父组件发送消息。</p>
<h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><p>实例1：</p>
<pre><code>Vue.component(&#39;child&#39;, &#123;
  // 声明 props
  props: [&#39;message&#39;],
  // 就像 data 一样，prop 也可以在模板中使用
  // 同样也可以在 vm 实例中通过 this.message 来使用
  template: &#39;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#39;
&#125;)

&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;
</code></pre>
<p>结果：<code>hello!</code></p>
<p>实例2：<br>HTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：</p>
<pre><code>Vue.component(&#39;child&#39;, &#123;
  // 在 JavaScript 中使用 camelCase
  props: [&#39;myMessage&#39;],
  template: &#39;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&#39;
&#125;)

&lt;!-- 在 HTML 中使用 kebab-case --&gt;
&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;
</code></pre>
<p>如果你使用字符串模板，则没有这些限制。</p>
<h3 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h3><pre><code>&lt;div&gt;
  &lt;input v-model=&quot;parentMsg&quot;&gt;
  &lt;br&gt;
  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
&lt;/div&gt;
</code></pre>
<p>你也可以使用 v-bind 的缩写语法：</p>
<pre><code>&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
</code></pre>
<p>**<code>（重要）</code>**如果你想把一个<code>对象</code>的所有<code>属性</code>作为 prop 进行传递，可以使用不带任何参数的 <code>v-bind</code>(即用 v-bind 而不是 v-bind:prop-name)。例如，已知一个<code>todo</code> 对象：</p>
<pre><code>todo: &#123;
  text: &#39;Learn Vue&#39;,
  isComplete: false
&#125;
</code></pre>
<p>然后：</p>
<pre><code>&lt;todo-item v-bind=&quot;todo&quot;&gt;&lt;/todo-item&gt;
</code></pre>
<p>将等价于：</p>
<pre><code>&lt;todo-item
  v-bind:text=&quot;todo.text&quot;
  v-bind:is-complete=&quot;todo.isComplete&quot;
&gt;&lt;/todo-item&gt;
</code></pre>
<h3 id="字面量语法-vs-动态语法"><a href="#字面量语法-vs-动态语法" class="headerlink" title="字面量语法 vs 动态语法"></a>字面量语法 vs 动态语法</h3><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>
<pre><code>&lt;!-- 传递了一个字符串 &quot;1&quot; --&gt;
&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;
</code></pre>
<p>因为它是一个字面量 <code>prop</code>，它的值是字符串 “1” 而不是一个数值。如果想传递一个真正的 JavaScript 数值，则需要使用 <code>v-bind</code>，从而让它的值被当作 <code>JavaScript 表达式</code>计算：</p>
<pre><code>&lt;!-- 传递真正的数值 --&gt;
&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;
</code></pre>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</p>
<p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你<code>不应该</code>在子组件内部改变<code>prop</code>。如果你这么做了，Vue 会在控制台给出警告。</p>
<p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p>
<ul>
<li>Prop 作为初始值传入后，子组件想把它当作局部数据来用；</li>
<li>Prop 作为原始数据传入，由子组件处理成其它数据输出。</li>
</ul>
<p>对这两种情况，正确的应对方式是：<br>1.定义一个局部变量，并用 prop 的值初始化它：</p>
<pre><code>props: [&#39;initialCounter&#39;],
data: function () &#123;
  return &#123; counter: this.initialCounter &#125;
&#125;
</code></pre>
<p>2.定义一个计算属性，处理 prop 的值并返回：</p>
<pre><code>props: [&#39;size&#39;],
computed: &#123;
  normalizedSize: function () &#123;
    return this.size.trim().toLowerCase()
  &#125;
&#125;
</code></pre>
<blockquote>
<p>注意在 JavaScript 中<code>对象</code>和<code>数组</code>是引用类型，指向<code>同一个内存空间</code>，如果 prop 是一个对象或数组，在子组件内部改变它<code>会影响</code>父组件的状态。</p>
</blockquote>
<h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><p>我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。<br>要指定验证规则，需要用<code>对象的形式</code>来定义 prop，而<code>不能用字符串数组</code>：</p>
<pre><code>Vue.component(&#39;example&#39;, &#123;
  props: &#123;
    // 基础类型检测 (`null` 指允许任何类型)
    propA: Number,
    // 可能是多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: &#123;
      type: String,
      required: true
    &#125;,
    // 数值且有默认值
    propD: &#123;
      type: Number,
      default: 100
    &#125;,
    // 数组/对象的默认值应当由一个工厂函数返回
    propE: &#123;
      type: Object,
      default: function () &#123;
        return &#123; message: &#39;hello&#39; &#125;
      &#125;
    &#125;,
    // 自定义验证函数
    propF: &#123;
      validator: function (value) &#123;
        return value &gt; 10
      &#125;
    &#125;
  &#125;
&#125;)
</code></pre>
<p><code>type</code> 可以是下面原生构造器：String ，Number，Boolean，Function，Object，Array，Symbol。</p>
<p><code>type</code> 也可以是一个自定义构造器函数，使用 <code>instanceof</code> 检测。</p>
<p>当<code>prop</code>验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 prop 会在组件实例创建之前进行校验，所以在<code>default</code> 或 <code>validator</code> 函数里，诸如 <code>data</code>、<code>computed</code> 或 <code>methods</code> 等实例属性还无法使用。</p>
<p>其它实例：</p>
<pre><code>Vue.component(&#39;modal&#39;, &#123;
  template: &#39;#modal-template&#39;,
  props: &#123;
    show: &#123;
      type: Boolean,
      required: true,
      twoWay: true    
    &#125;
  &#125;
&#125;);
</code></pre>
<p><code>twoWay Prop</code> 的参数 <code>移除</code>。Props 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。所以上面的的最后一个实例只是贴出来代码而已，最新版本已经移除了。</p>
<h2 id="四-非Prop特性"><a href="#四-非Prop特性" class="headerlink" title="四.非Prop特性"></a>四.非Prop特性</h2><p>所谓非 prop 特性，就是指它可以直接传入组件，而不需要定义相应的 prop。</p>
<p>尽管为组件定义明确的 prop 是推荐的传参方式，组件的作者却并不总能预见到组件被使用的场景。所以，<code>组件可以接收任意传入的特性</code>，这些特性都会被添加到组件的<code>根元素上</code>。</p>
<p>例如，假设我们使用了第三方组件 bs-date-input，它包含一个 Bootstrap 插件，该插件需要在 input 上添加 data-3d-date-picker 这个特性。这时可以把特性直接添加到组件上 (不需要事先定义 prop)：</p>
<pre><code>&lt;bs-date-input data-3d-date-picker=&quot;true&quot;&gt;&lt;/bs-date-input&gt;
</code></pre>
<p>添加属性 <code>data-3d-date-picker=&quot;true&quot;</code> 之后，它会被自动添加到<code>bs-date-input</code> 的根元素上。</p>
<p>假设这是 bs-date-input 的模板：</p>
<pre><code>&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;
</code></pre>
<p>为了给该日期选择器插件增加一个特殊的主题，我们可能需要增加一个特殊的 class，比如：</p>
<pre><code>&lt;bs-date-input
  data-3d-date-picker=&quot;true&quot;
  class=&quot;date-picker-theme-dark&quot;
&gt;&lt;/bs-date-input&gt;
</code></pre>
<p>最终在根元素上生成的class值为：form-control date-picker-theme-dark。</p>
<h2 id="五-自定义事件"><a href="#五-自定义事件" class="headerlink" title="五.自定义事件"></a>五.自定义事件</h2><p>我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。</p>
<h3 id="使用-v-on-绑定自定义事件"><a href="#使用-v-on-绑定自定义事件" class="headerlink" title="使用 v-on 绑定自定义事件"></a>使用 v-on 绑定自定义事件</h3><p>每个 Vue 实例都实现了事件接口，即：</p>
<ul>
<li>使用 $on(eventName) 监听事件</li>
<li>使用 $emit(eventName) 触发事件</li>
</ul>
<blockquote>
<p>Vue 的事件系统与浏览器的 <code>EventTarget API</code> 有所不同。尽管它们的运行起来类似，但是 <code>$on</code>和 <code>$emit</code> 并不是<code>addEventListener</code> 和<code>dispatchEvent</code> 的别名。</p>
</blockquote>
<p>另外，父组件可以在使用子组件的地方直接用 <code>v-on</code> 来监听子组件触发的事件。</p>
<p>不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定，参见下面的例子。</p>
<pre><code>&lt;div id=&quot;counter-event-example&quot;&gt;
  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;
  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;
  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;
&lt;/div&gt;
Vue.component(&#39;button-counter&#39;, &#123;
  template: &#39;&lt;button v-on:click=&quot;incrementCounter&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&#39;,
  data: function () &#123;
    return &#123;
      counter: 0
    &#125;
  &#125;,
  methods: &#123;
    incrementCounter: function () &#123;
      this.counter += 1
      this.$emit(&#39;increment&#39;)
    &#125;
  &#125;,
&#125;)

new Vue(&#123;
  el: &#39;#counter-event-example&#39;,
  data: &#123;
    total: 0
  &#125;,
  methods: &#123;
    incrementTotal: function () &#123;
      this.total += 1
    &#125;
  &#125;
&#125;)
</code></pre>
<h3 id="给组件绑定原生事件-native"><a href="#给组件绑定原生事件-native" class="headerlink" title="给组件绑定原生事件.native"></a>给组件绑定原生事件.native</h3><p>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 <code>.native</code>。例如：</p>
<pre><code>&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;
</code></pre>
<h3 id="sync-修饰符-2-3-0"><a href="#sync-修饰符-2-3-0" class="headerlink" title=".sync 修饰符(2.3.0+)"></a>.sync 修饰符(2.3.0+)</h3><pre><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;
</code></pre>
<p>会被扩展为：</p>
<pre><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;
</code></pre>
<p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>
<pre><code>this.$emit(&#39;update:foo&#39;, newValue)
</code></pre>
<h3 id="使用自定义事件的表单输入组件"><a href="#使用自定义事件的表单输入组件" class="headerlink" title="使用自定义事件的表单输入组件"></a>使用自定义事件的表单输入组件</h3><p>自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。要牢记：</p>
<pre><code>&lt;input v-model=&quot;something&quot;&gt;
</code></pre>
<p>这不过是以下示例的语法糖：</p>
<pre><code>&lt;input
  v-bind:value=&quot;something&quot;
  v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre>
<p>所以在组件中使用时，它相当于下面的简写：</p>
<pre><code>&lt;custom-input
  v-bind:value=&quot;something&quot;
  v-on:input=&quot;something = arguments[0]&quot;&gt;
&lt;/custom-input&gt;
</code></pre>
<p>所以要让组件的 v-model 生效，它应该 (从 2.2.0 起是可配置的)：</p>
<ul>
<li>接受一个 <code>value prop</code></li>
<li>在有新的值时触发 <code>input</code> 事件并将新值作为参数</li>
</ul>
<p>例子1：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
      &lt;custom-input v-model=&quot;something&quot;&gt;&lt;/custom-input&gt;
    &lt;br/&gt;
    &#123;&#123;something&#125;&#125;
&lt;/div&gt;
// 注册
Vue.component(&#39;custom-input&#39;, &#123;
  props:[&#39;something&#39;],
  template: &#39;&lt;input type=&quot;text&quot;  v-bind:value=&quot;something&quot; v-on:input=&quot;updateValue($event.target.value)&quot;/&gt;&#39;,
  methods:&#123;
      updateValue:function(value)&#123;
           this.$emit(&#39;input&#39;, value)
      &#125;
  &#125;
&#125;)
var vm = new Vue(&#123;
  el: &#39;#app&#39;,
  data: &#123;
       something:&#39;&#39;
  &#125;
  
&#125;)
</code></pre>
<p>例子2：货币输入的自定义控件</p>
<pre><code>&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currency-input&gt;
Vue.component(&#39;currency-input&#39;, &#123;
  template: &#39;\
    &lt;span&gt;\
      $\
      &lt;input\
        ref=&quot;input&quot;\
        v-bind:value=&quot;value&quot;\
        v-on:input=&quot;updateValue($event.target.value)&quot;\
      &gt;\
    &lt;/span&gt;\
  &#39;,
  props: [&#39;value&#39;],
  methods: &#123;
    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制
    updateValue: function (value) &#123;
      var formattedValue = value
        // 删除两侧的空格符
        .trim()
        // 保留 2 位小数
        .slice(
          0,
          value.indexOf(&#39;.&#39;) === -1
            ? value.length
            : value.indexOf(&#39;.&#39;) + 3
        )
      // 如果值尚不合规，则手动覆盖为合规的值
      if (formattedValue !== value) &#123;
        this.$refs.input.value = formattedValue
      &#125;
      // 通过 input 事件带出数值
      this.$emit(&#39;input&#39;, Number(formattedValue))
    &#125;
  &#125;
&#125;)
</code></pre>
<p>实例3：更加完善的货币过滤器</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;currency-input 
    label=&quot;Price&quot; 
    v-model=&quot;price&quot;
  &gt;&lt;/currency-input&gt;
  &lt;currency-input 
    label=&quot;Shipping&quot; 
    v-model=&quot;shipping&quot;
  &gt;&lt;/currency-input&gt;
  &lt;currency-input 
    label=&quot;Handling&quot; 
    v-model=&quot;handling&quot;
  &gt;&lt;/currency-input&gt;
  &lt;currency-input 
    label=&quot;Discount&quot; 
    v-model=&quot;discount&quot;
  &gt;&lt;/currency-input&gt;
  
  &lt;p&gt;Total: $&#123;&#123; total &#125;&#125;&lt;/p&gt;
&lt;/div&gt;
Vue.component(&#39;currency-input&#39;, &#123;
  template: &#39;\
    &lt;div&gt;\
      &lt;label v-if=&quot;label&quot;&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;\
      $\
      &lt;input\
        ref=&quot;input&quot;\
        v-bind:value=&quot;value&quot;\
        v-on:input=&quot;updateValue($event.target.value)&quot;\
        v-on:focus=&quot;selectAll&quot;\
        v-on:blur=&quot;formatValue&quot;\
      &gt;\
    &lt;/div&gt;\
  &#39;,
  props: &#123;
    value: &#123;
      type: Number,
      default: 0
    &#125;,
    label: &#123;
      type: String,
      default: &#39;&#39;
    &#125;
  &#125;,
  mounted: function () &#123;
    this.formatValue()
  &#125;,
  methods: &#123;
    updateValue: function (value) &#123;
      var result = currencyValidator.parse(value, this.value)
      if (result.warning) &#123;
        this.$refs.input.value = result.value
      &#125;
      this.$emit(&#39;input&#39;, result.value)
    &#125;,
    formatValue: function () &#123;
      this.$refs.input.value = currencyValidator.format(this.value)
    &#125;,
    selectAll: function (event) &#123;
      // Workaround for Safari bug
      // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome
      setTimeout(function () &#123;
          event.target.select()
      &#125;, 0)
    &#125;
  &#125;
&#125;)

new Vue(&#123;
  el: &#39;#app&#39;,
  data: &#123;
    price: 0,
    shipping: 0,
    handling: 0,
    discount: 0
  &#125;,
  computed: &#123;
    total: function () &#123;
      return ((
        this.price * 100 + 
        this.shipping * 100 + 
        this.handling * 100 - 
        this.discount * 100
      ) / 100).toFixed(2)
    &#125;
  &#125;
&#125;)
</code></pre>
<h3 id="自定义组件的-v-model（2-2-0-新增）"><a href="#自定义组件的-v-model（2-2-0-新增）" class="headerlink" title="自定义组件的 v-model（2.2.0 新增）"></a>自定义组件的 v-model（2.2.0 新增）</h3><p>默认情况下，一个组件的 v-model 会使用 value prop 和 input 事件。但是诸如单选框、复选框之类的输入类型可能把 value 用作了别的目的。model 选项可以避免这样的冲突：</p>
<pre><code>Vue.component(&#39;my-checkbox&#39;, &#123;
  model: &#123;
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  &#125;,
  props: &#123;
    checked: Boolean,
    // 这样就允许拿 `value` 这个 prop 做其它事了
    value: String
  &#125;,
  // ...
&#125;)
&lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;
</code></pre>
<p>上述代码等价于：</p>
<pre><code>&lt;my-checkbox
  :checked=&quot;foo&quot;
  @change=&quot;val =&gt; &#123; foo = val &#125;&quot;
  value=&quot;some value&quot;&gt;
&lt;/my-checkbox&gt;
</code></pre>
<blockquote>
<p>注意你仍然需要显式声明 <code>checked</code> 这个<code>prop</code>。</p>
</blockquote>
<p>完整的代码：<br>html：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
      &lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;
    &#123;&#123;foo&#125;&#125;
&lt;/div&gt;
</code></pre>
<p>JS代码：</p>
<pre><code>Vue.component(&#39;my-checkbox&#39;, &#123;
  model: &#123;
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  &#125;,
  props: &#123;
    checked: Boolean,
    // 这样就允许拿 `value` 这个 prop 做其它事了
    value: String
  &#125;,
  template:&#39;&lt;input type=&quot;checkbox&quot; @change=&quot;changefun(ischecked)&quot;/&gt;&#39;,
  data:function()&#123;
      return &#123;
          ischecked:this.checked
      &#125;
  &#125;,
  methods:&#123;
      changefun(state)&#123;
          this.ischecked = !state;
          this.$emit(&#39;change&#39;, this.ischecked);
      &#125;
  &#125;
&#125;)
var vm = new Vue(&#123;
  el: &#39;#app&#39;,
  data: &#123;
       foo:false
  &#125;
  
&#125;)
</code></pre>
<h3 id="非父子组件的通信"><a href="#非父子组件的通信" class="headerlink" title="非父子组件的通信"></a>非父子组件的通信</h3><p>有时候，非父子关系的两个组件之间也需要通信。在简单的场景下，可以使用一个空的 Vue 实例作为事件总线：</p>
<pre><code>var bus = new Vue()
// 触发组件 A 中的事件
bus.$emit(&#39;id-selected&#39;, 1)
// 在组件 B 创建的钩子中监听事件
bus.$on(&#39;id-selected&#39;, function (id) &#123;
  // ...
&#125;)
</code></pre>
<p>在复杂的情况下，我们应该考虑使用专门的状态管理模式<code>Vuex</code>。</p>
<p>来看一个完整的例子：<br>html代码：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
     &lt;comp-a v-on:id-selected=&quot;getdate&quot;&gt;&lt;/comp-a&gt;
     &lt;comp-b&gt;&lt;/comp-b&gt;
&lt;/div&gt;
</code></pre>
<p>JS代码：</p>
<pre><code>var bus = new Vue();

Vue.component(&#39;comp-a&#39;, &#123;
  template:&#39;&lt;button class=&quot;compa&quot; @click=&quot;comfuna&quot;&gt;组件A&lt;/button&gt;&#39;,
  data:function()&#123;
      return &#123;
          
      &#125;
  &#125;,
  methods:&#123;
      comfuna()&#123;
          bus.$emit(&#39;id-selected&#39;, 1);
          this.$emit(&#39;id-selected&#39;, 1);
      &#125;
  &#125;
&#125;)
Vue.component(&#39;comp-b&#39;, &#123;
  template:&#39;&lt;div class=&quot;compb&quot;&gt;组件B&lt;/div&gt;&#39;,
  data:function()&#123;
      return &#123;
          
      &#125;
  &#125;,
  mounted()&#123;
      // 在组件 B 创建的钩子中监听事件
    bus.$on(&#39;id-selected&#39;, function (id) &#123;
         console.log(&#39;在B组件中得到的值：&#39;+id);
    &#125;)
  &#125;
 
&#125;)
var vm = new Vue(&#123;
  el: &#39;#app&#39;,
  data: &#123;&#125;,
  methods:&#123;
      getdate(value)&#123;
          console.log(&#39;得到当前的值：&#39;+value);
      &#125;
  &#125;
  
&#125;)
</code></pre>
<h2 id="六-使用插槽slot分发内容"><a href="#六-使用插槽slot分发内容" class="headerlink" title="六.使用插槽slot分发内容"></a>六.使用插槽slot分发内容</h2><p>在使用组件时，我们常常要像这样组合它们：</p>
<pre><code>&lt;app&gt;
  &lt;app-header&gt;&lt;/app-header&gt;
  &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/app&gt;
</code></pre>
<p>注意两点：</p>
<ul>
<li><code>&lt;app&gt;</code> 组件不知道它会收到什么内容。这是由使用 <code>&lt;app&gt;</code> 的父组件决定的。</li>
<li><code>&lt;app&gt;</code> 组件很可能有它自己的模板。</li>
</ul>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p>
<p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p>
<pre><code>&lt;!-- 无效 --&gt;
&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;
</code></pre>
<p>正确做法：</p>
<pre><code>Vue.component(&#39;child-component&#39;, &#123;
  // 有效，因为是在正确的作用域内
  template: &#39;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&#39;,
  data: function () &#123;
    return &#123;
      someChildProperty: true
    &#125;
  &#125;
&#125;)
</code></pre>
<h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><p>假定 my-component 组件有如下模板：</p>
<pre><code>&lt;div&gt;
  &lt;h2&gt;我是子组件的标题&lt;/h2&gt;
  &lt;slot&gt;
    只有在没有要分发的内容时才会显示。
  &lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p>父组件模板：</p>
<pre><code>&lt;div&gt;
  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;
  &lt;my-component&gt;
    &lt;p&gt;这是一些初始内容&lt;/p&gt;
    &lt;p&gt;这是更多的初始内容&lt;/p&gt;
  &lt;/my-component&gt;
&lt;/div&gt;
</code></pre>
<p>渲染结果：</p>
<pre><code>&lt;div&gt;
  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;
  &lt;div&gt;
    &lt;h2&gt;我是子组件的标题&lt;/h2&gt;
    &lt;p&gt;这是一些初始内容&lt;/p&gt;
    &lt;p&gt;这是更多的初始内容&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>&lt;slot&gt;</code> 元素可以用一个特殊的特性 <code>name</code> 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 <code>slot</code> 特性的元素。</p>
<p>仍然可以有一个<strong>匿名插槽</strong>，它是<strong>默认插槽</strong>，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。</p>
<p>例如，假定我们有一个 app-layout 组件，它的模板为：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>父组件模板：</p>
<pre><code>&lt;app-layout&gt;
  &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;

  &lt;p&gt;主要内容的一个段落。&lt;/p&gt;
  &lt;p&gt;另一个主要段落。&lt;/p&gt;

  &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;
&lt;/app-layout&gt;
</code></pre>
<p>渲染结果为：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;
    &lt;p&gt;另一个主要段落。&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;p&gt;这里有一些联系信息&lt;/p&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<h3 id="作用域插槽-2-1-0-新增"><a href="#作用域插槽-2-1-0-新增" class="headerlink" title="作用域插槽(2.1.0 新增)"></a>作用域插槽(2.1.0 新增)</h3><p>作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。</p>
<p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p>
<pre><code>&lt;div class=&quot;child&quot;&gt;
  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p>在父级中，具有特殊特性 <code>slot-scope</code>的<code>&lt;template&gt;</code> 元素必须存在，表示它是作用域插槽的模板。<code>slot-scope</code>的值将被用作一个临时变量名，此变量接收从子组件传递过来的 <code>prop</code> 对象：</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;child&gt;
    &lt;template slot-scope=&quot;props&quot;&gt;
      &lt;span&gt;hello from parent&lt;/span&gt;
      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;
    &lt;/template&gt;
  &lt;/child&gt;
&lt;/div&gt;
</code></pre>
<p>如果我们渲染上述模板，得到的输出会是：</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;div class=&quot;child&quot;&gt;
    &lt;span&gt;hello from parent&lt;/span&gt;
    &lt;span&gt;hello from child&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>在 <code>2.5.0+</code>，<code>slot-scope</code> 能被用在任意元素或组件中而<code>不再局限于 &lt;template&gt;</code></p>
</blockquote>
<p>作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项：</p>
<pre><code>&lt;my-awesome-list :items=&quot;items&quot;&gt;
  &lt;!-- 作用域插槽也可以是具名的 --&gt;
  &lt;li
    slot=&quot;item&quot;
    slot-scope=&quot;props&quot;
    class=&quot;my-fancy-item&quot;&gt;
    &#123;&#123; props.text &#125;&#125;
  &lt;/li&gt;
&lt;/my-awesome-list&gt;
</code></pre>
<p>列表组件的模板：</p>
<pre><code>&lt;ul&gt;
  &lt;slot name=&quot;item&quot;
    v-for=&quot;item in items&quot;
    :text=&quot;item.text&quot;&gt;
    &lt;!-- 这里写入备用内容 --&gt;
  &lt;/slot&gt;
&lt;/ul&gt;
</code></pre>
<p><strong>解构</strong></p>
<p><code>slot-scope</code>的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境 (单文件组件或现代浏览器) 中，您还可以在表达式中使用 ES2015 解构：</p>
<pre><code>&lt;child&gt;
  &lt;span slot-scope=&quot;&#123; text &#125;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;
&lt;/child&gt;
</code></pre>
<h2 id="七-动态组件"><a href="#七-动态组件" class="headerlink" title="七.动态组件"></a>七.动态组件</h2><p>通过使用保留的<code>&lt;component&gt;</code>元素，并对其<code>is</code>特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：</p>
<pre><code>var vm = new Vue(&#123;
  el: &#39;#example&#39;,
  data: &#123;
    currentView: &#39;home&#39;
  &#125;,
  components: &#123;
    home: &#123; /* ... */ &#125;,
    posts: &#123; /* ... */ &#125;,
    archive: &#123; /* ... */ &#125;
  &#125;
&#125;)
&lt;component v-bind:is=&quot;currentView&quot;&gt;
  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;
&lt;/component&gt;
</code></pre>
<p>也可以直接绑定到组件对象上：</p>
<pre><code>var Home = &#123;
  template: &#39;&lt;p&gt;Welcome home!&lt;/p&gt;&#39;
&#125;

var vm = new Vue(&#123;
  el: &#39;#example&#39;,
  data: &#123;
    currentView: Home
  &#125;
&#125;)
</code></pre>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 <code>keep-alive</code> 指令参数：</p>
<pre><code>&lt;keep-alive&gt;
  &lt;component :is=&quot;currentView&quot;&gt;
    &lt;!-- 非活动组件将被缓存！ --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
<h2 id="八-杂项"><a href="#八-杂项" class="headerlink" title="八.杂项"></a>八.杂项</h2><h3 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h3><p>Vue 组件的 API 来自三部分——prop、事件和插槽：</p>
<ul>
<li><code>Prop</code> 允许外部环境传递数据给组件；</li>
<li><code>事件</code>允许从组件内触发外部环境的副作用；</li>
<li><code>插槽</code>允许外部环境将额外的内容组合在组件中。</li>
</ul>
<p>使用 v-bind 和 v-on 的简写语法，模板的意图会更清楚且简洁：</p>
<pre><code>&lt;my-component
  :foo=&quot;baz&quot;
  :bar=&quot;qux&quot;
  @event-a=&quot;doThis&quot;
  @event-b=&quot;doThat&quot;
&gt;
  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;
  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;
&lt;/my-component&gt;
</code></pre>
<h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><p>尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 <code>ref</code>为子组件指定一个引用 ID。例如：</p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;
&lt;/div&gt;
var parent = new Vue(&#123; el: &#39;#parent&#39; &#125;)
// 访问子组件实例
var child = parent.$refs.profile
</code></pre>
<p>当 <code>ref</code>和<code>v-for</code> 一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。</p>
<blockquote>
<p><code>$refs</code>只在组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 <code>$refs</code>。</p>
</blockquote>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了进一步简化，Vue.js 允许将组件定义为一个工厂函数，异步地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>
<pre><code>Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;
  setTimeout(function () &#123;
    // 将组件定义传入 resolve 回调函数
    resolve(&#123;
      template: &#39;&lt;div&gt;I am async!&lt;/div&gt;&#39;
    &#125;)
  &#125;, 1000)
&#125;)
</code></pre>
<p>工厂函数接收一个 <code>resolve</code> 回调，在收到从服务器下载的组件定义时调用。也可以调用 <code>reject(reason)</code>指示加载失败。这里使用 setTimeout 只是为了演示，实际上如何获取组件完全由你决定。</p>
<p>推荐配合 webpack 的代码分割功能 来使用：</p>
<pre><code>Vue.component(&#39;async-webpack-example&#39;, function (resolve) &#123;
  // 这个特殊的 require 语法告诉 webpack
  // 自动将编译后的代码分割成不同的块，
  // 这些块将通过 Ajax 请求自动下载。
  require([&#39;./my-async-component&#39;], resolve)
&#125;)
</code></pre>
<p>你可以在工厂函数中返回一个 Promise，所以当使用 webpack 2 + ES2015 的语法时可以这样：</p>
<pre><code>Vue.component(
  &#39;async-webpack-example&#39;,
  // 该 `import` 函数返回一个 `Promise` 对象。
  () =&gt; import(&#39;./my-async-component&#39;)
)
</code></pre>
<p>当使用局部注册时，也可以直接提供一个返回 Promise 的函数：</p>
<pre><code>new Vue(&#123;
  // ...
  components: &#123;
    &#39;my-component&#39;: () =&gt; import(&#39;./my-async-component&#39;)
  &#125;
&#125;)
</code></pre>
<h3 id="高级异步组件-2-3-0-新增"><a href="#高级异步组件-2-3-0-新增" class="headerlink" title="高级异步组件(2.3.0 新增)"></a>高级异步组件(2.3.0 新增)</h3><p>自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象：</p>
<pre><code>const AsyncComp = () =&gt; (&#123;
  // 需要加载的组件。应当是一个 Promise
  component: import(&#39;./MyComp.vue&#39;),
  // 加载中应当渲染的组件
  loading: LoadingComp,
  // 出错时渲染的组件
  error: ErrorComp,
  // 渲染加载中组件前的等待时间。默认：200ms。
  delay: 200,
  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity
  timeout: 3000
&#125;)
</code></pre>
<blockquote>
<p>注意，当一个异步组件被作为<code>vue-router</code>的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用 <code>vue-router 2.4.0 以上</code>的版本。</p>
</blockquote>
<h3 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h3><p>当注册组件 (或者 prop) 时，可以使用 kebab-case (短横线分隔命名)、camelCase (驼峰式命名) 或 PascalCase (单词首字母大写命名)。</p>
<pre><code>// 在组件定义中
components: &#123;
  // 使用 kebab-case 注册
  &#39;kebab-cased-component&#39;: &#123; /* ... */ &#125;,
  // 使用 camelCase 注册
  &#39;camelCasedComponent&#39;: &#123; /* ... */ &#125;,
  // 使用 PascalCase 注册
  &#39;PascalCasedComponent&#39;: &#123; /* ... */ &#125;
&#125;
</code></pre>
<p>在 HTML 模板中，请使用 kebab-case：</p>
<pre><code>&lt;!-- 在 HTML 模板中始终使用 kebab-case --&gt;
&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;
&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;
&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;
</code></pre>
<p>当使用字符串模式时，可以不受 HTML 大小写不敏感的限制。这意味实际上在模板中，你可以使用下面的方式来引用你的组件：</p>
<ul>
<li>kebab-case</li>
<li>camelCase 或 kebab-case (如果组件已经被定义为 camelCase)</li>
<li>kebab-case、camelCase 或 PascalCase (如果组件已经被定义为 PascalCase)</li>
</ul>
<pre><code>components: &#123;
  &#39;kebab-cased-component&#39;: &#123; /* ... */ &#125;,
  camelCasedComponent: &#123; /* ... */ &#125;,
  PascalCasedComponent: &#123; /* ... */ &#125;
&#125;
&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;

&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;
&lt;camelCasedComponent&gt;&lt;/camelCasedComponent&gt;

&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;
&lt;pascalCasedComponent&gt;&lt;/pascalCasedComponent&gt;
&lt;PascalCasedComponent&gt;&lt;/PascalCasedComponent&gt;
</code></pre>
<p>这意味着 PascalCase 是最通用的声明约定而 kebab-case 是最通用的使用约定。</p>
<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件在它的模板内可以递归地调用自己。不过，只有当它有<code>name</code> 选项时才可以这么做：</p>
<pre><code>name: &#39;unique-name-of-my-component&#39;
</code></pre>
<p>当你利用 <code>Vue.component</code> 全局注册了一个组件，全局的 <code>ID</code>会被自动设置为组件的 <code>name</code>。</p>
<pre><code>Vue.component(&#39;unique-name-of-my-component&#39;, &#123;
  // ...
&#125;)
</code></pre>
<p>如果稍有不慎，递归组件可能导致死循环：</p>
<pre><code>name: &#39;stack-overflow&#39;,
template: &#39;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#39;
</code></pre>
<p>上面组件会导致一个“max stack size exceeded”错误，所以要确保递归调用有终止条件 (比如递归调用时使用 <code>v-if</code>并最终解析为 <code>false</code>)。</p>
<h3 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a>组件间的循环引用</h3><p>假设你正在构建一个文件目录树，像在 Finder 或资源管理器中。你可能有一个 <code>tree-folder</code>组件：</p>
<pre><code>&lt;p&gt;
  &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt;
  &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;
&lt;/p&gt;
</code></pre>
<p>以及一个 tree-folder-contents 组件：</p>
<pre><code>&lt;ul&gt;
  &lt;li v-for=&quot;child in children&quot;&gt;
    &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;
    &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点——这是矛盾的！当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。</p>
<p>然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：</p>
<pre><code>Failed to mount component: template or render function not defined.
</code></pre>
<p>在我们的例子中，可以选择让 tree-folder 组件中来做这件事。我们知道引起矛盾的子组件是 tree-folder-contents，所以我们要等到 beforeCreate 生命周期钩子中才去注册它：</p>
<pre><code>beforeCreate: function () &#123;
  this.$options.components.TreeFolderContents = require(&#39;./tree-folder-contents.vue&#39;)
&#125;
</code></pre>
<h3 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a>X-Template</h3><p>另一种定义模板的方式是在 JavaScript 标签里使用 <code>text/x-template</code>类型，并且指定一个 id。例如：</p>
<pre><code>&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;
  &lt;p&gt;Hello hello hello&lt;/p&gt;
&lt;/script&gt;

Vue.component(&#39;hello-world&#39;, &#123;
  template: &#39;#hello-world-template&#39;
&#125;)
</code></pre>
<p>这在有很多大模板的演示应用或者特别小的应用中可能有用，其它场合应该避免使用，因为这将模板和组件的其它定义分离了。</p>
<h3 id="对低开销的静态组件使用-v-once"><a href="#对低开销的静态组件使用-v-once" class="headerlink" title="对低开销的静态组件使用 v-once"></a>对低开销的静态组件使用 <code>v-once</code></h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：</p>
<pre><code>Vue.component(&#39;terms-of-service&#39;, &#123;
  template: &#39;\
    &lt;div v-once&gt;\
      &lt;h1&gt;Terms of Service&lt;/h1&gt;\
      ...很多静态内容...\
    &lt;/div&gt;\
  &#39;
&#125;)
</code></pre>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Vue-Vue项目配置服务器的环境变量
        
      </div>
    </a>
  
  
    <a href="/2022/08/29/vue-cli4vue-cil3%E4%BD%BF%E7%94%A8process.env.VUE_APP_BASE_API%E5%85%A8%E5%B1%80%E5%9C%B0%E5%9D%80%E4%BB%A3%E6%9B%BFvue-cli2%E7%9A%84process.env.BASE_API/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Vue-vue-cli4/vue-cil3使用process.env.VUE_APP_BASE_API全局地址代替vue-cli2的process.env.BASE_API</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>