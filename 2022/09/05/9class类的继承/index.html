<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Es6-Class 的继承 | 我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Class 的继承 简介 私有属性和私有方法的继承 静态属性和静态方法的继承 Object.getPrototypeOf() [super 关键字](https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;class-extends#super 关键字) [类的 prototype 属性和__proto__属性](https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;clas">
<meta property="og:type" content="article">
<meta property="og:title" content="Es6-Class 的继承">
<meta property="og:url" content="https://18821767806wxg.github.io/2022/09/05/9class%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="Class 的继承 简介 私有属性和私有方法的继承 静态属性和静态方法的继承 Object.getPrototypeOf() [super 关键字](https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;class-extends#super 关键字) [类的 prototype 属性和__proto__属性](https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;clas">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-05T02:50:09.215Z">
<meta property="article:modified_time" content="2022-09-05T02:50:21.314Z">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-9class类的继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/9class%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/" class="article-date">
  	<time datetime="2022-09-05T02:50:09.215Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Es6-Class 的继承
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF">私有属性和私有方法的继承</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF">静态属性和静态方法的继承</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#Object.getPrototypeOf()">Object.getPrototypeOf()</a></li>
<li>[super 关键字](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#super">https://es6.ruanyifeng.com/#docs/class-extends#super</a> 关键字)</li>
<li>[类的 prototype 属性和__proto__属性](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%B1%BB%E7%9A%84">https://es6.ruanyifeng.com/#docs/class-extends#类的</a> prototype 属性和__proto__属性)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">原生构造函数的继承</a></li>
<li>[Mixin 模式的实现](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#Mixin">https://es6.ruanyifeng.com/#docs/class-extends#Mixin</a> 模式的实现)</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。</p>
<pre><code class="javascript">class Point &#123;
&#125;

class ColorPoint extends Point &#123;
&#125;
</code></pre>
<p>上面示例中，<code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。</p>
<p>下面，我们在<code>ColorPoint</code>内部加上代码。</p>
<pre><code class="javascript">class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  &#125;

  toString() &#123;
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象。</p>
<p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p>
<pre><code class="javascript">class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor() &#123;
  &#125;
&#125;

let cp = new ColorPoint(); // ReferenceError
</code></pre>
<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super()</code>，导致新建实例时报错。</p>
<p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p>
<p>注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。</p>
<pre><code class="javascript">class Foo &#123;
  constructor() &#123;
    console.log(1);
  &#125;
&#125;

class Bar extends Foo &#123;
  constructor() &#123;
    super();
    console.log(2);
  &#125;
&#125;

const bar = new Bar();
// 1
// 2
</code></pre>
<p>上面示例中，子类 Bar 新建实例时，会输出1和2。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p>
<pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;
&#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。</p>
<p>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。</p>
<pre><code class="javascript">class ColorPoint extends Point &#123;
&#125;

// 等同于
class ColorPoint extends Point &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;
</code></pre>
<p>有了子类的定义，就可以生成子类的实例了。</p>
<pre><code class="javascript">let cp = new ColorPoint(25, 8, &#39;green&#39;);

cp instanceof ColorPoint // true
cp instanceof Point // true
</code></pre>
<p>上面示例中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p>
<h2 id="私有属性和私有方法的继承"><a href="#私有属性和私有方法的继承" class="headerlink" title="私有属性和私有方法的继承"></a>私有属性和私有方法的继承</h2><p>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。</p>
<p>子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。</p>
<pre><code class="javascript">class Foo &#123;
  #p = 1;
  #m() &#123;
    console.log(&#39;hello&#39;);
  &#125;
&#125;

class Bar extends Foo &#123;
  constructor() &#123;
    super();
    console.log(this.#p); // 报错
    this.#m(); // 报错
  &#125;
&#125;
</code></pre>
<p>上面示例中，子类 Bar 调用父类 Foo 的私有属性或私有方法，都会报错。</p>
<p>如果父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性。</p>
<pre><code class="javascript">class Foo &#123;
  #p = 1;
  getP() &#123;
    return this.#p;
  &#125;
&#125;

class Bar extends Foo &#123;
  constructor() &#123;
    super();
    console.log(this.getP()); // 1
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，通过该方法，子类就可以读到父类的私有属性。</p>
<h2 id="静态属性和静态方法的继承"><a href="#静态属性和静态方法的继承" class="headerlink" title="静态属性和静态方法的继承"></a>静态属性和静态方法的继承</h2><p>父类的静态属性和静态方法，也会被子类继承。</p>
<pre><code class="javascript">class A &#123;
  static hello() &#123;
    console.log(&#39;hello world&#39;);
  &#125;
&#125;

class B extends A &#123;
&#125;

B.hello()  // hello world
</code></pre>
<p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p>
<p>注意，静态属性是通过软拷贝实现继承的。</p>
<pre><code class="javascript">class A &#123; static foo = 100; &#125;
class B extends A &#123;
  constructor() &#123;
    super();
    B.foo--;
  &#125;
&#125;

const b = new B();
B.foo // 99
A.foo // 100
</code></pre>
<p>上面示例中，<code>foo</code>是 A 类的静态属性，B 类继承了 A 类，因此也继承了这个属性。但是，在 B 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code>，原因就是 B 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。</p>
<p>但是，由于这种拷贝是浅拷贝，如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。</p>
<pre><code class="javascript">class A &#123;
  static foo = &#123; n: 100 &#125;;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    B.foo.n--;
  &#125;
&#125;

const b = new B();
B.foo.n // 99
A.foo.n // 99
</code></pre>
<p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>A</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code>方法可以用来从子类上获取父类。</p>
<pre><code class="javascript">class Point &#123; /*...*/ &#125;

class ColorPoint extends Point &#123; /*...*/ &#125;

Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    console.log(new.target.name);
  &#125;
&#125;
class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
new A() // A
new B() // B
</code></pre>
<p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>
<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  m() &#123;
    super(); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p>
<p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<pre><code class="javascript">class A &#123;
  p() &#123;
    return 2;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.p()); // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
<p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.p = 2;
  &#125;
&#125;

class B extends A &#123;
  get m() &#123;
    return super.p;
  &#125;
&#125;

let b = new B();
b.m // undefined
</code></pre>
<p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>
<pre><code class="javascript">class A &#123;&#125;
A.prototype.x = 2;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.x) // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>
<p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  m() &#123;
    super.print();
  &#125;
&#125;

let b = new B();
b.m() // 2
</code></pre>
<p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p>
<p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>
<pre><code class="javascript">class Parent &#123;
  static myMethod(msg) &#123;
    console.log(&#39;static&#39;, msg);
  &#125;

  myMethod(msg) &#123;
    console.log(&#39;instance&#39;, msg);
  &#125;
&#125;

class Child extends Parent &#123;
  static myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;

  myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;
&#125;

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
</code></pre>
<p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  static print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  static m() &#123;
    super.print();
  &#125;
&#125;

B.x = 3;
B.m() // 3
</code></pre>
<p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>
<p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.valueOf() instanceof B); // true
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>
<pre><code class="javascript">var obj = &#123;
  toString() &#123;
    return &quot;MyObject: &quot; + super.toString();
  &#125;
&#125;;

obj.toString(); // MyObject: [object Object]
</code></pre>
<h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
<pre><code class="javascript">class A &#123;
&#125;

class B extends A &#123;
&#125;

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
</code></pre>
<p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<pre><code class="javascript">class A &#123;
&#125;

class B &#123;
&#125;

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 继承 A 的静态属性
Object.setPrototypeOf(B, A);

const b = new B();
</code></pre>
<p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p>
<pre><code class="javascript">Object.setPrototypeOf = function (obj, proto) &#123;
  obj.__proto__ = proto;
  return obj;
&#125;
</code></pre>
<p>因此，就得到了上面的结果。</p>
<pre><code class="javascript">Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;
</code></pre>
<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<pre><code class="javascript">B.prototype = Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;
</code></pre>
<p><code>extends</code>关键字后面可以跟多种类型的值。</p>
<pre><code class="javascript">class B extends A &#123;
&#125;
</code></pre>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p>
<pre><code class="javascript">class A extends Object &#123;
&#125;

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p>
<p>第二种情况，不存在任何继承。</p>
<pre><code class="javascript">class A &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p>
<h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<pre><code class="javascript">var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, &#39;red&#39;);

p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true
</code></pre>
<p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<pre><code class="javascript">p2.__proto__.__proto__.printName = function () &#123;
  console.log(&#39;Ha&#39;);
&#125;;

p1.printName() // &quot;Ha&quot;
</code></pre>
<p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p>
<h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p>
<pre><code class="javascript">function MyArray() &#123;
  Array.apply(this, arguments);
&#125;

MyArray.prototype = Object.create(Array.prototype, &#123;
  constructor: &#123;
    value: MyArray,
    writable: true,
    configurable: true,
    enumerable: true
  &#125;
&#125;);
</code></pre>
<p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p>
<pre><code class="javascript">var colors = new MyArray();
colors[0] = &quot;red&quot;;
colors.length  // 0

colors.length = 0;
colors[0]  // &quot;red&quot;
</code></pre>
<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>
<p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p>
<pre><code class="javascript">var e = &#123;&#125;;

Object.getOwnPropertyNames(Error.call(e))
// [ &#39;stack&#39; ]

Object.getOwnPropertyNames(e)
// []
</code></pre>
<p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p>
<pre><code class="javascript">class MyArray extends Array &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
</code></pre>
<p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p>
<p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<pre><code class="javascript">class VersionedArray extends Array &#123;
  constructor() &#123;
    super();
    this.history = [[]];
  &#125;
  commit() &#123;
    this.history.push(this.slice());
  &#125;
  revert() &#123;
    this.splice(0, this.length, ...this.history[this.history.length - 1]);
  &#125;
&#125;

var x = new VersionedArray();

x.push(1);
x.push(2);
x // [1, 2]
x.history // [[]]

x.commit();
x.history // [[], [1, 2]]

x.push(3);
x // [1, 2, 3]
x.history // [[], [1, 2]]

x.revert();
x // [1, 2]
</code></pre>
<p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p>
<pre><code class="javascript">class ExtendableError extends Error &#123;
  constructor(message) &#123;
    super();
    this.message = message;
    this.stack = (new Error()).stack;
    this.name = this.constructor.name;
  &#125;
&#125;

class MyError extends ExtendableError &#123;
  constructor(m) &#123;
    super(m);
  &#125;
&#125;

var myerror = new MyError(&#39;ll&#39;);
myerror.message // &quot;ll&quot;
myerror instanceof Error // true
myerror.name // &quot;MyError&quot;
myerror.stack
// Error
//     at MyError.ExtendableError
//     ...
</code></pre>
<p>注意，继承<code>Object</code>的子类，有一个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p>
<pre><code class="javascript">class NewObj extends Object&#123;
  constructor()&#123;
    super(...arguments);
  &#125;
&#125;
var o = new NewObj(&#123;attr: true&#125;);
o.attr === true  // false
</code></pre>
<p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p>
<h2 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>
<pre><code class="javascript">const a = &#123;
  a: &#39;a&#39;
&#125;;
const b = &#123;
  b: &#39;b&#39;
&#125;;
const c = &#123;...a, ...b&#125;; // &#123;a: &#39;a&#39;, b: &#39;b&#39;&#125;
</code></pre>
<p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p>
<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>
<pre><code class="javascript">function mix(...mixins) &#123;
  class Mix &#123;
    constructor() &#123;
      for (let mixin of mixins) &#123;
        copyProperties(this, new mixin()); // 拷贝实例属性
      &#125;
    &#125;
  &#125;

  for (let mixin of mixins) &#123;
    copyProperties(Mix, mixin); // 拷贝静态属性
    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
  &#125;

  return Mix;
&#125;

function copyProperties(target, source) &#123;
  for (let key of Reflect.ownKeys(source)) &#123;
    if ( key !== &#39;constructor&#39;
      &amp;&amp; key !== &#39;prototype&#39;
      &amp;&amp; key !== &#39;name&#39;
    ) &#123;
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<pre><code class="javascript">class DistributedEdit extends mix(Loggable, Serializable) &#123;
  // ...
&#125;
</code></pre>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/05/10%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Es6-编程风格
        
      </div>
    </a>
  
  
    <a href="/2022/09/05/8%E6%96%B0%E5%A2%9ESet%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Es6-Set 和 Map 数据结构</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>