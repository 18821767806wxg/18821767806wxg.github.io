<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Es6-Promise对象 | 我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Promise 对象 [Promise 的含义](https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;promise#Promise 的含义) 基本用法 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() Promise.">
<meta property="og:type" content="article">
<meta property="og:title" content="Es6-Promise对象">
<meta property="og:url" content="https://18821767806wxg.github.io/2022/09/05/2.Promise/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="Promise 对象 [Promise 的含义](https:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;promise#Promise 的含义) 基本用法 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() Promise.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-05T01:51:48.696Z">
<meta property="article:modified_time" content="2022-09-05T01:54:13.511Z">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/10/">React博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2.Promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/2.Promise/" class="article-date">
  	<time datetime="2022-09-05T01:51:48.696Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Es6-Promise对象
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><ol>
<li>[Promise 的含义](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise">https://es6.ruanyifeng.com/#docs/promise#Promise</a> 的含义)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.then()">Promise.prototype.then()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.catch()">Promise.prototype.catch()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.finally()">Promise.prototype.finally()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.all()">Promise.all()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.race()">Promise.race()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.allSettled()">Promise.allSettled()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.any()">Promise.any()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.resolve()">Promise.resolve()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.reject()">Promise.reject()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#%E5%BA%94%E7%94%A8">应用</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.try()">Promise.try()</a></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://wx.kaikeba.com/xiaoke/market/landing-page/v2/N3MIpFtF2DZ91C502gp?kol_ad_code=kKx4Fnfd9ENkHgIfwHb">【课程消息】《Vue 3.0 核心源码与实战》带大家动手，从零开发网页游戏《飞机大战》，快速上手 Vue 3.0 项目。开课吧的课程资料，现在 0 元领取。</a></p>
<h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  // ... some code

  if (/* 异步操作成功 */)&#123;
    resolve(value);
  &#125; else &#123;
    reject(error);
  &#125;
&#125;);
</code></pre>
<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<pre><code class="javascript">promise.then(function(value) &#123;
  // success
&#125;, function(error) &#123;
  // failure
&#125;);
</code></pre>
<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<pre><code class="javascript">function timeout(ms) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(resolve, ms, &#39;done&#39;);
  &#125;);
&#125;

timeout(100).then((value) =&gt; &#123;
  console.log(value);
&#125;);
</code></pre>
<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<pre><code class="javascript">let promise = new Promise(function(resolve, reject) &#123;
  console.log(&#39;Promise&#39;);
  resolve();
&#125;);

promise.then(function() &#123;
  console.log(&#39;resolved.&#39;);
&#125;);

console.log(&#39;Hi!&#39;);

// Promise
// Hi!
// resolved
</code></pre>
<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<pre><code class="javascript">function loadImageAsync(url) &#123;
  return new Promise(function(resolve, reject) &#123;
    const image = new Image();

    image.onload = function() &#123;
      resolve(image);
    &#125;;

    image.onerror = function() &#123;
      reject(new Error(&#39;Could not load image at &#39; + url));
    &#125;;

    image.src = url;
  &#125;);
&#125;
</code></pre>
<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<pre><code class="javascript">const getJSON = function(url) &#123;
  const promise = new Promise(function(resolve, reject)&#123;
    const handler = function() &#123;
      if (this.readyState !== 4) &#123;
        return;
      &#125;
      if (this.status === 200) &#123;
        resolve(this.response);
      &#125; else &#123;
        reject(new Error(this.statusText));
      &#125;
    &#125;;
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

  &#125;);

  return promise;
&#125;;

getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  console.log(&#39;Contents: &#39; + json);
&#125;, function(error) &#123;
  console.error(&#39;出错了&#39;, error);
&#125;);
</code></pre>
<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;
  // ...
&#125;);

const p2 = new Promise(function (resolve, reject) &#123;
  // ...
  resolve(p1);
&#125;)
</code></pre>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)
&#125;)

const p2 = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; resolve(p1), 1000)
&#125;)

p2
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre>
<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>
<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  resolve(1);
  console.log(2);
&#125;).then(r =&gt; &#123;
  console.log(r);
&#125;);
// 2
// 1
</code></pre>
<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
&#125;)
</code></pre>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre>
<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function (comments) &#123;
  console.log(&quot;resolved: &quot;, comments);
&#125;, function (err)&#123;
  console.log(&quot;rejected: &quot;, err);
&#125;);
</code></pre>
<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre>
<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>
<pre><code class="javascript">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));

// 等同于
p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  throw new Error(&#39;test&#39;);
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);
// Error: test
</code></pre>
<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<pre><code class="javascript">// 写法一
const promise = new Promise(function(resolve, reject) &#123;
  try &#123;
    throw new Error(&#39;test&#39;);
  &#125; catch(e) &#123;
    reject(e);
  &#125;
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);

// 写法二
const promise = new Promise(function(resolve, reject) &#123;
  reject(new Error(&#39;test&#39;));
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);
</code></pre>
<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  resolve(&#39;ok&#39;);
  throw new Error(&#39;test&#39;);
&#125;);
promise
  .then(function(value) &#123; console.log(value) &#125;)
  .catch(function(error) &#123; console.log(error) &#125;);
// ok
</code></pre>
<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre>
<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<pre><code class="javascript">// bad
promise
  .then(function(data) &#123;
    // success
  &#125;, function(err) &#123;
    // error
  &#125;);

// good
promise
  .then(function(data) &#123; //cb
    // success
  &#125;)
  .catch(function(err) &#123;
    // error
  &#125;);
</code></pre>
<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing().then(function() &#123;
  console.log(&#39;everything is great&#39;);
&#125;);

setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
</code></pre>
<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<pre><code class="javascript">process.on(&#39;unhandledRejection&#39;, function (err, p) &#123;
  throw err;
&#125;);
</code></pre>
<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">const promise = new Promise(function (resolve, reject) &#123;
  resolve(&#39;ok&#39;);
  setTimeout(function () &#123; throw new Error(&#39;test&#39;) &#125;, 0)
&#125;);
promise.then(function (value) &#123; console.log(value) &#125;);
// ok
// Uncaught Error: test
</code></pre>
<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing()
.catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
&#125;)
.then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// oh no [ReferenceError: x is not defined]
// carry on
</code></pre>
<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>
<pre><code class="javascript">Promise.resolve()
.catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
&#125;)
.then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// carry on
</code></pre>
<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing().then(function() &#123;
  return someOtherAsyncThing();
&#125;).catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为 y 没有声明
  y + 2;
&#125;).then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// oh no [ReferenceError: x is not defined]
</code></pre>
<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<pre><code class="javascript">someAsyncThing().then(function() &#123;
  return someOtherAsyncThing();
&#125;).catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为y没有声明
  y + 2;
&#125;).catch(function(error) &#123;
  console.log(&#39;carry on&#39;, error);
&#125;);
// oh no [ReferenceError: x is not defined]
// carry on [ReferenceError: y is not defined]
</code></pre>
<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre>
<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<pre><code class="javascript">server.listen(port)
  .then(function () &#123;
    // ...
  &#125;)
  .finally(server.stop);
</code></pre>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>
<pre><code class="javascript">promise
.finally(() =&gt; &#123;
  // 语句
&#125;);

// 等同于
promise
.then(
  result =&gt; &#123;
    // 语句
    return result;
  &#125;,
  error =&gt; &#123;
    // 语句
    throw error;
  &#125;
);
</code></pre>
<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<pre><code class="javascript">Promise.prototype.finally = function (callback) &#123;
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)
  );
&#125;;
</code></pre>
<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>
<pre><code class="javascript">// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; &#123;&#125;)

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)

// reject 的值是 3
Promise.reject(3).finally(() =&gt; &#123;&#125;)
</code></pre>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p>下面是一个具体的例子。</p>
<pre><code class="javascript">// 生成一个Promise对象的数组
const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;
  return getJSON(&#39;/post/&#39; + id + &quot;.json&quot;);
&#125;);

Promise.all(promises).then(function (posts) &#123;
  // ...
&#125;).catch(function(reason)&#123;
  // ...
&#125;);
</code></pre>
<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) =&gt; pickTopRecommendations(books, user));
</code></pre>
<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p>
<p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p>
<pre><code class="javascript">const urls = [url_1, url_2, url_3];
const requests = urls.map(x =&gt; fetch(x));

try &#123;
  await Promise.all(requests);
  console.log(&#39;所有请求都成功。&#39;);
&#125; catch &#123;
  console.log(&#39;至少一个请求失败，其他请求可能还没结束。&#39;);
&#125;
</code></pre>
<p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p>
<p>为了解决这个问题，<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p>
<p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre>
<p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p>
<p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p>
<pre><code class="javascript">const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) &#123;
  console.log(results);
&#125;);
// [
//    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,
//    &#123; status: &#39;rejected&#39;, reason: -1 &#125;
// ]
</code></pre>
<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p>
<p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p>
<pre><code class="javascript">// 异步操作成功时
&#123;status: &#39;fulfilled&#39;, value: value&#125;

// 异步操作失败时
&#123;status: &#39;rejected&#39;, reason: reason&#125;
</code></pre>
<p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p>
<p>下面是返回值的用法例子。</p>
<pre><code class="javascript">const promises = [ fetch(&#39;index.html&#39;), fetch(&#39;https://does-not-exist/&#39;) ];
const results = await Promise.allSettled(promises);

// 过滤出成功的请求
const successfulPromises = results.filter(p =&gt; p.status === &#39;fulfilled&#39;);

// 过滤出失败的请求，并输出原因
const errors = results
  .filter(p =&gt; p.status === &#39;rejected&#39;)
  .map(p =&gt; p.reason);
</code></pre>
<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>
<pre><code class="javascript">Promise.any([
  fetch(&#39;https://v8.dev/&#39;).then(() =&gt; &#39;home&#39;),
  fetch(&#39;https://v8.dev/blog&#39;).then(() =&gt; &#39;blog&#39;),
  fetch(&#39;https://v8.dev/docs&#39;).then(() =&gt; &#39;docs&#39;)
]).then((first) =&gt; &#123;  // 只要有一个 fetch() 请求成功
  console.log(first);
&#125;).catch((error) =&gt; &#123; // 所有三个 fetch() 全部请求失败
  console.log(error);
&#125;);
</code></pre>
<p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
<p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),
  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),
  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),
];

try &#123;
  const first = await Promise.any(promises);
  console.log(first);
&#125; catch (error) &#123;
  console.log(error);
&#125;
</code></pre>
<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<pre><code class="javascript">// new AggregateError() extends Array

const err = new AggregateError();
err.push(new Error(&quot;first error&quot;));
err.push(new Error(&quot;second error&quot;));
// ...
throw err;
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var resolved = Promise.resolve(42);
var rejected = Promise.reject(-1);
var alsoRejected = Promise.reject(Infinity);

Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;
  console.log(result); // 42
&#125;);

Promise.any([rejected, alsoRejected]).catch(function (results) &#123;
  console.log(results); // [-1, Infinity]
&#125;);
</code></pre>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<pre><code class="javascript">const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>
<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>
<p><strong>（1）参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<pre><code class="javascript">let thenable = &#123;
  then: function(resolve, reject) &#123;
    resolve(42);
  &#125;
&#125;;
</code></pre>
<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<pre><code class="javascript">let thenable = &#123;
  then: function(resolve, reject) &#123;
    resolve(42);
  &#125;
&#125;;

let p1 = Promise.resolve(thenable);
p1.then(function (value) &#123;
  console.log(value);  // 42
&#125;);
</code></pre>
<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>
<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<pre><code class="javascript">const p = Promise.resolve(&#39;Hello&#39;);

p.then(function (s) &#123;
  console.log(s)
&#125;);
// Hello
</code></pre>
<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<pre><code class="javascript">const p = Promise.resolve();

p.then(function () &#123;
  // ...
&#125;);
</code></pre>
<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<pre><code class="javascript">setTimeout(function () &#123;
  console.log(&#39;three&#39;);
&#125;, 0);

Promise.resolve().then(function () &#123;
  console.log(&#39;two&#39;);
&#125;);

console.log(&#39;one&#39;);

// one
// two
// three
</code></pre>
<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<pre><code class="javascript">const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre>
<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre>
<h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<pre><code class="javascript">function getFoo () &#123;
  return new Promise(function (resolve, reject)&#123;
    resolve(&#39;foo&#39;);
  &#125;);
&#125;

const g = function* () &#123;
  try &#123;
    const foo = yield getFoo();
    console.log(foo);
  &#125; catch (e) &#123;
    console.log(e);
  &#125;
&#125;;

function run (generator) &#123;
  const it = generator();

  function go(result) &#123;
    if (result.done) return result.value;

    return result.value.then(function (value) &#123;
      return go(it.next(value));
    &#125;, function (error) &#123;
      return go(it.throw(error));
    &#125;);
  &#125;

  go(it.next());
&#125;

run(g);
</code></pre>
<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
<h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<pre><code class="javascript">Promise.resolve().then(f)
</code></pre>
<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
Promise.resolve().then(f);
console.log(&#39;next&#39;);
// next
// now
</code></pre>
<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
(async () =&gt; f())();
console.log(&#39;next&#39;);
// now
// next
</code></pre>
<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<pre><code class="javascript">(async () =&gt; f())()
.then(...)
</code></pre>
<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<pre><code class="javascript">(async () =&gt; f())()
.then(...)
.catch(...)
</code></pre>
<p>第二种写法是使用<code>new Promise()</code>。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
(
  () =&gt; new Promise(
    resolve =&gt; resolve(f())
  )
)();
console.log(&#39;next&#39;);
// now
// next
</code></pre>
<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个<a target="_blank" rel="noopener" href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
Promise.try(f);
console.log(&#39;next&#39;);
// now
// next
</code></pre>
<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a target="_blank" rel="noopener" href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a target="_blank" rel="noopener" href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a target="_blank" rel="noopener" href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<pre><code class="javascript">function getUsername(userId) &#123;
  return database.users.get(&#123;id: userId&#125;)
  .then(function(user) &#123;
    return user.name;
  &#125;);
&#125;
</code></pre>
<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<pre><code class="javascript">database.users.get(&#123;id: userId&#125;)
.then(...)
.catch(...)
</code></pre>
<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<pre><code class="javascript">try &#123;
  database.users.get(&#123;id: userId&#125;)
  .then(...)
  .catch(...)
&#125; catch (e) &#123;
  // ...
&#125;
</code></pre>
<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<pre><code class="javascript">Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))
  .then(...)
  .catch(...)
</code></pre>
<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/05/3%E6%B5%85%E8%B0%88Es6%E4%B8%ADimport%20%20as%20xxx%20from%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Es6-Es6中import  as xxx from几种基本用法
        
      </div>
    </a>
  
  
    <a href="/2022/09/04/1.proxy/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">ES6-proxy</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>