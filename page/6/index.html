<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/6/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-5let和const命名" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/5let%E5%92%8Cconst%E5%91%BD%E5%90%8D/" class="article-date">
  	<time datetime="2022-09-05T02:48:36.001Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/5let%E5%92%8Cconst%E5%91%BD%E5%90%8D/">
        Es6-let 和 const 命令
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><ol>
<li>[let 命令](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#let">https://es6.ruanyifeng.com/#docs/let#let</a> 命令)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</a></li>
<li>[const 命令](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#const">https://es6.ruanyifeng.com/#docs/let#const</a> 命令)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">顶层对象的属性</a></li>
<li>[globalThis 对象](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#globalThis">https://es6.ruanyifeng.com/#docs/let#globalThis</a> 对象)</li>
</ol>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<pre><code class="javascript">&#123;
  let a = 10;
  var b = 1;
&#125;

a // ReferenceError: a is not defined.
b // 1
</code></pre>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>
<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<pre><code class="javascript">for (let i = 0; i &lt; 10; i++) &#123;
  // ...
&#125;

console.log(i);
// ReferenceError: i is not defined
</code></pre>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p>
<pre><code class="javascript">var a = [];
for (var i = 0; i &lt; 10; i++) &#123;
  a[i] = function () &#123;
    console.log(i);
  &#125;;
&#125;
a[6](); // 10
</code></pre>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<pre><code class="javascript">var a = [];
for (let i = 0; i &lt; 10; i++) &#123;
  a[i] = function () &#123;
    console.log(i);
  &#125;;
&#125;
a[6](); // 6
</code></pre>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code class="javascript">for (let i = 0; i &lt; 3; i++) &#123;
  let i = &#39;abc&#39;;
  console.log(i);
&#125;
// abc
// abc
// abc
</code></pre>
<p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 <code>let</code> 重复声明同一个变量）。</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code class="javascript">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre><code class="javascript">var tmp = 123;

if (true) &#123;
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
&#125;
</code></pre>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<pre><code class="javascript">if (true) &#123;
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
&#125;
</code></pre>
<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p>
<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<pre><code class="javascript">typeof x; // ReferenceError
let x;
</code></pre>
<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>
<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<pre><code class="javascript">typeof undeclared_variable // &quot;undefined&quot;
</code></pre>
<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<pre><code class="javascript">function bar(x = y, y = 2) &#123;
  return [x, y];
&#125;

bar(); // 报错
</code></pre>
<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>
<pre><code class="javascript">function bar(x = 2, y = x) &#123;
  return [x, y];
&#125;
bar(); // [2, 2]
</code></pre>
<p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p>
<pre><code class="javascript">// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
</code></pre>
<p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code class="javascript">// 报错
function func() &#123;
  let a = 10;
  var a = 1;
&#125;

// 报错
function func() &#123;
  let a = 10;
  let a = 1;
&#125;
</code></pre>
<p>因此，不能在函数内部重新声明参数。</p>
<pre><code class="javascript">function func(arg) &#123;
  let arg;
&#125;
func() // 报错

function func(arg) &#123;
  &#123;
    let arg;
  &#125;
&#125;
func() // 不报错
</code></pre>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<pre><code class="javascript">var tmp = new Date();

function f() &#123;
  console.log(tmp);
  if (false) &#123;
    var tmp = &#39;hello world&#39;;
  &#125;
&#125;

f(); // undefined
</code></pre>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<pre><code class="javascript">var s = &#39;hello&#39;;

for (var i = 0; i &lt; s.length; i++) &#123;
  console.log(s[i]);
&#125;

console.log(i); // 5
</code></pre>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<pre><code class="javascript">function f1() &#123;
  let n = 5;
  if (true) &#123;
    let n = 10;
  &#125;
  console.log(n); // 5
&#125;
</code></pre>
<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<pre><code class="javascript">&#123;&#123;&#123;&#123;
  &#123;let insane = 'Hello World'&#125;
  console.log(insane); // 报错
&#125;&#125;&#125;&#125;;
</code></pre>
<p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<pre><code class="javascript">&#123;&#123;&#123;&#123;
  let insane = 'Hello World';
  &#123;let insane = 'Hello World'&#125;
&#125;&#125;&#125;&#125;;
</code></pre>
<p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<pre><code class="javascript">// IIFE 写法
(function () &#123;
  var tmp = ...;
  ...
&#125;());

// 块级作用域写法
&#123;
  let tmp = ...;
  ...
&#125;
</code></pre>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<pre><code class="javascript">// 情况一
if (true) &#123;
  function f() &#123;&#125;
&#125;

// 情况二
try &#123;
  function f() &#123;&#125;
&#125; catch(e) &#123;
  // ...
&#125;
</code></pre>
<p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<pre><code class="javascript">function f() &#123; console.log(&#39;I am outside!&#39;); &#125;

(function () &#123;
  if (false) &#123;
    // 重复声明一次函数f
    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;
  &#125;

  f();
&#125;());
</code></pre>
<p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p>
<pre><code class="javascript">// ES5 环境
function f() &#123; console.log(&#39;I am outside!&#39;); &#125;

(function () &#123;
  function f() &#123; console.log(&#39;I am inside!&#39;); &#125;
  if (false) &#123;
  &#125;
  f();
&#125;());
</code></pre>
<p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<pre><code class="javascript">// 浏览器的 ES6 环境
function f() &#123; console.log(&#39;I am outside!&#39;); &#125;

(function () &#123;
  if (false) &#123;
    // 重复声明一次函数f
    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;
  &#125;

  f();
&#125;());
// Uncaught TypeError: f is not a function
</code></pre>
<p>上面的代码在 ES6 浏览器中，都会报错。</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>
<p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下。</p>
<pre><code class="javascript">// 浏览器的 ES6 环境
function f() &#123; console.log(&#39;I am outside!&#39;); &#125;
(function () &#123;
  var f = undefined;
  if (false) &#123;
    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;
  &#125;

  f();
&#125;());
// Uncaught TypeError: f is not a function
</code></pre>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code class="javascript">// 块级作用域内部的函数声明语句，建议不要使用
&#123;
  let a = &#39;secret&#39;;
  function f() &#123;
    return a;
  &#125;
&#125;

// 块级作用域内部，优先使用函数表达式
&#123;
  let a = &#39;secret&#39;;
  let f = function () &#123;
    return a;
  &#125;;
&#125;
</code></pre>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
<pre><code class="javascript">// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) &#123;
  let x = 1;
&#125;
</code></pre>
<p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而<code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p>
<p>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</p>
<pre><code class="javascript">// 不报错
&#39;use strict&#39;;
if (true) &#123;
  function f() &#123;&#125;
&#125;

// 报错
&#39;use strict&#39;;
if (true)
  function f() &#123;&#125;
</code></pre>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code class="javascript">const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre>
<p>上面代码表明改变常量的值会报错。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code class="javascript">const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<pre><code class="javascript">if (true) &#123;
  const MAX = 5;
&#125;

MAX // Uncaught ReferenceError: MAX is not defined
</code></pre>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<pre><code class="javascript">if (true) &#123;
  console.log(MAX); // ReferenceError
  const MAX = 5;
&#125;
</code></pre>
<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<pre><code class="javascript">var message = &quot;Hello!&quot;;
let age = 25;

// 以下两行都会报错
const message = &quot;Goodbye!&quot;;
const age = 30;
</code></pre>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错
</code></pre>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="javascript">const foo = Object.freeze(&#123;&#125;);

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="javascript">var constantize = (obj) =&gt; &#123;
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; &#123;
    if ( typeof obj[key] === &#39;object&#39; ) &#123;
      constantize( obj[key] );
    &#125;
  &#125;);
&#125;;
</code></pre>
<h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code class="javascript">window.a = 1;
a // 1

a = 2;
window.a // 2
</code></pre>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code class="javascript">var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre>
<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
<h2 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h2><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>关键字，但是有局限性。</p>
<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node.js 模块中<code>this</code>返回的是当前模块，ES6 模块中<code>this</code>返回的是<code>undefined</code>。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<pre><code class="javascript">// 方法一
(typeof window !== &#39;undefined&#39;
   ? window
   : (typeof process === &#39;object&#39; &amp;&amp;
      typeof require === &#39;function&#39; &amp;&amp;
      typeof global === &#39;object&#39;)
     ? global
     : this);

// 方法二
var getGlobal = function () &#123;
  if (typeof self !== &#39;undefined&#39;) &#123; return self; &#125;
  if (typeof window !== &#39;undefined&#39;) &#123; return window; &#125;
  if (typeof global !== &#39;undefined&#39;) &#123; return global; &#125;
  throw new Error(&#39;unable to locate global object&#39;);
&#125;;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-global">ES2020</a> 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p>
<p>垫片库<a target="_blank" rel="noopener" href="https://github.com/ungap/global-this"><code>global-this</code></a>模拟了这个提案，可以在所有环境拿到<code>globalTh</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-4class类的基本语法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/4class%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  	<time datetime="2022-09-05T02:47:33.031Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/4class%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">
        Es6-Class 的基本语法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E7%B1%BB%E7%9A%84%E7%94%B1%E6%9D%A5">类的由来</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#constructor(">constructor() 方法</a> 方法)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">类的实例</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95">实例属性的新写法</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88getter%EF%BC%89%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88setter%EF%BC%89">取值函数（getter）和存值函数（setter）</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F">属性表达式</a></li>
<li>[Class 表达式](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#Class">https://es6.ruanyifeng.com/#docs/class#Class</a> 表达式)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有方法和私有属性</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E9%9D%99%E6%80%81%E5%9D%97">静态块</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">类的注意点</a></li>
<li>[new.target 属性](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#new.target">https://es6.ruanyifeng.com/#docs/class#new.target</a> 属性)</li>
</ol>
<h2 id="类的由来"><a href="#类的由来" class="headerlink" title="类的由来"></a>类的由来</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<pre><code class="javascript">function Point(x, y) &#123;
  this.x = x;
  this.y = y;
&#125;

Point.prototype.toString = function () &#123;
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
&#125;;

var p = new Point(1, 2);
</code></pre>
<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>
<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>
<pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;
</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数<code>Point</code>是一致的。</p>
<p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<pre><code class="javascript">class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true
</code></pre>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>
<pre><code class="javascript">class Bar &#123;
  doStuff() &#123;
    console.log(&#39;stuff&#39;);
  &#125;
&#125;

const b = new Bar();
b.doStuff() // &quot;stuff&quot;
</code></pre>
<p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<pre><code class="javascript">class Point &#123;
  constructor() &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;

  toValue() &#123;
    // ...
  &#125;
&#125;

// 等同于

Point.prototype = &#123;
  constructor() &#123;&#125;,
  toString() &#123;&#125;,
  toValue() &#123;&#125;,
&#125;;
</code></pre>
<p>上面代码中，<code>constructor()</code>、<code>toString()</code>、<code>toValue()</code>这三个方法，其实都是定义在<code>Point.prototype</code>上面。</p>
<p>因此，在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<pre><code class="javascript">class B &#123;&#125;
const b = new B();

b.constructor === B.prototype.constructor // true
</code></pre>
<p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor()</code>方法就是<code>B</code>类原型的<code>constructor()</code>方法。</p>
<p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</p>
<pre><code class="javascript">class Point &#123;
  constructor()&#123;
    // ...
  &#125;
&#125;

Object.assign(Point.prototype, &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;);
</code></pre>
<p><code>prototype</code>对象的<code>constructor()</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>
<pre><code class="javascript">Point.prototype.constructor === Point // true
</code></pre>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;
&#125;

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码中，<code>toString()</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p>
<pre><code class="javascript">var Point = function (x, y) &#123;
  // ...
&#125;;

Point.prototype.toString = function () &#123;
  // ...
&#125;;

Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码采用 ES5 的写法，<code>toString()</code>方法就是可枚举的。</p>
<h2 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor() 方法"></a>constructor() 方法</h2><p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p>
<pre><code class="javascript">class Point &#123;
&#125;

// 等同于
class Point &#123;
  constructor() &#123;&#125;
&#125;
</code></pre>
<p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor()</code>方法。</p>
<p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>
<pre><code class="javascript">class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

new Foo() instanceof Foo
// false
</code></pre>
<p>上面代码中，<code>constructor()</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>
<p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>
<pre><code class="javascript">class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</code></pre>
<h2 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h2><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class()</code>，将会报错。</p>
<pre><code class="javascript">class Point &#123;
  // ...
&#125;

// 报错
var point = Point(2, 3);

// 正确
var point = new Point(2, 3);
</code></pre>
<p>类的属性和方法，除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>
<pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre>
<p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>对象上），所以<code>hasOwnProperty()</code>方法返回<code>true</code>，而<code>toString()</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty()</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>
<pre><code class="javascript">var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
</code></pre>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p>
<p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p>
<blockquote>
<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf()</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>
</blockquote>
<pre><code class="javascript">var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;

p1.printName() // &quot;Oops&quot;
p2.printName() // &quot;Oops&quot;

var p3 = new Point(4,2);
p3.printName() // &quot;Oops&quot;
</code></pre>
<p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
<h2 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h2><p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-class-fields">ES2022</a> 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类内部的最顶层。</p>
<pre><code class="javascript">// 原来的写法
class IncreasingCounter &#123;
  constructor() &#123;
    this._count = 0;
  &#125;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this._count;
  &#125;
  increment() &#123;
    this._count++;
  &#125;
&#125;
</code></pre>
<p>上面示例中，实例属性<code>_count</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。</p>
<p>现在的新写法是，这个属性也可以定义在类的最顶层，其他都不变。</p>
<pre><code class="javascript">class IncreasingCounter &#123;
  _count = 0;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this._count;
  &#125;
  increment() &#123;
    this._count++;
  &#125;
&#125;
</code></pre>
<p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</p>
<p>注意，新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型上面。</p>
<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
<pre><code class="javascript">class foo &#123;
  bar = &#39;hello&#39;;
  baz = &#39;world&#39;;

  constructor() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p>
<h2 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h2><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<pre><code class="javascript">class MyClass &#123;
  constructor() &#123;
    // ...
  &#125;
  get prop() &#123;
    return &#39;getter&#39;;
  &#125;
  set prop(value) &#123;
    console.log(&#39;setter: &#39;+value);
  &#125;
&#125;

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// &#39;getter&#39;
</code></pre>
<p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<pre><code class="javascript">class CustomHTMLElement &#123;
  constructor(element) &#123;
    this.element = element;
  &#125;

  get html() &#123;
    return this.element.innerHTML;
  &#125;

  set html(value) &#123;
    this.element.innerHTML = value;
  &#125;
&#125;

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, &quot;html&quot;
);

&quot;get&quot; in descriptor  // true
&quot;set&quot; in descriptor  // true
</code></pre>
<p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p>
<h2 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h2><p>类的属性名，可以采用表达式。</p>
<pre><code class="javascript">let methodName = &#39;getArea&#39;;

class Square &#123;
  constructor(length) &#123;
    // ...
  &#125;

  [methodName]() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p>
<h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p>
<pre><code class="javascript">const MyClass = class Me &#123;
  getClassName() &#123;
    return Me.name;
  &#125;
&#125;;
</code></pre>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</p>
<pre><code class="javascript">let inst = new MyClass();
inst.getClassName() // Me
Me.name // ReferenceError: Me is not defined
</code></pre>
<p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p>
<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>
<pre><code class="javascript">const MyClass = class &#123; /* ... */ &#125;;
</code></pre>
<p>采用 Class 表达式，可以写出立即执行的 Class。</p>
<pre><code class="javascript">let person = new class &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;

  sayName() &#123;
    console.log(this.name);
  &#125;
&#125;(&#39;张三&#39;);

person.sayName(); // &quot;张三&quot;
</code></pre>
<p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code class="javascript">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

Foo.classMethod() // &#39;hello&#39;

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
</code></pre>
<p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p>
<pre><code class="javascript">class Foo &#123;
  static bar() &#123;
    this.baz();
  &#125;
  static baz() &#123;
    console.log(&#39;hello&#39;);
  &#125;
  baz() &#123;
    console.log(&#39;world&#39;);
  &#125;
&#125;

Foo.bar() // hello
</code></pre>
<p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>
<p>父类的静态方法，可以被子类继承。</p>
<pre><code class="javascript">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
&#125;

Bar.classMethod() // &#39;hello&#39;
</code></pre>
<p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>
<p>静态方法也是可以从<code>super</code>对象上调用的。</p>
<pre><code class="javascript">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
  static classMethod() &#123;
    return super.classMethod() + &#39;, too&#39;;
  &#125;
&#125;

Bar.classMethod() // &quot;hello, too&quot;
</code></pre>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>
<pre><code class="javascript">class Foo &#123;
&#125;

Foo.prop = 1;
Foo.prop // 1
</code></pre>
<p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-class-fields">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p>
<pre><code class="javascript">class MyClass &#123;
  static myStaticProp = 42;

  constructor() &#123;
    console.log(MyClass.myStaticProp); // 42
  &#125;
&#125;
</code></pre>
<p>这个新写法大大方便了静态属性的表达。</p>
<pre><code class="javascript">// 老写法
class Foo &#123;
  // ...
&#125;
Foo.prop = 1;

// 新写法
class Foo &#123;
  static prop = 1;
&#125;
</code></pre>
<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<h2 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h2><h3 id="早期解决方案"><a href="#早期解决方案" class="headerlink" title="早期解决方案"></a>早期解决方案</h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但早期的 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<pre><code class="javascript">class Widget &#123;

  // 公有方法
  foo (baz) &#123;
    this._bar(baz);
  &#125;

  // 私有方法
  _bar(baz) &#123;
    return this.snaf = baz;
  &#125;

  // ...
&#125;
</code></pre>
<p>上面代码中，<code>_bar()</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p>
<pre><code class="javascript">class Widget &#123;
  foo (baz) &#123;
    bar.call(this, baz);
  &#125;

  // ...
&#125;

function bar(baz) &#123;
  return this.snaf = baz;
&#125;
</code></pre>
<p>上面代码中，<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。</p>
<p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p>
<pre><code class="javascript">const bar = Symbol(&#39;bar&#39;);
const snaf = Symbol(&#39;snaf&#39;);

export default class myClass&#123;

  // 公有方法
  foo(baz) &#123;
    this[bar](baz);
  &#125;

  // 私有方法
  [bar](baz) &#123;
    return this[snaf] = baz;
  &#125;

  // ...
&#125;;
</code></pre>
<p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p>
<pre><code class="javascript">const inst = new myClass();

Reflect.ownKeys(myClass.prototype)
// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]
</code></pre>
<p>上面代码中，Symbol 值的属性名依然可以从类的外部拿到。</p>
<h3 id="私有属性的正式写法"><a href="#私有属性的正式写法" class="headerlink" title="私有属性的正式写法"></a>私有属性的正式写法</h3><p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-class-fields">ES2022</a>正式为<code>class</code>添加了私有属性，方法是在属性名之前使用<code>#</code>表示。</p>
<pre><code class="javascript">class IncreasingCounter &#123;
  #count = 0;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this.#count;
  &#125;
  increment() &#123;
    this.#count++;
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</p>
<pre><code class="javascript">const counter = new IncreasingCounter();
counter.#count // 报错
counter.#count = 42 // 报错
</code></pre>
<p>上面示例中，在类的外部，读取或写入私有属性<code>#count</code>，都会报错。</p>
<p>另外，不管在类的内部或外部，读取一个不存在的私有属性，也都会报错。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回<code>undefined</code>。</p>
<pre><code class="javascript">class IncreasingCounter &#123;
  #count = 0;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this.#myCount; // 报错
  &#125;
  increment() &#123;
    this.#count++;
  &#125;
&#125;

const counter = new IncreasingCounter();
counter.#myCount // 报错
</code></pre>
<p>上面示例中，<code>#myCount</code>是一个不存在的私有属性，不管在函数内部或外部，读取该属性都会导致报错。</p>
<p>注意，私有属性的属性名必须包括<code>#</code>，如果不带<code>#</code>，会被当作另一个属性。</p>
<pre><code class="javascript">class Point &#123;
  #x;

  constructor(x = 0) &#123;
    this.#x = +x;
  &#125;

  get x() &#123;
    return this.#x;
  &#125;

  set x(value) &#123;
    this.#x = +value;
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>#x</code>就是私有属性，在<code>Point</code>类之外是读取不到这个属性的。由于井号<code>#</code>是属性名的一部分，使用时必须带有<code>#</code>一起使用，所以<code>#x</code>和<code>x</code>是两个不同的属性。</p>
<p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p>
<pre><code class="javascript">class Foo &#123;
  #a;
  #b;
  constructor(a, b) &#123;
    this.#a = a;
    this.#b = b;
  &#125;
  #sum() &#123;
    return this.#a + this.#b;
  &#125;
  printSum() &#123;
    console.log(this.#sum());
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>#sum()</code>就是一个私有方法。</p>
<p>另外，私有属性也可以设置 getter 和 setter 方法。</p>
<pre><code class="javascript">class Counter &#123;
  #xValue = 0;

  constructor() &#123;
    console.log(this.#x);
  &#125;

  get #x() &#123; return this.#xValue; &#125;
  set #x(value) &#123;
    this.#xValue = value;
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>操作另一个私有属性<code>#xValue</code>来完成。</p>
<p>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</p>
<pre><code class="javascript">class Foo &#123;
  #privateValue = 42;
  static getPrivateValue(foo) &#123;
    return foo.#privateValue;
  &#125;
&#125;

Foo.getPrivateValue(new Foo()); // 42
</code></pre>
<p>上面代码允许从实例<code>foo</code>上面引用私有属性。</p>
<p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p>
<pre><code class="javascript">class FakeMath &#123;
  static PI = 22 / 7;
  static #totallyRandomNumber = 4;

  static #computeRandomNumber() &#123;
    return FakeMath.#totallyRandomNumber;
  &#125;

  static random() &#123;
    console.log(&#39;I heard you like random numbers…&#39;)
    return FakeMath.#computeRandomNumber();
  &#125;
&#125;

FakeMath.PI // 3.142857142857143
FakeMath.random()
// I heard you like random numbers…
// 4
FakeMath.#totallyRandomNumber // 报错
FakeMath.#computeRandomNumber() // 报错
</code></pre>
<p>上面代码中，<code>#totallyRandomNumber</code>是私有属性，<code>#computeRandomNumber()</code>是私有方法，只能在<code>FakeMath</code>这个类的内部调用，外部调用就会报错。</p>
<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>前面说过，直接访问某个类不存在的私有属性会报错，但是访问不存在的公开属性不会报错。这个特性可以用来判断，某个对象是否为类的实例。</p>
<pre><code class="javascript">class C &#123;
  #brand;

  static isC(obj) &#123;
    try &#123;
      obj.#brand;
      return true;
    &#125; catch &#123;
      return false;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面示例中，类<code>C</code>的静态方法<code>isC()</code>就用来判断，某个对象是否为<code>C</code>的实例。它采用的方法就是，访问该对象的私有属性<code>#brand</code>。如果不报错，就会返回<code>true</code>；如果报错，就说明该对象不是当前类的实例，从而<code>catch</code>部分返回<code>false</code>。</p>
<p>因此，<code>try...catch</code>结构可以用来判断某个私有属性是否存在。但是，这样的写法很麻烦，代码可读性很差，<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-private-fields-in-in">ES2022</a> 改进了<code>in</code>运算符，使它也可以用来判断私有属性。</p>
<pre><code class="javascript">class C &#123;
  #brand;

  static isC(obj) &#123;
    if (#brand in obj) &#123;
      // 私有属性 #brand 存在
      return true;
    &#125; else &#123;
      // 私有属性 #foo 不存在
      return false;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>in</code>运算符判断某个对象是否有私有属性<code>#foo</code>。它不会报错，而是返回一个布尔值。</p>
<p>这种用法的<code>in</code>，也可以跟<code>this</code>一起配合使用。</p>
<pre><code class="javascript">class A &#123;
  #foo = 0;
  m() &#123;
    console.log(#foo in this); // true
    console.log(#bar in this); // false
  &#125;
&#125;
</code></pre>
<p>注意，判断私有属性时，<code>in</code>只能用在类的内部。</p>
<p>子类从父类继承的私有属性，也可以使用<code>in</code>运算符来判断。</p>
<pre><code class="javascript">class A &#123;
  #foo = 0;
  static test(obj) &#123;
    console.log(#foo in obj);
  &#125;
&#125;

class SubA extends A &#123;&#125;;

A.test(new SubA()) // true
</code></pre>
<p>上面示例中，<code>SubA</code>从父类继承了私有属性<code>#foo</code>，<code>in</code>运算符也有效。</p>
<p>注意，<code>in</code>运算符对于<code>Object.create()</code>、<code>Object.setPrototypeOf</code>形成的继承，是无效的，因为这种继承不会传递私有属性。</p>
<pre><code class="javascript">class A &#123;
  #foo = 0;
  static test(obj) &#123;
    console.log(#foo in obj);
  &#125;
&#125;
const a = new A();

const o1 = Object.create(a);
A.test(o1) // false
A.test(o1.__proto__) // true

const o2 = &#123;&#125;;
Object.setPrototypeOf(o2, a);
A.test(o2) // false
A.test(o2.__proto__) // true
</code></pre>
<p>上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以<code>in</code>运算符无效。</p>
<h2 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h2><p>静态属性的一个问题是，它的初始化要么写在类的外部，要么写在<code>constructor()</code>方法里面。</p>
<pre><code class="javascript">class C &#123;
  static x = 234;
  static y;
  static z;
&#125;

try &#123;
  const obj = doSomethingWith(C.x);
  C.y = obj.y
  C.z = obj.z;
&#125; catch &#123;
  C.y = ...;
  C.z = ...;
&#125;
</code></pre>
<p>上面示例中，静态属性<code>y</code>和<code>z</code>的值依赖静态属性<code>x</code>，它们的初始化写在类的外部（上例的<code>try...catch</code>代码块）。另一种方法是写到类的<code>constructor()</code>方法里面。这两种方法都不是很理想，前者是将类的内部逻辑写到了外部，后者则是每次新建实例都会运行一次。</p>
<p>为了解决这个问题，ES2022 引入了<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-class-static-block">静态块</a>（static block），允许在类的内部设置一个代码块，在类生成时运行一次，主要作用是对静态属性进行初始化。</p>
<pre><code class="javascript">class C &#123;
  static x = ...;
  static y;
  static z;

  static &#123;
    try &#123;
      const obj = doSomethingWith(this.x);
      this.y = obj.y;
      this.z = obj.z;
    &#125;
    catch &#123;
      this.y = ...;
      this.z = ...;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码中，类的内部有一个 static 代码块，这就是静态块。它的好处是将静态属性<code>y</code>和<code>z</code>的初始化逻辑，写入了类的内部，而且只运行一次。</p>
<p>每个类只能有一个静态块，在静态属性声明后运行。静态块的内部不能有<code>return</code>语句。</p>
<p>静态块内部可以使用类名或<code>this</code>，指代当前类。</p>
<pre><code class="c">class C &#123;
  static x = 1;
  static &#123;
    this.x; // 1
    // 或者
    C.x; // 1
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>this.x</code>和<code>C.x</code>都能获取静态属性<code>x</code>。</p>
<p>除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</p>
<pre><code class="javascript">let getX;

export class C &#123;
  #x = 1;
  static &#123;
    getX = obj =&gt; obj.#x;
  &#125;
&#125;

console.log(getX(new C())); // 1
</code></pre>
<p>上面示例中，<code>#x</code>是类的私有属性，如果类外部的<code>getX()</code>方法希望获取这个属性，以前是要写在类的<code>constructor()</code>方法里面，这样的话，每次新建实例都会定义一次<code>getX()</code>方法。现在可以写在静态块里面，这样的话，只在类生成时定义一次。</p>
<h2 id="类的注意点"><a href="#类的注意点" class="headerlink" title="类的注意点"></a>类的注意点</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
<h3 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h3><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<pre><code class="javascript">new Foo(); // ReferenceError
class Foo &#123;&#125;
</code></pre>
<p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<pre><code class="javascript">&#123;
  let Foo = class &#123;&#125;;
  class Bar extends Foo &#123;
  &#125;
&#125;
</code></pre>
<p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p>
<h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>
<pre><code class="javascript">class Point &#123;&#125;
Point.name // &quot;Point&quot;
</code></pre>
<p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>
<h3 id="Generator-方法"><a href="#Generator-方法" class="headerlink" title="Generator 方法"></a>Generator 方法</h3><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p>
<pre><code class="javascript">class Foo &#123;
  constructor(...args) &#123;
    this.args = args;
  &#125;
  * [Symbol.iterator]() &#123;
    for (let arg of this.args) &#123;
      yield arg;
    &#125;
  &#125;
&#125;

for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) &#123;
  console.log(x);
&#125;
// hello
// world
</code></pre>
<p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p>
<h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<pre><code class="javascript">class Logger &#123;
  printName(name = &#39;there&#39;) &#123;
    this.print(`Hello $&#123;name&#125;`);
  &#125;

  print(text) &#123;
    console.log(text);
  &#125;
&#125;

const logger = new Logger();
const &#123; printName &#125; = logger;
printName(); // TypeError: Cannot read property &#39;print&#39; of undefined
</code></pre>
<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>
<pre><code class="javascript">class Logger &#123;
  constructor() &#123;
    this.printName = this.printName.bind(this);
  &#125;

  // ...
&#125;
</code></pre>
<p>另一种解决方法是使用箭头函数。</p>
<pre><code class="javascript">class Obj &#123;
  constructor() &#123;
    this.getThis = () =&gt; this;
  &#125;
&#125;

const myObj = new Obj();
myObj.getThis() === myObj // true
</code></pre>
<p>箭头函数内部的<code>this</code>总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p>
<p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p>
<pre><code class="javascript">function selfish (target) &#123;
  const cache = new WeakMap();
  const handler = &#123;
    get (target, key) &#123;
      const value = Reflect.get(target, key);
      if (typeof value !== &#39;function&#39;) &#123;
        return value;
      &#125;
      if (!cache.has(value)) &#123;
        cache.set(value, value.bind(target));
      &#125;
      return cache.get(value);
    &#125;
  &#125;;
  const proxy = new Proxy(target, handler);
  return proxy;
&#125;

const logger = selfish(new Logger());
</code></pre>
<h2 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h2><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code class="javascript">function Person(name) &#123;
  if (new.target !== undefined) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用 new 命令生成实例&#39;);
  &#125;
&#125;

// 另一种写法
function Person(name) &#123;
  if (new.target === Person) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用 new 命令生成实例&#39;);
  &#125;
&#125;

var person = new Person(&#39;张三&#39;); // 正确
var notAPerson = Person.call(person, &#39;张三&#39;);  // 报错
</code></pre>
<p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p>
<p>Class 内部调用<code>new.target</code>，返回当前 Class。</p>
<pre><code class="javascript">class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  &#125;
&#125;

var obj = new Rectangle(3, 4); // 输出 true
</code></pre>
<p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p>
<pre><code class="javascript">class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    // ...
  &#125;
&#125;

class Square extends Rectangle &#123;
  constructor(length, width) &#123;
    super(length, width);
  &#125;
&#125;

var obj = new Square(3); // 输出 false
</code></pre>
<p>上面代码中，<code>new.target</code>会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<pre><code class="javascript">class Shape &#123;
  constructor() &#123;
    if (new.target === Shape) &#123;
      throw new Error(&#39;本类不能实例化&#39;);
    &#125;
  &#125;
&#125;

class Rectangle extends Shape &#123;
  constructor(length, width) &#123;
    super();
    // ...
  &#125;
&#125;

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre>
<p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用<code>new.target</code>会报错。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-3浅谈Es6中import  as xxx from几种基本用法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/3%E6%B5%85%E8%B0%88Es6%E4%B8%ADimport%20%20as%20xxx%20from%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="article-date">
  	<time datetime="2022-09-05T01:52:59.182Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/3%E6%B5%85%E8%B0%88Es6%E4%B8%ADimport%20%20as%20xxx%20from%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">
        Es6-Es6中import  as xxx from几种基本用法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020">ES6</a>，javascript第一次支持了module。ES6的模块化分为导出（export）与导入（import）两个模块，其中在项目中，我们会经常看到一种用法import * as obj from，这种写法是把所有的输出包裹到obj对象里。</p>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><pre><code class="javascript">// index.js



export function fn1(data)&#123;



  console.log(1)



&#125;



export function fn2(data)&#123;



  console.log(2)



&#125;
import * as Fn from &#39;./index.js&#39;



Fn.fn1()  // 1



Fn.fn2()  // 2
</code></pre>
<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><pre><code class="javascript">let myName = &quot;Jon&quot;;



let myAge = 18;



let myfn = function()&#123;



    return &quot;我是&quot;+myName+&quot;！今年&quot;+myAge+&quot;岁了&quot;



&#125;



export &#123;



    myName as name,



    myAge as age,



    myfn as fn



&#125;
</code></pre>
<h3 id="接收的代码"><a href="#接收的代码" class="headerlink" title="接收的代码"></a>接收的代码</h3><pre><code class="javascript">import &#123;fn,age,name&#125; from &quot;./test.js&quot;;



console.log(fn()); //我是Jon！今年19岁了



console.log(age); //19



console.log(name); //Jon
</code></pre>
<h3 id="或者写成"><a href="#或者写成" class="headerlink" title="或者写成"></a>或者写成</h3><pre><code class="javascript">import * as info from &quot;./test.js&quot;; //通过*来批量接收，as 来指定接收的名字



console.log(info.fn()); //我是Jon！今年18岁了



console.log(info.age); //18



console.log(info.name); //Jon
</code></pre>
<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>重命名export和import，如果导入的多个文件中，变量名字相同，即会产生命名冲突的问题，为了解决该问题，ES6为提供了重命名的方法，当你在导入名称时可以这样做。</p>
<pre><code class="javascript">/*************test1.js*****************/



export let myName = &quot;我来自test1.js&quot;;



/*************test2.js*****************/



export let myName = &quot;我来自test2.js&quot;;



 



/*************index.js****************/



import &#123;myName as name1&#125; from &quot;./test1.js&quot;;



import &#123;myName as name2&#125; from &quot;./test2.js&quot;;



console.log(name1); //我来自test1.js



console.log(name2); //我来自test2.js
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-2.Promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/2.Promise/" class="article-date">
  	<time datetime="2022-09-05T01:51:48.696Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/2.Promise/">
        Es6-Promise对象
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><ol>
<li>[Promise 的含义](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise">https://es6.ruanyifeng.com/#docs/promise#Promise</a> 的含义)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.then()">Promise.prototype.then()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.catch()">Promise.prototype.catch()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.finally()">Promise.prototype.finally()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.all()">Promise.all()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.race()">Promise.race()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.allSettled()">Promise.allSettled()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.any()">Promise.any()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.resolve()">Promise.resolve()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.reject()">Promise.reject()</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#%E5%BA%94%E7%94%A8">应用</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise#Promise.try()">Promise.try()</a></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://wx.kaikeba.com/xiaoke/market/landing-page/v2/N3MIpFtF2DZ91C502gp?kol_ad_code=kKx4Fnfd9ENkHgIfwHb">【课程消息】《Vue 3.0 核心源码与实战》带大家动手，从零开发网页游戏《飞机大战》，快速上手 Vue 3.0 项目。开课吧的课程资料，现在 0 元领取。</a></p>
<h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  // ... some code

  if (/* 异步操作成功 */)&#123;
    resolve(value);
  &#125; else &#123;
    reject(error);
  &#125;
&#125;);
</code></pre>
<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<pre><code class="javascript">promise.then(function(value) &#123;
  // success
&#125;, function(error) &#123;
  // failure
&#125;);
</code></pre>
<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<pre><code class="javascript">function timeout(ms) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(resolve, ms, &#39;done&#39;);
  &#125;);
&#125;

timeout(100).then((value) =&gt; &#123;
  console.log(value);
&#125;);
</code></pre>
<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<pre><code class="javascript">let promise = new Promise(function(resolve, reject) &#123;
  console.log(&#39;Promise&#39;);
  resolve();
&#125;);

promise.then(function() &#123;
  console.log(&#39;resolved.&#39;);
&#125;);

console.log(&#39;Hi!&#39;);

// Promise
// Hi!
// resolved
</code></pre>
<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<pre><code class="javascript">function loadImageAsync(url) &#123;
  return new Promise(function(resolve, reject) &#123;
    const image = new Image();

    image.onload = function() &#123;
      resolve(image);
    &#125;;

    image.onerror = function() &#123;
      reject(new Error(&#39;Could not load image at &#39; + url));
    &#125;;

    image.src = url;
  &#125;);
&#125;
</code></pre>
<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<pre><code class="javascript">const getJSON = function(url) &#123;
  const promise = new Promise(function(resolve, reject)&#123;
    const handler = function() &#123;
      if (this.readyState !== 4) &#123;
        return;
      &#125;
      if (this.status === 200) &#123;
        resolve(this.response);
      &#125; else &#123;
        reject(new Error(this.statusText));
      &#125;
    &#125;;
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

  &#125;);

  return promise;
&#125;;

getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  console.log(&#39;Contents: &#39; + json);
&#125;, function(error) &#123;
  console.error(&#39;出错了&#39;, error);
&#125;);
</code></pre>
<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;
  // ...
&#125;);

const p2 = new Promise(function (resolve, reject) &#123;
  // ...
  resolve(p1);
&#125;)
</code></pre>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)
&#125;)

const p2 = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; resolve(p1), 1000)
&#125;)

p2
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre>
<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>
<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  resolve(1);
  console.log(2);
&#125;).then(r =&gt; &#123;
  console.log(r);
&#125;);
// 2
// 1
</code></pre>
<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
&#125;)
</code></pre>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre>
<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function (comments) &#123;
  console.log(&quot;resolved: &quot;, comments);
&#125;, function (err)&#123;
  console.log(&quot;rejected: &quot;, err);
&#125;);
</code></pre>
<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre>
<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>
<pre><code class="javascript">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));

// 等同于
p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  throw new Error(&#39;test&#39;);
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);
// Error: test
</code></pre>
<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<pre><code class="javascript">// 写法一
const promise = new Promise(function(resolve, reject) &#123;
  try &#123;
    throw new Error(&#39;test&#39;);
  &#125; catch(e) &#123;
    reject(e);
  &#125;
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);

// 写法二
const promise = new Promise(function(resolve, reject) &#123;
  reject(new Error(&#39;test&#39;));
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);
</code></pre>
<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  resolve(&#39;ok&#39;);
  throw new Error(&#39;test&#39;);
&#125;);
promise
  .then(function(value) &#123; console.log(value) &#125;)
  .catch(function(error) &#123; console.log(error) &#125;);
// ok
</code></pre>
<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre>
<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<pre><code class="javascript">// bad
promise
  .then(function(data) &#123;
    // success
  &#125;, function(err) &#123;
    // error
  &#125;);

// good
promise
  .then(function(data) &#123; //cb
    // success
  &#125;)
  .catch(function(err) &#123;
    // error
  &#125;);
</code></pre>
<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing().then(function() &#123;
  console.log(&#39;everything is great&#39;);
&#125;);

setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
</code></pre>
<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<pre><code class="javascript">process.on(&#39;unhandledRejection&#39;, function (err, p) &#123;
  throw err;
&#125;);
</code></pre>
<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">const promise = new Promise(function (resolve, reject) &#123;
  resolve(&#39;ok&#39;);
  setTimeout(function () &#123; throw new Error(&#39;test&#39;) &#125;, 0)
&#125;);
promise.then(function (value) &#123; console.log(value) &#125;);
// ok
// Uncaught Error: test
</code></pre>
<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing()
.catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
&#125;)
.then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// oh no [ReferenceError: x is not defined]
// carry on
</code></pre>
<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>
<pre><code class="javascript">Promise.resolve()
.catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
&#125;)
.then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// carry on
</code></pre>
<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing().then(function() &#123;
  return someOtherAsyncThing();
&#125;).catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为 y 没有声明
  y + 2;
&#125;).then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// oh no [ReferenceError: x is not defined]
</code></pre>
<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<pre><code class="javascript">someAsyncThing().then(function() &#123;
  return someOtherAsyncThing();
&#125;).catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为y没有声明
  y + 2;
&#125;).catch(function(error) &#123;
  console.log(&#39;carry on&#39;, error);
&#125;);
// oh no [ReferenceError: x is not defined]
// carry on [ReferenceError: y is not defined]
</code></pre>
<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre>
<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<pre><code class="javascript">server.listen(port)
  .then(function () &#123;
    // ...
  &#125;)
  .finally(server.stop);
</code></pre>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>
<pre><code class="javascript">promise
.finally(() =&gt; &#123;
  // 语句
&#125;);

// 等同于
promise
.then(
  result =&gt; &#123;
    // 语句
    return result;
  &#125;,
  error =&gt; &#123;
    // 语句
    throw error;
  &#125;
);
</code></pre>
<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<pre><code class="javascript">Promise.prototype.finally = function (callback) &#123;
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)
  );
&#125;;
</code></pre>
<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>
<pre><code class="javascript">// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; &#123;&#125;)

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)

// reject 的值是 3
Promise.reject(3).finally(() =&gt; &#123;&#125;)
</code></pre>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p>下面是一个具体的例子。</p>
<pre><code class="javascript">// 生成一个Promise对象的数组
const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;
  return getJSON(&#39;/post/&#39; + id + &quot;.json&quot;);
&#125;);

Promise.all(promises).then(function (posts) &#123;
  // ...
&#125;).catch(function(reason)&#123;
  // ...
&#125;);
</code></pre>
<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) =&gt; pickTopRecommendations(books, user));
</code></pre>
<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p>
<p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p>
<pre><code class="javascript">const urls = [url_1, url_2, url_3];
const requests = urls.map(x =&gt; fetch(x));

try &#123;
  await Promise.all(requests);
  console.log(&#39;所有请求都成功。&#39;);
&#125; catch &#123;
  console.log(&#39;至少一个请求失败，其他请求可能还没结束。&#39;);
&#125;
</code></pre>
<p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p>
<p>为了解决这个问题，<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p>
<p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre>
<p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p>
<p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p>
<pre><code class="javascript">const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) &#123;
  console.log(results);
&#125;);
// [
//    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,
//    &#123; status: &#39;rejected&#39;, reason: -1 &#125;
// ]
</code></pre>
<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p>
<p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p>
<pre><code class="javascript">// 异步操作成功时
&#123;status: &#39;fulfilled&#39;, value: value&#125;

// 异步操作失败时
&#123;status: &#39;rejected&#39;, reason: reason&#125;
</code></pre>
<p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p>
<p>下面是返回值的用法例子。</p>
<pre><code class="javascript">const promises = [ fetch(&#39;index.html&#39;), fetch(&#39;https://does-not-exist/&#39;) ];
const results = await Promise.allSettled(promises);

// 过滤出成功的请求
const successfulPromises = results.filter(p =&gt; p.status === &#39;fulfilled&#39;);

// 过滤出失败的请求，并输出原因
const errors = results
  .filter(p =&gt; p.status === &#39;rejected&#39;)
  .map(p =&gt; p.reason);
</code></pre>
<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>
<pre><code class="javascript">Promise.any([
  fetch(&#39;https://v8.dev/&#39;).then(() =&gt; &#39;home&#39;),
  fetch(&#39;https://v8.dev/blog&#39;).then(() =&gt; &#39;blog&#39;),
  fetch(&#39;https://v8.dev/docs&#39;).then(() =&gt; &#39;docs&#39;)
]).then((first) =&gt; &#123;  // 只要有一个 fetch() 请求成功
  console.log(first);
&#125;).catch((error) =&gt; &#123; // 所有三个 fetch() 全部请求失败
  console.log(error);
&#125;);
</code></pre>
<p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
<p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),
  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),
  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),
];

try &#123;
  const first = await Promise.any(promises);
  console.log(first);
&#125; catch (error) &#123;
  console.log(error);
&#125;
</code></pre>
<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<pre><code class="javascript">// new AggregateError() extends Array

const err = new AggregateError();
err.push(new Error(&quot;first error&quot;));
err.push(new Error(&quot;second error&quot;));
// ...
throw err;
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var resolved = Promise.resolve(42);
var rejected = Promise.reject(-1);
var alsoRejected = Promise.reject(Infinity);

Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;
  console.log(result); // 42
&#125;);

Promise.any([rejected, alsoRejected]).catch(function (results) &#123;
  console.log(results); // [-1, Infinity]
&#125;);
</code></pre>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<pre><code class="javascript">const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>
<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>
<p><strong>（1）参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<pre><code class="javascript">let thenable = &#123;
  then: function(resolve, reject) &#123;
    resolve(42);
  &#125;
&#125;;
</code></pre>
<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<pre><code class="javascript">let thenable = &#123;
  then: function(resolve, reject) &#123;
    resolve(42);
  &#125;
&#125;;

let p1 = Promise.resolve(thenable);
p1.then(function (value) &#123;
  console.log(value);  // 42
&#125;);
</code></pre>
<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>
<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<pre><code class="javascript">const p = Promise.resolve(&#39;Hello&#39;);

p.then(function (s) &#123;
  console.log(s)
&#125;);
// Hello
</code></pre>
<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<pre><code class="javascript">const p = Promise.resolve();

p.then(function () &#123;
  // ...
&#125;);
</code></pre>
<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<pre><code class="javascript">setTimeout(function () &#123;
  console.log(&#39;three&#39;);
&#125;, 0);

Promise.resolve().then(function () &#123;
  console.log(&#39;two&#39;);
&#125;);

console.log(&#39;one&#39;);

// one
// two
// three
</code></pre>
<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<pre><code class="javascript">const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre>
<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre>
<h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<pre><code class="javascript">function getFoo () &#123;
  return new Promise(function (resolve, reject)&#123;
    resolve(&#39;foo&#39;);
  &#125;);
&#125;

const g = function* () &#123;
  try &#123;
    const foo = yield getFoo();
    console.log(foo);
  &#125; catch (e) &#123;
    console.log(e);
  &#125;
&#125;;

function run (generator) &#123;
  const it = generator();

  function go(result) &#123;
    if (result.done) return result.value;

    return result.value.then(function (value) &#123;
      return go(it.next(value));
    &#125;, function (error) &#123;
      return go(it.throw(error));
    &#125;);
  &#125;

  go(it.next());
&#125;

run(g);
</code></pre>
<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
<h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<pre><code class="javascript">Promise.resolve().then(f)
</code></pre>
<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
Promise.resolve().then(f);
console.log(&#39;next&#39;);
// next
// now
</code></pre>
<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
(async () =&gt; f())();
console.log(&#39;next&#39;);
// now
// next
</code></pre>
<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<pre><code class="javascript">(async () =&gt; f())()
.then(...)
</code></pre>
<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<pre><code class="javascript">(async () =&gt; f())()
.then(...)
.catch(...)
</code></pre>
<p>第二种写法是使用<code>new Promise()</code>。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
(
  () =&gt; new Promise(
    resolve =&gt; resolve(f())
  )
)();
console.log(&#39;next&#39;);
// now
// next
</code></pre>
<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个<a target="_blank" rel="noopener" href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
Promise.try(f);
console.log(&#39;next&#39;);
// now
// next
</code></pre>
<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a target="_blank" rel="noopener" href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a target="_blank" rel="noopener" href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a target="_blank" rel="noopener" href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<pre><code class="javascript">function getUsername(userId) &#123;
  return database.users.get(&#123;id: userId&#125;)
  .then(function(user) &#123;
    return user.name;
  &#125;);
&#125;
</code></pre>
<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<pre><code class="javascript">database.users.get(&#123;id: userId&#125;)
.then(...)
.catch(...)
</code></pre>
<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<pre><code class="javascript">try &#123;
  database.users.get(&#123;id: userId&#125;)
  .then(...)
  .catch(...)
&#125; catch (e) &#123;
  // ...
&#125;
</code></pre>
<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<pre><code class="javascript">Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))
  .then(...)
  .catch(...)
</code></pre>
<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1.proxy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/04/1.proxy/" class="article-date">
  	<time datetime="2022-09-04T07:54:55.224Z" itemprop="datePublished">2022-09-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/04/1.proxy/">
        ES6-proxy
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy#%E6%A6%82%E8%BF%B0">概述</a></li>
<li>[Proxy 实例的方法](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy#Proxy">https://es6.ruanyifeng.com/#docs/proxy#Proxy</a> 实例的方法)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy#Proxy.revocable()">Proxy.revocable()</a></li>
<li>[this 问题](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy#this">https://es6.ruanyifeng.com/#docs/proxy#this</a> 问题)</li>
<li>[实例：Web 服务的客户端](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy#%E5%AE%9E%E4%BE%8B%EF%BC%9AWeb">https://es6.ruanyifeng.com/#docs/proxy#实例：Web</a> 服务的客户端)</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://wx.kaikeba.com/xiaoke/market/landing-page/v2/N3MIpFtF2DZ91C502gp?kol_ad_code=kKx4Fnfd9ENkHgIfwHb">【课程消息】《Vue 3.0 核心源码与实战》带大家动手，从零开发网页游戏《飞机大战》，快速上手 Vue 3.0 项目。开课吧的课程资料，现在 0 元领取。</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code class="javascript">var obj = new Proxy(&#123;&#125;, &#123;
  get: function (target, propKey, receiver) &#123;
    console.log(`getting $&#123;propKey&#125;!`);
    return Reflect.get(target, propKey, receiver);
  &#125;,
  set: function (target, propKey, value, receiver) &#123;
    console.log(`setting $&#123;propKey&#125;!`);
    return Reflect.set(target, propKey, value, receiver);
  &#125;
&#125;);
</code></pre>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<pre><code class="javascript">obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
</code></pre>
<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler);
</code></pre>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre>
<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<pre><code class="javascript">var target = &#123;&#125;;
var handler = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.a = &#39;b&#39;;
target.a // &quot;b&quot;
</code></pre>
<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<pre><code class="javascript">var object = &#123; proxy: new Proxy(target, handler) &#125;;
</code></pre>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

let obj = Object.create(proxy);
obj.time // 35
</code></pre>
<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<pre><code class="javascript">var handler = &#123;
  get: function(target, name) &#123;
    if (name === &#39;prototype&#39;) &#123;
      return Object.prototype;
    &#125;
    return &#39;Hello, &#39; + name;
  &#125;,

  apply: function(target, thisBinding, args) &#123;
    return args[0];
  &#125;,

  construct: function(target, args) &#123;
    return &#123;value: args[1]&#125;;
  &#125;
&#125;;

var fproxy = new Proxy(function(x, y) &#123;
  return x + y;
&#125;, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // &#123;value: 2&#125;
fproxy.prototype === Object.prototype // true
fproxy.foo === &quot;Hello, foo&quot; // true
</code></pre>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    if (propKey in target) &#123;
      return target[propKey];
    &#125; else &#123;
      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);
    &#125;
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
proxy.age // 抛出一个错误
</code></pre>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>
<p><code>get</code>方法可以继承。</p>
<pre><code class="javascript">let proto = new Proxy(&#123;&#125;, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(&#39;GET &#39; + propertyKey);
    return target[propertyKey];
  &#125;
&#125;);

let obj = Object.create(proto);
obj.foo // &quot;GET foo&quot;
</code></pre>
<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c
</code></pre>
<p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p>
<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<pre><code class="javascript">var pipe = function (value) &#123;
  var funcStack = [];
  var oproxy = new Proxy(&#123;&#125; , &#123;
    get : function (pipeObject, fnName) &#123;
      if (fnName === &#39;get&#39;) &#123;
        return funcStack.reduce(function (val, fn) &#123;
          return fn(val);
        &#125;,value);
      &#125;
      funcStack.push(window[fnName]);
      return oproxy;
    &#125;
  &#125;);

  return oproxy;
&#125;

var double = n =&gt; n * 2;
var pow    = n =&gt; n * n;
var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;

pipe(3).double.pow.reverseInt.get; // 63
</code></pre>
<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p>
<pre><code class="javascript">const dom = new Proxy(&#123;&#125;, &#123;
  get(target, property) &#123;
    return function(attrs = &#123;&#125;, ...children) &#123;
      const el = document.createElement(property);
      for (let prop of Object.keys(attrs)) &#123;
        el.setAttribute(prop, attrs[prop]);
      &#125;
      for (let child of children) &#123;
        if (typeof child === &#39;string&#39;) &#123;
          child = document.createTextNode(child);
        &#125;
        el.appendChild(child);
      &#125;
      return el;
    &#125;
  &#125;
&#125;);

const el = dom.div(&#123;&#125;,
  &#39;Hello, my name is &#39;,
  dom.a(&#123;href: &#39;//example.com&#39;&#125;, &#39;Mark&#39;),
  &#39;. I like:&#39;,
  dom.ul(&#123;&#125;,
    dom.li(&#123;&#125;, &#39;The web&#39;),
    dom.li(&#123;&#125;, &#39;Food&#39;),
    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)
  )
);

document.body.appendChild(el);
</code></pre>
<p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p>
<pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);
proxy.getReceiver === proxy // true
</code></pre>
<p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p>
<pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);

const d = Object.create(proxy);
d.a === d // true
</code></pre>
<p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p>
<p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
    return true;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre>
<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code class="javascript">const handler = &#123;
  get (target, key) &#123;
    invariant(key, &#39;get&#39;);
    return target[key];
  &#125;,
  set (target, key, value) &#123;
    invariant(key, &#39;set&#39;);
    target[key] = value;
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;
const target = &#123;&#125;;
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &#39;c&#39;
// Error: Invalid attempt to set private &quot;_prop&quot; property
</code></pre>
<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p>下面是<code>set</code>方法第四个参数的例子。</p>
<pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    return true;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
proxy.foo === proxy // true
</code></pre>
<p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p>
<pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    return true;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
const myObj = &#123;&#125;;
Object.setPrototypeOf(myObj, proxy);

myObj.foo = &#39;bar&#39;;
myObj.foo === myObj // true
</code></pre>
<p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p>
<p>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
    return true;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;
</code></pre>
<p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p>
<p>注意，<code>set</code>代理应当返回一个布尔值。严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</code></pre>
<p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<pre><code class="javascript">var handler = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments);
  &#125;
&#125;;
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var target = function () &#123; return &#39;I am the target&#39;; &#125;;
var handler = &#123;
  apply: function () &#123;
    return &#39;I am the proxy&#39;;
  &#125;
&#125;;

var p = new Proxy(target, handler);

p()
// &quot;I am the proxy&quot;
</code></pre>
<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>
<p>下面是另外一个例子。</p>
<pre><code class="javascript">var twice = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments) * 2;
  &#125;
&#125;;
function sum (left, right) &#123;
  return left + right;
&#125;;
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30
</code></pre>
<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>
<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>
<pre><code class="javascript">Reflect.apply(proxy, null, [9, 10]) // 38
</code></pre>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<pre><code class="javascript">var handler = &#123;
  has (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return false;
    &#125;
    return key in target;
  &#125;
&#125;;
var target = &#123; _prop: &#39;foo&#39;, prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
&#39;_prop&#39; in proxy // false
</code></pre>
<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p>
<pre><code class="javascript">var obj = &#123; a: 10 &#125;;
Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  has: function(target, prop) &#123;
    return false;
  &#125;
&#125;);

&#39;a&#39; in p // TypeError is thrown
</code></pre>
<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>
<p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p>
<pre><code class="javascript">let stu1 = &#123;name: &#39;张三&#39;, score: 59&#125;;
let stu2 = &#123;name: &#39;李四&#39;, score: 99&#125;;

let handler = &#123;
  has(target, prop) &#123;
    if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;
      console.log(`$&#123;target.name&#125; 不及格`);
      return false;
    &#125;
    return prop in target;
  &#125;
&#125;

let oproxy1 = new Proxy(stu1, handler);
let oproxy2 = new Proxy(stu2, handler);

&#39;score&#39; in oproxy1
// 张三 不及格
// false

&#39;score&#39; in oproxy2
// true

for (let a in oproxy1) &#123;
  console.log(oproxy1[a]);
&#125;
// 张三
// 59

for (let b in oproxy2) &#123;
  console.log(oproxy2[b]);
&#125;
// 李四
// 99
</code></pre>
<p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>
<pre><code class="javascript">const handler = &#123;
  construct (target, args, newTarget) &#123;
    return new target(...args);
  &#125;
&#125;;
</code></pre>
<p><code>construct()</code>方法可以接受三个参数。</p>
<ul>
<li><code>target</code>：目标对象。</li>
<li><code>args</code>：构造函数的参数数组。</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li>
</ul>
<pre><code class="javascript">const p = new Proxy(function () &#123;&#125;, &#123;
  construct: function(target, args) &#123;
    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));
    return &#123; value: args[0] * 10 &#125;;
  &#125;
&#125;);

(new p(1)).value
// &quot;called: 1&quot;
// 10
</code></pre>
<p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p>
<pre><code class="javascript">const p = new Proxy(function() &#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return 1;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)
</code></pre>
<p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p>
<pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return &#123;&#125;;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: p is not a constructor
</code></pre>
<p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p>
<p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p>
<pre><code class="javascript">const handler = &#123;
  construct: function(target, args) &#123;
    console.log(this === handler);
    return new target(...args);
  &#125;
&#125;

let p = new Proxy(function () &#123;&#125;, handler);
new p() // true
</code></pre>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    delete target[key];
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: Invalid attempt to delete private &quot;_prop&quot; property
</code></pre>
<p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p>
<pre><code class="javascript">var handler = &#123;
  defineProperty (target, key, descriptor) &#123;
    return false;
  &#125;
&#125;;
var target = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.foo = &#39;bar&#39; // 不会生效
</code></pre>
<p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>
<p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p>
<pre><code class="javascript">var handler = &#123;
  getOwnPropertyDescriptor (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return;
    &#125;
    return Object.getOwnPropertyDescriptor(target, key);
  &#125;
&#125;;
var target = &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)
// &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;
</code></pre>
<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript">var proto = &#123;&#125;;
var p = new Proxy(&#123;&#125;, &#123;
  getPrototypeOf(target) &#123;
    return proto;
  &#125;
&#125;);
Object.getPrototypeOf(p) === proto // true
</code></pre>
<p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>
<p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    console.log(&quot;called&quot;);
    return true;
  &#125;
&#125;);

Object.isExtensible(p)
// &quot;called&quot;
// true
</code></pre>
<p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>
<pre><code class="javascript">Object.isExtensible(proxy) === Object.isExtensible(target)
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    return false;
  &#125;
&#125;);

Object.isExtensible(p)
// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)
</code></pre>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for...in</code>循环</li>
</ul>
<p>下面是拦截<code>Object.keys()</code>的例子。</p>
<pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3
&#125;;

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [ &#39;a&#39; ]
</code></pre>
<p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<pre><code class="javascript">let target = &#123;
  _bar: &#39;foo&#39;,
  _prop: &#39;bar&#39;,
  prop: &#39;baz&#39;
&#125;;

let handler = &#123;
  ownKeys (target) &#123;
    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;);
  &#125;
&#125;;

let proxy = new Proxy(target, handler);
for (let key of Object.keys(proxy)) &#123;
  console.log(target[key]);
&#125;
// &quot;baz&quot;
</code></pre>
<p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为 Symbol 值</li>
<li>不可遍历（<code>enumerable</code>）的属性</li>
</ul>
<pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3,
  [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;,
&#125;;

Object.defineProperty(target, &#39;key&#39;, &#123;
  enumerable: false,
  configurable: true,
  writable: true,
  value: &#39;static&#39;
&#125;);

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [&#39;a&#39;]
</code></pre>
<p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
<p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>
<pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</code></pre>
<p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p>
<pre><code class="javascript">const obj = &#123; hello: &#39;world&#39; &#125;;
const proxy = new Proxy(obj, &#123;
  ownKeys: function () &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

for (let key in proxy) &#123;
  console.log(key); // 没有任何输出
&#125;
</code></pre>
<p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p>
<p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<pre><code class="javascript">var obj = &#123;&#125;;

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [123, true, undefined, null, &#123;&#125;, []];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: 123 is not a valid property name
</code></pre>
<p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>
<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p>
<pre><code class="javascript">var obj = &#123;&#125;;
Object.defineProperty(obj, &#39;a&#39;, &#123;
  configurable: false,
  enumerable: true,
  value: 10 &#125;
);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39;
</code></pre>
<p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>
<p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>
<pre><code class="javascript">var obj = &#123;
  a: 1
&#125;;

Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible
</code></pre>
<p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible
</code></pre>
<p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>
<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p>
<pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    console.log(&#39;called&#39;);
    Object.preventExtensions(target);
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// &quot;called&quot;
// Proxy &#123;&#125;
</code></pre>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p>
<p>下面是一个例子。</p>
<pre><code class="javascript">var handler = &#123;
  setPrototypeOf (target, proto) &#123;
    throw new Error(&#39;Changing the prototype is forbidden&#39;);
  &#125;
&#125;;
var proto = &#123;&#125;;
var target = function () &#123;&#125;;
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden
</code></pre>
<p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>
<pre><code class="javascript">let target = &#123;&#125;;
let handler = &#123;&#125;;

let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
</code></pre>
<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<pre><code class="javascript">const target = &#123;
  m: function () &#123;
    console.log(this === proxy);
  &#125;
&#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true
</code></pre>
<p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。所以，虽然<code>proxy</code>没有做任何拦截，<code>target.m()</code>和<code>proxy.m()</code>返回不一样的结果。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>
<pre><code class="javascript">const _name = new WeakMap();

class Person &#123;
  constructor(name) &#123;
    _name.set(this, name);
  &#125;
  get name() &#123;
    return _name.get(this);
  &#125;
&#125;

const jane = new Person(&#39;Jane&#39;);
jane.name // &#39;Jane&#39;

const proxy = new Proxy(jane, &#123;&#125;);
proxy.name // undefined
</code></pre>
<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<pre><code class="javascript">const target = new Date();
const handler = &#123;&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.
</code></pre>
<p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<pre><code class="javascript">const target = new Date(&#39;2015-01-01&#39;);
const handler = &#123;
  get(target, prop) &#123;
    if (prop === &#39;getDate&#39;) &#123;
      return target.getDate.bind(target);
    &#125;
    return Reflect.get(target, prop);
  &#125;
&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate() // 1
</code></pre>
<p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p>
<pre><code class="javascript">const handler = &#123;
  get: function (target, key, receiver) &#123;
    console.log(this === handler);
    return &#39;Hello, &#39; + key;
  &#125;,
  set: function (target, key, value) &#123;
    console.log(this === handler);
    target[key] = value;
    return true;
  &#125;
&#125;;

const proxy = new Proxy(&#123;&#125;, handler);

proxy.foo
// true
// Hello, foo

proxy.foo = 1
// true
</code></pre>
<p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p>
<h2 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<pre><code class="javascript">const service = createWebService(&#39;http://example.com/data&#39;);

service.employees().then(json =&gt; &#123;
  const employees = JSON.parse(json);
  // ···
&#125;);
</code></pre>
<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<pre><code class="javascript">function createWebService(baseUrl) &#123;
  return new Proxy(&#123;&#125;, &#123;
    get(target, propKey, receiver) &#123;
      return () =&gt; httpGet(baseUrl + &#39;/&#39; + propKey);
    &#125;
  &#125;);
&#125;
</code></pre>
<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-result" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/04/result/" class="article-date">
  	<time datetime="2022-09-04T07:50:53.284Z" itemprop="datePublished">2022-09-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/04/result/">
        JS-隐式类型转换
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>[] == 0</code> //返回结果是 true<br><code>![] == 0</code> //返回结果是 true<br>[] == ‘’ //返回结果是 true<br>!![] == ‘’ //返回结果是 false<br>‘’ == true //返回结果是 false</p>
<p>隐式转换内容：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014465934/article/details/84642329">https://blog.csdn.net/u014465934/article/details/84642329</a><br>不建议在开发中使用==与 let，let 应极力避免。而且应该在开发中避免隐式转换的使用，方便自己也方便他人的代码阅读</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-01常规操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/02/01%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/" class="article-date">
  	<time datetime="2022-09-02T08:03:46.553Z" itemprop="datePublished">2022-09-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/02/01%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/">
        SVN-修改svn密码
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>修改svn密码:<br> 办法1：<br>SVN的密码保存在服务器上，一般能通过Web方式修改密码（前提是服务器上安装了SVNManager或者其它的PHP或者CGI程序）<br>如果SVN是和Apache一起使用的话，可以找到Apache目录下的 conf\httpd.conf文件，里面的&lt;Location /svn&gt;段中 AuthUserFile 指定的就是用户密码文件，是文本形式的，密码用MD5加密。<br>如果不是SVN，那就找SVN库下的conf/passwd文件，是文本文件，密码未加密</p>
<p> 办法2：<br>TortoiseSVN更改用户名密码<br>在项目上右键，选择TortoiseSVN–&gt;settings,在弹出的TortoiseSVN Settings页面中选择“Saved Data”选项，然后点击“Authentication data”对应的“Clear”按钮，清除一下之前的认证信息就可以了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-01 git常用操作命令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/02/01%20git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/" class="article-date">
  	<time datetime="2022-09-02T07:34:47.661Z" itemprop="datePublished">2022-09-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/02/01%20git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/">
        Git-git常用操作命令
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><pre><code>git add
</code></pre>
<blockquote>
<p>新增文件</p>
</blockquote>
<pre><code>git commit -m
</code></pre>
<blockquote>
<p>新增日志</p>
</blockquote>
<pre><code>git log
</code></pre>
<blockquote>
<p>查看日志</p>
</blockquote>
<pre><code>git reflog
</code></pre>
<blockquote>
<p>查看日志操作日志哦</p>
</blockquote>
<pre><code>git status
</code></pre>
<blockquote>
<p>查看状态</p>
</blockquote>
<pre><code>git diff
</code></pre>
<blockquote>
<p>查看不同</p>
</blockquote>
<pre><code>gid reset --hard +&quot;版本号&quot;
</code></pre>
<blockquote>
<p>回退版本</p>
</blockquote>
<pre><code>git clone url
</code></pre>
<p>​ 克隆需远程仓库的地址 url</p>
<pre><code>gitk
</code></pre>
<p>查看代码图解</p>
<pre><code>git checkout  -b  name
</code></pre>
<p>创建分支前先在本地切换到 develop 分支并且 pull 一下此时分支为 develop，然后进行下面指令操作本地创建新分支</p>
<pre><code>git checkout -b name origin/develop
</code></pre>
<p>创建远程已有分支，远程分支是以 develop 复制创建的</p>
<pre><code>git branch
</code></pre>
<p>查看当前分支</p>
<pre><code>git checkout  name
</code></pre>
<p>切换分支</p>
<pre><code>git pull
</code></pre>
<p>拉去远程代码</p>
<pre><code>git merge
</code></pre>
<p>合并代码，交叉合并</p>
<pre><code>git merge  --no-ff
</code></pre>
<p>合并代码，交叉合并</p>
<pre><code>git rebase
</code></pre>
<p>合并代码，不产生交叉合并</p>
<pre><code>git fetch  origin
</code></pre>
<p>分支名 从远程仓库拉取到本地：</p>
<pre><code>git fetch
</code></pre>
<p>分支名 从远程仓库中抓取与拉去</p>
<pre><code>git push origin master
</code></pre>
<p>提交到远程仓库 master 上</p>
<pre><code>git  config -l
</code></pre>
<p>查看 git 名字和 email</p>
<pre><code>git config --global  user.name &#39;mingzi&#39;
</code></pre>
<p>修改用户名</p>
<pre><code>git config --global   user.email &#39;邮箱地址&#39;
</code></pre>
<p>修改邮箱地址</p>
<pre><code>git remote rm origin
</code></pre>
<p>​ 删除远程 Git 仓库</p>
<pre><code>git remote add origin https:......git
</code></pre>
<p>​ 本地项目关联远程仓库</p>
<p>运行</p>
<pre><code>git fetch
</code></pre>
<p>，可以将远程分支信息获取到本地，再运行</p>
<pre><code>git checkout -b local-branchname origin/remote_branchname
</code></pre>
<p>就可以将远程分支映射到本地命名为 local-branchname 的一分支</p>
<pre><code>git branch --set-upstream-to=origin/dev
</code></pre>
<p>设置</p>
<pre><code>git push,pul
</code></pre>
<p>l 默认的提交获取分支,这样就很方便的使用 git push 提交信息或 git pull 获取信息</p>
<pre><code> git branch --unset-upstream master
</code></pre>
<p>​ 取消对 master 的跟踪</p>
<p><em>git</em> <em>config</em> –<em>global</em> <em>gui</em>.<em>encoding</em> <em>utf</em>-<em>8</em> 修改 gitk 乱码现象</p>
<p><strong>如何放弃本地文件修改</strong></p>
<p>1.git reset HEAD . 清除已经 git add 缓存的文件</p>
<p>2.git checkout . 未使用 git add 放弃所有文件修改</p>
<p>3.git reset –hard HEAD^ 文件已提交 commit，可以回退到上个 commit 版本</p>
<p>生成安全密钥：</p>
<p>ssh-keygen -t rsa -C “<a href="mailto:&#x39;&#52;&#x35;&#52;&#x39;&#x37;&#x33;&#52;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x39;&#52;&#x35;&#52;&#x39;&#x37;&#x33;&#52;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>“</p>
<p>git stash 保存到暂存区</p>
<p>git stash pop 从暂存区拉去代码</p>
<p>git cherry-pick 某个commit id  从其他分支拉取commit到本分支上</p>
<p><strong>PRO GIT</strong></p>
<p>1.<a target="_blank" rel="noopener" href="https://www.progit.cn/">https://www.progit.cn</a> pro git 里面有最全的 git 命令讲解</p>
<p>修改 git 密码：解决方法三<br>进入控制面板》用户账号》凭据管理器？windows 凭据》普通凭据，在里面找到 git，点开编辑密码，更新为最新密码之后就可以正常操作了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-1.初始ts" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/1.%E5%88%9D%E5%A7%8Bts/" class="article-date">
  	<time datetime="2022-08-29T07:57:24.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/1.%E5%88%9D%E5%A7%8Bts/">
        安装 TypeScript
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.在线笔记地址<a target="_blank" rel="noopener" href="http://huaxhe.gitee.io/vue3_study_docs/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.htm">http://huaxhe.gitee.io/vue3_study_docs/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.htm</a></p>
<p>2.安装 TypeScript</p>
<p>命令行运行如下命令，全局安装 TypeScript：</p>
<pre><code class="bash">npm install -g typescript
</code></pre>
<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>
<pre><code class="bash">tsc -V
</code></pre>
<p>3.<a target="_blank" rel="noopener" href="https://vitejs.cn/guide/why.html#slow-updates">https://vitejs.cn/guide/why.html#slow-updates</a>   vite官网</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>