<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/5/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-css-清除浮动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/css-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/" class="article-date">
  	<time datetime="2022-09-05T03:09:34.605Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/css-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/">
        Css-清除浮动
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="css">.clearfix::after &#123;
  content: &quot;&quot;;
  clear: both;
  display: table;
&#125;
</code></pre>
<h4 id="1-上面伪类清除法"><a href="#1-上面伪类清除法" class="headerlink" title="1.上面伪类清除法"></a>1.上面伪类清除法</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-15参考链接" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/15%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/" class="article-date">
  	<time datetime="2022-09-05T02:55:02.204Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/15%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/">
        Es6-参考链接
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E5%AE%98%E6%96%B9%E6%96%87%E4%BB%B6">官方文件</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E7%BB%BC%E5%90%88%E4%BB%8B%E7%BB%8D">综合介绍</a></li>
<li>[let 和 const](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#let">https://es6.ruanyifeng.com/#docs/reference#let</a> 和 const)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E6%AD%A3%E5%88%99">正则</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E6%95%B0%E5%80%BC">数值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E5%AF%B9%E8%B1%A1">对象</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Symbol">Symbol</a></li>
<li>[Set 和 Map](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Set">https://es6.ruanyifeng.com/#docs/reference#Set</a> 和 Map)</li>
<li>[Proxy 和 Reflect](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Proxy">https://es6.ruanyifeng.com/#docs/reference#Proxy</a> 和 Reflect)</li>
<li>[Promise 对象](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Promise">https://es6.ruanyifeng.com/#docs/reference#Promise</a> 对象)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Iterator">Iterator</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Generator">Generator</a></li>
<li>[异步操作和 Async 函数](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%92%8C">https://es6.ruanyifeng.com/#docs/reference#异步操作和</a> Async 函数)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Class">Class</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Decorator">Decorator</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#Module">Module</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%BB%84">二进制数组</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#SIMD">SIMD</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/reference#%E5%B7%A5%E5%85%B7">工具</a></li>
</ol>
<h2 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/index.html">ECMAScript® 2015 Language Specification</a>: ECMAScript 2015 规格</li>
<li><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/7.0/">ECMAScript® 2016 Language Specification</a>: ECMAScript 2016 规格</li>
<li><a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/">ECMAScript® 2017 Language Specification</a>：ECMAScript 2017 规格（草案）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/ecma262">ECMAScript Current Proposals</a>: ECMAScript 当前的所有提案</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/proposals">ECMAScript Active Proposals</a>: 已经进入正式流程的提案</li>
<li><a target="_blank" rel="noopener" href="https://github.com/hemanth/es-next">ECMAScript proposals</a>：从阶段 0 到阶段 4 的所有提案列表</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/agendas">TC39 meeting agendas</a>: TC39 委员会历年的会议记录</li>
<li><a target="_blank" rel="noopener" href="https://ecmascript-daily.github.io/">ECMAScript Daily</a>: TC39 委员会的动态</li>
<li><a target="_blank" rel="noopener" href="https://tc39.github.io/process-document/">The TC39 Process</a>: 提案进入正式规格的流程</li>
<li><a target="_blank" rel="noopener" href="https://thefeedbackloop.xyz/tc39-a-process-sketch-stages-0-and-1/">TC39: A Process Sketch, Stages 0 and 1</a>: Stage 0 和 Stage 1 的含义</li>
<li><a target="_blank" rel="noopener" href="https://thefeedbackloop.xyz/tc39-process-sketch-stage-2/">TC39 Process Sketch, Stage 2</a>: Stage 2 的含义</li>
</ul>
<h2 id="综合介绍"><a href="#综合介绍" class="headerlink" title="综合介绍"></a>综合介绍</h2><ul>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="http://exploringjs.com/es6/">Exploring ES6: Upgrade to the next version of JavaScript</a>: ES6 的专著，本书的许多代码实例来自该书</li>
<li>Sayanee Basu, <a target="_blank" rel="noopener" href="http://net.tutsplus.com/articles/news/ecmascript-6-today/">Use ECMAScript 6 Today</a></li>
<li>Ariya Hidayat, <a target="_blank" rel="noopener" href="http://www.sencha.com/blog/toward-modern-web-apps-with-ecmascript-6/">Toward Modern Web Apps with ECMAScript 6</a></li>
<li>Dale Schouten, <a target="_blank" rel="noopener" href="http://html5hub.com/10-ecmascript-6-tricks-you-can-perform-right-now/">10 Ecmascript-6 tricks you can perform right now</a></li>
<li>Colin Toh, <a target="_blank" rel="noopener" href="http://colintoh.com/blog/lightweight-es6-features">Lightweight ES6 Features That Pack A Punch</a>: ES6 的一些“轻量级”的特性介绍</li>
<li>Domenic Denicola, <a target="_blank" rel="noopener" href="http://www.slideshare.net/domenicdenicola/es6-the-awesome-parts">ES6: The Awesome Parts</a></li>
<li>Nicholas C. Zakas, <a target="_blank" rel="noopener" href="https://github.com/nzakas/understandinges6">Understanding ECMAScript 6</a></li>
<li>Justin Drake, <a target="_blank" rel="noopener" href="https://github.com/JustinDrake/node-es6-examples">ECMAScript 6 in Node.JS</a></li>
<li>Ryan Dao, <a target="_blank" rel="noopener" href="http://ryandao.net/portal/content/summary-ecmascript-6-major-features">Summary of ECMAScript 6 major features</a></li>
<li>Luke Hoban, <a target="_blank" rel="noopener" href="https://github.com/lukehoban/es6features">ES6 features</a>: ES6 新语法点的罗列</li>
<li>Traceur-compiler, <a target="_blank" rel="noopener" href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures">Language Features</a>: Traceur 文档列出的一些 ES6 例子</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://speakerdeck.com/rauschma/ecmascript-6-whats-next-for-javascript-august-2014">ECMAScript 6: what’s next for JavaScript?</a>: 关于 ES6 新增语法的综合介绍，有很多例子</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/08/getting-started-es6.html">Getting started with ECMAScript 6</a>: ES6 语法点的综合介绍</li>
<li>Toby Ho, <a target="_blank" rel="noopener" href="http://davidwalsh.name/es6-io">ES6 in io.js</a></li>
<li>Guillermo Rauch, <a target="_blank" rel="noopener" href="http://rauchg.com/2015/ecmascript-6/">ECMAScript 6</a></li>
<li>Benjamin De Cock, <a target="_blank" rel="noopener" href="https://github.com/bendc/frontend-guidelines">Frontend Guidelines</a>: ES6 最佳实践</li>
<li>Jani Hartikainen, <a target="_blank" rel="noopener" href="http://codeutopia.net/blog/2015/01/06/es6-what-are-the-benefits-of-the-new-features-in-practice/">ES6: What are the benefits of the new features in practice?</a></li>
<li>kangax, <a target="_blank" rel="noopener" href="http://perfectionkills.com/javascript-quiz-es6/">JavaScript quiz. ES6 edition</a>: ES6 小测试</li>
<li>Jeremy Fairbank, <a target="_blank" rel="noopener" href="https://speakerdeck.com/jfairbank/html5devconf-es7-and-beyond">HTML5DevConf ES7 and Beyond!</a>: ES7 新增语法点介绍</li>
<li>Timothy Gu, <a target="_blank" rel="noopener" href="https://timothygu.me/es-howto/">How to Read the ECMAScript Specification</a>: 如何读懂 ES6 规格</li>
</ul>
<h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><ul>
<li>Kyle Simpson, <a target="_blank" rel="noopener" href="http://davidwalsh.name/for-and-against-let">For and against let</a>: 讨论 let 命令的作用域</li>
<li>kangax, <a target="_blank" rel="noopener" href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15">Why typeof is no longer “safe”</a>: 讨论在块级作用域内，let 命令的变量声明和赋值的行为</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/02/es6-scoping.html">Variables and scoping in ECMAScript 6</a>: 讨论块级作用域与 let 和 const 的行为</li>
<li>Nicolas Bevacqua, <a target="_blank" rel="noopener" href="http://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth">ES6 Let, Const and the “Temporal Dead Zone” (TDZ) in Depth</a></li>
<li>acorn, <a target="_blank" rel="noopener" href="https://github.com/ternjs/acorn/issues/118">Function statements in strict mode</a>: 块级作用域对严格模式的函数声明的影响</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2016/09/global.html">ES proposal: global</a>: 顶层对象<code>global</code></li>
<li>Mathias Bynens, <a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/globalthis">A horrifying <code>globalThis</code> polyfill in universal JavaScript</a>：如何写 globalThis 的垫片库</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul>
<li>Nick Fitzgerald, <a target="_blank" rel="noopener" href="http://fitzgeraldnick.com/weblog/50/">Destructuring Assignment in ECMAScript 6</a>: 详细介绍解构赋值的用法</li>
<li>Nicholas C. Zakas, <a target="_blank" rel="noopener" href="https://www.nczonline.net/blog/2015/10/ecmascript-6-destructuring-gotcha/">ECMAScript 6 destructuring gotcha</a></li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>Nicholas C. Zakas, <a target="_blank" rel="noopener" href="http://www.nczonline.net/blog/2012/08/01/a-critical-review-of-ecmascript-6-quasi-literals/">A critical review of ECMAScript 6 quasi-literals</a></li>
<li>Mozilla Developer Network, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">Template strings</a></li>
<li>Addy Osmani, <a target="_blank" rel="noopener" href="http://updates.html5rocks.com/2015/01/ES6-Template-Strings">Getting Literal With ES6 Template Strings</a>: 模板字符串的介绍</li>
<li>Blake Winton, <a target="_blank" rel="noopener" href="https://weblog.latte.ca/blake/tech/firefox/templates.html">ES6 Templates</a>: 模板字符串的介绍</li>
<li>Peter Jaszkowiak, <a target="_blank" rel="noopener" href="https://medium.com/@PitaJ/how-to-write-a-template-compiler-in-javascript-f174df6f32f">How to write a template compiler in JavaScript</a>: 使用模板字符串，编写一个模板编译函数</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/11/string-padding.html">ES.stage3: string padding</a></li>
</ul>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ul>
<li>Mathias Bynens, <a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/es6-unicode-regex">Unicode-aware regular expressions in ES6</a>: 详细介绍正则表达式的 u 修饰符</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/07/regexp-es6.html">New regular expression features in ECMAScript 6</a>：ES6 正则特性的详细介绍</li>
<li>Yang Guo, <a target="_blank" rel="noopener" href="http://v8project.blogspot.jp/2016/02/regexp-lookbehind-assertions.html">RegExp lookbehind assertions</a>：介绍后行断言</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2017/05/regexp-named-capture-groups.html">ES proposal: RegExp named capture groups</a>: 具名组匹配的介绍</li>
<li>Mathias Bynens, <a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/es-regexp-proposals">ECMAScript regular expressions are getting better!</a>: 介绍 ES2018 添加的多项正则语法</li>
</ul>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ul>
<li>Nicolas Bevacqua, <a target="_blank" rel="noopener" href="http://ponyfoo.com/articles/es6-number-improvements-in-depth">ES6 Number Improvements in Depth</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2017/03/es-integer.html">ES proposal: arbitrary precision integers</a></li>
<li>Mathias Bynens, <a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2018/05/bigint">BigInt: arbitrary-precision integers in JavaScript</a></li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/05/es6-array-methods.html">ECMAScript 6’s new array methods</a>: 对 ES6 新增的数组方法的全面介绍</li>
<li>TC39, <a target="_blank" rel="noopener" href="https://github.com/tc39/Array.prototype.includes/">Array.prototype.includes</a>: 数组的 includes 方法的规格</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/09/holes-arrays-es6.html">ECMAScript 6: holes in Arrays</a>: 数组的空位问题</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>Nicholas C. Zakas, <a target="_blank" rel="noopener" href="http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/">Understanding ECMAScript 6 arrow functions</a></li>
<li>Jack Franklin, <a target="_blank" rel="noopener" href="http://javascriptplayground.com/blog/2014/04/real-life-es6-arrow-fn/">Real Life ES6 - Arrow Functions</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/04/required-parameters-es6.html">Handling required parameters in ECMAScript 6</a></li>
<li>Dmitry Soshnikov, <a target="_blank" rel="noopener" href="http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/">ES6 Notes: Default values of parameters</a>: 介绍参数的默认值</li>
<li>Ragan Wald, <a target="_blank" rel="noopener" href="http://raganwald.com/2015/02/02/destructuring.html">Destructuring and Recursion in ES6</a>: rest 参数和扩展运算符的详细介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/09/function-names-es6.html">The names of functions in ES6</a>: 函数的 name 属性的详细介绍</li>
<li>Kyle Simpson, <a target="_blank" rel="noopener" href="http://blog.getify.com/arrow-this/">Arrow This</a>: 箭头函数并没有自己的 this</li>
<li>Derick Bailey, <a target="_blank" rel="noopener" href="http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/">Do ES6 Arrow Functions Really Solve “this” In JavaScript?</a>：使用箭头函数处理 this 指向，必须非常小心</li>
<li>Mark McDonnell, <a target="_blank" rel="noopener" href="http://www.integralist.co.uk/posts/js-recursion.html">Understanding recursion in functional JavaScript programming</a>: 如何自己实现尾递归优化</li>
<li>Nicholas C. Zakas, <a target="_blank" rel="noopener" href="https://www.nczonline.net/blog/2016/10/the-ecmascript-2016-change-you-probably-dont-know/">The ECMAScript 2016 change you probably don’t know</a>: 使用参数默认值时，不能在函数内部显式开启严格模式</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2017/08/optional-catch-binding.html">ES proposal: optional catch binding</a></li>
<li>Cynthia Lee, <a target="_blank" rel="noopener" href="https://medium.freecodecamp.org/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26">When you should use ES6 arrow functions — and when you shouldn’t</a>: 讨论箭头函数的适用场合</li>
<li>Eric Elliott, <a target="_blank" rel="noopener" href="https://medium.com/javascript-scene/what-is-this-the-inner-workings-of-javascript-objects-d397bfa0708a">What is this?</a>: 箭头函数内部的 this 的解释。</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>Addy Osmani, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es7/observe/">Data-binding Revolutions with Object.observe()</a>: 介绍 Object.observe()的概念</li>
<li>Sella Rafaeli, <a target="_blank" rel="noopener" href="http://www.sellarafaeli.com/blog/native_javascript_data_binding">Native JavaScript Data-Binding</a>: 如何使用 Object.observe 方法，实现数据对象与 DOM 对象的双向绑定</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/09/proto-es6.html"><code>__proto__</code> in ECMAScript 6</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/10/enumerability-es6.html">Enumerability in ECMAScript 6</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2016/02/object-getownpropertydescriptors.html">ES proposal: Object.getOwnPropertyDescriptors()</a></li>
<li>TC39, <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-object-getownpropertydescriptors">Object.getOwnPropertyDescriptors Proposal</a></li>
<li>David Titarenco, <a target="_blank" rel="noopener" href="https://dvt.name/2018/06/02/spread-syntax-breaks-javascript/">How Spread Syntax Breaks JavaScript</a>: 扩展运算符的一些不合理的地方</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/12/es6-symbols.html">Symbols in ECMAScript 6</a>: Symbol 简介</li>
<li>MDN, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>: Symbol 类型的详细介绍</li>
<li>Jason Orendorff, <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">ES6 In Depth: Symbols</a></li>
<li>Keith Cirkel, <a target="_blank" rel="noopener" href="http://blog.keithcirkel.co.uk/metaprogramming-in-es6-symbols/">Metaprogramming in ES6: Symbols and why they’re awesome</a>: Symbol 的深入介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/09/well-known-symbols-es6.html">Customizing ES6 via well-known symbols</a></li>
<li>Derick Bailey, <a target="_blank" rel="noopener" href="https://derickbailey.com/2016/03/09/creating-a-true-singleton-in-node-js-with-es6-symbols/">Creating A True Singleton In Node.js, With ES6 Symbols</a></li>
<li>Das Surma, <a target="_blank" rel="noopener" href="https://dassur.ma/things/reading-specs-2/">How to read web specs Part IIa – Or: ECMAScript Symbols</a>: 介绍 Symbol 的规格</li>
</ul>
<h2 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h2><ul>
<li>Mozilla Developer Network, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a>：介绍 WeakSet 数据结构</li>
<li>Dwayne Charrington, <a target="_blank" rel="noopener" href="http://ilikekillnerds.com/2015/02/what-are-weakmaps-in-es6/">What Are Weakmaps In ES6?</a>: WeakMap 数据结构介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/01/es6-maps-sets.html">ECMAScript 6: maps and sets</a>: Set 和 Map 结构的详细介绍</li>
<li>Jason Orendorff, <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2015/06/es6-in-depth-collections/">ES6 In Depth: Collections</a>：Set 和 Map 结构的设计思想</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/08/es6-map-json.html">Converting ES6 Maps to and from JSON</a>: 如何将 Map 与其他数据结构互相转换</li>
</ul>
<h2 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h2><ul>
<li>Nicholas C. Zakas, <a target="_blank" rel="noopener" href="http://www.nczonline.net/blog/2014/04/22/creating-defensive-objects-with-es6-proxies/">Creating defensive objects with ES6 proxies</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/12/es6-proxies.html">Meta programming with ECMAScript 6 proxies</a>: Proxy 详解</li>
<li>Daniel Zautner, <a target="_blank" rel="noopener" href="http://dzautner.com/meta-programming-javascript-using-proxies/">Meta-programming JavaScript Using Proxies</a>: 使用 Proxy 实现元编程</li>
<li>Tom Van Cutsem, <a target="_blank" rel="noopener" href="https://github.com/tvcutsem/harmony-reflect/wiki">Harmony-reflect</a>: Reflect 对象的设计目的</li>
<li>Tom Van Cutsem, <a target="_blank" rel="noopener" href="https://github.com/tvcutsem/harmony-reflect/blob/master/doc/traps.md">Proxy Traps</a>: Proxy 拦截操作一览</li>
<li>Tom Van Cutsem, <a target="_blank" rel="noopener" href="https://github.com/tvcutsem/harmony-reflect/blob/master/doc/api.md">Reflect API</a></li>
<li>Tom Van Cutsem, <a target="_blank" rel="noopener" href="https://github.com/tvcutsem/harmony-reflect/blob/master/doc/handler_api.md">Proxy Handler API</a></li>
<li>Nicolas Bevacqua, <a target="_blank" rel="noopener" href="http://ponyfoo.com/articles/es6-proxies-in-depth">ES6 Proxies in Depth</a></li>
<li>Nicolas Bevacqua, <a target="_blank" rel="noopener" href="http://ponyfoo.com/articles/es6-proxy-traps-in-depth">ES6 Proxy Traps in Depth</a></li>
<li>Nicolas Bevacqua, <a target="_blank" rel="noopener" href="http://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">More ES6 Proxy Traps in Depth</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2016/11/proxying-builtins.html">Pitfall: not all objects can be wrapped transparently by proxies</a></li>
<li>Bertalan Miklos, <a target="_blank" rel="noopener" href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/">Writing a JavaScript Framework - Data Binding with ES6 Proxies</a>: 使用 Proxy 实现观察者模式</li>
<li>Keith Cirkel, <a target="_blank" rel="noopener" href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/">Metaprogramming in ES6: Part 2 - Reflect</a>: Reflect API 的详细介绍</li>
</ul>
<h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><ul>
<li>Jake Archibald, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/">JavaScript Promises: There and back again</a></li>
<li>Jake Archibald, <a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
<li>Tilde, <a target="_blank" rel="noopener" href="https://github.com/tildeio/rsvp.js">rsvp.js</a></li>
<li>Sandeep Panda, <a target="_blank" rel="noopener" href="http://www.sitepoint.com/overview-javascript-promises/">An Overview of JavaScript Promises</a>: ES6 Promise 入门介绍</li>
<li>Dave Atchley, <a target="_blank" rel="noopener" href="http://www.datchley.name/es6-promises/">ES6 Promises</a>: Promise 的语法介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/10/es6-promises-api.html">ECMAScript 6 promises (2/2): the API</a>: 对 ES6 Promise 规格和用法的详细介绍</li>
<li>Jack Franklin, <a target="_blank" rel="noopener" href="http://javascriptplayground.com/blog/2015/02/promises/">Embracing Promises in JavaScript</a>: catch 方法的例子</li>
<li>Ronald Chen, <a target="_blank" rel="noopener" href="https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513#.2an1he6vf">How to escape Promise Hell</a>: 如何使用<code>Promise.all</code>方法的一些很好的例子</li>
<li>Jordan Harband, <a target="_blank" rel="noopener" href="https://github.com/ljharb/proposal-promise-try">proposal-promise-try</a>: Promise.try() 方法的提案</li>
<li>Sven Slootweg, <a target="_blank" rel="noopener" href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">What is Promise.try, and why does it matter?</a>: Promise.try() 方法的优点</li>
<li>Yehuda Katz, <a target="_blank" rel="noopener" href="https://thefeedbackloop.xyz/tc39-promises-promises/">TC39: Promises, Promises</a>: Promise.try() 的用处</li>
</ul>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul>
<li>Mozilla Developer Network, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">Iterators and generators</a></li>
<li>Mozilla Developer Network, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">The Iterator protocol</a></li>
<li>Jason Orendorff, <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 In Depth: Iterators and the for-of loop</a>: 遍历器与 for…of 循环的介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2013/06/iterators-generators.html">Iterators and generators in ECMAScript 6</a>: 探讨 Iterator 和 Generator 的设计目的</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a>: Iterator 的详细介绍</li>
<li>Kyle Simpson, <a target="_blank" rel="noopener" href="http://blog.getify.com/iterating-es6-numbers/">Iterating ES6 Numbers</a>: 在数值对象上部署遍历器</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ul>
<li>Matt Baker, <a target="_blank" rel="noopener" href="http://flippinawesome.org/2014/02/10/replacing-callbacks-with-es6-generators/">Replacing callbacks with ES6 Generators</a></li>
<li>Steven Sanderson, <a target="_blank" rel="noopener" href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">Experiments with Koa and JavaScript Generators</a></li>
<li>jmar777, <a target="_blank" rel="noopener" href="http://devsmash.com/blog/whats-the-big-deal-with-generators">What’s the Big Deal with Generators?</a></li>
<li>Marc Harter, <a target="_blank" rel="noopener" href="http://strongloop.com/strongblog/how-to-generators-node-js-yield-use-cases/">Generators in Node.js: Common Misconceptions and Three Good Use Cases</a>: 讨论 Generator 函数的作用</li>
<li>StackOverflow, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20977379/es6-yield-what-happens-to-the-arguments-of-the-first-call-next">ES6 yield : what happens to the arguments of the first call next()?</a>: 第一次使用 next 方法时不能带有参数</li>
<li>Kyle Simpson, <a target="_blank" rel="noopener" href="http://davidwalsh.name/es6-generators">ES6 Generators: Complete Series</a>: 由浅入深探讨 Generator 的系列文章，共四篇</li>
<li>Gajus Kuizinas, <a target="_blank" rel="noopener" href="http://gajus.com/blog/2/the-definetive-guide-to-the-javascript-generators">The Definitive Guide to the JavaScript Generators</a>: 对 Generator 的综合介绍</li>
<li>Jan Krems, <a target="_blank" rel="noopener" href="https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c">Generators Are Like Arrays</a>: 讨论 Generator 可以被当作数据结构看待</li>
<li>Harold Cooper, <a target="_blank" rel="noopener" href="http://syzygy.st/javascript-coroutines/">Coroutine Event Loops in JavaScript</a>: Generator 用于实现状态机</li>
<li>Ruslan Ismagilov, <a target="_blank" rel="noopener" href="https://github.com/isRuslan/learn-generators">learn-generators</a>: 编程练习，共 6 道题</li>
<li>Steven Sanderson, <a target="_blank" rel="noopener" href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">Experiments with Koa and JavaScript Generators</a>: Generator 入门介绍，以 Koa 框架为例</li>
<li>Mahdi Dibaiee, <a target="_blank" rel="noopener" href="http://dibaiee.ir/es7-array-generator-comprehensions/">ES7 Array and Generator comprehensions</a>：ES7 的 Generator 推导</li>
<li>Nicolas Bevacqua, <a target="_blank" rel="noopener" href="http://ponyfoo.com/articles/es6-generators-in-depth">ES6 Generators in Depth</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/03/es6-generators.html">ES6 generators in depth</a>: Generator 规格的详尽讲解</li>
<li>Derick Bailey, <a target="_blank" rel="noopener" href="https://derickbailey.com/2015/10/05/using-es6-generators-to-short-circuit-hierarchical-data-iteration/">Using ES6 Generators To Short-Circuit Hierarchical Data Iteration</a>：使用 for…of 循环完成预定的操作步骤</li>
</ul>
<h2 id="异步操作和-Async-函数"><a href="#异步操作和-Async-函数" class="headerlink" title="异步操作和 Async 函数"></a>异步操作和 Async 函数</h2><ul>
<li>Luke Hoban, <a target="_blank" rel="noopener" href="https://github.com/lukehoban/ecmascript-asyncawait">Async Functions for ECMAScript</a>: Async 函数的设计思想，与 Promise、Gernerator 函数的关系</li>
<li>Jafar Husain, <a target="_blank" rel="noopener" href="https://github.com/jhusain/asyncgenerator">Asynchronous Generators for ES7</a>: Async 函数的深入讨论</li>
<li>Nolan Lawson, <a target="_blank" rel="noopener" href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html">Taming the asynchronous beast with ES7</a>: async 函数通俗的实例讲解</li>
<li>Jafar Husain, <a target="_blank" rel="noopener" href="https://docs.google.com/file/d/0B4PVbLpUIdzoMDR5dWstRllXblU/view?sle=true">Async Generators</a>: 对 async 与 Generator 混合使用的一些讨论</li>
<li>Daniel Brain, <a target="_blank" rel="noopener" href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand promises before you start using async/await</a>: 讨论 async/await 与 Promise 的关系</li>
<li>Jake Archibald, <a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/getting-started/primers/async-functions">Async functions - making promises friendly</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2016/10/asynchronous-iteration.html">ES proposal: asynchronous iteration</a>: 异步遍历器的详细介绍</li>
<li>Dima Grossman, <a target="_blank" rel="noopener" href="http://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">How to write async await without try-catch blocks in JavaScript</a>: 除了 try/catch 以外的 async 函数内部捕捉错误的方法</li>
<li>Mostafa Gaafa, <a target="_blank" rel="noopener" href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9">6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a>: Async 函数的6个好处</li>
<li>Mathias Bynens, <a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/async-stack-traces">Asynchronous stack traces: why await beats Promise#then()</a>: async 函数可以保留错误堆栈</li>
</ul>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul>
<li>Sebastian Porto, <a target="_blank" rel="noopener" href="https://reinteractive.net/posts/235-es6-classes-and-javascript-prototypes">ES6 classes and JavaScript prototypes</a>: ES6 Class 的写法与 ES5 Prototype 的写法对比</li>
<li>Jack Franklin, <a target="_blank" rel="noopener" href="http://javascriptplayground.com/blog/2014/07/introduction-to-es6-classes-tutorial/">An introduction to ES6 classes</a>: ES6 class 的入门介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/12/es6-oop.html">ECMAScript 6: new OOP features besides classes</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/02/es6-classes-final.html">Classes in ECMAScript 6 (final semantics)</a>: Class 语法的详细介绍和设计思想分析</li>
<li>Eric Faust, <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/">ES6 In Depth: Subclassing</a>: Class 语法的深入介绍</li>
<li>Nicolás Bevacqua, <a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/binding-methods-to-class-instance-objects">Binding Methods to Class Instance Objects</a>: 如何绑定类的实例中的 this</li>
<li>Jamie Kyle, <a target="_blank" rel="noopener" href="https://jamie.build/javascripts-new-private-class-fields.html">JavaScript’s new #private class fields</a>：私有属性的介绍。</li>
<li>Mathias Bynens, <a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2018/12/class-fields">Public and private class fields</a>：实例属性的新写法的介绍。</li>
</ul>
<h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><ul>
<li>Maximiliano Fierro, <a target="_blank" rel="noopener" href="https://elmasse.github.io/js/decorators-bindings-es7.html">Declarative vs Imperative</a>: Decorators 和 Mixin 介绍</li>
<li>Justin Fagnani, <a target="_blank" rel="noopener" href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">“Real” Mixins with JavaScript Classes</a>: 使用类的继承实现 Mixin</li>
<li>Addy Osmani, <a target="_blank" rel="noopener" href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841">Exploring ES2016 Decorators</a>: Decorator 的深入介绍</li>
<li>Sebastian McKenzie, <a target="_blank" rel="noopener" href="https://github.com/wycats/javascript-decorators/issues/4">Allow decorators for functions as well</a>: 为什么修饰器不能用于函数</li>
<li>Maximiliano Fierro, <a target="_blank" rel="noopener" href="https://cocktailjs.github.io/blog/traits-with-es7-decorators.html">Traits with ES7 Decorators</a>: Trait 的用法介绍</li>
<li>Jonathan Creamer: <a target="_blank" rel="noopener" href="http://jonathancreamer.com/using-es2016-decorators-to-publish-on-an-event-bus/">Using ES2016 Decorators to Publish on an Event Bus</a>: 使用修饰器实现自动发布事件</li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul>
<li>Jack Franklin, <a target="_blank" rel="noopener" href="http://24ways.org/2014/javascript-modules-the-es6-way/">JavaScript Modules the ES6 Way</a>: ES6 模块入门</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2014/09/es6-modules-final.html">ECMAScript 6 modules: the final syntax</a>: ES6 模块的介绍，以及与 CommonJS 规格的详细比较</li>
<li>Dave Herman, <a target="_blank" rel="noopener" href="http://calculist.org/blog/2012/06/29/static-module-resolution/">Static module resolution</a>: ES6 模块的静态化设计思想</li>
<li>Jason Orendorff, <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">ES6 In Depth: Modules</a>: ES6 模块设计思想的介绍</li>
<li>Ben Newman, <a target="_blank" rel="noopener" href="https://benjamn.github.io/empirenode-2015/#/">The Importance of import and export</a>: ES6 模块的设计思想</li>
<li>ESDiscuss, <a target="_blank" rel="noopener" href="https://esdiscuss.org/topic/why-is-export-default-var-a-1-invalid-syntax">Why is “export default var a = 1;” invalid syntax?</a></li>
<li>Bradley Meck, <a target="_blank" rel="noopener" href="https://github.com/nodejs/node-eps/blob/master/002-es6-modules.md">ES6 Module Interoperability</a>: 介绍 Node 如何处理 ES6 语法加载 CommonJS 模块</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2017/01/babel-esm-spec-mode.html">Making transpiled ES modules more spec-compliant</a>: ES6 模块编译成 CommonJS 模块的详细介绍</li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2017/01/import-operator.html">ES proposal: import() – dynamically importing ES modules</a>: import() 的用法</li>
<li>Node EPS, <a target="_blank" rel="noopener" href="https://github.com/nodejs/node-eps/blob/master/002-es-modules.md">ES Module Interoperability</a>: Node 对 ES6 模块的处理规格</li>
<li>Dan Fabulich, <a target="_blank" rel="noopener" href="https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1">Why CommonJS and ES Modules Can’t Get Along</a>: Node.js 对 ES6 模块的处理</li>
</ul>
<h2 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h2><ul>
<li>Ilmari Heikkinen, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/">Typed Arrays: Binary Data in the Browser</a></li>
<li>Khronos, <a target="_blank" rel="noopener" href="http://www.khronos.org/registry/typedarray/specs/latest/">Typed Array Specification</a></li>
<li>Ian Elliot, <a target="_blank" rel="noopener" href="http://www.i-programmer.info/projects/36-web/6234-reading-a-bmp-file-in-javascript.html">Reading A BMP File In JavaScript</a></li>
<li>Renato Mangini, <a target="_blank" rel="noopener" href="http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String">How to convert ArrayBuffer to and from String</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2015/09/typed-arrays.html">Typed Arrays in ECMAScript 6</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2017/01/shared-array-buffer.html">ES proposal: Shared memory and atomics</a></li>
<li>Lin Clark, <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/">Avoiding race conditions in SharedArrayBuffers with Atomics</a>: Atomics 对象使用场景的解释</li>
<li>Lars T Hansen, <a target="_blank" rel="noopener" href="https://github.com/tc39/ecmascript_sharedmem/blob/master/TUTORIAL.md">Shared memory - a brief tutorial</a></li>
<li>James Milner, <a target="_blank" rel="noopener" href="https://www.sitepen.com/blog/2018/09/19/the-return-of-sharedarraybuffers-and-atomics/">The Return of SharedArrayBuffers and Atomics</a></li>
</ul>
<h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><ul>
<li>TC39, <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1MY9NHrHmL7ma7C8dyNXvmYNNGgVmmxXk8ZIiQtPlfH4/edit#slide=id.p19">SIMD.js Stage 2</a></li>
<li>MDN, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SIMD">SIMD</a></li>
<li>TC39, <a target="_blank" rel="noopener" href="https://github.com/tc39/ecmascript_simd">ECMAScript SIMD</a></li>
<li>Axel Rauschmayer, <a target="_blank" rel="noopener" href="https://2ality.com/2013/12/simd-js.html">JavaScript gains support for SIMD</a></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>Babel, <a target="_blank" rel="noopener" href="https://github.com/thejameskyle/babel-handbook/tree/master/translations/en">Babel Handbook</a>: Babel 的用法介绍</p>
</li>
<li><p>Google, <a target="_blank" rel="noopener" href="https://github.com/google/traceur-compiler">traceur-compiler</a>: Traceur 编译器</p>
</li>
<li><p>Casper Beyer, <a target="_blank" rel="noopener" href="https://caspervonb.github.io/2014/03/05/ecmascript6-features-and-tools.html">ECMAScript 6 Features and Tools</a></p>
</li>
<li><p>Stoyan Stefanov, <a target="_blank" rel="noopener" href="http://www.phpied.com/writing-es6-today-with-jstransform/">Writing ES6 today with jstransform</a></p>
</li>
<li><p>ES6 Module Loader, <a target="_blank" rel="noopener" href="https://github.com/ModuleLoader/es6-module-loader">ES6 Module Loader Polyfill</a>: 在浏览器和 node.js 加载 ES6 模块的一个库，文档里对 ES6 模块有详细解释</p>
</li>
<li><p>Paul Miller, <a target="_blank" rel="noopener" href="https://github.com/paulmillr/es6-shim">es6-shim</a>: 一个针对老式浏览器，模拟 ES6 部分功能的垫片库（shim）</p>
</li>
<li><p>army8735, <a target="_blank" rel="noopener" href="https://github.com/army8735/jsdc">JavaScript Downcast</a>: 国产的 ES6 到 ES5 的转码器</p>
</li>
<li><p>esnext, <a target="_blank" rel="noopener" href="https://github.com/esnext/es6-module-transpiler">ES6 Module Transpiler</a>：基于 node.js 的将 ES6 模块转为 ES5 代码的命令行工具</p>
</li>
<li><p>Sebastian McKenzie, <a target="_blank" rel="noopener" href="http://babeljs.io/">BabelJS</a>: ES6 转译器</p>
</li>
<li><p>SystemJS, <a target="_blank" rel="noopener" href="https://github.com/systemjs/systemjs">SystemJS</a>: 在浏览器中加载 AMD、CJS、ES6 模块的一个垫片库</p>
</li>
<li><p>Modernizr, <a target="_blank" rel="noopener" href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#ecmascript-6-harmony">HTML5 Cross Browser Polyfills</a>: ES6 垫片库清单</p>
</li>
<li><p>Facebook, <a target="_blank" rel="noopener" href="https://github.com/facebook/regenerator">regenerator</a>: 将 Generator 函数转为 ES5 的转码器</p>
<h2 id="Es6-阮一峰"><a href="#Es6-阮一峰" class="headerlink" title="Es6-阮一峰"></a>Es6-<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/">阮一峰</a></h2><ul>
<li>来源</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-13module的加载实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/13module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/" class="article-date">
  	<time datetime="2022-09-05T02:51:22.850Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/13module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/">
        Es6-Module 的加载实现
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module-loader#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD">浏览器加载</a></li>
<li>[ES6 模块与 CommonJS 模块的差异](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module-loader#ES6">https://es6.ruanyifeng.com/#docs/module-loader#ES6</a> 模块与 CommonJS 模块的差异)</li>
<li>[Node.js 的模块加载方法](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module-loader#Node.js">https://es6.ruanyifeng.com/#docs/module-loader#Node.js</a> 的模块加载方法)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module-loader#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">循环加载</a></li>
</ol>
<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>
<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>
<pre><code class="html">&lt;!-- 页面内嵌的脚本 --&gt;
&lt;script type=&quot;application/javascript&quot;&gt;
  // module code
&lt;/script&gt;

&lt;!-- 外部脚本 --&gt;
&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;
&lt;/script&gt;
</code></pre>
<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
<pre><code class="html">&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p>
<pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
&lt;!-- 等同于 --&gt;
&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p>
<script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。

```html
<script type="module" src="./foo.js" async></script>
<pre><code>
一旦使用了`async`属性，`&lt;script type=&quot;module&quot;&gt;`就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。

ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。

```html
&lt;script type=&quot;module&quot;&gt;
  import utils from &quot;./utils.js&quot;;

  // other code
&lt;/script&gt;
</code></pre>
<p>举例来说，jQuery 就支持模块加载。</p>
<pre><code class="html">&lt;script type=&quot;module&quot;&gt;
  import $ from &quot;./jquery/src/jquery.js&quot;;
  $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);
&lt;/script&gt;
</code></pre>
<p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>下面是一个示例模块。</p>
<pre><code class="javascript">import utils from &#39;https://example.com/js/utils.js&#39;;

const x = 1;

console.log(x === window.x); //false
console.log(this === undefined); // true
</code></pre>
<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>
<pre><code class="javascript">const isNotModuleScript = this !== undefined;
</code></pre>
<h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><p>讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p>
<p>它们有三个重大差异。</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
<li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</li>
</ul>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异。</p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p>
<pre><code class="javascript">// lib.js
var counter = 3;
function incCounter() &#123;
  counter++;
&#125;
module.exports = &#123;
  counter: counter,
  incCounter: incCounter,
&#125;;
</code></pre>
<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>
<pre><code class="javascript">// main.js
var mod = require(&#39;./lib&#39;);

console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 3
</code></pre>
<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<pre><code class="javascript">// lib.js
var counter = 3;
function incCounter() &#123;
  counter++;
&#125;
module.exports = &#123;
  get counter() &#123;
    return counter
  &#125;,
  incCounter: incCounter,
&#125;;
</code></pre>
<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>
<pre><code class="bash">$ node main.js
3
4
</code></pre>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<p>还是举上面的例子。</p>
<pre><code class="javascript">// lib.js
export let counter = 3;
export function incCounter() &#123;
  counter++;
&#125;

// main.js
import &#123; counter, incCounter &#125; from &#39;./lib&#39;;
console.log(counter); // 3
incCounter();
console.log(counter); // 4
</code></pre>
<p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>
<p>再举一个出现在<code>export</code>一节中的例子。</p>
<pre><code class="javascript">// m1.js
export var foo = &#39;bar&#39;;
setTimeout(() =&gt; foo = &#39;baz&#39;, 500);

// m2.js
import &#123;foo&#125; from &#39;./m1.js&#39;;
console.log(foo);
setTimeout(() =&gt; console.log(foo), 500);
</code></pre>
<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。</p>
<p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p>
<pre><code class="bash">$ babel-node m2.js

bar
baz
</code></pre>
<p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>
<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<pre><code class="javascript">// lib.js
export let obj = &#123;&#125;;

// main.js
import &#123; obj &#125; from &#39;./lib&#39;;

obj.prop = 123; // OK
obj = &#123;&#125;; // TypeError
</code></pre>
<p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p>
<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>
<pre><code class="javascript">// mod.js
function C() &#123;
  this.sum = 0;
  this.add = function () &#123;
    this.sum += 1;
  &#125;;
  this.show = function () &#123;
    console.log(this.sum);
  &#125;;
&#125;

export let c = new C();
</code></pre>
<p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<pre><code class="javascript">// x.js
import &#123;c&#125; from &#39;./mod&#39;;
c.add();

// y.js
import &#123;c&#125; from &#39;./mod&#39;;
c.show();

// main.js
import &#39;./x&#39;;
import &#39;./y&#39;;
</code></pre>
<p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p>
<pre><code class="bash">$ babel-node main.js
1
</code></pre>
<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>
<h2 id="Node-js-的模块加载方法"><a href="#Node-js-的模块加载方法" class="headerlink" title="Node.js 的模块加载方法"></a>Node.js 的模块加载方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p>
<p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p>
<p>它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p>
<p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p>
<p>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</p>
<pre><code class="javascript">&#123;
   &quot;type&quot;: &quot;module&quot;
&#125;
</code></pre>
<p>一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。</p>
<pre><code class="bash"># 解释成 ES6 模块
$ node my-app.js
</code></pre>
<p>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</p>
<p>总结为一句话：<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</p>
<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p>
<h3 id="package-json-的-main-字段"><a href="#package-json-的-main-字段" class="headerlink" title="package.json 的 main 字段"></a>package.json 的 main 字段</h3><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p>
<pre><code class="javascript">// ./node_modules/es-module-package/package.json
&#123;
  &quot;type&quot;: &quot;module&quot;,
  &quot;main&quot;: &quot;./src/index.js&quot;
&#125;
</code></pre>
<p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p>
<p>然后，<code>import</code>命令就可以加载这个模块。</p>
<pre><code class="javascript">// ./my-app.mjs

import &#123; something &#125; from &#39;es-module-package&#39;;
// 实际加载的是 ./node_modules/es-module-package/src/index.js
</code></pre>
<p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p>
<p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p>
<h3 id="package-json-的-exports-字段"><a href="#package-json-的-exports-字段" class="headerlink" title="package.json 的 exports 字段"></a>package.json 的 exports 字段</h3><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p>
<p>（1）子目录别名</p>
<p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p>
<pre><code class="javascript">// ./node_modules/es-module-package/package.json
&#123;
  &quot;exports&quot;: &#123;
    &quot;./submodule&quot;: &quot;./src/submodule.js&quot;
  &#125;
&#125;
</code></pre>
<p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p>
<pre><code class="javascript">import submodule from &#39;es-module-package/submodule&#39;;
// 加载 ./node_modules/es-module-package/src/submodule.js
</code></pre>
<p>下面是子目录别名的例子。</p>
<pre><code class="javascript">// ./node_modules/es-module-package/package.json
&#123;
  &quot;exports&quot;: &#123;
    &quot;./features/&quot;: &quot;./src/features/&quot;
  &#125;
&#125;

import feature from &#39;es-module-package/features/x.js&#39;;
// 加载 ./node_modules/es-module-package/src/features/x.js
</code></pre>
<p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p>
<pre><code class="javascript">// 报错
import submodule from &#39;es-module-package/private-module.js&#39;;

// 不报错
import submodule from &#39;./node_modules/es-module-package/private-module.js&#39;;
</code></pre>
<p>（2）main 的别名</p>
<p><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p>
<pre><code class="javascript">&#123;
  &quot;exports&quot;: &#123;
    &quot;.&quot;: &quot;./main.js&quot;
  &#125;
&#125;

// 等同于
&#123;
  &quot;exports&quot;: &quot;./main.js&quot;
&#125;
</code></pre>
<p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p>
<pre><code class="javascript">&#123;
  &quot;main&quot;: &quot;./main-legacy.cjs&quot;,
  &quot;exports&quot;: &#123;
    &quot;.&quot;: &quot;./main-modern.cjs&quot;
  &#125;
&#125;
</code></pre>
<p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>
<p><strong>（3）条件加载</strong></p>
<p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p>
<pre><code class="javascript">&#123;
  &quot;type&quot;: &quot;module&quot;,
  &quot;exports&quot;: &#123;
    &quot;.&quot;: &#123;
      &quot;require&quot;: &quot;./main.cjs&quot;,
      &quot;default&quot;: &quot;./main.js&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p>
<p>上面的写法可以简写如下。</p>
<pre><code class="javascript">&#123;
  &quot;exports&quot;: &#123;
    &quot;require&quot;: &quot;./main.cjs&quot;,
    &quot;default&quot;: &quot;./main.js&quot;
  &#125;
&#125;
</code></pre>
<p>注意，如果同时还有其他别名，就不能采用简写，否则会报错。</p>
<pre><code class="javascript">&#123;
  // 报错
  &quot;exports&quot;: &#123;
    &quot;./feature&quot;: &quot;./lib/feature.js&quot;,
    &quot;require&quot;: &quot;./main.cjs&quot;,
    &quot;default&quot;: &quot;./main.js&quot;
  &#125;
&#125;
</code></pre>
<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</p>
<pre><code class="javascript">(async () =&gt; &#123;
  await import(&#39;./my-app.mjs&#39;);
&#125;)();
</code></pre>
<p>上面代码可以在 CommonJS 模块中运行。</p>
<p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>
<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</p>
<pre><code class="javascript">// 正确
import packageMain from &#39;commonjs-package&#39;;

// 报错
import &#123; method &#125; from &#39;commonjs-package&#39;;
</code></pre>
<p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p>
<p>加载单一的输出项，可以写成下面这样。</p>
<pre><code class="javascript">import packageMain from &#39;commonjs-package&#39;;
const &#123; method &#125; = packageMain;
</code></pre>
<p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p>
<pre><code class="javascript">// cjs.cjs
module.exports = &#39;cjs&#39;;

// esm.mjs
import &#123; createRequire &#125; from &#39;module&#39;;

const require = createRequire(import.meta.url);

const cjs = require(&#39;./cjs.cjs&#39;);
cjs === &#39;cjs&#39;; // true
</code></pre>
<p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p>
<h3 id="同时支持两种格式的模块"><a href="#同时支持两种格式的模块" class="headerlink" title="同时支持两种格式的模块"></a>同时支持两种格式的模块</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p>
<p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p>
<p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p>
<pre><code class="javascript">import cjsModule from &#39;../index.js&#39;;
export const foo = cjsModule.foo;
</code></pre>
<p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p>
<p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p>
<p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p>
<pre><code class="javascript">&quot;exports&quot;：&#123;
  &quot;require&quot;: &quot;./index.js&quot;，
  &quot;import&quot;: &quot;./esm/wrapper.js&quot;
&#125;
</code></pre>
<p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p>
<h3 id="Node-js-的内置模块"><a href="#Node-js-的内置模块" class="headerlink" title="Node.js 的内置模块"></a>Node.js 的内置模块</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p>
<pre><code class="javascript">// 整体加载
import EventEmitter from &#39;events&#39;;
const e = new EventEmitter();

// 加载指定的输出项
import &#123; readFile &#125; from &#39;fs&#39;;
readFile(&#39;./foo.txt&#39;, (err, source) =&gt; &#123;
  if (err) &#123;
    console.error(err);
  &#125; else &#123;
    console.log(source);
  &#125;
&#125;);
</code></pre>
<h3 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p>
<pre><code class="javascript">// ES6 模块中将报错
import &#123; something &#125; from &#39;./index&#39;;
</code></pre>
<p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p>
<pre><code class="javascript">import &#39;./foo.mjs?query=1&#39;; // 加载 ./foo 传入参数 ?query=1
</code></pre>
<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p>
<p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p>
<h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p>
<p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p>
<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p>
<ul>
<li><code>arguments</code></li>
<li><code>require</code></li>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>__filename</code></li>
<li><code>__dirname</code></li>
</ul>
<h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>
<pre><code class="javascript">// a.js
var b = require(&#39;b&#39;);

// b.js
var a = require(&#39;a&#39;);
</code></pre>
<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>
<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p>
<p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<pre><code class="javascript">&#123;
  id: &#39;...&#39;,
  exports: &#123; ... &#125;,
  loaded: true,
  ...
&#125;
</code></pre>
<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p>
<p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>
<h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<p>让我们来看，Node <a target="_blank" rel="noopener" href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。脚本文件<code>a.js</code>代码如下。</p>
<pre><code class="javascript">exports.done = false;
var b = require(&#39;./b.js&#39;);
console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a.js 执行完毕&#39;);
</code></pre>
<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<p>再看<code>b.js</code>的代码。</p>
<pre><code class="javascript">exports.done = false;
var a = require(&#39;./a.js&#39;);
console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b.js 执行完毕&#39;);
</code></pre>
<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>
<p><code>a.js</code>已经执行的部分，只有一行。</p>
<pre><code class="javascript">exports.done = false;
</code></pre>
<p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p>
<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>
<pre><code class="javascript">var a = require(&#39;./a.js&#39;);
var b = require(&#39;./b.js&#39;);
console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);
</code></pre>
<p>执行<code>main.js</code>，运行结果如下。</p>
<pre><code class="bash">$ node main.js

在 b.js 之中，a.done = false
b.js 执行完毕
在 a.js 之中，b.done = true
a.js 执行完毕
在 main.js 之中, a.done=true, b.done=true
</code></pre>
<p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>
<pre><code class="javascript">exports.done = true;
</code></pre>
<p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p>
<p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>
<pre><code class="javascript">var a = require(&#39;a&#39;); // 安全的写法
var foo = require(&#39;a&#39;).foo; // 危险的写法

exports.good = function (arg) &#123;
  return a.foo(&#39;good&#39;, arg); // 使用的是 a.foo 的最新值
&#125;;

exports.bad = function (arg) &#123;
  return foo(&#39;bad&#39;, arg); // 使用的是一个部分加载时的值
&#125;;
</code></pre>
<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p>
<h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>请看下面这个例子。</p>
<pre><code class="javascript">// a.mjs
import &#123;bar&#125; from &#39;./b&#39;;
console.log(&#39;a.mjs&#39;);
console.log(bar);
export let foo = &#39;foo&#39;;

// b.mjs
import &#123;foo&#125; from &#39;./a&#39;;
console.log(&#39;b.mjs&#39;);
console.log(foo);
export let bar = &#39;bar&#39;;
</code></pre>
<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>
<pre><code class="bash">$ node --experimental-modules a.mjs
b.mjs
ReferenceError: foo is not defined
</code></pre>
<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p>
<p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p>
<p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>
<pre><code class="javascript">// a.mjs
import &#123;bar&#125; from &#39;./b&#39;;
console.log(&#39;a.mjs&#39;);
console.log(bar());
function foo() &#123; return &#39;foo&#39; &#125;
export &#123;foo&#125;;

// b.mjs
import &#123;foo&#125; from &#39;./a&#39;;
console.log(&#39;b.mjs&#39;);
console.log(foo());
function bar() &#123; return &#39;bar&#39; &#125;
export &#123;bar&#125;;
</code></pre>
<p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>
<pre><code class="bash">$ node --experimental-modules a.mjs
b.mjs
foo
a.mjs
bar
</code></pre>
<p>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p>
<pre><code class="javascript">// a.mjs
import &#123;bar&#125; from &#39;./b&#39;;
console.log(&#39;a.mjs&#39;);
console.log(bar());
const foo = () =&gt; &#39;foo&#39;;
export &#123;foo&#125;;
</code></pre>
<p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p>
<p>我们再来看 ES6 模块加载器<a target="_blank" rel="noopener" href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p>
<pre><code class="javascript">// even.js
import &#123; odd &#125; from &#39;./odd&#39;
export var counter = 0;
export function even(n) &#123;
  counter++;
  return n === 0 || odd(n - 1);
&#125;

// odd.js
import &#123; even &#125; from &#39;./even&#39;;
export function odd(n) &#123;
  return n !== 0 &amp;&amp; even(n - 1);
&#125;
</code></pre>
<p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p>
<p>运行上面这段代码，结果如下。</p>
<pre><code class="javascript">$ babel-node
&gt; import * as m from &#39;./even.js&#39;;
&gt; m.even(10);
true
&gt; m.counter
6
&gt; m.even(20)
true
&gt; m.counter
17
</code></pre>
<p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p>
<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>
<pre><code class="javascript">// even.js
var odd = require(&#39;./odd&#39;);
var counter = 0;
exports.counter = counter;
exports.even = function (n) &#123;
  counter++;
  return n == 0 || odd(n - 1);
&#125;

// odd.js
var even = require(&#39;./even&#39;).even;
module.exports = function (n) &#123;
  return n != 0 &amp;&amp; even(n - 1);
&#125;
</code></pre>
<p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p>
<pre><code class="bash">$ node
&gt; var m = require(&#39;./even&#39;);
&gt; m.even(10)
TypeError: even is not a function
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-12Module的语法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/12Module%E7%9A%84%E8%AF%AD%E6%B3%95/" class="article-date">
  	<time datetime="2022-09-05T02:51:04.614Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/12Module%E7%9A%84%E8%AF%AD%E6%B3%95/">
        Es6-Module 的语法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li>
<li>[export 命令](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#export">https://es6.ruanyifeng.com/#docs/module#export</a> 命令)</li>
<li>[import 命令](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#import">https://es6.ruanyifeng.com/#docs/module#import</a> 命令)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD">模块的整体加载</a></li>
<li>[export default 命令](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#export">https://es6.ruanyifeng.com/#docs/module#export</a> default 命令)</li>
<li>[export 与 import 的复合写法](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#export">https://es6.ruanyifeng.com/#docs/module#export</a> 与 import 的复合写法)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%A7%E6%89%BF">模块的继承</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%B8%B8%E9%87%8F">跨模块常量</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module#import()">import()</a></li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<pre><code class="javascript">// CommonJS模块
let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>
<pre><code class="javascript">// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre>
<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p>
<h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p>
<pre><code class="javascript">// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;
</code></pre>
<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>
<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>
<pre><code class="javascript">// profile.js
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123; firstName, lastName, year &#125;;
</code></pre>
<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p>
<pre><code class="javascript">export function multiply(x, y) &#123;
  return x * y;
&#125;;
</code></pre>
<p>上面代码对外输出一个函数<code>multiply</code>。</p>
<p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p>
<pre><code class="javascript">function v1() &#123; ... &#125;
function v2() &#123; ... &#125;

export &#123;
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
&#125;;
</code></pre>
<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>
<p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<pre><code class="javascript">// 报错
export 1;

// 报错
var m = 1;
export m;
</code></pre>
<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p>
<pre><code class="javascript">// 写法一
export var m = 1;

// 写法二
var m = 1;
export &#123;m&#125;;

// 写法三
var n = 1;
export &#123;n as m&#125;;
</code></pre>
<p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>
<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>
<pre><code class="javascript">// 报错
function f() &#123;&#125;
export f;

// 正确
export function f() &#123;&#125;;

// 正确
function f() &#123;&#125;
export &#123;f&#125;;
</code></pre>
<p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<pre><code class="javascript">export var foo = &#39;bar&#39;;
setTimeout(() =&gt; foo = &#39;baz&#39;, 500);
</code></pre>
<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>
<p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。</p>
<p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<pre><code class="javascript">function foo() &#123;
  export default &#39;bar&#39; // SyntaxError
&#125;
foo()
</code></pre>
<p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>
<h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<pre><code class="javascript">// main.js
import &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;

function setName(element) &#123;
  element.textContent = firstName + &#39; &#39; + lastName;
&#125;
</code></pre>
<p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>
<pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre>
<p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</p>
<pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;
</code></pre>
<p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p>
<pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
</code></pre>
<p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p>
<p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
<pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre>
<p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>
<p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<pre><code class="javascript">foo();

import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre>
<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p>
<p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<pre><code class="javascript">// 报错
import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;

// 报错
let module = &#39;my_module&#39;;
import &#123; foo &#125; from module;

// 报错
if (x === 1) &#123;
  import &#123; foo &#125; from &#39;module1&#39;;
&#125; else &#123;
  import &#123; foo &#125; from &#39;module2&#39;;
&#125;
</code></pre>
<p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p>
<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>
<pre><code class="javascript">import &#39;lodash&#39;;
</code></pre>
<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>
<p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p>
<pre><code class="javascript">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre>
<p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p>
<pre><code class="javascript">import &#123; foo &#125; from &#39;my_module&#39;;
import &#123; bar &#125; from &#39;my_module&#39;;

// 等同于
import &#123; foo, bar &#125; from &#39;my_module&#39;;
</code></pre>
<p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p>
<p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>
<pre><code class="javascript">require(&#39;core-js/modules/es6.symbol&#39;);
require(&#39;core-js/modules/es6.promise&#39;);
import React from &#39;React&#39;;
</code></pre>
<h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>
<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>
<pre><code class="javascript">// circle.js

export function area(radius) &#123;
  return Math.PI * radius * radius;
&#125;

export function circumference(radius) &#123;
  return 2 * Math.PI * radius;
&#125;
</code></pre>
<p>现在，加载这个模块。</p>
<pre><code class="javascript">// main.js

import &#123; area, circumference &#125; from &#39;./circle&#39;;

console.log(&#39;圆面积：&#39; + area(4));
console.log(&#39;圆周长：&#39; + circumference(14));
</code></pre>
<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>
<pre><code class="javascript">import * as circle from &#39;./circle&#39;;

console.log(&#39;圆面积：&#39; + circle.area(4));
console.log(&#39;圆周长：&#39; + circle.circumference(14));
</code></pre>
<p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>
<pre><code class="javascript">import * as circle from &#39;./circle&#39;;

// 下面两行都是不允许的
circle.foo = &#39;hello&#39;;
circle.area = function () &#123;&#125;;
</code></pre>
<h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>
<pre><code class="javascript">// export-default.js
export default function () &#123;
  console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>
<pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre>
<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>
<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>
<pre><code class="javascript">// export-default.js
export default function foo() &#123;
  console.log(&#39;foo&#39;);
&#125;

// 或者写成

function foo() &#123;
  console.log(&#39;foo&#39;);
&#125;

export default foo;
</code></pre>
<p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>
<p>下面比较一下默认输出和正常输出。</p>
<pre><code class="javascript">// 第一组
export default function crc32() &#123; // 输出
  // ...
&#125;

import crc32 from &#39;crc32&#39;; // 输入

// 第二组
export function crc32() &#123; // 输出
  // ...
&#125;;

import &#123;crc32&#125; from &#39;crc32&#39;; // 输入
</code></pre>
<p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p>
<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p>
<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<pre><code class="javascript">// modules.js
function add(x, y) &#123;
  return x * y;
&#125;
export &#123;add as default&#125;;
// 等同于
// export default add;

// app.js
import &#123; default as foo &#125; from &#39;modules&#39;;
// 等同于
// import foo from &#39;modules&#39;;
</code></pre>
<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>
<pre><code class="javascript">// 正确
export var a = 1;

// 正确
var a = 1;
export default a;

// 错误
export default var a = 1;
</code></pre>
<p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>
<p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p>
<pre><code class="javascript">// 正确
export default 42;

// 报错
export 42;
</code></pre>
<p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p>
<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p>
<pre><code class="javascript">import _ from &#39;lodash&#39;;
</code></pre>
<p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p>
<pre><code class="javascript">import _, &#123; each, forEach &#125; from &#39;lodash&#39;;
</code></pre>
<p>对应上面代码的<code>export</code>语句如下。</p>
<pre><code class="javascript">export default function (obj) &#123;
  // ···
&#125;

export function each(obj, iterator, context) &#123;
  // ···
&#125;

export &#123; each as forEach &#125;;
</code></pre>
<p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p>
<p><code>export default</code>也可以用来输出类。</p>
<pre><code class="javascript">// MyClass.js
export default class &#123; ... &#125;

// main.js
import MyClass from &#39;MyClass&#39;;
let o = new MyClass();
</code></pre>
<h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>
<pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre>
<p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p>
<p>模块的接口改名和整体输出，也可以采用这种写法。</p>
<pre><code class="javascript">// 接口改名
export &#123; foo as myFoo &#125; from &#39;my_module&#39;;

// 整体输出
export * from &#39;my_module&#39;;
</code></pre>
<p>默认接口的写法如下。</p>
<pre><code class="javascript">export &#123; default &#125; from &#39;foo&#39;;
</code></pre>
<p>具名接口改为默认接口的写法如下。</p>
<pre><code class="javascript">export &#123; es6 as default &#125; from &#39;./someModule&#39;;

// 等同于
import &#123; es6 &#125; from &#39;./someModule&#39;;
export default es6;
</code></pre>
<p>同样地，默认接口也可以改名为具名接口。</p>
<pre><code class="javascript">export &#123; default as es6 &#125; from &#39;./someModule&#39;;
</code></pre>
<p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p>
<pre><code class="javascript">import * as someIdentifier from &quot;someModule&quot;;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-export-ns-from">ES2020</a>补上了这个写法。</p>
<pre><code class="javascript">export * as ns from &quot;mod&quot;;

// 等同于
import * as ns from &quot;mod&quot;;
export &#123;ns&#125;;
</code></pre>
<h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间也可以继承。</p>
<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>
<pre><code class="javascript">// circleplus.js

export * from &#39;circle&#39;;
export var e = 2.71828182846;
export default function(x) &#123;
  return Math.exp(x);
&#125;
</code></pre>
<p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>
<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>
<pre><code class="javascript">// circleplus.js

export &#123; area as circleArea &#125; from &#39;circle&#39;;
</code></pre>
<p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>
<p>加载上面模块的写法如下。</p>
<pre><code class="javascript">// main.js

import * as math from &#39;circleplus&#39;;
import exp from &#39;circleplus&#39;;
console.log(exp(math.e));
</code></pre>
<p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>
<h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>
<pre><code class="javascript">// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from &#39;./constants&#39;;
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import &#123;A, B&#125; from &#39;./constants&#39;;
console.log(A); // 1
console.log(B); // 3
</code></pre>
<p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<pre><code class="javascript">// constants/db.js
export const db = &#123;
  url: &#39;http://my.couchdbserver.local:5984&#39;,
  admin_username: &#39;admin&#39;,
  admin_password: &#39;admin password&#39;
&#125;;

// constants/user.js
export const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;];
</code></pre>
<p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p>
<pre><code class="javascript">// constants/index.js
export &#123;db&#125; from &#39;./db&#39;;
export &#123;users&#125; from &#39;./users&#39;;
</code></pre>
<p>使用的时候，直接加载<code>index.js</code>就可以了。</p>
<pre><code class="javascript">// script.js
import &#123;db, users&#125; from &#39;./constants/index&#39;;
</code></pre>
<h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>
<pre><code class="javascript">// 报错
if (x === 2) &#123;
  import MyModual from &#39;./myModual&#39;;
&#125;
</code></pre>
<p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>
<pre><code class="javascript">const path = &#39;./&#39; + fileName;
const myModual = require(path);
</code></pre>
<p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>
<pre><code class="javascript">import(specifier)
</code></pre>
<p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p>
<pre><code class="javascript">const main = document.querySelector(&#39;main&#39;);

import(`./section-modules/$&#123;someVariable&#125;.js`)
  .then(module =&gt; &#123;
    module.loadPageInto(main);
  &#125;)
  .catch(err =&gt; &#123;
    main.textContent = err.message;
  &#125;);
</code></pre>
<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node.js 的<code>require()</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>
<p>由于<code>import()</code>返回 Promise 对象，所以需要使用<code>then()</code>方法指定处理函数。考虑到代码的清晰，更推荐使用<code>await</code>命令。</p>
<pre><code class="javascript">async function renderWidget() &#123;
  const container = document.getElementById(&#39;widget&#39;);
  if (container !== null) &#123;
    // 等同于
    // import(&quot;./widget&quot;).then(widget =&gt; &#123;
    //   widget.render(container);
    // &#125;);
    const widget = await import(&#39;./widget.js&#39;);
    widget.render(container);
  &#125;
&#125;

renderWidget();
</code></pre>
<p>上面示例中，<code>await</code>命令后面就是使用<code>import()</code>，对比<code>then()</code>的写法明显更简洁易读。</p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>下面是<code>import()</code>的一些适用场合。</p>
<p>（1）按需加载。</p>
<p><code>import()</code>可以在需要的时候，再加载某个模块。</p>
<pre><code class="javascript">button.addEventListener(&#39;click&#39;, event =&gt; &#123;
  import(&#39;./dialogBox.js&#39;)
  .then(dialogBox =&gt; &#123;
    dialogBox.open();
  &#125;)
  .catch(error =&gt; &#123;
    /* Error handling */
  &#125;)
&#125;);
</code></pre>
<p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>
<p>（2）条件加载</p>
<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>
<pre><code class="javascript">if (condition) &#123;
  import(&#39;moduleA&#39;).then(...);
&#125; else &#123;
  import(&#39;moduleB&#39;).then(...);
&#125;
</code></pre>
<p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p>
<p>（3）动态的模块路径</p>
<p><code>import()</code>允许模块路径动态生成。</p>
<pre><code class="javascript">import(f())
.then(...);
</code></pre>
<p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p>
<pre><code class="javascript">import(&#39;./myModule.js&#39;)
.then((&#123;export1, export2&#125;) =&gt; &#123;
  // ...·
&#125;);
</code></pre>
<p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p>
<p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p>
<pre><code class="javascript">import(&#39;./myModule.js&#39;)
.then(myModule =&gt; &#123;
  console.log(myModule.default);
&#125;);
</code></pre>
<p>上面的代码也可以使用具名输入的形式。</p>
<pre><code class="javascript">import(&#39;./myModule.js&#39;)
.then((&#123;default: theDefault&#125;) =&gt; &#123;
  console.log(theDefault);
&#125;);
</code></pre>
<p>如果想同时加载多个模块，可以采用下面的写法。</p>
<pre><code class="javascript">Promise.all([
  import(&#39;./module1.js&#39;),
  import(&#39;./module2.js&#39;),
  import(&#39;./module3.js&#39;),
])
.then(([module1, module2, module3]) =&gt; &#123;
   ···
&#125;);
</code></pre>
<p><code>import()</code>也可以用在 async 函数之中。</p>
<pre><code class="javascript">async function main() &#123;
  const myModule = await import(&#39;./myModule.js&#39;);
  const &#123;export1, export2&#125; = await import(&#39;./myModule.js&#39;);
  const [module1, module2, module3] =
    await Promise.all([
      import(&#39;./module1.js&#39;),
      import(&#39;./module2.js&#39;),
      import(&#39;./module3.js&#39;),
    ]);
&#125;
main();
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-11async函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/11async%E5%87%BD%E6%95%B0/" class="article-date">
  	<time datetime="2022-09-05T02:50:47.179Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/11async%E5%87%BD%E6%95%B0/">
        Es6-async 函数
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E8%AF%AD%E6%B3%95">语法</a></li>
<li>[async 函数的实现原理](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#async">https://es6.ruanyifeng.com/#docs/async#async</a> 函数的实现原理)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83">与其他异步处理方法的比较</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C">实例：按顺序完成异步操作</a></li>
<li>[顶层 await](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E9%A1%B6%E5%B1%82">https://es6.ruanyifeng.com/#docs/async#顶层</a> await)</li>
</ol>
<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;

const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>
<pre><code class="javascript">const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code class="javascript">asyncReadFile();
</code></pre>
<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）返回值是 Promise。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<pre><code class="javascript">async function getStockPriceByName(name) &#123;
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
&#125;

getStockPriceByName(&#39;goog&#39;).then(function (result) &#123;
  console.log(result);
&#125;);
</code></pre>
<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>
<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>
<pre><code class="javascript">function timeout(ms) &#123;
  return new Promise((resolve) =&gt; &#123;
    setTimeout(resolve, ms);
  &#125;);
&#125;

async function asyncPrint(value, ms) &#123;
  await timeout(ms);
  console.log(value);
&#125;

asyncPrint(&#39;hello world&#39;, 50);
</code></pre>
<p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p>
<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>
<pre><code class="javascript">async function timeout(ms) &#123;
  await new Promise((resolve) =&gt; &#123;
    setTimeout(resolve, ms);
  &#125;);
&#125;

async function asyncPrint(value, ms) &#123;
  await timeout(ms);
  console.log(value);
&#125;

asyncPrint(&#39;hello world&#39;, 50);
</code></pre>
<p>async 函数有多种使用形式。</p>
<pre><code class="javascript">// 函数声明
async function foo() &#123;&#125;

// 函数表达式
const foo = async function () &#123;&#125;;

// 对象的方法
let obj = &#123; async foo() &#123;&#125; &#125;;
obj.foo().then(...)

// Class 的方法
class Storage &#123;
  constructor() &#123;
    this.cachePromise = caches.open(&#39;avatars&#39;);
  &#125;

  async getAvatar(name) &#123;
    const cache = await this.cachePromise;
    return cache.match(`/avatars/$&#123;name&#125;.jpg`);
  &#125;
&#125;

const storage = new Storage();
storage.getAvatar(&#39;jake&#39;).then(…);

// 箭头函数
const foo = async () =&gt; &#123;&#125;;
</code></pre>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p>
<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>
<pre><code class="javascript">async function f() &#123;
  return &#39;hello world&#39;;
&#125;

f().then(v =&gt; console.log(v))
// &quot;hello world&quot;
</code></pre>
<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>
<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>
<pre><code class="javascript">async function f() &#123;
  throw new Error(&#39;出错了&#39;);
&#125;

f().then(
  v =&gt; console.log(&#39;resolve&#39;, v),
  e =&gt; console.log(&#39;reject&#39;, e)
)
//reject Error: 出错了
</code></pre>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<pre><code class="javascript">async function getTitle(url) &#123;
  let response = await fetch(url);
  let html = await response.text();
  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];
&#125;
getTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log)
// &quot;ECMAScript 2017 Language Specification&quot;
</code></pre>
<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<pre><code class="javascript">async function f() &#123;
  // 等同于
  // return 123;
  return await 123;
&#125;

f().then(v =&gt; console.log(v))
// 123
</code></pre>
<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>
<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>
<pre><code class="javascript">class Sleep &#123;
  constructor(timeout) &#123;
    this.timeout = timeout;
  &#125;
  then(resolve, reject) &#123;
    const startTime = Date.now();
    setTimeout(
      () =&gt; resolve(Date.now() - startTime),
      this.timeout
    );
  &#125;
&#125;

(async () =&gt; &#123;
  const sleepTime = await new Sleep(1000);
  console.log(sleepTime);
&#125;)();
// 1000
</code></pre>
<p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>
<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>
<pre><code class="javascript">function sleep(interval) &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(resolve, interval);
  &#125;)
&#125;

// 用法
async function one2FiveInAsync() &#123;
  for(let i = 1; i &lt;= 5; i++) &#123;
    console.log(i);
    await sleep(1000);
  &#125;
&#125;

one2FiveInAsync();
</code></pre>
<p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>
<pre><code class="javascript">async function f() &#123;
  await Promise.reject(&#39;出错了&#39;);
&#125;

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// 出错了
</code></pre>
<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>
<p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>
<pre><code class="javascript">async function f() &#123;
  await Promise.reject(&#39;出错了&#39;);
  await Promise.resolve(&#39;hello world&#39;); // 不会执行
&#125;
</code></pre>
<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>
<pre><code class="javascript">async function f() &#123;
  try &#123;
    await Promise.reject(&#39;出错了&#39;);
  &#125; catch(e) &#123;
  &#125;
  return await Promise.resolve(&#39;hello world&#39;);
&#125;

f()
.then(v =&gt; console.log(v))
// hello world
</code></pre>
<p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>
<pre><code class="javascript">async function f() &#123;
  await Promise.reject(&#39;出错了&#39;)
    .catch(e =&gt; console.log(e));
  return await Promise.resolve(&#39;hello world&#39;);
&#125;

f()
.then(v =&gt; console.log(v))
// 出错了
// hello world
</code></pre>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>
<pre><code class="javascript">async function f() &#123;
  await new Promise(function (resolve, reject) &#123;
    throw new Error(&#39;出错了&#39;);
  &#125;);
&#125;

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// Error：出错了
</code></pre>
<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>
<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>
<pre><code class="javascript">async function f() &#123;
  try &#123;
    await new Promise(function (resolve, reject) &#123;
      throw new Error(&#39;出错了&#39;);
    &#125;);
  &#125; catch(e) &#123;
  &#125;
  return await(&#39;hello world&#39;);
&#125;
</code></pre>
<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>
<pre><code class="javascript">async function main() &#123;
  try &#123;
    const val1 = await firstStep();
    const val2 = await secondStep(val1);
    const val3 = await thirdStep(val1, val2);

    console.log(&#39;Final: &#39;, val3);
  &#125;
  catch (err) &#123;
    console.error(err);
  &#125;
&#125;
</code></pre>
<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>
<pre><code class="javascript">const superagent = require(&#39;superagent&#39;);
const NUM_RETRIES = 3;

async function test() &#123;
  let i;
  for (i = 0; i &lt; NUM_RETRIES; ++i) &#123;
    try &#123;
      await superagent.get(&#39;http://google.com/this-throws-an-error&#39;);
      break;
    &#125; catch(err) &#123;&#125;
  &#125;
  console.log(i); // 3
&#125;

test();
</code></pre>
<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>
<pre><code class="javascript">async function myFunction() &#123;
  try &#123;
    await somethingThatReturnsAPromise();
  &#125; catch (err) &#123;
    console.log(err);
  &#125;
&#125;

// 另一种写法

async function myFunction() &#123;
  await somethingThatReturnsAPromise()
  .catch(function (err) &#123;
    console.log(err);
  &#125;);
&#125;
</code></pre>
<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<pre><code class="javascript">let foo = await getFoo();
let bar = await getBar();
</code></pre>
<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<pre><code class="javascript">// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre>
<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>
<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>
<pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  // 报错
  docs.forEach(function (doc) &#123;
    await db.post(doc);
  &#125;);
&#125;
</code></pre>
<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>
<pre><code class="javascript">function dbFuc(db) &#123; //这里不需要 async
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  // 可能得到错误结果
  docs.forEach(async function (doc) &#123;
    await db.post(doc);
  &#125;);
&#125;
</code></pre>
<p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>
<pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  for (let doc of docs) &#123;
    await db.post(doc);
  &#125;
&#125;
</code></pre>
<p>另一种方法是使用数组的<code>reduce()</code>方法。</p>
<pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  await docs.reduce(async (_, doc) =&gt; &#123;
    await _;
    await db.post(doc);
  &#125;, undefined);
&#125;
</code></pre>
<p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p>
<p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p>
<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>
<pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = await Promise.all(promises);
  console.log(results);
&#125;

// 或者使用下面的写法

async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = [];
  for (let promise of promises) &#123;
    results.push(await promise);
  &#125;
  console.log(results);
&#125;
</code></pre>
<p>第四点，async 函数可以保留运行堆栈。</p>
<pre><code class="javascript">const a = () =&gt; &#123;
  b().then(() =&gt; c());
&#125;;
</code></pre>
<p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>
<p>现在将这个例子改成<code>async</code>函数。</p>
<pre><code class="javascript">const a = async () =&gt; &#123;
  await b();
  c();
&#125;;
</code></pre>
<p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>
<h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<pre><code class="javascript">async function fn(args) &#123;
  // ...
&#125;

// 等同于

function fn(args) &#123;
  return spawn(function* () &#123;
    // ...
  &#125;);
&#125;
</code></pre>
<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>
<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>
<pre><code class="javascript">function spawn(genF) &#123;
  return new Promise(function(resolve, reject) &#123;
    const gen = genF();
    function step(nextF) &#123;
      let next;
      try &#123;
        next = nextF();
      &#125; catch(e) &#123;
        return reject(e);
      &#125;
      if(next.done) &#123;
        return resolve(next.value);
      &#125;
      Promise.resolve(next.value).then(function(v) &#123;
        step(function() &#123; return gen.next(v); &#125;);
      &#125;, function(e) &#123;
        step(function() &#123; return gen.throw(e); &#125;);
      &#125;);
    &#125;
    step(function() &#123; return gen.next(undefined); &#125;);
  &#125;);
&#125;
</code></pre>
<h2 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>
<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是 Promise 的写法。</p>
<pre><code class="javascript">function chainAnimationsPromise(elem, animations) &#123;

  // 变量ret用来保存上一个动画的返回值
  let ret = null;

  // 新建一个空的Promise
  let p = Promise.resolve();

  // 使用then方法，添加所有动画
  for(let anim of animations) &#123;
    p = p.then(function(val) &#123;
      ret = val;
      return anim(elem);
    &#125;);
  &#125;

  // 返回一个部署了错误捕捉机制的Promise
  return p.catch(function(e) &#123;
    /* 忽略错误，继续执行 */
  &#125;).then(function() &#123;
    return ret;
  &#125;);

&#125;
</code></pre>
<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>
<p>接着是 Generator 函数的写法。</p>
<pre><code class="javascript">function chainAnimationsGenerator(elem, animations) &#123;

  return spawn(function*() &#123;
    let ret = null;
    try &#123;
      for(let anim of animations) &#123;
        ret = yield anim(elem);
      &#125;
    &#125; catch(e) &#123;
      /* 忽略错误，继续执行 */
    &#125;
    return ret;
  &#125;);

&#125;
</code></pre>
<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>
<p>最后是 async 函数的写法。</p>
<pre><code class="javascript">async function chainAnimationsAsync(elem, animations) &#123;
  let ret = null;
  try &#123;
    for(let anim of animations) &#123;
      ret = await anim(elem);
    &#125;
  &#125; catch(e) &#123;
    /* 忽略错误，继续执行 */
  &#125;
  return ret;
&#125;
</code></pre>
<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>
<h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>
<p>Promise 的写法如下。</p>
<pre><code class="javascript">function logInOrder(urls) &#123;
  // 远程读取所有URL
  const textPromises = urls.map(url =&gt; &#123;
    return fetch(url).then(response =&gt; response.text());
  &#125;);

  // 按次序输出
  textPromises.reduce((chain, textPromise) =&gt; &#123;
    return chain.then(() =&gt; textPromise)
      .then(text =&gt; console.log(text));
  &#125;, Promise.resolve());
&#125;
</code></pre>
<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>
<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>
<pre><code class="javascript">async function logInOrder(urls) &#123;
  for (const url of urls) &#123;
    const response = await fetch(url);
    console.log(await response.text());
  &#125;
&#125;
</code></pre>
<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>
<pre><code class="javascript">async function logInOrder(urls) &#123;
  // 并发读取远程URL
  const textPromises = urls.map(async url =&gt; &#123;
    const response = await fetch(url);
    return response.text();
  &#125;);

  // 按次序输出
  for (const textPromise of textPromises) &#123;
    console.log(await textPromise);
  &#125;
&#125;
</code></pre>
<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>
<h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><p>早期的语法规定是，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>
<pre><code class="javascript">// 报错
const data = await fetch(&#39;https://api.example.com&#39;);
</code></pre>
<p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p>
<p>从 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-top-level-await">ES2022</a> 开始，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。它的主要目的是使用<code>await</code>解决模块异步加载的问题。</p>
<pre><code class="javascript">// awaiting.js
let output;
async function main() &#123;
  const dynamic = await import(someMission);
  const data = await fetch(url);
  output = someProcess(dynamic.default, data);
&#125;
main();
export &#123; output &#125;;
</code></pre>
<p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p>
<p>下面是加载这个模块的写法。</p>
<pre><code class="javascript">// usage.js
import &#123; output &#125; from &quot;./awaiting.js&quot;;

function outputPlusValue(value) &#123; return output + value &#125;

console.log(outputPlusValue(100));
setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);
</code></pre>
<p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p>
<p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p>
<pre><code class="javascript">// awaiting.js
let output;
export default (async function main() &#123;
  const dynamic = await import(someMission);
  const data = await fetch(url);
  output = someProcess(dynamic.default, data);
&#125;)();
export &#123; output &#125;;
</code></pre>
<p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p>
<p>下面是加载这个模块的新的写法。</p>
<pre><code class="javascript">// usage.js
import promise, &#123; output &#125; from &quot;./awaiting.js&quot;;

function outputPlusValue(value) &#123; return output + value &#125;

promise.then(() =&gt; &#123;
  console.log(outputPlusValue(100));
  setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);
&#125;);
</code></pre>
<p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p>
<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p>
<p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>
<pre><code class="javascript">// awaiting.js
const dynamic = import(someMission);
const data = fetch(url);
export const output = someProcess((await dynamic).default, await data);
</code></pre>
<p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p>
<p>加载这个模块的写法如下。</p>
<pre><code class="javascript">// usage.js
import &#123; output &#125; from &quot;./awaiting.js&quot;;
function outputPlusValue(value) &#123; return output + value &#125;

console.log(outputPlusValue(100));
setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);
</code></pre>
<p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>
<p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p>
<p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p>
<p>下面是顶层<code>await</code>的一些使用场景。</p>
<pre><code class="javascript">// import() 方法加载
const strings = await import(`/i18n/$&#123;navigator.language&#125;`);

// 数据库操作
const connection = await dbConnector();

// 依赖回滚
let jQuery;
try &#123;
  jQuery = await import(&#39;https://cdn-a.com/jQuery&#39;);
&#125; catch &#123;
  jQuery = await import(&#39;https://cdn-b.com/jQuery&#39;);
&#125;
</code></pre>
<p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p>
<pre><code class="javascript">// x.js
console.log(&quot;X1&quot;);
await new Promise(r =&gt; setTimeout(r, 1000));
console.log(&quot;X2&quot;);

// y.js
console.log(&quot;Y&quot;);

// z.js
import &quot;./x.js&quot;;
import &quot;./y.js&quot;;
console.log(&quot;Z&quot;);
</code></pre>
<p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p>
<p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-10编码风格" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/10%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/" class="article-date">
  	<time datetime="2022-09-05T02:50:25.924Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/10%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/">
        Es6-编程风格
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E5%AF%B9%E8%B1%A1">对象</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E5%87%BD%E6%95%B0">函数</a></li>
<li>[Map 结构](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#Map">https://es6.ruanyifeng.com/#docs/style#Map</a> 结构)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#Class">Class</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#%E6%A8%A1%E5%9D%97">模块</a></li>
<li>[ESLint 的使用](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/style#ESLint">https://es6.ruanyifeng.com/#docs/style#ESLint</a> 的使用)</li>
</ol>
<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>
<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a target="_blank" rel="noopener" href="https://github.com/airbnb/javascript">Airbnb</a> 公司的 JavaScript 风格规范。</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p><strong>（1）let 取代 var</strong></p>
<p>ES6 提出了两个新的声明变量的命令：<code>let</code>和<code>const</code>。其中，<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。</p>
<pre><code class="javascript">&#39;use strict&#39;;

if (true) &#123;
  let x = &#39;hello&#39;;
&#125;

for (let i = 0; i &lt; 10; i++) &#123;
  console.log(i);
&#125;
</code></pre>
<p>上面代码如果用<code>var</code>替代<code>let</code>，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p>
<p><code>var</code>命令存在变量提升效用，<code>let</code>命令没有这个问题。</p>
<pre><code class="javascript">&#39;use strict&#39;;

if (true) &#123;
  console.log(x); // ReferenceError
  let x = &#39;hello&#39;;
&#125;
</code></pre>
<p>上面代码如果使用<code>var</code>替代<code>let</code>，<code>console.log</code>那一行就不会报错，而是会输出<code>undefined</code>，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p>
<p>所以，建议不再使用<code>var</code>命令，而是使用<code>let</code>命令取代。</p>
<p><strong>（2）全局常量和线程安全</strong></p>
<p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p>
<p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</p>
<pre><code class="javascript">// bad
var a = 1, b = 2, c = 3;

// good
const a = 1;
const b = 2;
const c = 3;

// best
const [a, b, c] = [1, 2, 3];
</code></pre>
<p><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p>
<p>所有的函数都应该设置为常量。</p>
<p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<pre><code class="javascript">// bad
const a = &quot;foobar&quot;;
const b = &#39;foo&#39; + a + &#39;bar&#39;;

// acceptable
const c = `foobar`;

// good
const a = &#39;foobar&#39;;
const b = `foo$&#123;a&#125;bar`;
</code></pre>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<pre><code class="javascript">const arr = [1, 2, 3, 4];

// bad
const first = arr[0];
const second = arr[1];

// good
const [first, second] = arr;
</code></pre>
<p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<pre><code class="javascript">// bad
function getFullName(user) &#123;
  const firstName = user.firstName;
  const lastName = user.lastName;
&#125;

// good
function getFullName(obj) &#123;
  const &#123; firstName, lastName &#125; = obj;
&#125;

// best
function getFullName(&#123; firstName, lastName &#125;) &#123;
&#125;
</code></pre>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<pre><code class="javascript">// bad
function processInput(input) &#123;
  return [left, right, top, bottom];
&#125;

// good
function processInput(input) &#123;
  return &#123; left, right, top, bottom &#125;;
&#125;

const &#123; left, right &#125; = processInput(input);
</code></pre>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<pre><code class="javascript">// bad
const a = &#123; k1: v1, k2: v2, &#125;;
const b = &#123;
  k1: v1,
  k2: v2
&#125;;

// good
const a = &#123; k1: v1, k2: v2 &#125;;
const b = &#123;
  k1: v1,
  k2: v2,
&#125;;
</code></pre>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<pre><code class="javascript">// bad
const a = &#123;&#125;;
a.x = 3;

// if reshape unavoidable
const a = &#123;&#125;;
Object.assign(a, &#123; x: 3 &#125;);

// good
const a = &#123; x: null &#125;;
a.x = 3;
</code></pre>
<p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p>
<pre><code class="javascript">// bad
const obj = &#123;
  id: 5,
  name: &#39;San Francisco&#39;,
&#125;;
obj[getKey(&#39;enabled&#39;)] = true;

// good
const obj = &#123;
  id: 5,
  name: &#39;San Francisco&#39;,
  [getKey(&#39;enabled&#39;)]: true,
&#125;;
</code></pre>
<p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p>
<p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p>
<pre><code class="javascript">var ref = &#39;some value&#39;;

// bad
const atom = &#123;
  ref: ref,

  value: 1,

  addValue: function (value) &#123;
    return atom.value + value;
  &#125;,
&#125;;

// good
const atom = &#123;
  ref,

  value: 1,

  addValue(value) &#123;
    return atom.value + value;
  &#125;,
&#125;;
</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用扩展运算符（…）拷贝数组。</p>
<pre><code class="javascript">// bad
const len = items.length;
const itemsCopy = [];
let i;

for (i = 0; i &lt; len; i++) &#123;
  itemsCopy[i] = items[i];
&#125;

// good
const itemsCopy = [...items];
</code></pre>
<p>使用 Array.from 方法，将类似数组的对象转为数组。</p>
<pre><code class="javascript">const foo = document.querySelectorAll(&#39;.foo&#39;);
const nodes = Array.from(foo);
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>立即执行函数可以写成箭头函数的形式。</p>
<pre><code class="javascript">(() =&gt; &#123;
  console.log(&#39;Welcome to the Internet.&#39;);
&#125;)();
</code></pre>
<p>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p>
<pre><code class="javascript">// bad
[1, 2, 3].map(function (x) &#123;
  return x * x;
&#125;);

// good
[1, 2, 3].map((x) =&gt; &#123;
  return x * x;
&#125;);

// best
[1, 2, 3].map(x =&gt; x * x);
</code></pre>
<p>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</p>
<pre><code class="javascript">// bad
const self = this;
const boundMethod = function(...params) &#123;
  return method.apply(self, params);
&#125;

// acceptable
const boundMethod = method.bind(this);

// best
const boundMethod = (...params) =&gt; method.apply(this, params);
</code></pre>
<p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p>
<p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<pre><code class="javascript">// bad
function divide(a, b, option = false ) &#123;
&#125;

// good
function divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;
&#125;
</code></pre>
<p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p>
<pre><code class="javascript">// bad
function concatenateAll() &#123;
  const args = Array.prototype.slice.call(arguments);
  return args.join(&#39;&#39;);
&#125;

// good
function concatenateAll(...args) &#123;
  return args.join(&#39;&#39;);
&#125;
</code></pre>
<p>使用默认值语法设置函数参数的默认值。</p>
<pre><code class="javascript">// bad
function handleThings(opts) &#123;
  opts = opts || &#123;&#125;;
&#125;

// good
function handleThings(opts = &#123;&#125;) &#123;
  // ...
&#125;
</code></pre>
<h2 id="Map-结构"><a href="#Map-结构" class="headerlink" title="Map 结构"></a>Map 结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p>
<pre><code class="javascript">let map = new Map(arr);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;

for (let value of map.values()) &#123;
  console.log(value);
&#125;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
</code></pre>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</p>
<pre><code class="javascript">// bad
function Queue(contents = []) &#123;
  this._queue = [...contents];
&#125;
Queue.prototype.pop = function() &#123;
  const value = this._queue[0];
  this._queue.splice(0, 1);
  return value;
&#125;

// good
class Queue &#123;
  constructor(contents = []) &#123;
    this._queue = [...contents];
  &#125;
  pop() &#123;
    const value = this._queue[0];
    this._queue.splice(0, 1);
    return value;
  &#125;
&#125;
</code></pre>
<p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p>
<pre><code class="javascript">// bad
const inherits = require(&#39;inherits&#39;);
function PeekableQueue(contents) &#123;
  Queue.apply(this, contents);
&#125;
inherits(PeekableQueue, Queue);
PeekableQueue.prototype.peek = function() &#123;
  return this._queue[0];
&#125;

// good
class PeekableQueue extends Queue &#123;
  peek() &#123;
    return this._queue[0];
  &#125;
&#125;
</code></pre>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。</p>
<p>首先，使用<code>import</code>取代<code>require()</code>。</p>
<pre><code class="javascript">// CommonJS 的写法
const moduleA = require(&#39;moduleA&#39;);
const func1 = moduleA.func1;
const func2 = moduleA.func2;

// ES6 的写法
import &#123; func1, func2 &#125; from &#39;moduleA&#39;;
</code></pre>
<p>其次，使用<code>export</code>取代<code>module.exports</code>。</p>
<pre><code class="javascript">// commonJS 的写法
var React = require(&#39;react&#39;);

var Breadcrumbs = React.createClass(&#123;
  render() &#123;
    return &lt;nav /&gt;;
  &#125;
&#125;);

module.exports = Breadcrumbs;

// ES6 的写法
import React from &#39;react&#39;;

class Breadcrumbs extends React.Component &#123;
  render() &#123;
    return &lt;nav /&gt;;
  &#125;
&#125;;

export default Breadcrumbs;
</code></pre>
<p>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，除非其中某个输出值特别重要，否则建议不要使用<code>export default</code>，即多个输出值如果是平等关系，<code>export default</code>与普通的<code>export</code>就不要同时使用。</p>
<p>如果模块默认输出一个函数，函数名的首字母应该小写，表示这是一个工具方法。</p>
<pre><code class="javascript">function makeStyleGuide() &#123;
&#125;

export default makeStyleGuide;
</code></pre>
<p>如果模块默认输出一个对象，对象名的首字母应该大写，表示这是一个配置值对象。</p>
<pre><code class="javascript">const StyleGuide = &#123;
  es6: &#123;
  &#125;
&#125;;

export default StyleGuide;
</code></pre>
<h2 id="ESLint-的使用"><a href="#ESLint-的使用" class="headerlink" title="ESLint 的使用"></a>ESLint 的使用</h2><p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p>
<p>首先，在项目的根目录安装 ESLint。</p>
<pre><code class="bash">$ npm install --save-dev eslint
</code></pre>
<p>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。</p>
<pre><code class="bash">$ npm install --save-dev eslint-config-airbnb
$ npm install --save-dev eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
</code></pre>
<p>最后，在项目的根目录下新建一个<code>.eslintrc</code>文件，配置 ESLint。</p>
<pre><code class="javascript">&#123;
  &quot;extends&quot;: &quot;eslint-config-airbnb&quot;
&#125;
</code></pre>
<p>现在就可以检查，当前项目的代码是否符合预设的规则。</p>
<p><code>index.js</code>文件的代码如下。</p>
<pre><code class="javascript">var unused = &#39;I have no purpose!&#39;;

function greet() &#123;
    var message = &#39;Hello, World!&#39;;
    console.log(message);
&#125;

greet();
</code></pre>
<p>使用 ESLint 检查这个文件，就会报出错误。</p>
<pre><code class="bash">$ npx eslint index.js
index.js
  1:1  error  Unexpected var, use let or const instead          no-var
  1:5  error  unused is defined but never used                 no-unused-vars
  4:5  error  Expected indentation of 2 characters but found 4  indent
  4:5  error  Unexpected var, use let or const instead          no-var
  5:5  error  Expected indentation of 2 characters but found 4  indent

✖ 5 problems (5 errors, 0 warnings)
</code></pre>
<p>上面代码说明，原文件有五个错误，其中两个是不应该使用<code>var</code>命令，而要使用<code>let</code>或<code>const</code>；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-9class类的继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/9class%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/" class="article-date">
  	<time datetime="2022-09-05T02:50:09.215Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/9class%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/">
        Es6-Class 的继承
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF">私有属性和私有方法的继承</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF">静态属性和静态方法的继承</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#Object.getPrototypeOf()">Object.getPrototypeOf()</a></li>
<li>[super 关键字](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#super">https://es6.ruanyifeng.com/#docs/class-extends#super</a> 关键字)</li>
<li>[类的 prototype 属性和__proto__属性](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%B1%BB%E7%9A%84">https://es6.ruanyifeng.com/#docs/class-extends#类的</a> prototype 属性和__proto__属性)</li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">原生构造函数的继承</a></li>
<li>[Mixin 模式的实现](<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#Mixin">https://es6.ruanyifeng.com/#docs/class-extends#Mixin</a> 模式的实现)</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。</p>
<pre><code class="javascript">class Point &#123;
&#125;

class ColorPoint extends Point &#123;
&#125;
</code></pre>
<p>上面示例中，<code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。</p>
<p>下面，我们在<code>ColorPoint</code>内部加上代码。</p>
<pre><code class="javascript">class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  &#125;

  toString() &#123;
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象。</p>
<p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p>
<pre><code class="javascript">class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor() &#123;
  &#125;
&#125;

let cp = new ColorPoint(); // ReferenceError
</code></pre>
<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super()</code>，导致新建实例时报错。</p>
<p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p>
<p>注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。</p>
<pre><code class="javascript">class Foo &#123;
  constructor() &#123;
    console.log(1);
  &#125;
&#125;

class Bar extends Foo &#123;
  constructor() &#123;
    super();
    console.log(2);
  &#125;
&#125;

const bar = new Bar();
// 1
// 2
</code></pre>
<p>上面示例中，子类 Bar 新建实例时，会输出1和2。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p>
<pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;
&#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。</p>
<p>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。</p>
<pre><code class="javascript">class ColorPoint extends Point &#123;
&#125;

// 等同于
class ColorPoint extends Point &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;
</code></pre>
<p>有了子类的定义，就可以生成子类的实例了。</p>
<pre><code class="javascript">let cp = new ColorPoint(25, 8, &#39;green&#39;);

cp instanceof ColorPoint // true
cp instanceof Point // true
</code></pre>
<p>上面示例中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p>
<h2 id="私有属性和私有方法的继承"><a href="#私有属性和私有方法的继承" class="headerlink" title="私有属性和私有方法的继承"></a>私有属性和私有方法的继承</h2><p>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。</p>
<p>子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。</p>
<pre><code class="javascript">class Foo &#123;
  #p = 1;
  #m() &#123;
    console.log(&#39;hello&#39;);
  &#125;
&#125;

class Bar extends Foo &#123;
  constructor() &#123;
    super();
    console.log(this.#p); // 报错
    this.#m(); // 报错
  &#125;
&#125;
</code></pre>
<p>上面示例中，子类 Bar 调用父类 Foo 的私有属性或私有方法，都会报错。</p>
<p>如果父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性。</p>
<pre><code class="javascript">class Foo &#123;
  #p = 1;
  getP() &#123;
    return this.#p;
  &#125;
&#125;

class Bar extends Foo &#123;
  constructor() &#123;
    super();
    console.log(this.getP()); // 1
  &#125;
&#125;
</code></pre>
<p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，通过该方法，子类就可以读到父类的私有属性。</p>
<h2 id="静态属性和静态方法的继承"><a href="#静态属性和静态方法的继承" class="headerlink" title="静态属性和静态方法的继承"></a>静态属性和静态方法的继承</h2><p>父类的静态属性和静态方法，也会被子类继承。</p>
<pre><code class="javascript">class A &#123;
  static hello() &#123;
    console.log(&#39;hello world&#39;);
  &#125;
&#125;

class B extends A &#123;
&#125;

B.hello()  // hello world
</code></pre>
<p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p>
<p>注意，静态属性是通过软拷贝实现继承的。</p>
<pre><code class="javascript">class A &#123; static foo = 100; &#125;
class B extends A &#123;
  constructor() &#123;
    super();
    B.foo--;
  &#125;
&#125;

const b = new B();
B.foo // 99
A.foo // 100
</code></pre>
<p>上面示例中，<code>foo</code>是 A 类的静态属性，B 类继承了 A 类，因此也继承了这个属性。但是，在 B 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code>，原因就是 B 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。</p>
<p>但是，由于这种拷贝是浅拷贝，如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。</p>
<pre><code class="javascript">class A &#123;
  static foo = &#123; n: 100 &#125;;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    B.foo.n--;
  &#125;
&#125;

const b = new B();
B.foo.n // 99
A.foo.n // 99
</code></pre>
<p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>A</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code>方法可以用来从子类上获取父类。</p>
<pre><code class="javascript">class Point &#123; /*...*/ &#125;

class ColorPoint extends Point &#123; /*...*/ &#125;

Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    console.log(new.target.name);
  &#125;
&#125;
class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
new A() // A
new B() // B
</code></pre>
<p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>
<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  m() &#123;
    super(); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p>
<p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<pre><code class="javascript">class A &#123;
  p() &#123;
    return 2;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.p()); // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
<p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.p = 2;
  &#125;
&#125;

class B extends A &#123;
  get m() &#123;
    return super.p;
  &#125;
&#125;

let b = new B();
b.m // undefined
</code></pre>
<p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>
<pre><code class="javascript">class A &#123;&#125;
A.prototype.x = 2;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.x) // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>
<p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  m() &#123;
    super.print();
  &#125;
&#125;

let b = new B();
b.m() // 2
</code></pre>
<p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p>
<p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>
<pre><code class="javascript">class Parent &#123;
  static myMethod(msg) &#123;
    console.log(&#39;static&#39;, msg);
  &#125;

  myMethod(msg) &#123;
    console.log(&#39;instance&#39;, msg);
  &#125;
&#125;

class Child extends Parent &#123;
  static myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;

  myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;
&#125;

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
</code></pre>
<p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>
<pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  static print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  static m() &#123;
    super.print();
  &#125;
&#125;

B.x = 3;
B.m() // 3
</code></pre>
<p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>
<p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p>
<pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.valueOf() instanceof B); // true
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>
<pre><code class="javascript">var obj = &#123;
  toString() &#123;
    return &quot;MyObject: &quot; + super.toString();
  &#125;
&#125;;

obj.toString(); // MyObject: [object Object]
</code></pre>
<h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
<pre><code class="javascript">class A &#123;
&#125;

class B extends A &#123;
&#125;

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
</code></pre>
<p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<pre><code class="javascript">class A &#123;
&#125;

class B &#123;
&#125;

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 继承 A 的静态属性
Object.setPrototypeOf(B, A);

const b = new B();
</code></pre>
<p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p>
<pre><code class="javascript">Object.setPrototypeOf = function (obj, proto) &#123;
  obj.__proto__ = proto;
  return obj;
&#125;
</code></pre>
<p>因此，就得到了上面的结果。</p>
<pre><code class="javascript">Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;
</code></pre>
<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<pre><code class="javascript">B.prototype = Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;
</code></pre>
<p><code>extends</code>关键字后面可以跟多种类型的值。</p>
<pre><code class="javascript">class B extends A &#123;
&#125;
</code></pre>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p>
<pre><code class="javascript">class A extends Object &#123;
&#125;

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p>
<p>第二种情况，不存在任何继承。</p>
<pre><code class="javascript">class A &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p>
<h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<pre><code class="javascript">var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, &#39;red&#39;);

p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true
</code></pre>
<p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<pre><code class="javascript">p2.__proto__.__proto__.printName = function () &#123;
  console.log(&#39;Ha&#39;);
&#125;;

p1.printName() // &quot;Ha&quot;
</code></pre>
<p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p>
<h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p>
<pre><code class="javascript">function MyArray() &#123;
  Array.apply(this, arguments);
&#125;

MyArray.prototype = Object.create(Array.prototype, &#123;
  constructor: &#123;
    value: MyArray,
    writable: true,
    configurable: true,
    enumerable: true
  &#125;
&#125;);
</code></pre>
<p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p>
<pre><code class="javascript">var colors = new MyArray();
colors[0] = &quot;red&quot;;
colors.length  // 0

colors.length = 0;
colors[0]  // &quot;red&quot;
</code></pre>
<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>
<p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p>
<pre><code class="javascript">var e = &#123;&#125;;

Object.getOwnPropertyNames(Error.call(e))
// [ &#39;stack&#39; ]

Object.getOwnPropertyNames(e)
// []
</code></pre>
<p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p>
<pre><code class="javascript">class MyArray extends Array &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
</code></pre>
<p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p>
<p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<pre><code class="javascript">class VersionedArray extends Array &#123;
  constructor() &#123;
    super();
    this.history = [[]];
  &#125;
  commit() &#123;
    this.history.push(this.slice());
  &#125;
  revert() &#123;
    this.splice(0, this.length, ...this.history[this.history.length - 1]);
  &#125;
&#125;

var x = new VersionedArray();

x.push(1);
x.push(2);
x // [1, 2]
x.history // [[]]

x.commit();
x.history // [[], [1, 2]]

x.push(3);
x // [1, 2, 3]
x.history // [[], [1, 2]]

x.revert();
x // [1, 2]
</code></pre>
<p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p>
<pre><code class="javascript">class ExtendableError extends Error &#123;
  constructor(message) &#123;
    super();
    this.message = message;
    this.stack = (new Error()).stack;
    this.name = this.constructor.name;
  &#125;
&#125;

class MyError extends ExtendableError &#123;
  constructor(m) &#123;
    super(m);
  &#125;
&#125;

var myerror = new MyError(&#39;ll&#39;);
myerror.message // &quot;ll&quot;
myerror instanceof Error // true
myerror.name // &quot;MyError&quot;
myerror.stack
// Error
//     at MyError.ExtendableError
//     ...
</code></pre>
<p>注意，继承<code>Object</code>的子类，有一个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p>
<pre><code class="javascript">class NewObj extends Object&#123;
  constructor()&#123;
    super(...arguments);
  &#125;
&#125;
var o = new NewObj(&#123;attr: true&#125;);
o.attr === true  // false
</code></pre>
<p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p>
<h2 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>
<pre><code class="javascript">const a = &#123;
  a: &#39;a&#39;
&#125;;
const b = &#123;
  b: &#39;b&#39;
&#125;;
const c = &#123;...a, ...b&#125;; // &#123;a: &#39;a&#39;, b: &#39;b&#39;&#125;
</code></pre>
<p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p>
<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>
<pre><code class="javascript">function mix(...mixins) &#123;
  class Mix &#123;
    constructor() &#123;
      for (let mixin of mixins) &#123;
        copyProperties(this, new mixin()); // 拷贝实例属性
      &#125;
    &#125;
  &#125;

  for (let mixin of mixins) &#123;
    copyProperties(Mix, mixin); // 拷贝静态属性
    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
  &#125;

  return Mix;
&#125;

function copyProperties(target, source) &#123;
  for (let key of Reflect.ownKeys(source)) &#123;
    if ( key !== &#39;constructor&#39;
      &amp;&amp; key !== &#39;prototype&#39;
      &amp;&amp; key !== &#39;name&#39;
    ) &#123;
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<pre><code class="javascript">class DistributedEdit extends mix(Loggable, Serializable) &#123;
  // ...
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-8新增Set和Map的数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/8%E6%96%B0%E5%A2%9ESet%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  	<time datetime="2022-09-05T02:49:51.323Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/8%E6%96%B0%E5%A2%9ESet%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
        Es6-Set 和 Map 数据结构
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map#Set">Set</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map#WeakSet">WeakSet</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map#Map">Map</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map#WeakMap">WeakMap</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map#WeakRef">WeakRef</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/set-map#FinalizationRegistry">FinalizationRegistry</a></li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<pre><code class="javascript">const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));

for (let i of s) &#123;
  console.log(i);
&#125;
// 2 3 5 4
</code></pre>
<p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>
<p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<pre><code class="javascript">// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll(&#39;div&#39;));
set.size // 56

// 类似于
const set = new Set();
document
 .querySelectorAll(&#39;div&#39;)
 .forEach(div =&gt; set.add(div));
set.size // 56
</code></pre>
<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<pre><code class="javascript">// 去除数组的重复成员
[...new Set(array)]
</code></pre>
<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<pre><code class="javascript">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)
// &quot;abc&quot;
</code></pre>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<pre><code class="javascript">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set &#123;NaN&#125;
</code></pre>
<p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p>
<p>另外，两个对象总是不相等的。</p>
<pre><code class="javascript">let set = new Set();

set.add(&#123;&#125;);
set.size // 1

set.add(&#123;&#125;);
set.size // 2
</code></pre>
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>上面这些属性和方法的实例如下。</p>
<pre><code class="javascript">s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false
</code></pre>
<p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>
<pre><code class="javascript">// 对象的写法
const properties = &#123;
  &#39;width&#39;: 1,
  &#39;height&#39;: 1
&#125;;

if (properties[someName]) &#123;
  // do something
&#125;

// Set的写法
const properties = new Set();

properties.add(&#39;width&#39;);
properties.add(&#39;height&#39;);

if (properties.has(someName)) &#123;
  // do something
&#125;
</code></pre>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<pre><code class="javascript">const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
</code></pre>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<pre><code class="javascript">function dedupe(array) &#123;
  return Array.from(new Set(array));
&#125;

dedupe([1, 1, 2, 3]) // [1, 2, 3]
</code></pre>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.values()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.entries()) &#123;
  console.log(item);
&#125;
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
</code></pre>
<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<pre><code class="javascript">Set.prototype[Symbol.iterator] === Set.prototype.values
// true
</code></pre>
<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let x of set) &#123;
  console.log(x);
&#125;
// red
// green
// blue
</code></pre>
<p><strong>（2）<code>forEach()</code></strong></p>
<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code class="javascript">let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre>
<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p>
<p><strong>（3）遍历的应用</strong></p>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
let arr = [...set];
// [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
</code></pre>
<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<pre><code class="javascript">let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
</code></pre>
<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>
<pre><code class="javascript">let set = new Set([1, 2, 3]);
set = new Set([...set].map(x =&gt; x * 2));
// 返回Set结构：&#123;2, 4, 6&#125;

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x =&gt; (x % 2) == 0));
// 返回Set结构：&#123;2, 4&#125;
</code></pre>
<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>
<pre><code class="javascript">// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val =&gt; val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val =&gt; val * 2));
// set的值是2, 4, 6
</code></pre>
<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<pre><code class="javascript">const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
</code></pre>
<p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>
<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p>
<pre><code class="javascript">const ws = new WeakSet();
</code></pre>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<pre><code class="javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet &#123;[1, 2], [3, 4]&#125;
</code></pre>
<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p>
<p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>
<pre><code class="javascript">const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
</code></pre>
<p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li>
<li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li>
<li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>下面是一个例子。</p>
<pre><code class="javascript">const ws = new WeakSet();
const obj = &#123;&#125;;
const foo = &#123;&#125;;

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false

ws.delete(window);
ws.has(window);    // false
</code></pre>
<p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p>
<pre><code class="javascript">ws.size // undefined
ws.forEach // undefined

ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)
// TypeError: undefined is not a function
</code></pre>
<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<p>下面是 WeakSet 的另一个例子。</p>
<pre><code class="javascript">const foos = new WeakSet()
class Foo &#123;
  constructor() &#123;
    foos.add(this)
  &#125;
  method () &#123;
    if (!foos.has(this)) &#123;
      throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<pre><code class="javascript">const data = &#123;&#125;;
const element = document.getElementById(&#39;myDiv&#39;);

data[element] = &#39;metadata&#39;;
data[&#39;[object HTMLDivElement]&#39;] // &quot;metadata&quot;
</code></pre>
<p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<pre><code class="javascript">const m = new Map();
const o = &#123;p: &#39;Hello World&#39;&#125;;

m.set(o, &#39;content&#39;)
m.get(o) // &quot;content&quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false
</code></pre>
<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<pre><code class="javascript">const map = new Map([
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
]);

map.size // 2
map.has(&#39;name&#39;) // true
map.get(&#39;name&#39;) // &quot;张三&quot;
map.has(&#39;title&#39;) // true
map.get(&#39;title&#39;) // &quot;Author&quot;
</code></pre>
<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>
<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<pre><code class="javascript">const items = [
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
];

const map = new Map();

items.forEach(
  ([key, value]) =&gt; map.set(key, value)
);
</code></pre>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>
<pre><code class="javascript">const set = new Set([
  [&#39;foo&#39;, 1],
  [&#39;bar&#39;, 2]
]);
const m1 = new Map(set);
m1.get(&#39;foo&#39;) // 1

const m2 = new Map([[&#39;baz&#39;, 3]]);
const m3 = new Map(m2);
m3.get(&#39;baz&#39;) // 3
</code></pre>
<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<pre><code class="javascript">const map = new Map();

map
.set(1, &#39;aaa&#39;)
.set(1, &#39;bbb&#39;);

map.get(1) // &quot;bbb&quot;
</code></pre>
<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<pre><code class="javascript">new Map().get(&#39;asfddfsasadf&#39;)
// undefined
</code></pre>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<pre><code class="javascript">const map = new Map();

map.set([&#39;a&#39;], 555);
map.get([&#39;a&#39;]) // undefined
</code></pre>
<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<pre><code class="javascript">const map = new Map();

const k1 = [&#39;a&#39;];
const k2 = [&#39;a&#39;];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
</code></pre>
<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<pre><code class="javascript">let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set(&#39;true&#39;, 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
</code></pre>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size 属性</strong></p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
</code></pre>
<p><strong>（2）Map.prototype.set(key, value)</strong></p>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6)        // 键是字符串
m.set(262, &#39;standard&#39;)     // 键是数值
m.set(undefined, &#39;nah&#39;)    // 键是 undefined
</code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="javascript">let map = new Map()
  .set(1, &#39;a&#39;)
  .set(2, &#39;b&#39;)
  .set(3, &#39;c&#39;);
</code></pre>
<p><strong>（3）Map.prototype.get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="javascript">const m = new Map();

const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数

m.get(hello)  // Hello ES6!
</code></pre>
<p><strong>（4）Map.prototype.has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);

m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre>
<p><strong>（5）Map.prototype.delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="javascript">const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre>
<p><strong>（6）Map.prototype.clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="javascript">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
map.clear()
map.size // 0
</code></pre>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<pre><code class="javascript">const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) &#123;
  console.log(value);
&#125;
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;
</code></pre>
<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<pre><code class="javascript">map[Symbol.iterator] === map.entries
// true
</code></pre>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<pre><code class="javascript">const map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]

[...map.entries()]
// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]

[...map]
// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]
</code></pre>
<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p>
<pre><code class="javascript">const map0 = new Map()
  .set(1, &#39;a&#39;)
  .set(2, &#39;b&#39;)
  .set(3, &#39;c&#39;);

const map1 = new Map(
  [...map0].filter(([k, v]) =&gt; k &lt; 3)
);
// 产生 Map 结构 &#123;1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;&#125;

const map2 = new Map(
  [...map0].map(([k, v]) =&gt; [k * 2, &#39;_&#39; + v])
    );
// 产生 Map 结构 &#123;2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;&#125;
</code></pre>
<p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>
<pre><code class="javascript">map.forEach(function(value, key, map) &#123;
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
&#125;);
</code></pre>
<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
<pre><code class="javascript">const reporter = &#123;
  report: function(key, value) &#123;
    console.log(&quot;Key: %s, Value: %s&quot;, key, value);
  &#125;
&#125;;

map.forEach(function(value, key, map) &#123;
  this.report(key, value);
&#125;, reporter);
</code></pre>
<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p>
<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>
<pre><code class="javascript">const myMap = new Map()
  .set(true, 7)
  .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
[...myMap]
// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]
</code></pre>
<p><strong>（2）数组 转为 Map</strong></p>
<p>将数组传入 Map 构造函数，就可以转为 Map。</p>
<pre><code class="javascript">new Map([
  [true, 7],
  [&#123;foo: 3&#125;, [&#39;abc&#39;]]
])
// Map &#123;
//   true =&gt; 7,
//   Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]
// &#125;
</code></pre>
<p><strong>（3）Map 转为对象</strong></p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<pre><code class="javascript">function strMapToObj(strMap) &#123;
  let obj = Object.create(null);
  for (let [k,v] of strMap) &#123;
    obj[k] = v;
  &#125;
  return obj;
&#125;

const myMap = new Map()
  .set(&#39;yes&#39;, true)
  .set(&#39;no&#39;, false);
strMapToObj(myMap)
// &#123; yes: true, no: false &#125;
</code></pre>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p><strong>（4）对象转为 Map</strong></p>
<p>对象转为 Map 可以通过<code>Object.entries()</code>。</p>
<pre><code class="javascript">let obj = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;
let map = new Map(Object.entries(obj));
</code></pre>
<p>此外，也可以自己实现一个转换函数。</p>
<pre><code class="javascript">function objToStrMap(obj) &#123;
  let strMap = new Map();
  for (let k of Object.keys(obj)) &#123;
    strMap.set(k, obj[k]);
  &#125;
  return strMap;
&#125;

objToStrMap(&#123;yes: true, no: false&#125;)
// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;
</code></pre>
<p><strong>（5）Map 转为 JSON</strong></p>
<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<pre><code class="javascript">function strMapToJson(strMap) &#123;
  return JSON.stringify(strMapToObj(strMap));
&#125;

let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);
strMapToJson(myMap)
// &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39;
</code></pre>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>
<pre><code class="javascript">function mapToArrayJson(map) &#123;
  return JSON.stringify([...map]);
&#125;

let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
mapToArrayJson(myMap)
// &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;
</code></pre>
<p><strong>（6）JSON 转为 Map</strong></p>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<pre><code class="javascript">function jsonToStrMap(jsonStr) &#123;
  return objToStrMap(JSON.parse(jsonStr));
&#125;

jsonToStrMap(&#39;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#39;)
// Map &#123;&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false&#125;
</code></pre>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<pre><code class="javascript">function jsonToMap(jsonStr) &#123;
  return new Map(JSON.parse(jsonStr));
&#125;

jsonToMap(&#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;)
// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]&#125;
</code></pre>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = &#123;foo: 1&#125;;
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
wm2.get(k2) // &quot;bar&quot;
</code></pre>
<p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>
<p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>
<pre><code class="javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre>
<p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p>
<p>不过，现在有一个<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-symbols-as-weakmap-keys">提案</a>，允许 Symbol 值也可以作为 WeakMap 的键名。一旦纳入标准，就意味着键名存在两种可能：对象和 Symbol 值。</p>
<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<pre><code class="javascript">const e1 = document.getElementById(&#39;foo&#39;);
const e2 = document.getElementById(&#39;bar&#39;);
const arr = [
  [e1, &#39;foo 元素&#39;],
  [e2, &#39;bar 元素&#39;],
];
</code></pre>
<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>
<pre><code class="javascript">// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
</code></pre>
<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<pre><code class="javascript">const wm = new WeakMap();

const element = document.getElementById(&#39;example&#39;);

wm.set(element, &#39;some information&#39;);
wm.get(element) // &quot;some information&quot;
</code></pre>
<p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。</p>
<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<pre><code class="javascript">const wm = new WeakMap();
let key = &#123;&#125;;
let obj = &#123;foo: 1&#125;;

wm.set(key, obj);
obj = null;
wm.get(key)
// Object &#123;foo: 1&#125;
</code></pre>
<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p>
<h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<pre><code class="javascript">const wm = new WeakMap();

// size、forEach、clear 方法都不存在
wm.size // undefined
wm.forEach // undefined
wm.clear // undefined
</code></pre>
<h3 id="WeakMap-的示例"><a href="#WeakMap-的示例" class="headerlink" title="WeakMap 的示例"></a>WeakMap 的示例</h3><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p>
<p>贺师俊老师<a target="_blank" rel="noopener" href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a target="_blank" rel="noopener" href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925">vtxf</a>补充了下面的例子。</p>
<p>首先，打开 Node 命令行。</p>
<pre><code class="bash">$ node --expose-gc
</code></pre>
<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>
<p>然后，执行下面的代码。</p>
<pre><code class="javascript">// 手动执行一次垃圾回收，保证获取的内存使用状态准确
&gt; global.gc();
undefined

// 查看内存占用的初始状态，heapUsed 为 4M 左右
&gt; process.memoryUsage();
&#123; rss: 21106688,
  heapTotal: 7376896,
  heapUsed: 4153936,
  external: 9059 &#125;

&gt; let wm = new WeakMap();
undefined

// 新建一个变量 key，指向一个 5*1024*1024 的数组
&gt; let key = new Array(5 * 1024 * 1024);
undefined

// 设置 WeakMap 实例的键名，也指向 key 数组
// 这时，key 数组实际被引用了两次，
// 变量 key 引用一次，WeakMap 的键名引用了第二次
// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1
&gt; wm.set(key, 1);
WeakMap &#123;&#125;

&gt; global.gc();
undefined

// 这时内存占用 heapUsed 增加到 45M 了
&gt; process.memoryUsage();
&#123; rss: 67538944,
  heapTotal: 7376896,
  heapUsed: 45782816,
  external: 8945 &#125;

// 清除变量 key 对数组的引用，
// 但没有手动清除 WeakMap 实例的键名对数组的引用
&gt; key = null;
null

// 再次执行垃圾回收
&gt; global.gc();
undefined

// 内存占用 heapUsed 变回 4M 左右，
// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收
&gt; process.memoryUsage();
&#123; rss: 20639744,
  heapTotal: 8425472,
  heapUsed: 3979792,
  external: 8956 &#125;
</code></pre>
<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>
<p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p>
<h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p>
<pre><code class="javascript">let myWeakmap = new WeakMap();

myWeakmap.set(
  document.getElementById(&#39;logo&#39;),
  &#123;timesClicked: 0&#125;)
;

document.getElementById(&#39;logo&#39;).addEventListener(&#39;click&#39;, function() &#123;
  let logoData = myWeakmap.get(document.getElementById(&#39;logo&#39;));
  logoData.timesClicked++;
&#125;, false);
</code></pre>
<p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<pre><code class="javascript">const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown &#123;
  constructor(counter, action) &#123;
    _counter.set(this, counter);
    _action.set(this, action);
  &#125;
  dec() &#123;
    let counter = _counter.get(this);
    if (counter &lt; 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) &#123;
      _action.get(this)();
    &#125;
  &#125;
&#125;

const c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;));

c.dec()
c.dec()
// DONE
</code></pre>
<p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<h2 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h2><p>WeakSet 和 WeakMap 是基于弱引用的数据结构，<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-weakrefs">ES2021</a> 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。</p>
<pre><code class="javascript">let target = &#123;&#125;;
let wr = new WeakRef(target);
</code></pre>
<p>上面示例中，<code>target</code>是原始对象，构造函数<code>WeakRef()</code>创建了一个基于<code>target</code>的新对象<code>wr</code>。这里，<code>wr</code>就是一个 WeakRef 的实例，属于对<code>target</code>的弱引用，垃圾回收机制不会计入这个引用，也就是说，<code>wr</code>的引用不会妨碍原始对象<code>target</code>被垃圾回收机制清除。</p>
<p>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</p>
<pre><code class="javascript">let target = &#123;&#125;;
let wr = new WeakRef(target);

let obj = wr.deref();
if (obj) &#123; // target 未被垃圾回收机制清除
  // ...
&#125;
</code></pre>
<p>上面示例中，<code>deref()</code>方法可以判断原始对象是否已被清除。</p>
<p>弱引用对象的一大用处，就是作为缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。</p>
<pre><code class="javascript">function makeWeakCached(f) &#123;
  const cache = new Map();
  return key =&gt; &#123;
    const ref = cache.get(key);
    if (ref) &#123;
      const cached = ref.deref();
      if (cached !== undefined) return cached;
    &#125;

    const fresh = f(key);
    cache.set(key, new WeakRef(fresh));
    return fresh;
  &#125;;
&#125;

const getImageCached = makeWeakCached(getImage);
</code></pre>
<p>上面示例中，<code>makeWeakCached()</code>用于建立一个缓存，缓存里面保存对原始文件的弱引用。</p>
<p>注意，标准规定，一旦使用<code>WeakRef()</code>创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。</p>
<h2 id="FinalizationRegistry"><a href="#FinalizationRegistry" class="headerlink" title="FinalizationRegistry"></a>FinalizationRegistry</h2><p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-weakrefs#finalizers">ES2021</a> 引入了清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。</p>
<p>首先，新建一个注册表实例。</p>
<pre><code class="javascript">const registry = new FinalizationRegistry(heldValue =&gt; &#123;
  // ....
&#125;);
</code></pre>
<p>上面代码中，<code>FinalizationRegistry()</code>是系统提供的构造函数，返回一个清理器注册表实例，里面登记了所要执行的回调函数。回调函数作为<code>FinalizationRegistry()</code>的参数传入，它本身有一个参数<code>heldValue</code>。</p>
<p>然后，注册表实例的<code>register()</code>方法，用来注册所要观察的目标对象。</p>
<pre><code class="javascript">registry.register(theObject, &quot;some value&quot;);
</code></pre>
<p>上面示例中，<code>theObject</code>就是所要观察的目标对象，一旦该对象被垃圾回收机制清除，注册表就会在清除完成后，调用早前注册的回调函数，并将<code>some value</code>作为参数（前面的<code>heldValue</code>）传入回调函数。</p>
<p>注意，注册表不对目标对象<code>theObject</code>构成强引用，属于弱引用。因为强引用的话，原始对象就不会被垃圾回收机制清除，这就失去使用注册表的意义了。</p>
<p>回调函数的参数<code>heldValue</code>可以是任意类型的值，字符串、数值、布尔值、对象，甚至可以是<code>undefined</code>。</p>
<p>最后，如果以后还想取消已经注册的回调函数，则要向<code>register()</code>传入第三个参数，作为标记值。这个标记值必须是对象，一般都用原始对象。接着，再使用注册表实例对象的<code>unregister()</code>方法取消注册。</p>
<pre><code class="javascript">registry.register(theObject, &quot;some value&quot;, theObject);
// ...其他操作...
registry.unregister(theObject);
</code></pre>
<p>上面代码中，<code>register()</code>方法的第三个参数就是标记值<code>theObject</code>。取消回调函数时，要使用<code>unregister()</code>方法，并将标记值作为该方法的参数。这里<code>register()</code>方法对第三个参数的引用，也属于弱引用。如果没有这个参数，则回调函数无法取消。</p>
<p>由于回调函数被调用以后，就不再存在于注册表之中了，所以执行<code>unregister()</code>应该是在回调函数还没被调用之前。</p>
<p>下面使用<code>FinalizationRegistry</code>，对前一节的缓存函数进行增强。</p>
<pre><code class="javascript">function makeWeakCached(f) &#123;
  const cache = new Map();
  const cleanup = new FinalizationRegistry(key =&gt; &#123;
    const ref = cache.get(key);
    if (ref &amp;&amp; !ref.deref()) cache.delete(key);
  &#125;);

  return key =&gt; &#123;
    const ref = cache.get(key);
    if (ref) &#123;
      const cached = ref.deref();
      if (cached !== undefined) return cached;
    &#125;

    const fresh = f(key);
    cache.set(key, new WeakRef(fresh));
    cleanup.register(fresh, key);
    return fresh;
  &#125;;
&#125;

const getImageCached = makeWeakCached(getImage);
</code></pre>
<p>上面示例与前一节的例子相比，就是增加一个清理器注册表，一旦缓存的原始对象被垃圾回收机制清除，会自动执行一个回调函数。该回调函数会清除缓存里面已经失效的键。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">class Thingy &#123;
  #file;
  #cleanup = file =&gt; &#123;
    console.error(
      `The \`release\` method was never called for the \`Thingy\` for the file &quot;$&#123;file.name&#125;&quot;`
    );
  &#125;;
  #registry = new FinalizationRegistry(this.#cleanup);

  constructor(filename) &#123;
    this.#file = File.open(filename);
    this.#registry.register(this, this.#file, this.#file);
  &#125;

  release() &#123;
    if (this.#file) &#123;
      this.#registry.unregister(this.#file);
      File.close(this.#file);
      this.#file = null;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面示例中，如果由于某种原因，<code>Thingy</code>类的实例对象没有调用<code>release()</code>方法，就被垃圾回收机制清除了，那么清理器就会调用回调函数<code>#cleanup()</code>，输出一条错误信息。</p>
<p>由于无法知道清理器何时会执行，所以最好避免使用它。另外，如果浏览器窗口关闭或者进程意外退出，清理器则不会运行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-7变量的结构赋值" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/7%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/" class="article-date">
  	<time datetime="2022-09-05T02:49:18.789Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/7%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/">
        Es6-变量的解构赋值
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><ol>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">数组的解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">对象的解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">字符串的解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E5%80%BC%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">数值和布尔值的解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">函数参数的解构赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98">圆括号问题</a></li>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/destructuring#%E7%94%A8%E9%80%94">用途</a></li>
</ol>
<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="javascript">let a = 1;
let b = 2;
let c = 3;
</code></pre>
<p>ES6 允许写成下面这样。</p>
<pre><code class="javascript">let [a, b, c] = [1, 2, 3];
</code></pre>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
<pre><code class="javascript">let [foo] = [];
let [bar, foo] = [1];
</code></pre>
<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code class="javascript">let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre>
<p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<pre><code class="javascript">// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = &#123;&#125;;
</code></pre>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<pre><code class="javascript">let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
x // &quot;a&quot;
</code></pre>
<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<pre><code class="javascript">function* fibs() &#123;
  let a = 0;
  let b = 1;
  while (true) &#123;
    yield a;
    [a, b] = [b, a + b];
  &#125;
&#125;

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre>
<p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。</p>
<pre><code class="javascript">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre>
<p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p>
<pre><code class="javascript">let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre>
<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<pre><code class="javascript">function f() &#123;
  console.log(&#39;aaa&#39;);
&#125;

let [x = f()] = [1];
</code></pre>
<p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p>
<pre><code class="javascript">let x;
if ([1][0] === undefined) &#123;
  x = f();
&#125; else &#123;
  x = [1][0];
&#125;
</code></pre>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<pre><code class="javascript">let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
</code></pre>
<p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<pre><code class="javascript">let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="javascript">let &#123; bar, foo &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let &#123; baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // undefined
</code></pre>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>
<p>如果解构失败，变量的值等于<code>undefined</code>。</p>
<pre><code class="javascript">let &#123;foo&#125; = &#123;bar: &#39;baz&#39;&#125;;
foo // undefined
</code></pre>
<p>上面代码中，等号右边的对象没有<code>foo</code>属性，所以变量<code>foo</code>取不到值，所以等于<code>undefined</code>。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<pre><code class="javascript">// 例一
let &#123; log, sin, cos &#125; = Math;

// 例二
const &#123; log &#125; = console;
log(&#39;hello&#39;) // hello
</code></pre>
<p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code class="javascript">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // &quot;aaa&quot;

let obj = &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;
let &#123; first: f, last: l &#125; = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<pre><code class="javascript">let &#123; foo: foo, bar: bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
</code></pre>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code class="javascript">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre>
<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<pre><code class="javascript">let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p: [x, &#123; y &#125;] &#125; = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre>
<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p>
<pre><code class="javascript">let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]
</code></pre>
<p>下面是另一个例子。</p>
<pre><code class="javascript">const node = &#123;
  loc: &#123;
    start: &#123;
      line: 1,
      column: 5
    &#125;
  &#125;
&#125;;

let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;
line // 1
loc  // Object &#123;start: Object&#125;
start // Object &#123;line: 1, column: 5&#125;
</code></pre>
<p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p>
<p>下面是嵌套赋值的例子。</p>
<pre><code class="javascript">let obj = &#123;&#125;;
let arr = [];

(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);

obj // &#123;prop:123&#125;
arr // [true]
</code></pre>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<pre><code class="javascript">// 报错
let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &#39;baz&#39;&#125;;
</code></pre>
<p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p>
<p>注意，对象的解构赋值可以取到继承的属性。</p>
<pre><code class="javascript">const obj1 = &#123;&#125;;
const obj2 = &#123; foo: &#39;bar&#39; &#125;;
Object.setPrototypeOf(obj1, obj2);

const &#123; foo &#125; = obj1;
foo // &quot;bar&quot;
</code></pre>
<p>上面代码中，对象<code>obj1</code>的原型对象是<code>obj2</code>。<code>foo</code>属性不是<code>obj1</code>自身的属性，而是继承自<code>obj2</code>的属性，解构赋值可以取到这个属性。</p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>对象的解构也可以指定默认值。</p>
<pre><code class="javascript">var &#123;x = 3&#125; = &#123;&#125;;
x // 3

var &#123;x, y = 5&#125; = &#123;x: 1&#125;;
x // 1
y // 5

var &#123;x: y = 3&#125; = &#123;&#125;;
y // 3

var &#123;x: y = 3&#125; = &#123;x: 5&#125;;
y // 5

var &#123; message: msg = &#39;Something went wrong&#39; &#125; = &#123;&#125;;
msg // &quot;Something went wrong&quot;
</code></pre>
<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>
<pre><code class="javascript">var &#123;x = 3&#125; = &#123;x: undefined&#125;;
x // 3

var &#123;x = 3&#125; = &#123;x: null&#125;;
x // null
</code></pre>
<p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<pre><code class="javascript">// 错误的写法
let x;
&#123;x&#125; = &#123;x: 1&#125;;
// SyntaxError: syntax error
</code></pre>
<p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<pre><code class="javascript">// 正确的写法
let x;
(&#123;x&#125; = &#123;x: 1&#125;);
</code></pre>
<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<pre><code class="javascript">(&#123;&#125; = [true, false]);
(&#123;&#125; = &#39;abc&#39;);
(&#123;&#125; = []);
</code></pre>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<pre><code class="javascript">let arr = [1, 2, 3];
let &#123;0 : first, [arr.length - 1] : last&#125; = arr;
first // 1
last // 3
</code></pre>
<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。</p>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<pre><code class="javascript">let &#123;length : len&#125; = &#39;hello&#39;;
len // 5
</code></pre>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code class="javascript">let &#123;toString: s&#125; = 123;
s === Number.prototype.toString // true

let &#123;toString: s&#125; = true;
s === Boolean.prototype.toString // true
</code></pre>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code class="javascript">let &#123; prop: x &#125; = undefined; // TypeError
let &#123; prop: y &#125; = null; // TypeError
</code></pre>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p>
<pre><code class="javascript">function add([x, y])&#123;
  return x + y;
&#125;

add([1, 2]); // 3
</code></pre>
<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>
<p>下面是另一个例子。</p>
<pre><code class="javascript">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
// [ 3, 7 ]
</code></pre>
<p>函数参数的解构也可以使用默认值。</p>
<pre><code class="javascript">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, 0]
move(&#123;&#125;); // [0, 0]
move(); // [0, 0]
</code></pre>
<p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<pre><code class="javascript">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, undefined]
move(&#123;&#125;); // [undefined, undefined]
move(); // [0, 0]
</code></pre>
<p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>
<p><code>undefined</code>就会触发函数参数的默认值。</p>
<pre><code class="javascript">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<pre><code class="javascript">// 全部报错
let [(a)] = [1];

let &#123;x: (c)&#125; = &#123;&#125;;
let (&#123;x: c&#125;) = &#123;&#125;;
let &#123;(x: c)&#125; = &#123;&#125;;
let &#123;(x): c&#125; = &#123;&#125;;

let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;
</code></pre>
<p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>
<p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<pre><code class="javascript">// 报错
function f([(z)]) &#123; return z; &#125;
// 报错
function f([z,(x)]) &#123; return x; &#125;
</code></pre>
<p>（3）赋值语句的模式</p>
<pre><code class="javascript">// 全部报错
(&#123; p: a &#125;) = &#123; p: 42 &#125;;
([a]) = [5];
</code></pre>
<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<pre><code class="javascript">// 报错
[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];
</code></pre>
<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<pre><code class="javascript">[(b)] = [3]; // 正确
(&#123; p: (d) &#125; = &#123;&#125;); // 正确
[(parseInt.prop)] = [3]; // 正确
</code></pre>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>变量的解构赋值用途很多。</p>
<p><strong>（1）交换变量的值</strong></p>
<pre><code class="javascript">let x = 1;
let y = 2;

[x, y] = [y, x];
</code></pre>
<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p><strong>（2）从函数返回多个值</strong></p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code class="javascript">// 返回一个数组

function example() &#123;
  return [1, 2, 3];
&#125;
let [a, b, c] = example();

// 返回一个对象

function example() &#123;
  return &#123;
    foo: 1,
    bar: 2
  &#125;;
&#125;
let &#123; foo, bar &#125; = example();
</code></pre>
<p><strong>（3）函数参数的定义</strong></p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code class="javascript">// 参数是一组有次序的值
function f([x, y, z]) &#123; ... &#125;
f([1, 2, 3]);

// 参数是一组无次序的值
function f(&#123;x, y, z&#125;) &#123; ... &#125;
f(&#123;z: 3, y: 2, x: 1&#125;);
</code></pre>
<p><strong>（4）提取 JSON 数据</strong></p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code class="javascript">let jsonData = &#123;
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
&#125;;

let &#123; id, status, data: number &#125; = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre>
<p>上面代码可以快速提取 JSON 数据的值。</p>
<p><strong>（5）函数参数的默认值</strong></p>
<pre><code class="javascript">jQuery.ajax = function (url, &#123;
  async = true,
  beforeSend = function () &#123;&#125;,
  cache = true,
  complete = function () &#123;&#125;,
  crossDomain = false,
  global = true,
  // ... more config
&#125; = &#123;&#125;) &#123;
  // ... do stuff
&#125;;
</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<p><strong>（6）遍历 Map 结构</strong></p>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) &#123;
  console.log(key + &quot; is &quot; + value);
&#125;
// first is hello
// second is world
</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="javascript">// 获取键名
for (let [key] of map) &#123;
  // ...
&#125;

// 获取键值
for (let [,value] of map) &#123;
  // ...
&#125;
</code></pre>
<p><strong>（7）输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code class="javascript">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/6/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>