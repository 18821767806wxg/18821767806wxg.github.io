<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/9/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-33vuex-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/33vuex-2/" class="article-date">
  	<time datetime="2022-08-29T07:31:58.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/33vuex-2/">
        Vue-vuex-2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一.前言<br>　　本文章是vuex系列的最后一篇，主要总结的是如何使用mapState和mapGetters访问vuex中的state和getters。</p>
<p>二.多个模块中mapState和mapGetters的使用<br>　　上一篇文章《Vuex实践（中）》里面我们总结的就是多模块的内容，所以关于store.js、moduleA.js和moduleB.js的代码保持不变。</p>
<p>　　在此为了方便观看，我将这三个文件的代码在贴在这里</p>
<p>E:\MyStudy\test\VueDemo\src\vuex\store.js</p>
<p> 1 import Vue from ‘vue’<br> 2 import Vuex from ‘vuex’<br> 3 import moduleA from ‘./moduleA’<br> 4 import moduleB from ‘./moduleB’<br> 5<br> 6 Vue.use(Vuex)<br> 7<br> 8 export default new Vuex.Store({<br> 9     state: {<br>10         counter: 1000<br>11     },<br>12     mutations: {<br>13         //递增<br>14         increase(state) {<br>15             console.log(“store-increase”)<br>16             state.counter++<br>17         },<br>18         //递减<br>19         decrement(state) {<br>20             state.counter–<br>21         }<br>22     },<br>23     actions: {<br>24         increaseAction(context) {<br>25             setTimeout(function(){<br>26                 //action通过提交mutation改变共享数据状态<br>27                 context.commit(‘increase’);<br>28             },3000)<br>29         },<br>30         decrementAction(context){<br>31             setTimeout(function(){<br>32                 //action通过提交mutation改变共享数据状态<br>33                 context.commit(‘decrement’);<br>34             },3000)<br>35         }<br>36     },<br>37     getters: {<br>38         doubleCounter(state) {<br>39             return state.counter*state.counter<br>40         }<br>41     },<br>42     modules: {<br>43         a: moduleA,<br>44         b: moduleB<br>45     }<br>46 })</p>
<p>E:\MyStudy\test\VueDemo\src\vuex\moduleA.js</p>
<p>const moduleA = {<br>    namespaced: true,<br>    state:{<br>        counter: 100<br>    },<br>    mutations: {<br>        //递增<br>        increase(state) {<br>            console.log(“moduleA-increase”)<br>            state.counter++<br>        },<br>        //递减<br>        decrement(state) {<br>            state.counter–<br>        }<br>    },<br>    actions: {<br>        increaseAction(context) {<br>            setTimeout(function(){<br>                //action通过提交mutation改变共享数据状态<br>                context.commit(‘increase’);<br>            },3000)<br>        },<br>        decrementAction(context){<br>            setTimeout(function(){<br>                //action通过提交mutation改变共享数据状态<br>                context.commit(‘decrement’);<br>            },3000)<br>        }<br>    },<br>    getters: {<br>        doubleCounter(state) {<br>            return state.counter*state.counter<br>        }<br>    }<br>}</p>
<p>export default moduleA</p>
<p>E:\MyStudy\test\VueDemo\src\vuex\moduleB.js</p>
<p> 1 const moduleB = {<br> 2     namespaced: true,<br> 3     state:{<br> 4         counter: 5<br> 5     },<br> 6     mutations: {<br> 7         //递增<br> 8         increase(state) {<br> 9             console.log(“moduleB-increase”)<br>10             state.counter++<br>11         },<br>12         //递减<br>13         decrementAction(state) {<br>14             state.counter–<br>15         }<br>16     },<br>17     actions: {<br>18         increaseAction(context) {<br>19             setTimeout(function(){<br>20                 //action通过提交mutation改变共享数据状态<br>21                 context.commit(‘increase’);<br>22             },3000)<br>23         },<br>24         decrementAction(context){<br>25             setTimeout(function(){<br>26                 //action通过提交mutation改变共享数据状态<br>27                 context.commit(‘decrement’);<br>28             },3000)<br>29         }<br>30     },<br>31     getters: {<br>32         doubleCounter(state){<br>33             return state.counter*state.counter<br>34         }<br>35     }<br>36 }<br>37<br>38 export default moduleB</p>
<p>　　现在需要在组件中使用mapState和mapGetters</p>
<p>　　还是按照之前的套路</p>
<p>　　在App.vue组件中访问根根模块store和a模块moduleA的state和getters。</p>
<p>　　在Index.vue组件中访问b模块moduleB的state和getters</p>
<p>1.使用mapState</p>
<p>　　使用mapState访问state的写法也有多种，我们一个一个来实践（不包含es6的写法）</p>
<p>　　[第一种写法]</p>
<p>E:\MyStudy\test\VueDemo\src\App.vue　　</p>
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <!-- 获取共享数据 -->
    <h1>这里是App组件</h1>
    <h3> App组件获取共享数据 </h3>
    <h3>使用mapState访问根组件counter : </h3>
    <h3>使用mapState访问a组件counter : </h3>
    <hr/>
    <Index></Index>
  </div>
</template>

<script>
import Index  from './components/Index'
import { mapState } from 'vuex'
export default {
  name: 'App',
  components: { Index },
  computed: mapState({
    //访问store根模块
    counter: function(state){
      return state.counter
    },
    //访问a模块
    counterA: function(state){
      return state.a.counter
    }
  })
}
</script>

<style>
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>




<p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p>
<template>
    <div>  
        <h1>这里是Index.vue组件</h1>
        <h3>Index组件获取共享数据 </h3>
        <h3>使用mapState访问b模块counter ：</h3>
    </div>
</template>
<script>
import { mapState } from 'vuex'
export default {
    name: 'Index',
    computed: mapState({
        counterB: function(state){
            return state.b.counter
        }
    })
}
</script>




<p>　　在App.vue、Index.vue组件中使用mapState，首先第一步需要引入mapState。</p>
<p>　　接着就是在计算属性computed中使用，以Index.vue中的代码为例</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>computed: mapState({</p>
<pre><code>counterB: function(state)&#123;

     return state.b.counter

&#125;
</code></pre>
<p>})</p>
<p> 　   可以看到mapState关联到vue的计算属性中。</p>
<p>　　获取b模块的state，只需要以vue计算属性的形式在函数中返回state.b.counter即可。</p>
<p>　 （获取根模块state返回state.counter；获取a模块state返回state.a.counter）</p>
<p>　　这样在模板中就可以使用计算属性的语法访问state</p>
<p>　　备注：这种方式，当注释掉命名空间的配置后，依然可以正常访问到不同模块的state</p>
<p>　　[第二种写法]</p>
<p>　　第二种写法和第一种有些类似，只是以字符串的形式返回计算属性。</p>
<p>　　我们先在Index.vue组件中访问b模块的数据。</p>
<p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p>
<p> 1 <template><br> 2     <div><br> 3         <h1>这里是Index.vue组件</h1><br> 4         <h3>Index组件获取共享数据 </h3><br> 5         <h3>使用mapState访问b模块counter ：</h3><br> 6     </div><br> 7 </template><br> 8 <script><br> 9 import { mapState } from 'vuex'<br>10 export default {<br>11     name: 'Index',<br>12     computed: mapState('b',{<br>13         counterB: 'counter'<br>14     })<br>15 }<br>16 </script></p>
<p>　　核心代码如下</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>computed: mapState(‘b’,{</p>
<pre><code>counterB: &#39;counter&#39;
</code></pre>
<p>})</p>
<p> 　  可以看到，mapState第一个参数限定了模块名称。</p>
<p>　　接着就是以’counter’字符串的形式返回了b模块的counter值。</p>
<p>　　那么根据之前一系列的总结，可知</p>
<p>　　　　访问根模块的数据，不需要限定第一个参数；</p>
<p>　　　　访问a模块的数据，需要限定第一个参数为a</p>
<p>　　然而，因为访问根模块和访问a模块同在App.vue组件中，那么因为mapState第一个参数限定的问题，我们需要编写两个mapState。</p>
<p>　　现在直接上代码（只把computed中的核心代码贴上）</p>
<p>E:\MyStudy\test\VueDemo\src\App.vue　　</p>
<p>computed: {<br>    …mapState({<br>      //访问store根模块<br>      counter: ‘counter’,<br>    }),<br>    …mapState(‘a’,{<br>      //访问a模块<br>      counterA: ‘counter’<br>    })<br>}</p>
<p>　　可以看到，我写了两个mapState，还是…mapState的形式。</p>
<p>　　…mapState它是ES6中扩展运算符的语法，应用在mapState上，官方文档是这样说的</p>
<p>　　</p>
<p> 　 （</p>
<p>　　　　此处若对此有疑问，可以在去仔细研究一下对象扩展运算符的内容。</p>
<p>　　　　我这里贴一个简单的示例</p>
<p>　　　　</p>
<p> 　　　  最终newObj的打印结果为　　</p>
<p>　　　　相信这个示例可以很清楚的解释我们写的两个…mapState的写法</p>
<p>　　）</p>
<p>　　官方文档处提到这个对象展开运算符的场景是为了将一个组件中原本的计算属性和mapState混合使用</p>
<p>　　（混合使用这个点日常开发会用到，很实用的一个点）。</p>
<p>　　那本次我们也是使用这个语法成功的获取到了不同模块的state。</p>
<p>　　最后我们在使用浏览器查看一下最终App.vue和Index.vue中的结果</p>
<p>　　</p>
<p>　　我们已经使用mapState成功的访问到了多模块中的state数据。</p>
<p>　</p>
<p>　　备注：这种关于mapState的写法不能删除moduleA和moduleB中关于命令空间的配置，否则会报错。</p>
<p>　　最后作者还尝试了一个问题，就是将moduleA.js中的state属性改为counterA</p>
<p>　　</p>
<p>　　然后修改了App.vue组件中computed访问a模块数据的代码</p>
<p>　　</p>
<p>　　最后发现这样并不能正常访问到a模块的state数据。（删除a模块的命名空间配置也无法正常访问）</p>
<p>　　这个尝试仅给大家一个反面的示例。</p>
<p>2.使用mapGetters</p>
<p>　　前面使用mapState访问了state数据，那么现在我们使用mapGetters访问一下vuex中的getters。</p>
<p>　　在研究之后发现，暂时发现使用mapGetters访问一下vuex中的getters只有字符串的形式。</p>
<p>E:\MyStudy\test\VueDemo\src\App.vue</p>
<p> 1 <template><br> 2   <div id="app"><br> 3     <img src="./assets/logo.png"><br> 4     <!-- 获取共享数据 --><br> 5     <h1>这里是App组件</h1><br> 6     <h3> App组件获取共享数据 </h3><br> 7     <h3>使用mapState访问根组件counter : </h3><br> 8     <h3>使用mapState访问a组件counter : </h3><br> 9     <h3>使用mapGetters访问根组件doubleCounter : </h3><br>10     <h3>使用mapGetters访问a组件doubleCounter : </h3><br>11     <hr/><br>12     <Index></Index><br>13   </div><br>14 </template><br>15<br>16 <script><br>17 import Index  from './components/Index'<br>18 import { mapState,mapGetters } from 'vuex'<br>19 export default {<br>20   name: 'App',<br>21   components: { Index },<br>22   computed: {<br>23     ...mapState({<br>24       //访问store根模块<br>25       counter: 'counter',<br>26     }),<br>27     ...mapState('a',{<br>28       //访问a模块<br>29       counterA: 'counter'<br>30     }),<br>31     ...mapGetters({<br>32       //访问store根模块<br>33       doubleCounter: 'doubleCounter'<br>34     }),<br>35     ...mapGetters('a',{<br>36       //访问store根模块<br>37       doubleCounterA: 'doubleCounter'<br>38     })<br>39<br>40   }<br>41<br>42 }<br>43 </script><br>44<br>45 <style><br>46 #app {<br>47   font-family: ‘Avenir’, Helvetica, Arial, sans-serif;<br>48   -webkit-font-smoothing: antialiased;<br>49   -moz-osx-font-smoothing: grayscale;<br>50   text-align: center;<br>51   color: #2c3e50;<br>52   margin-top: 60px;<br>53 }<br>54 </style></p>
<p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p>
<p> 1 <strong><strong><template><br> 2     <div><br> 3         <h1>这里是Index.vue组件</h1><br> 4         <h3>Index组件获取共享数据 </h3><br> 5         <h3>使用mapState访问b模块counter ：</h3><br> 6         <h3>使用mapGetters访问b组件doubleCounter : </h3><br> 7     </div><br> 8 </template></strong><br> 9 <script><br>10 import { mapState,mapGetters } from 'vuex'<br>11 export default {<br>12     name: 'Index',<br>13     computed: {<br>14         ...mapState('b',{<br>15             counterB: 'counter'<br>16          }),<br>17         ...mapGetters('b',{<br>18             doubleCounterB: 'doubleCounter'<br>19         }),<br>20     }<br>21 }<br>22 </script></strong></p>
<p>　　浏览器查看结果</p>
<p>　　</p>
<p>三.总结</p>
<p>　　在最后呢，再补充一点，不管是mapState和mapGetters，我们给传入的都是一个字典。</p>
<p>　　简单一些的，假如我们的state和getters不重名，我们可以给mapState和mapGetters传入一个数组</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-31自定义属性props" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/31%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7props/" class="article-date">
  	<time datetime="2022-08-29T07:31:26.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/31%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7props/">
        Vue-自定义属性props
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、属性"><a href="#一、属性" class="headerlink" title="一、属性"></a>一、属性</h3><h4 id="1-自定义属性props"><a href="#1-自定义属性props" class="headerlink" title="1. 自定义属性props"></a>1. 自定义属性props</h4><p>prop 定义了这个组件有哪些可配置的属性，组件的核心功能也都是它来确定的。写通用组件时，props 最好用对象的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，这点在组件开发中很重要，然而很多人却忽视，直接使用 props 的数组用法，这样的组件往往是不严谨的。</p>
<pre><code>// 父组件 
&lt;props 
name=&#39;属性&#39;          
:type=&#39;type&#39;         
:is-visible=&quot;false&quot;          
:on-change=&quot;handlePropChange&quot;          
:list=[22,33,44]          
title=&quot;属性Demo&quot;          
class=&quot;test1&quot;          
:class=&quot;[&#39;test2&#39;]&quot;           
:style=&quot;&#123; marginTop: &#39;20px&#39; &#125;&quot; //注意:style 的优先级是要高于style  style=&quot;margin-top: 10px&quot;&gt;  
&lt;/props&gt;
// 子组件  
props: &#123; 
    name: String,    
    type: &#123;//从父级传入的 type，它的值必须是指定的 &#39;success&#39;, &#39;warning&#39;,&#39;danger&#39;中的一个，如果传入这三个以外的值，都会抛出一条警告         validator: (value) =&gt; &#123;        
        return [&#39;success&#39;, &#39;warning&#39;,&#39;danger&#39;].includes(value) 
      &#125;   
    &#125;,    
    onChange: &#123;//对于接收的数据，可以是各种数据类型，同样也可以传递一个函数 
          type: Function,    
          default: () =&gt; &#123; &#125;    
    &#125;,   
    isVisible: &#123;      type: Boolean,      default: false    &#125;,     list: &#123;  type: Array, // 对象或数组默认值必须从一个工厂函数获取             default: () =&gt; []   
    &#125;  
&#125;
</code></pre>
<p>从上面的例中，可以得出props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，<strong>同样也可以传递一个函数。通过一般属性实现父向子通信；通过函数属性实现子向父通信</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-30 vue-router" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/30%20vue-router/" class="article-date">
  	<time datetime="2022-08-29T07:31:10.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/30%20vue-router/">
        Vue-vue-router
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>Vue Router 是 <a target="_blank" rel="noopener" href="http://cn.vuejs.org/">Vue.js</a> 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：</p>
<pre><code class="js">const User = &#123;
  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;
&#125;

const router = new VueRouter(&#123;
  routes: [
    // 动态路径参数 以冒号开头
    &#123; path: &#39;/user/:id&#39;, component: User &#125;
  ]
&#125;)
</code></pre>
<p>现在呢，像 <code>/user/foo</code> 和 <code>/user/bar</code> 都将映射到相同的路由。</p>
<p>一个“路径参数”使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 ID：</p>
<pre><code class="js">const User = &#123;
  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-29 vuecli" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/29%20vuecli/" class="article-date">
  	<time datetime="2022-08-29T07:30:54.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/29%20vuecli/">
        Vue-vue/cli
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue/cli"></a>vue/cli</h1><h2 id="全局-CLI-配置"><a href="#全局-CLI-配置" class="headerlink" title="全局 CLI 配置"></a>全局 CLI 配置</h2><p>有些针对 <code>@vue/cli</code> 的全局配置，例如你惯用的包管理器和你本地保存的 preset，都保存在 home 目录下一个名叫 <code>.vuerc</code> 的 JSON 文件。你可以用编辑器直接编辑这个文件来更改已保存的选项。</p>
<p>你也可以使用 <code>vue config</code> 命令来审查或修改全局的 CLI 配置。</p>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。你也可以使用 <code>package.json</code> 中的 <code>vue</code> 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p>
<p>这个文件应该导出一个包含了选项的对象：</p>
<pre><code class="js">// vue.config.js
module.exports = &#123;
  // 选项...
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-28 单文件组件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/28%20%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/" class="article-date">
  	<time datetime="2022-08-29T07:30:38.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/28%20%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/">
        Vue-单文件组件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><p>在很多 Vue 项目中，我们使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue(&#123; el: &#39;#container &#39;&#125;)</code> 在每个页面内指定一个容器元素。</p>
<p>这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：</p>
<ul>
<li><strong>全局定义 (Global definitions)</strong> 强制要求每个 component 中的命名不得重复</li>
<li><strong>字符串模板 (String templates)</strong> 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\</code></li>
<li><strong>不支持 CSS (No CSS support)</strong> 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>
<li><strong>没有构建步骤 (No build step)</strong> 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li>
</ul>
<p>文件扩展名为 <code>.vue</code> 的 <strong>single-file components(单文件组件)</strong> 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。</p>
<p>这是一个文件名为 <code>Hello.vue</code> 的简单实例：</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/chrisvfritz/e2b6a6110e0829d78fa4aedf7cf6b235"><img src="https://cn.vuejs.org/images/vue-component.png" alt="单文件组件的示例 (点击查看文本版的代码)"></a></p>
<p>现在我们获得：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#source-code-editing">完整语法高亮</a></li>
<li><a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/modules/#what-is-a-webpack-module">CommonJS 模块</a></li>
<li><a target="_blank" rel="noopener" href="https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html">组件作用域的 CSS</a></li>
</ul>
<p>正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Pug，Babel (with ES2015 modules)，和 Stylus。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587"><img src="https://cn.vuejs.org/images/vue-component-with-preprocessors.png" alt="带预处理器的单文件组件的示例 (点击查看文本版的代码)"></a></p>
<p>这些特定的语言只是例子，你可以只是简单地使用 Babel，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。如果搭配 <code>vue-loader</code> 使用 webpack，它也能为 CSS Modules 提供头等支持。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-27 过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/27%20%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  	<time datetime="2022-08-29T07:30:12.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/27%20%E8%BF%87%E6%BB%A4%E5%99%A8/">
        Vue-过滤器
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>过滤器</p>
<p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p>
<pre><code class="html">&lt;!-- 在双花括号中 --&gt;
&lt;div&gt;&#123;&#123;myname | myfilter1 | myfilter2&#125;&#125;&lt;/div&gt;

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre>
<p>你可以在一个组件的选项中定义本地的过滤器：</p>
<pre><code class="js">  Vue.filter(&quot;myfilter1&quot;, data =&gt; &#123;
    return data.substring(0, 1)
  &#125;)
  Vue.filter(&quot;myfilter2&quot;, data =&gt; &#123;
    return data.toUpperCase()
  &#125;)
  Vue.filter(&quot;myimg&quot;, data =&gt; &#123;
    return `https://cube.elemecdn.com/$&#123;data[0]&#125;/$&#123;data.substring(1,3)&#125;/$&#123;data.substring(3,data.length)&#125;.jpeg?x-oss-process=image/format,webp/resize,w_90,h_90,m_fixed`
  &#125;)
</code></pre>
<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;
    if (!value) return &#39;&#39;
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
&#125;)

new Vue(&#123;
    // ...
&#125;)
</code></pre>
<p>当全局过滤器和局部过滤器重名时，会采用局部过滤器</p>
<p>过滤器可以串联：</p>
<pre><code class="html">&#123;&#123; message | filterA | filterB &#125;&#125;
</code></pre>
<p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p>
<p>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<pre><code class="html">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;
</code></pre>
<p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>&#39;arg1&#39;</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-26 指令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/26%20%E6%8C%87%E4%BB%A4/" class="article-date">
  	<time datetime="2022-08-29T07:29:58.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/26%20%E6%8C%87%E4%BB%A4/">
        Vue-自定义指令
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="Vue-directives"><a href="#Vue-directives" class="headerlink" title="Vue.directives"></a>Vue.directives</h2><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：</p>
<p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>
<pre><code class="js">// 注册一个全局自定义指令 `v-focus`
Vue.directive(&#39;focus&#39;, &#123;
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) &#123;
    // 聚焦元素
    el.focus()
  &#125;
&#125;)
</code></pre>
<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<pre><code class="js">directives: &#123;
  focus: &#123;
    // 指令的定义
    inserted: function (el) &#123;
      el.focus()
    &#125;
  &#125;
&#125;
</code></pre>
<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p>
<pre><code class="html">&lt;input v-focus&gt;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-25 生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/25%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  	<time datetime="2022-08-29T07:29:42.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/25%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
        Vue-生命周期
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p>
<h2 id="选项-生命周期钩子"><a href="#选项-生命周期钩子" class="headerlink" title="选项 / 生命周期钩子"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">选项 / 生命周期钩子</a></h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p>
<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeCreate">beforeCreate</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置前被调用。</p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#created">created</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前尚不可用。</p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeMount">beforeMount</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#mounted">mounted</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。 如果根实例挂载到了一个文档内的元素上，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。</p>
<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p>
<pre><code>mounted: function () &#123;
  this.$nextTick(function () &#123;
    // Code that will run only after the
    // entire view has been rendered
  &#125;)
&#125;
</code></pre>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeUpdate">beforeUpdate</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#updated">updated</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p>
<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p>
<pre><code>updated: function () &#123;
  this.$nextTick(function () &#123;
    // Code that will run only after the
    // entire view has been re-rendered
  &#125;)
&#125;
</code></pre>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#activated">activated</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件激活时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">构建组件 - keep-alive</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive">动态组件 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#deactivated">deactivated</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件停用时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">构建组件 - keep-alive</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive">动态组件 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeDestroy">beforeDestroy</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#destroyed">destroyed</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#errorCaptured">errorCaptured</a></h3><blockquote>
<p>2.5.0+ 新增</p>
</blockquote>
<ul>
<li><p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
<p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>
<p><strong>错误传播规则</strong></p>
<ul>
<li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li>
<li>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li>
<li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</li>
<li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-24 过渡效果" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/24%20%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/" class="article-date">
  	<time datetime="2022-08-29T07:29:24.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/24%20%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/">
        Vue-过渡效果
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开 &amp; 列表过渡"></a>进入/离开 &amp; 列表过渡</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>
<ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ul>
<h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>这里是一个典型的例子：</p>
<pre><code class="html">&lt;div id=&quot;demo&quot;&gt;
    &lt;button v-on:click=&quot;show = !show&quot;&gt;
        Toggle
    &lt;/button&gt;
    &lt;transition name=&quot;fade&quot;&gt;
        &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
    &lt;/transition&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
  el: &#39;#demo&#39;,
  data: &#123;
    show: true
  &#125;
&#125;)
.fade-enter-active, .fade-leave-active &#123;
  transition: opacity .5s;
&#125;
.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;
  opacity: 0;
&#125;
</code></pre>
<p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p>
<ol>
<li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li>
<li>如果过渡组件提供了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90">JavaScript 钩子函数</a>，这些钩子函数将在恰当的时机被调用。</li>
<li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 <code>nextTick</code> 概念不同)</li>
</ol>
<h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>: <strong>2.1.8版及以上</strong> 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>: <strong>2.1.8版及以上</strong> 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<p><img src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"></p>
<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>，则 `v-` 是这些类名的默认前缀。如果你使用了 </code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。</p>
<h3 id="初始化渲染页面时过渡"><a href="#初始化渲染页面时过渡" class="headerlink" title="初始化渲染页面时过渡"></a>初始化渲染页面时过渡</h3><p>需要利用apper属性</p>
<pre><code class="html">&lt;transition name=&#39;retr0&#39; appear&gt;
    &lt;div v-if=&#39;isshow&#39; style=&#39;background:red;&#39;&gt;
        show
    &lt;/div&gt;
&lt;/transition&gt;
</code></pre>
<h3 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h3><p>我们可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code> (2.1.8+)</li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code> (2.1.8+)</li>
</ul>
<pre><code class="html">&lt;transition enter-active-class=&#39;animated bounceInRight&#39; leave-active-class=&#39;animated bounceOutRight&#39; appear&gt;
    &lt;div v-if=&#39;isshow&#39;&gt;动画&lt;/div&gt;
&lt;/transition&gt;
</code></pre>
<h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><ul>
<li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li>
<li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</li>
</ul>
<pre><code class="html">&lt;transition enter-active-class=&#39;animated bounceInRight&#39; leave-active-class=&#39;animated bounceOutRight&#39; appear mode-&#39;out-in&#39;&gt;
    &lt;div v-if=&#39;isshow&#39;&gt;动画一&lt;/div&gt;
    &lt;div v-else&gt;动画一&lt;/div&gt;
&lt;/transition&gt;
</code></pre>
<h2 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h2><p>多个组件的过渡简单很多 - 我们不需要使用 <code>key</code> attribute。相反，我们只需要使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a>：</p>
<pre><code class="html">&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;
  &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/transition&gt;
</code></pre>
<pre><code class="css">.component-fade-enter-active, .component-fade-leave-active &#123;
  transition: opacity .3s ease;
&#125;
.component-fade-enter, .component-fade-leave-to
/* .component-fade-leave-active for below version 2.1.8 */ &#123;
  opacity: 0;
&#125;
</code></pre>
<pre><code class="js">
new Vue(&#123;
  el: &#39;#transition-components-demo&#39;,
  data: &#123;
    view: &#39;v-a&#39;
  &#125;,
  components: &#123;
    &#39;v-a&#39;: &#123;
      template: &#39;&lt;div&gt;Component A&lt;/div&gt;&#39;
    &#125;,
    &#39;v-b&#39;: &#123;
      template: &#39;&lt;div&gt;Component B&lt;/div&gt;&#39;
    &#125;
  &#125;
&#125;)
</code></pre>
<h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>目前为止，关于过渡我们已经讲到：</p>
<ul>
<li>单个节点</li>
<li>同一时间渲染多个节点中的一个</li>
</ul>
<p>那么怎么同时渲染整个列表，比如使用 <code>v-for</code> ？在这种场景中，使用 `` 组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p>
<ul>
<li>不同于 <code>，它会以一个真实元素呈现：默认为一个 </code>。你也可以通过 <code>tag</code> attribute 更换为其他元素。</li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E6%A8%A1%E5%BC%8F">过渡模式</a>不可用，因为我们不再相互切换特有的元素。</li>
<li>内部元素 <strong>总是需要</strong> 提供唯一的 <code>key</code> 属性值。</li>
<li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。</li>
</ul>
<h3 id="列表的进入-离开过渡"><a href="#列表的进入-离开过渡" class="headerlink" title="列表的进入/离开过渡"></a>列表的进入/离开过渡</h3><p>现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。</p>
<pre><code class="html">&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt;
    &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;
    &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;
    &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;
        &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;
            &#123;&#123; item &#125;&#125;
        &lt;/span&gt;
    &lt;/transition-group&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el: &#39;#list-demo&#39;,
    data: &#123;
        items: [1,2,3,4,5,6,7,8,9],
        nextNum: 10
    &#125;,
    methods: &#123;
        randomIndex: function () &#123;
            return Math.floor(Math.random() * this.items.length)
        &#125;,
        add: function () &#123;
            this.items.splice(this.randomIndex(), 0, this.nextNum++)
        &#125;,
        remove: function () &#123;
            this.items.splice(this.randomIndex(), 1)
        &#125;,
    &#125;
&#125;)
</code></pre>
<h2 id="可复用的过渡"><a href="#可复用的过渡" class="headerlink" title="可复用的过渡"></a>可复用的过渡</h2><p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>或者</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p>
<p>使用 template 的简单例子：</p>
<pre><code class="js">Vue.component(&#39;my-special-transition&#39;, &#123;
  template: &#39;\
    &lt;transition\
      name=&quot;very-special-transition&quot;\
      mode=&quot;out-in&quot;\
      v-on:before-enter=&quot;beforeEnter&quot;\
      v-on:after-enter=&quot;afterEnter&quot;\
    &gt;\
      &lt;slot&gt;&lt;/slot&gt;\
    &lt;/transition&gt;\
  &#39;,
  methods: &#123;
    beforeEnter: function (el) &#123;
      // ...
    &#125;,
    afterEnter: function (el) &#123;
      // ...
    &#125;
  &#125;
&#125;)
</code></pre>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6">函数式组件</a>更适合完成这个任务：</p>
<pre><code class="js">Vue.component(&#39;my-special-transition&#39;, &#123;
  functional: true,
  render: function (createElement, context) &#123;
    var data = &#123;
      props: &#123;
        name: &#39;very-special-transition&#39;,
        mode: &#39;out-in&#39;
      &#125;,
      on: &#123;
        beforeEnter: function (el) &#123;
          // ...
        &#125;,
        afterEnter: function (el) &#123;
          // ...
        &#125;
      &#125;
    &#125;
    return createElement(&#39;transition&#39;, data, context.children)
  &#125;
&#125;)
</code></pre>
<p>第三方过渡动画库</p>
<pre><code class="shell">npm istall animate.css --save 下载依赖包
</code></pre>
<pre><code class="js">import &#39;animate.css&#39;; 引入
</code></pre>
<p><a target="_blank" rel="noopener" href="https://animate.style/">https://animate.style/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/10/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>