<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/9/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-34vue检测数据的原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/34vue%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86/" class="article-date">
  	<time datetime="2022-08-29T07:32:18.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/34vue%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86/">
        Vue-Vue监视数据的原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.&lt;!–</p>
<p>​      Vue监视数据的原理：</p>
<p>​        \1. vue会监视data中所有层次的数据。</p>
<p>​        \2. 如何监测对象中的数据？</p>
<p>​                通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<p>​                  (1).对象中后追加的属性，Vue默认不做响应式处理</p>
<p>​                  (2).如需给后添加的属性做响应式，请使用如下API：</p>
<p>​                          Vue.set(target，propertyName/index，value) 或 </p>
<p>​                          vm.$set(target，propertyName/index，value)</p>
<p>​        \3. 如何监测数组中的数据？</p>
<p>​                  通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<p>​                    (1).调用原生对应的方法对数组进行更新。</p>
<p>​                    (2).重新解析模板，进而更新页面。</p>
<p>​        4.在Vue修改数组中的某个元素一定要用如下方法：</p>
<p>​              1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p>
<p>​              2.Vue.set() 或 vm.$set()</p>
<p>​        特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p>
<p>​    –&gt;</p>
<ol start="2">
<li><pre><code class="javascript">2.  &lt;!-- 准备好一个容器--&gt;

        &lt;div id=&quot;root&quot;&gt;

​      &lt;h1&gt;学生信息&lt;/h1&gt;

​      &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;student.sex = &#39;未知&#39; &quot;&gt;修改性别&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt;

​      &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt;

​      &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;/h3&gt;

​      &lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;/h3&gt;

​      &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;

​      &lt;h3&gt;爱好：&lt;/h3&gt;

​      &lt;ul&gt;

​        &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;

​          &#123;&#123;h&#125;&#125;

​        &lt;/li&gt;

​      &lt;/ul&gt;

​      &lt;h3&gt;朋友们：&lt;/h3&gt;

​      &lt;ul&gt;

​        &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;

​          &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;

​        &lt;/li&gt;

​      &lt;/ul&gt;

​    &lt;/div&gt;
</code></pre>
</li>
</ol>
<p>3.</p>
<pre><code class="js">

&lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。



        const vm = new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                student:&#123;
                    name:&#39;tom&#39;,
                    age:18,
                    hobby:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],
                    friends:[
                        &#123;name:&#39;jerry&#39;,age:35&#125;,
                        &#123;name:&#39;tony&#39;,age:36&#125;
                    ]
                &#125;
            &#125;,
            methods: &#123;
                addSex()&#123;
                    // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
                    this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
                &#125;,
                addFriend()&#123;
                    this.student.friends.unshift(&#123;name:&#39;jack&#39;,age:70&#125;)
                &#125;,
                updateFirstFriendName()&#123;
                    this.student.friends[0].name = &#39;张三&#39;
                &#125;,
                addHobby()&#123;
                    this.student.hobby.push(&#39;学习&#39;)
                &#125;,
                updateHobby()&#123;
                    // this.student.hobby.splice(0,1,&#39;开车&#39;)
                    // Vue.set(this.student.hobby,0,&#39;开车&#39;)
                    this.$set(this.student.hobby,0,&#39;开车&#39;)
                &#125;,
                removeSmoke()&#123;
                    this.student.hobby = this.student.hobby.filter((h)=&gt;&#123;
                        return h !== &#39;抽烟&#39;
                    &#125;)
                &#125;
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-33vuex-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/33vuex-2/" class="article-date">
  	<time datetime="2022-08-29T07:31:58.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/33vuex-2/">
        Vue-vuex-2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一.前言<br>　　本文章是vuex系列的最后一篇，主要总结的是如何使用mapState和mapGetters访问vuex中的state和getters。</p>
<p>二.多个模块中mapState和mapGetters的使用<br>　　上一篇文章《Vuex实践（中）》里面我们总结的就是多模块的内容，所以关于store.js、moduleA.js和moduleB.js的代码保持不变。</p>
<p>　　在此为了方便观看，我将这三个文件的代码在贴在这里</p>
<p>E:\MyStudy\test\VueDemo\src\vuex\store.js</p>
<p> 1 import Vue from ‘vue’<br> 2 import Vuex from ‘vuex’<br> 3 import moduleA from ‘./moduleA’<br> 4 import moduleB from ‘./moduleB’<br> 5<br> 6 Vue.use(Vuex)<br> 7<br> 8 export default new Vuex.Store({<br> 9     state: {<br>10         counter: 1000<br>11     },<br>12     mutations: {<br>13         //递增<br>14         increase(state) {<br>15             console.log(“store-increase”)<br>16             state.counter++<br>17         },<br>18         //递减<br>19         decrement(state) {<br>20             state.counter–<br>21         }<br>22     },<br>23     actions: {<br>24         increaseAction(context) {<br>25             setTimeout(function(){<br>26                 //action通过提交mutation改变共享数据状态<br>27                 context.commit(‘increase’);<br>28             },3000)<br>29         },<br>30         decrementAction(context){<br>31             setTimeout(function(){<br>32                 //action通过提交mutation改变共享数据状态<br>33                 context.commit(‘decrement’);<br>34             },3000)<br>35         }<br>36     },<br>37     getters: {<br>38         doubleCounter(state) {<br>39             return state.counter*state.counter<br>40         }<br>41     },<br>42     modules: {<br>43         a: moduleA,<br>44         b: moduleB<br>45     }<br>46 })</p>
<p>E:\MyStudy\test\VueDemo\src\vuex\moduleA.js</p>
<p>const moduleA = {<br>    namespaced: true,<br>    state:{<br>        counter: 100<br>    },<br>    mutations: {<br>        //递增<br>        increase(state) {<br>            console.log(“moduleA-increase”)<br>            state.counter++<br>        },<br>        //递减<br>        decrement(state) {<br>            state.counter–<br>        }<br>    },<br>    actions: {<br>        increaseAction(context) {<br>            setTimeout(function(){<br>                //action通过提交mutation改变共享数据状态<br>                context.commit(‘increase’);<br>            },3000)<br>        },<br>        decrementAction(context){<br>            setTimeout(function(){<br>                //action通过提交mutation改变共享数据状态<br>                context.commit(‘decrement’);<br>            },3000)<br>        }<br>    },<br>    getters: {<br>        doubleCounter(state) {<br>            return state.counter*state.counter<br>        }<br>    }<br>}</p>
<p>export default moduleA</p>
<p>E:\MyStudy\test\VueDemo\src\vuex\moduleB.js</p>
<p> 1 const moduleB = {<br> 2     namespaced: true,<br> 3     state:{<br> 4         counter: 5<br> 5     },<br> 6     mutations: {<br> 7         //递增<br> 8         increase(state) {<br> 9             console.log(“moduleB-increase”)<br>10             state.counter++<br>11         },<br>12         //递减<br>13         decrementAction(state) {<br>14             state.counter–<br>15         }<br>16     },<br>17     actions: {<br>18         increaseAction(context) {<br>19             setTimeout(function(){<br>20                 //action通过提交mutation改变共享数据状态<br>21                 context.commit(‘increase’);<br>22             },3000)<br>23         },<br>24         decrementAction(context){<br>25             setTimeout(function(){<br>26                 //action通过提交mutation改变共享数据状态<br>27                 context.commit(‘decrement’);<br>28             },3000)<br>29         }<br>30     },<br>31     getters: {<br>32         doubleCounter(state){<br>33             return state.counter*state.counter<br>34         }<br>35     }<br>36 }<br>37<br>38 export default moduleB</p>
<p>　　现在需要在组件中使用mapState和mapGetters</p>
<p>　　还是按照之前的套路</p>
<p>　　在App.vue组件中访问根根模块store和a模块moduleA的state和getters。</p>
<p>　　在Index.vue组件中访问b模块moduleB的state和getters</p>
<p>1.使用mapState</p>
<p>　　使用mapState访问state的写法也有多种，我们一个一个来实践（不包含es6的写法）</p>
<p>　　[第一种写法]</p>
<p>E:\MyStudy\test\VueDemo\src\App.vue　　</p>
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <!-- 获取共享数据 -->
    <h1>这里是App组件</h1>
    <h3> App组件获取共享数据 </h3>
    <h3>使用mapState访问根组件counter : </h3>
    <h3>使用mapState访问a组件counter : </h3>
    <hr/>
    <Index></Index>
  </div>
</template>

<script>
import Index  from './components/Index'
import { mapState } from 'vuex'
export default {
  name: 'App',
  components: { Index },
  computed: mapState({
    //访问store根模块
    counter: function(state){
      return state.counter
    },
    //访问a模块
    counterA: function(state){
      return state.a.counter
    }
  })
}
</script>

<style>
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>




<p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p>
<template>
    <div>  
        <h1>这里是Index.vue组件</h1>
        <h3>Index组件获取共享数据 </h3>
        <h3>使用mapState访问b模块counter ：</h3>
    </div>
</template>
<script>
import { mapState } from 'vuex'
export default {
    name: 'Index',
    computed: mapState({
        counterB: function(state){
            return state.b.counter
        }
    })
}
</script>




<p>　　在App.vue、Index.vue组件中使用mapState，首先第一步需要引入mapState。</p>
<p>　　接着就是在计算属性computed中使用，以Index.vue中的代码为例</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>computed: mapState({</p>
<pre><code>counterB: function(state)&#123;

     return state.b.counter

&#125;
</code></pre>
<p>})</p>
<p> 　   可以看到mapState关联到vue的计算属性中。</p>
<p>　　获取b模块的state，只需要以vue计算属性的形式在函数中返回state.b.counter即可。</p>
<p>　 （获取根模块state返回state.counter；获取a模块state返回state.a.counter）</p>
<p>　　这样在模板中就可以使用计算属性的语法访问state</p>
<p>　　备注：这种方式，当注释掉命名空间的配置后，依然可以正常访问到不同模块的state</p>
<p>　　[第二种写法]</p>
<p>　　第二种写法和第一种有些类似，只是以字符串的形式返回计算属性。</p>
<p>　　我们先在Index.vue组件中访问b模块的数据。</p>
<p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p>
<p> 1 <template><br> 2     <div><br> 3         <h1>这里是Index.vue组件</h1><br> 4         <h3>Index组件获取共享数据 </h3><br> 5         <h3>使用mapState访问b模块counter ：</h3><br> 6     </div><br> 7 </template><br> 8 <script><br> 9 import { mapState } from 'vuex'<br>10 export default {<br>11     name: 'Index',<br>12     computed: mapState('b',{<br>13         counterB: 'counter'<br>14     })<br>15 }<br>16 </script></p>
<p>　　核心代码如下</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>computed: mapState(‘b’,{</p>
<pre><code>counterB: &#39;counter&#39;
</code></pre>
<p>})</p>
<p> 　  可以看到，mapState第一个参数限定了模块名称。</p>
<p>　　接着就是以’counter’字符串的形式返回了b模块的counter值。</p>
<p>　　那么根据之前一系列的总结，可知</p>
<p>　　　　访问根模块的数据，不需要限定第一个参数；</p>
<p>　　　　访问a模块的数据，需要限定第一个参数为a</p>
<p>　　然而，因为访问根模块和访问a模块同在App.vue组件中，那么因为mapState第一个参数限定的问题，我们需要编写两个mapState。</p>
<p>　　现在直接上代码（只把computed中的核心代码贴上）</p>
<p>E:\MyStudy\test\VueDemo\src\App.vue　　</p>
<p>computed: {<br>    …mapState({<br>      //访问store根模块<br>      counter: ‘counter’,<br>    }),<br>    …mapState(‘a’,{<br>      //访问a模块<br>      counterA: ‘counter’<br>    })<br>}</p>
<p>　　可以看到，我写了两个mapState，还是…mapState的形式。</p>
<p>　　…mapState它是ES6中扩展运算符的语法，应用在mapState上，官方文档是这样说的</p>
<p>　　</p>
<p> 　 （</p>
<p>　　　　此处若对此有疑问，可以在去仔细研究一下对象扩展运算符的内容。</p>
<p>　　　　我这里贴一个简单的示例</p>
<p>　　　　</p>
<p> 　　　  最终newObj的打印结果为　　</p>
<p>　　　　相信这个示例可以很清楚的解释我们写的两个…mapState的写法</p>
<p>　　）</p>
<p>　　官方文档处提到这个对象展开运算符的场景是为了将一个组件中原本的计算属性和mapState混合使用</p>
<p>　　（混合使用这个点日常开发会用到，很实用的一个点）。</p>
<p>　　那本次我们也是使用这个语法成功的获取到了不同模块的state。</p>
<p>　　最后我们在使用浏览器查看一下最终App.vue和Index.vue中的结果</p>
<p>　　</p>
<p>　　我们已经使用mapState成功的访问到了多模块中的state数据。</p>
<p>　</p>
<p>　　备注：这种关于mapState的写法不能删除moduleA和moduleB中关于命令空间的配置，否则会报错。</p>
<p>　　最后作者还尝试了一个问题，就是将moduleA.js中的state属性改为counterA</p>
<p>　　</p>
<p>　　然后修改了App.vue组件中computed访问a模块数据的代码</p>
<p>　　</p>
<p>　　最后发现这样并不能正常访问到a模块的state数据。（删除a模块的命名空间配置也无法正常访问）</p>
<p>　　这个尝试仅给大家一个反面的示例。</p>
<p>2.使用mapGetters</p>
<p>　　前面使用mapState访问了state数据，那么现在我们使用mapGetters访问一下vuex中的getters。</p>
<p>　　在研究之后发现，暂时发现使用mapGetters访问一下vuex中的getters只有字符串的形式。</p>
<p>E:\MyStudy\test\VueDemo\src\App.vue</p>
<p> 1 <template><br> 2   <div id="app"><br> 3     <img src="./assets/logo.png"><br> 4     <!-- 获取共享数据 --><br> 5     <h1>这里是App组件</h1><br> 6     <h3> App组件获取共享数据 </h3><br> 7     <h3>使用mapState访问根组件counter : </h3><br> 8     <h3>使用mapState访问a组件counter : </h3><br> 9     <h3>使用mapGetters访问根组件doubleCounter : </h3><br>10     <h3>使用mapGetters访问a组件doubleCounter : </h3><br>11     <hr/><br>12     <Index></Index><br>13   </div><br>14 </template><br>15<br>16 <script><br>17 import Index  from './components/Index'<br>18 import { mapState,mapGetters } from 'vuex'<br>19 export default {<br>20   name: 'App',<br>21   components: { Index },<br>22   computed: {<br>23     ...mapState({<br>24       //访问store根模块<br>25       counter: 'counter',<br>26     }),<br>27     ...mapState('a',{<br>28       //访问a模块<br>29       counterA: 'counter'<br>30     }),<br>31     ...mapGetters({<br>32       //访问store根模块<br>33       doubleCounter: 'doubleCounter'<br>34     }),<br>35     ...mapGetters('a',{<br>36       //访问store根模块<br>37       doubleCounterA: 'doubleCounter'<br>38     })<br>39<br>40   }<br>41<br>42 }<br>43 </script><br>44<br>45 <style><br>46 #app {<br>47   font-family: ‘Avenir’, Helvetica, Arial, sans-serif;<br>48   -webkit-font-smoothing: antialiased;<br>49   -moz-osx-font-smoothing: grayscale;<br>50   text-align: center;<br>51   color: #2c3e50;<br>52   margin-top: 60px;<br>53 }<br>54 </style></p>
<p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p>
<p> 1 <strong><strong><template><br> 2     <div><br> 3         <h1>这里是Index.vue组件</h1><br> 4         <h3>Index组件获取共享数据 </h3><br> 5         <h3>使用mapState访问b模块counter ：</h3><br> 6         <h3>使用mapGetters访问b组件doubleCounter : </h3><br> 7     </div><br> 8 </template></strong><br> 9 <script><br>10 import { mapState,mapGetters } from 'vuex'<br>11 export default {<br>12     name: 'Index',<br>13     computed: {<br>14         ...mapState('b',{<br>15             counterB: 'counter'<br>16          }),<br>17         ...mapGetters('b',{<br>18             doubleCounterB: 'doubleCounter'<br>19         }),<br>20     }<br>21 }<br>22 </script></strong></p>
<p>　　浏览器查看结果</p>
<p>　　</p>
<p>三.总结</p>
<p>　　在最后呢，再补充一点，不管是mapState和mapGetters，我们给传入的都是一个字典。</p>
<p>　　简单一些的，假如我们的state和getters不重名，我们可以给mapState和mapGetters传入一个数组</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-31自定义属性props" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/31%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7props/" class="article-date">
  	<time datetime="2022-08-29T07:31:26.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/31%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7props/">
        Vue-自定义属性props
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、属性"><a href="#一、属性" class="headerlink" title="一、属性"></a>一、属性</h3><h4 id="1-自定义属性props"><a href="#1-自定义属性props" class="headerlink" title="1. 自定义属性props"></a>1. 自定义属性props</h4><p>prop 定义了这个组件有哪些可配置的属性，组件的核心功能也都是它来确定的。写通用组件时，props 最好用对象的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，这点在组件开发中很重要，然而很多人却忽视，直接使用 props 的数组用法，这样的组件往往是不严谨的。</p>
<pre><code>// 父组件 
&lt;props 
name=&#39;属性&#39;          
:type=&#39;type&#39;         
:is-visible=&quot;false&quot;          
:on-change=&quot;handlePropChange&quot;          
:list=[22,33,44]          
title=&quot;属性Demo&quot;          
class=&quot;test1&quot;          
:class=&quot;[&#39;test2&#39;]&quot;           
:style=&quot;&#123; marginTop: &#39;20px&#39; &#125;&quot; //注意:style 的优先级是要高于style  style=&quot;margin-top: 10px&quot;&gt;  
&lt;/props&gt;
// 子组件  
props: &#123; 
    name: String,    
    type: &#123;//从父级传入的 type，它的值必须是指定的 &#39;success&#39;, &#39;warning&#39;,&#39;danger&#39;中的一个，如果传入这三个以外的值，都会抛出一条警告         validator: (value) =&gt; &#123;        
        return [&#39;success&#39;, &#39;warning&#39;,&#39;danger&#39;].includes(value) 
      &#125;   
    &#125;,    
    onChange: &#123;//对于接收的数据，可以是各种数据类型，同样也可以传递一个函数 
          type: Function,    
          default: () =&gt; &#123; &#125;    
    &#125;,   
    isVisible: &#123;      type: Boolean,      default: false    &#125;,     list: &#123;  type: Array, // 对象或数组默认值必须从一个工厂函数获取             default: () =&gt; []   
    &#125;  
&#125;
</code></pre>
<p>从上面的例中，可以得出props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，<strong>同样也可以传递一个函数。通过一般属性实现父向子通信；通过函数属性实现子向父通信</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-30 vue-router" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/30%20vue-router/" class="article-date">
  	<time datetime="2022-08-29T07:31:10.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/30%20vue-router/">
        Vue-vue-router
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>Vue Router 是 <a target="_blank" rel="noopener" href="http://cn.vuejs.org/">Vue.js</a> 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：</p>
<pre><code class="js">const User = &#123;
  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;
&#125;

const router = new VueRouter(&#123;
  routes: [
    // 动态路径参数 以冒号开头
    &#123; path: &#39;/user/:id&#39;, component: User &#125;
  ]
&#125;)
</code></pre>
<p>现在呢，像 <code>/user/foo</code> 和 <code>/user/bar</code> 都将映射到相同的路由。</p>
<p>一个“路径参数”使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 ID：</p>
<pre><code class="js">const User = &#123;
  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-29 vuecli" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/29%20vuecli/" class="article-date">
  	<time datetime="2022-08-29T07:30:54.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/29%20vuecli/">
        Vue-vue/cli
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue/cli"></a>vue/cli</h1><h2 id="全局-CLI-配置"><a href="#全局-CLI-配置" class="headerlink" title="全局 CLI 配置"></a>全局 CLI 配置</h2><p>有些针对 <code>@vue/cli</code> 的全局配置，例如你惯用的包管理器和你本地保存的 preset，都保存在 home 目录下一个名叫 <code>.vuerc</code> 的 JSON 文件。你可以用编辑器直接编辑这个文件来更改已保存的选项。</p>
<p>你也可以使用 <code>vue config</code> 命令来审查或修改全局的 CLI 配置。</p>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。你也可以使用 <code>package.json</code> 中的 <code>vue</code> 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p>
<p>这个文件应该导出一个包含了选项的对象：</p>
<pre><code class="js">// vue.config.js
module.exports = &#123;
  // 选项...
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-28 单文件组件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/28%20%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/" class="article-date">
  	<time datetime="2022-08-29T07:30:38.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/28%20%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/">
        Vue-单文件组件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><p>在很多 Vue 项目中，我们使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue(&#123; el: &#39;#container &#39;&#125;)</code> 在每个页面内指定一个容器元素。</p>
<p>这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：</p>
<ul>
<li><strong>全局定义 (Global definitions)</strong> 强制要求每个 component 中的命名不得重复</li>
<li><strong>字符串模板 (String templates)</strong> 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\</code></li>
<li><strong>不支持 CSS (No CSS support)</strong> 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>
<li><strong>没有构建步骤 (No build step)</strong> 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li>
</ul>
<p>文件扩展名为 <code>.vue</code> 的 <strong>single-file components(单文件组件)</strong> 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。</p>
<p>这是一个文件名为 <code>Hello.vue</code> 的简单实例：</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/chrisvfritz/e2b6a6110e0829d78fa4aedf7cf6b235"><img src="https://cn.vuejs.org/images/vue-component.png" alt="单文件组件的示例 (点击查看文本版的代码)"></a></p>
<p>现在我们获得：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#source-code-editing">完整语法高亮</a></li>
<li><a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/modules/#what-is-a-webpack-module">CommonJS 模块</a></li>
<li><a target="_blank" rel="noopener" href="https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html">组件作用域的 CSS</a></li>
</ul>
<p>正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Pug，Babel (with ES2015 modules)，和 Stylus。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587"><img src="https://cn.vuejs.org/images/vue-component-with-preprocessors.png" alt="带预处理器的单文件组件的示例 (点击查看文本版的代码)"></a></p>
<p>这些特定的语言只是例子，你可以只是简单地使用 Babel，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。如果搭配 <code>vue-loader</code> 使用 webpack，它也能为 CSS Modules 提供头等支持。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-27 过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/27%20%E8%BF%87%E6%BB%A4%E5%99%A8/" class="article-date">
  	<time datetime="2022-08-29T07:30:12.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/27%20%E8%BF%87%E6%BB%A4%E5%99%A8/">
        Vue-过滤器
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>过滤器</p>
<p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p>
<pre><code class="html">&lt;!-- 在双花括号中 --&gt;
&lt;div&gt;&#123;&#123;myname | myfilter1 | myfilter2&#125;&#125;&lt;/div&gt;

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre>
<p>你可以在一个组件的选项中定义本地的过滤器：</p>
<pre><code class="js">  Vue.filter(&quot;myfilter1&quot;, data =&gt; &#123;
    return data.substring(0, 1)
  &#125;)
  Vue.filter(&quot;myfilter2&quot;, data =&gt; &#123;
    return data.toUpperCase()
  &#125;)
  Vue.filter(&quot;myimg&quot;, data =&gt; &#123;
    return `https://cube.elemecdn.com/$&#123;data[0]&#125;/$&#123;data.substring(1,3)&#125;/$&#123;data.substring(3,data.length)&#125;.jpeg?x-oss-process=image/format,webp/resize,w_90,h_90,m_fixed`
  &#125;)
</code></pre>
<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;
    if (!value) return &#39;&#39;
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
&#125;)

new Vue(&#123;
    // ...
&#125;)
</code></pre>
<p>当全局过滤器和局部过滤器重名时，会采用局部过滤器</p>
<p>过滤器可以串联：</p>
<pre><code class="html">&#123;&#123; message | filterA | filterB &#125;&#125;
</code></pre>
<p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p>
<p>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<pre><code class="html">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;
</code></pre>
<p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>&#39;arg1&#39;</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-26 指令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/26%20%E6%8C%87%E4%BB%A4/" class="article-date">
  	<time datetime="2022-08-29T07:29:58.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/26%20%E6%8C%87%E4%BB%A4/">
        Vue-自定义指令
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="Vue-directives"><a href="#Vue-directives" class="headerlink" title="Vue.directives"></a>Vue.directives</h2><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：</p>
<p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>
<pre><code class="js">// 注册一个全局自定义指令 `v-focus`
Vue.directive(&#39;focus&#39;, &#123;
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) &#123;
    // 聚焦元素
    el.focus()
  &#125;
&#125;)
</code></pre>
<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<pre><code class="js">directives: &#123;
  focus: &#123;
    // 指令的定义
    inserted: function (el) &#123;
      el.focus()
    &#125;
  &#125;
&#125;
</code></pre>
<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p>
<pre><code class="html">&lt;input v-focus&gt;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-25 生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/25%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  	<time datetime="2022-08-29T07:29:42.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/25%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
        Vue-生命周期
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p>
<h2 id="选项-生命周期钩子"><a href="#选项-生命周期钩子" class="headerlink" title="选项 / 生命周期钩子"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">选项 / 生命周期钩子</a></h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p>
<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeCreate">beforeCreate</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置前被调用。</p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#created">created</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前尚不可用。</p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeMount">beforeMount</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#mounted">mounted</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。 如果根实例挂载到了一个文档内的元素上，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。</p>
<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p>
<pre><code>mounted: function () &#123;
  this.$nextTick(function () &#123;
    // Code that will run only after the
    // entire view has been rendered
  &#125;)
&#125;
</code></pre>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeUpdate">beforeUpdate</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#updated">updated</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p>
<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p>
<pre><code>updated: function () &#123;
  this.$nextTick(function () &#123;
    // Code that will run only after the
    // entire view has been re-rendered
  &#125;)
&#125;
</code></pre>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#activated">activated</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件激活时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">构建组件 - keep-alive</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive">动态组件 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#deactivated">deactivated</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>被 keep-alive 缓存的组件停用时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">构建组件 - keep-alive</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive">动态组件 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#beforeDestroy">beforeDestroy</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#destroyed">destroyed</a></h3><ul>
<li><p><strong>类型</strong>：<code>Function</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p>
</li>
</ul>
<h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#errorCaptured">errorCaptured</a></h3><blockquote>
<p>2.5.0+ 新增</p>
</blockquote>
<ul>
<li><p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
<p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>
<p><strong>错误传播规则</strong></p>
<ul>
<li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li>
<li>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li>
<li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</li>
<li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/10/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>