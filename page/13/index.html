<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/13/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-16 ref" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/16%20ref/" class="article-date">
  	<time datetime="2022-08-25T02:58:18.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/16%20ref/">
        Vue-ref
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><p><strong>预期</strong>：<code>string</code></p>
<p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>
<pre><code class="html">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;
&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;

&lt;!-- `vm.$refs.child` will be the child component instance --&gt;
&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;
</code></pre>
<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>
<p>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0">子组件引用</a></p>
</li>
</ul>
<h3 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0">访问子组件实例或子元素</a></h3><p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用。例如：</p>
<pre><code class="htmk">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;
</code></pre>
<p>现在在你已经定义了这个 <code>ref</code> 的组件里，你可以使用：</p>
<pre><code class="js">this.$refs.usernameInput
</code></pre>
<p>来访问这个 <code>实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该</code> 组件也可以使用一个类似的 <code>ref</code> 提供对内部这个指定元素的访问，例如：</p>
<pre><code class="html">&lt;input ref=&quot;input&quot;&gt;
</code></pre>
<p>甚至可以通过其父级组件定义方法：</p>
<pre><code class="js">methods: &#123;
  // 用来从父级组件聚焦输入框
  focus: function () &#123;
    this.$refs.input.focus()
  &#125;
&#125;
</code></pre>
<p>这样就允许父级组件通过下面的代码聚焦 `` 里的输入框：</p>
<pre><code class="js">this.$refs.usernameInput.focus()
</code></pre>
<p>当 <code>ref</code> 和 <code>v-for</code> 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。</p>
<p><code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 <code>$refs</code>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-15 自定义事件 $emit" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/15%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%20$emit/" class="article-date">
  	<time datetime="2022-08-25T02:58:12.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/15%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%20$emit/">
        Vue-自定义事件$emit
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><h2 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h2><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p>
<pre><code class="js">this.$emit(&#39;myEvent&#39;)
</code></pre>
<p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p>
<pre><code class="js">&lt;!-- 没有效果 --&gt;
&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;
</code></pre>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p>
<h2 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的<code>v-model</code></h2><blockquote>
<p>2.2.0+ 新增</p>
</blockquote>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<pre><code class="js">Vue.component(&#39;base-checkbox&#39;, &#123;
  model: &#123;
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  &#125;,
  props: &#123;
    checked: Boolean
  &#125;,
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;
    &gt;
  `
&#125;)
</code></pre>
<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<pre><code class="html">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;
</code></pre>
<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>base-checkbox</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的属性将会被更新。</p>
<p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-14 prop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/14%20prop/" class="article-date">
  	<time datetime="2022-08-25T02:58:04.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/14%20prop/">
        Vue-prop
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1prop"><a href="#1prop" class="headerlink" title="1prop"></a>1prop</h1><h2 id="prop的大小写"><a href="#prop的大小写" class="headerlink" title="prop的大小写"></a>prop的大小写</h2><blockquote>
<p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p>
</blockquote>
<pre><code class="js">Vue.component(&#123;&#39;navbar&#39;&#125;,&#123;
    template:`&lt;div&gt;&#123;&#123;my-name&#125;&#125;&lt;/div&gt;`,
    props:[&#39;my-name&#39;]
&#125;)
</code></pre>
<pre><code class="html">&lt;navbar my-name=&#39;hello&#39;&gt;&lt;/navbar&gt;
</code></pre>
<h2 id="prop类型"><a href="#prop类型" class="headerlink" title="prop类型"></a>prop类型</h2><h3 id="字符串数组形式"><a href="#字符串数组形式" class="headerlink" title="字符串数组形式"></a>字符串数组形式</h3><pre><code class="js">props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]
</code></pre>
<h3 id="对象形式"><a href="#对象形式" class="headerlink" title="对象形式"></a>对象形式</h3><p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的<code>名称</code>和<code>类型</code>：</p>
<pre><code class="js">props: &#123;
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
&#125;
</code></pre>
<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">类型检查和其它 prop 验证</a>。</p>
<h2 id="传递静态或动态prop"><a href="#传递静态或动态prop" class="headerlink" title="传递静态或动态prop"></a>传递静态或动态prop</h2><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>可以像这样给 prop 传入一个静态的值，即传入了一个’hello’的字符串</p>
<pre><code class="js">Vue.component(&#39;navbar&#39;,&#123;
    template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,
    props:[&#39;myname&#39;]
&#125;)
</code></pre>
<pre><code class="html">&lt;navbar myname=&#39;hello&#39;&gt;&lt;/navbar&gt;
</code></pre>
<h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><h4 id="传入一个布尔值"><a href="#传入一个布尔值" class="headerlink" title="传入一个布尔值"></a>传入一个布尔值</h4><pre><code class="js">Vue.component(&#39;navbar&#39;,&#123;
    template:`&lt;div v-if=&#39;isshow&#39;&gt;动态显示和隐藏&lt;/div&gt;`,
    props:&#123;
        isshow:Boolean
    &#125;
&#125;)
</code></pre>
<pre><code class="html">&lt;navbar :isshow=&#39;false&#39;&gt;&lt;/navbar&gt; //传入的是一个false布尔值
</code></pre>
<h4 id="传入一个状态"><a href="#传入一个状态" class="headerlink" title="传入一个状态"></a>传入一个状态</h4><pre><code class="js">Vue.component(&#39;navar&#39;,&#123;
    template:`&lt;div v-if=&#39;data&#39;&gt;动态传入状态&lt;/div&gt;`,
    props:&#123;
        data:Boolean
    &#125;
&#125;)
new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        isshow:false
    &#125;
&#125;)
</code></pre>
<pre><code class="js">&lt;button @click=&#39;isshow=!isshow&#39;&gt;click&lt;/button&gt;
&lt;navbar :data=&#39;isshow&#39;&gt;&lt;/navbar&gt; //通过data属性传入一个父组件中一个叫isshow的状态
</code></pre>
<h4 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="传入一个数字"></a>传入一个数字</h4><pre><code class="js">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 用一个变量进行动态赋值。--&gt;
&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<h4 id="传入一个对象"><a href="#传入一个对象" class="headerlink" title="传入一个对象"></a>传入一个对象</h4><pre><code class="js">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post
  v-bind:author=&quot;&#123;
    name: &#39;Veronica&#39;,
    company: &#39;Veridian Dynamics&#39;
  &#125;&quot;
&gt;&lt;/blog-post&gt;

&lt;!-- 用一个变量进行动态赋值。--&gt;
&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>这里有两种常见的试图改变一个 prop 的情形：</p>
<ol>
<li><p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p>
<pre><code class="js">props: [&#39;initialCounter&#39;],
data: function () &#123;
  return &#123;
    counter: this.initialCounter
  &#125;
&#125;
</code></pre>
</li>
<li><p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<pre><code class="js">props: [&#39;size&#39;],
computed: &#123;
  normalizedSize: function () &#123;
    return this.size.trim().toLowerCase()
  &#125;
&#125;
</code></pre>
</li>
</ol>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p>
<h2 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>这里有两种常见的试图改变一个 prop 的情形：</p>
<ol>
<li><p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p>
<pre><code>props: [&#39;initialCounter&#39;],
data: function () &#123;
  return &#123;
    counter: this.initialCounter
  &#125;
&#125;
</code></pre>
</li>
<li><p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<pre><code>props: [&#39;size&#39;],
computed: &#123;
  normalizedSize: function () &#123;
    return this.size.trim().toLowerCase()
  &#125;
&#125;
</code></pre>
</li>
</ol>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p>
<h2 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h2><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p>
<p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p>
<pre><code class="js">Vue.component(&#39;my-component&#39;, &#123;
  props: &#123;
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: &#123;
      type: String,
      required: true
    &#125;,
    // 带有默认值的数字
    propD: &#123;
      type: Number,
      default: 100
    &#125;,
    // 带有默认值的对象
    propE: &#123;
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () &#123;
        return &#123; message: &#39;hello&#39; &#125;
      &#125;
    &#125;,
    // 自定义验证函数
    propF: &#123;
      validator: function (value) &#123;
        // 这个值必须匹配下列字符串中的一个
        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1
      &#125;
    &#125;
  &#125;
&#125;)
</code></pre>
<p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p>
<p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的属性 (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-13 json-server" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/13%20json-server/" class="article-date">
  	<time datetime="2022-08-25T02:57:52.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/13%20json-server/">
        json server  mock本地服务器
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="json-server"><a href="#json-server" class="headerlink" title="json server"></a>json server</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Install JSON Server</p>
<pre><code>npm install -g json-server
</code></pre>
<h2 id="创建json"><a href="#创建json" class="headerlink" title="创建json"></a>创建json</h2><p>Create a <code>db.json</code> file with some data</p>
<pre><code>&#123;
  &quot;posts&quot;: [
    &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;
  ],
  &quot;comments&quot;: [
    &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;
  ],
  &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;
&#125;
</code></pre>
<h2 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h2><p>Start JSON Server</p>
<pre><code>json-server --watch db.json --port 8080
</code></pre>
<h2 id="配合axios"><a href="#配合axios" class="headerlink" title="配合axios"></a>配合axios</h2><pre><code class="js">axios(&#123;
    url:&#39;http://localhost:8080/users&#39;,
    methods:&#39;xxx&#39;,
    data:&#123;
        xxx:&#39;xxx&#39;
    &#125;
&#125;)
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-13 组件注册" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/13%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/" class="article-date">
  	<time datetime="2022-08-25T02:56:58.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/13%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/">
        Vue-组件注册
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><h2 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h2><p>在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：</p>
<pre><code class="js">Vue.component(&#39;navbar&#39;, &#123; /* ... */ &#125;)
</code></pre>
<p>该组件名就是 <code>Vue.component</code> 的第一个参数。</p>
<p>你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>) 的时候，我们强烈推荐遵循 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">W3C 规范</a>中的自定义组件名 (<strong>字母全小写且必须包含一个连字符</strong>)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p>
<h3 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h3><p>定义组件名的方式有两种：</p>
<h4 id="使用-kebab-case"><a href="#使用-kebab-case" class="headerlink" title="使用 kebab-case"></a>使用 kebab-case</h4><pre><code class="js">Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)
</code></pre>
<p>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 ``。</p>
<h4 id="使用-PascalCase"><a href="#使用-PascalCase" class="headerlink" title="使用 PascalCase"></a>使用 PascalCase</h4><pre><code class="js">Vue.component(&#39;MyComponentName&#39;, &#123; /* ... */ &#125;)
</code></pre>
<p>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>和</code> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。</p>
<h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>到目前为止，我们只用过 <code>Vue.component</code> 来创建组件：</p>
<pre><code class="js">Vue.component(&#39;my-component-name&#39;, &#123;
  // ... 选项 ...
&#125;)
</code></pre>
<p>这些组件是<strong>全局注册的</strong>。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中。比如：</p>
<pre><code class="js">Vue.component(&#39;component-a&#39;, &#123; /* ... */ &#125;)
Vue.component(&#39;component-b&#39;, &#123; /* ... */ &#125;)
Vue.component(&#39;component-c&#39;, &#123; /* ... */ &#125;)

new Vue(&#123; el: &#39;#app&#39; &#125;)
&lt;div id=&quot;app&quot;&gt;
  &lt;component-a&gt;&lt;/component-a&gt;
  &lt;component-b&gt;&lt;/component-b&gt;
  &lt;component-c&gt;&lt;/component-c&gt;
&lt;/div&gt;
</code></pre>
<p>在所有子组件中也是如此，也就是说这三个组件<em>在各自内部</em>也都可以相互使用。</p>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p>
<p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：</p>
<pre><code class="js">var ComponentA = &#123; /* ... */ &#125;
var ComponentB = &#123; /* ... */ &#125;
var ComponentC = &#123; /* ... */ &#125;
</code></pre>
<p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<pre><code class="js">new Vue(&#123;
  el: &#39;#app&#39;,
  components: &#123;
    &#39;component-a&#39;: ComponentA,
    &#39;component-b&#39;: ComponentB
  &#125;
&#125;)
</code></pre>
<p>对于 <code>components</code> 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。</p>
<p>注意**局部注册的组件在其子组件中*不可用***。例如，如果你希望 <code>ComponentA</code> 在 <code>ComponentB</code> 中可用，则你需要这样写：</p>
<pre><code class="js">var ComponentA = &#123; /* ... */ &#125;

var ComponentB = &#123;
  components: &#123;
    &#39;component-a&#39;: ComponentA
  &#125;,
  // ...
&#125;
</code></pre>
<p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p>
<pre><code class="js">import ComponentA from &#39;./ComponentA.vue&#39;

export default &#123;
  components: &#123;
    ComponentA
  &#125;,
  // ...
&#125;
</code></pre>
<p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-12 组件介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/12%20%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" class="article-date">
  	<time datetime="2022-08-25T02:56:54.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/12%20%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/">
        Vue-组件介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><h2 id="虚拟dom、diff算法、key的作用"><a href="#虚拟dom、diff算法、key的作用" class="headerlink" title="虚拟dom、diff算法、key的作用"></a>虚拟dom、diff算法、key的作用</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190225916.png" alt="image-20200214190225916"></p>
<ol>
<li><p>把虚拟DOM树按照层级分解</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190256593.png" alt="image-20200214190256593"></p>
</li>
<li><p>同key值进行对比</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190317166.png" alt="image-20200214190317166"></p>
</li>
<li><p>同组件对比</p>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190333630.png" alt="image-20200214190333630"></p>
</li>
</ol>
<h2 id="组件化的意义"><a href="#组件化的意义" class="headerlink" title="组件化的意义"></a>组件化的意义</h2><p>扩展 HTML 元素，封装可重用的代码</p>
<h2 id="组件注册方式"><a href="#组件注册方式" class="headerlink" title="组件注册方式"></a>组件注册方式</h2><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><blockquote>
<p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p>
</blockquote>
<p>这里有一个 Vue 组件的示例：</p>
<pre><code class="js">Vue.components(&#39;navbar&#39;,&#123;
    template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,//html结构
       data()&#123;
        return &#123;
            myname:&#39;retr0&#39;
        &#125;
    &#125;
&#125;)
</code></pre>
<p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>navbar</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p>
<pre><code class="html">&lt;div id=&quot;box&quot;&gt;
    &lt;navbar&gt;&lt;/navbar&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123; el: &#39;#box&#39; &#125;)
</code></pre>
<p>因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>
<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>这里有一个局部Vue组件的实例：</p>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    components:&#123;
        child1:&#123;
            template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,
            data()&#123;
                return &#123;
                    myname:&#39;retr0Child&#39;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h2 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h2><p>当我们定义这个 <code>navbar</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象：</p>
<pre><code class="js">data: &#123;
    myname:&#39;retr0&#39;
&#125;
</code></pre>
<p>取而代之的是，<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝：</p>
<pre><code class="js">data()&#123;
    return &#123;
        myname:&#39;retr0&#39;
    &#125;
&#125;
</code></pre>
<p>如果 Vue 没有这条规则，点击一个按钮就可能会像如下代码一样影响到<em>其它所有实例</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-11-1高频前端面试题汇总之Vue篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/" class="article-date">
  	<time datetime="2022-08-25T02:56:48.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">
        Vue-11-1高频前端面试题汇总之Vue篇
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a44f18af182434d901b74df18491dea~tplv-k3u1fbpfcp-watermark.awebp" alt="Vue面试题.png"></p>
<h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b16025a35b4cd2b343a92e740621b7~tplv-k3u1fbpfcp-watermark.awebp" alt="0_tB3MJCzh_cB6i3mS-1.png"></p>
<h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>
<ol>
<li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286bdc076ae425fb9591bb8c4153240~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
<p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>
<h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>
<p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p>
<p><strong>（1）MVC</strong></p>
<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65e1b9145894647a25788caf12ddd26~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p>
<p>（2）MVVM</p>
<p>MVVM 分为 Model、View、ViewModel：</p>
<ul>
<li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>View代表UI视图，负责数据的展示；</li>
<li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li>
</ul>
<p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>
<p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ce15b7b704483eb91ee1f5d1d64786~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p>
<p><strong>（3）MVP</strong></p>
<p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p>
<ul>
<li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li>
<li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li>
<li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li>
<li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li>
</ul>
<p><strong>对于Watch：</strong></p>
<ul>
<li>它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>支持异步监听</li>
<li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul>
<li>immediate：组件加载立即触发回调函数</li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>
<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p>
<p><strong>不同点：</strong></p>
<ul>
<li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li>
<li>method 调用总会执行该函数。</li>
</ul>
<h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>
<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li>
<li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li>
</ul>
<p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式 *<em><code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code>*</em> 表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p>
<p>例如，在显示金额，给商品价格添加单位：</p>
<pre><code class="javascript">&lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;/li&gt;

 filters: &#123;
    filterPrice (price) &#123;
      return price ? (&#39;￥&#39; + price) : &#39;--&#39;
    &#125;
  &#125;
复制代码
</code></pre>
<h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p>
<ul>
<li>前组件会被卸载</li>
<li>前组件不会被卸载</li>
</ul>
<p>那么可以按照这两种情况分别得到以下方法：</p>
<p><strong>组件会被卸载：</strong></p>
<p><strong>（1）将状态存储在LocalStorage / SessionStorage</strong></p>
<p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p>
<p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p>
<p><strong>优点：</strong></p>
<ul>
<li>兼容性好，不需要额外库或工具。</li>
<li>简单快捷，基本可以满足大部分需求。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li>
<li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li>
</ul>
<p><strong>（2）路由传值</strong></p>
<p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p>
<p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p>
<p><strong>优点：</strong></p>
<ul>
<li>简单快捷，不会污染 LocalStorage / SessionStorage。</li>
<li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li>
</ul>
<p><strong>组件不会被卸载：</strong></p>
<p><strong>（1）单页面渲染</strong></p>
<p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p>
<p><strong>优点：</strong></p>
<ul>
<li>代码量少</li>
<li>不需要考虑状态传递过程中的错误</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加 A 组件维护成本</li>
<li>需要传入额外的 prop 到 B 组件</li>
<li>无法利用路由定位页面</li>
</ul>
<p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p>
<pre><code class="javascript">&lt;keep-alive&gt;
    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
&lt;/kepp-alive&gt;
复制代码
</code></pre>
<p><strong>router.js</strong></p>
<pre><code class="javascript">&#123;
  path: &#39;/&#39;,
  name: &#39;xxx&#39;,
  component: ()=&gt;import(&#39;../src/views/xxx.vue&#39;),
  meta:&#123;
    keepAlive: true // 需要被缓存
  &#125;
&#125;,
复制代码
</code></pre>
<h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul>
<li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li>
<li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>
<li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li>
<li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>
<li><code>.once</code> ：只会触发一次。</li>
</ul>
<h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul>
<li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>
<li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li>
<li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li>
</ul>
<h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul>
<li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li>
<li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li>
<li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
<li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>
</ul>
<h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p>
<pre><code class="javascript">&lt;input v-model=&quot;sth&quot; /&gt;
//  等同于
&lt;input 
    v-bind:value=&quot;message&quot; 
    v-on:input=&quot;message=$event.target.value&quot;
&gt;
//$event 指代当前触发的事件对象;
//$event.target 指代当前触发的事件对象的dom;
//$event.target.value 就是当前dom的value值;
//在@input方法中，value =&gt; sth;
//在:value中,sth =&gt; value;
复制代码
</code></pre>
<p><strong>（2）作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p>
<p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p>
<pre><code class="javascript">&lt;child :value=&quot;message&quot;  @input=&quot;function(e)&#123;message = e&#125;&quot;&gt;&lt;/child&gt;
复制代码
</code></pre>
<p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p>
<pre><code class="javascript">// 父组件
&lt;aa-input v-model=&quot;aa&quot;&gt;&lt;/aa-input&gt;
// 等价于
&lt;aa-input v-bind:value=&quot;aa&quot; v-on:input=&quot;aa=$event.target.value&quot;&gt;&lt;/aa-input&gt;

// 子组件：
&lt;input v-bind:value=&quot;aa&quot; v-on:input=&quot;onmessage&quot;&gt;&lt;/aa-input&gt;

props:&#123;value:aa,&#125;
methods:&#123;
    onmessage(e)&#123;
        $emit(&#39;input&#39;,e.target.value)
    &#125;
&#125;
复制代码
</code></pre>
<p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p>
<h3 id="15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p>
<pre><code class="javascript">&lt;input v-model=&quot;searchText&quot;&gt;
复制代码
</code></pre>
<p>实际上相当于：</p>
<pre><code class="javascript">&lt;input
  v-bind:value=&quot;searchText&quot;
  v-on:input=&quot;searchText = $event.target.value&quot;
&gt;
复制代码
</code></pre>
<p>用在自定义组件上也是同理：</p>
<pre><code class="javascript">&lt;custom-input v-model=&quot;searchText&quot;&gt;
复制代码
</code></pre>
<p>相当于：</p>
<pre><code class="javascript">&lt;custom-input
  v-bind:value=&quot;searchText&quot;
  v-on:input=&quot;searchText = $event&quot;
&gt;&lt;/custom-input&gt;
复制代码
</code></pre>
<p>显然，custom-input 与父组件的交互如下：</p>
<ol>
<li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li>
<li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li>
</ol>
<p>所以，custom-input 组件的实现应该类似于这样：</p>
<pre><code class="javascript">Vue.component(&#39;custom-input&#39;, &#123;
  props: [&#39;value&#39;],
  template: `
    &lt;input
      v-bind:value=&quot;value&quot;
      v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;
    &gt;
  `
&#125;)
复制代码
</code></pre>
<h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>
<p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>
<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>
<h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p><strong>（1）keep-alive</strong></p>
<p>keep-alive有以下三个属性：</p>
<ul>
<li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>
<li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>
<li>max 数字，最多可以缓存多少组件实例。</li>
</ul>
<p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p>
<p><strong>主要流程</strong></p>
<ol>
<li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li>
<li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li>
<li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li>
<li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li>
</ol>
<p><strong>（2）keep-alive 的实现</strong></p>
<pre><code class="javascript">const patternTypes: Array&lt;Function&gt; = [String, RegExp, Array] // 接收：字符串，正则，数组

export default &#123;
  name: &#39;keep-alive&#39;,
  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

  props: &#123;
    include: patternTypes, // 匹配的组件，缓存
    exclude: patternTypes, // 不去匹配的组件，不缓存
    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限
  &#125;,

  created() &#123;
    // 用于初始化缓存虚拟DOM数组和vnode的key
    this.cache = Object.create(null)
    this.keys = []
  &#125;,

  destroyed() &#123;
    // 销毁缓存cache的组件实例
    for (const key in this.cache) &#123;
      pruneCacheEntry(this.cache, key, this.keys)
    &#125;
  &#125;,

  mounted() &#123;
    // prune 削减精简[v.]
    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容
    this.$watch(&#39;include&#39;, (val) =&gt; &#123;
      pruneCache(this, (name) =&gt; matches(val, name))
    &#125;)
    this.$watch(&#39;exclude&#39;, (val) =&gt; &#123;
      pruneCache(this, (name) =&gt; !matches(val, name))
    &#125;)
  &#125;,
&#125;
复制代码
</code></pre>
<p><strong>render函数：</strong></p>
<ol>
<li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li>
<li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li>
<li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li>
</ol>
<pre><code class="javascript">render () &#123;
  //
  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;
    if (Array.isArray(children)) &#123;
  for (let i = 0; i &lt; children.length; i++) &#123;
    const c = children[i]
    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;
      return c
    &#125;
  &#125;
  &#125;
  &#125;
  const slot = this.$slots.default // 获取默认插槽
  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件
  const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // 组件参数
  if (componentOptions) &#123; // 是否有组件参数
    // check pattern
    const name: ?string = getComponentName(componentOptions) // 获取组件名
    const &#123; include, exclude &#125; = this
    if (
      // not included
      (include &amp;&amp; (!name || !matches(include, name))) ||
      // excluded
      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))
    ) &#123;
      // 如果不匹配当前组件的名字和include以及exclude
      // 那么直接返回组件的实例
      return vnode
    &#125;

    const &#123; cache, keys &#125; = this

    // 获取这个组件的key
    const key: ?string = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#39;&#39;)
      : vnode.key

    if (cache[key]) &#123;
      // LRU缓存策略执行
      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined

      // make current key freshest
      remove(keys, key)
      keys.push(key)
      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面
    &#125; else &#123;
      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除
      // 使用时间间隔最长的一个
      cache[key] = vnode
      keys.push(key)
      // prune oldest entry
      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;
        pruneCacheEntry(cache, keys[0], keys, this._vnode)
      &#125;
    &#125;
    // 将组件的keepAlive属性设置为true
    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数
  &#125;
  return vnode || (slot &amp;&amp; slot[0])
&#125;
复制代码
</code></pre>
<p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li>
<li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li>
<li>需要缓存，判断他当前是否在缓存数组里面：</li>
</ol>
<ul>
<li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li>
<li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li>
</ul>
<ol>
<li>最后将这个组件的 keepAlive 设置为 true</li>
</ol>
<p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p>
<p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p>
<p><strong>首次渲染</strong></p>
<ul>
<li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li>
</ul>
<pre><code class="javascript">// core/instance/lifecycle
function initLifecycle (vm: Component) &#123;
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent &amp;&amp; !options.abstract) &#123; // 判断组件的abstract属性，才往父组件里面挂载DOM
    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;
      parent = parent.$parent
    &#125;
    parent.$children.push(vm)
  &#125;

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = &#123;&#125;

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
&#125;
复制代码
</code></pre>
<ul>
<li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li>
</ul>
<pre><code class="javascript">// core/vdom/create-component
init (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;
    if (
      vnode.componentInstance &amp;&amp;
      !vnode.componentInstance._isDestroyed &amp;&amp;
      vnode.data.keepAlive
    ) &#123; // componentInstance在初次是undefined!!!
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程
    &#125; else &#123;
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    &#125;
  &#125;,
复制代码
</code></pre>
<p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p>
<p><strong>（4）LRU （least recently used）缓存策略</strong></p>
<p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 **”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p>
<ul>
<li>新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
<h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p>
<p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p>
<ul>
<li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li>
<li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li>
</ul>
<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p>
<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p>
<pre><code class="javascript">this.$nextTick(() =&gt; &#123;    // 获取数据的操作...&#125;)
复制代码
</code></pre>
<p>所以，在以下情况下，会用到nextTick：</p>
<ul>
<li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li>
<li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li>
</ul>
<p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p>
<h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><pre><code class="javascript">&lt;template&gt; 
   &lt;div&gt;
      &lt;ul&gt;
         &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; 
      &lt;/ul&gt; 
      &lt;button @click=&quot;addObjB&quot;&gt;添加 obj.b&lt;/button&gt; 
   &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123; 
       data () &#123; 
          return &#123; 
              obj: &#123; 
                  a: &#39;obj.a&#39; 
              &#125; 
          &#125; 
       &#125;,
       methods: &#123; 
          addObjB () &#123; 
              this.obj.b = &#39;obj.b&#39; 
              console.log(this.obj) 
          &#125; 
      &#125;
   &#125;
&lt;/script&gt;
复制代码
</code></pre>
<p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p>
<pre><code class="javascript">addObjB () (
   this.$set(this.obj, &#39;b&#39;, &#39;obj.b&#39;)
   console.log(this.obj)
&#125;
复制代码
</code></pre>
<p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p>
<h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be20296a76f4e7085dfb510a3211d16~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"> 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p>
<pre><code class="javascript">// 缓存数组原型
const arrayProto = Array.prototype;
// 实现 arrayMethods.__proto__ === Array.prototype
export const arrayMethods = Object.create(arrayProto);
// 需要进行功能拓展的方法
const methodsToPatch = [
  &quot;push&quot;,
  &quot;pop&quot;,
  &quot;shift&quot;,
  &quot;unshift&quot;,
  &quot;splice&quot;,
  &quot;sort&quot;,
  &quot;reverse&quot;
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function(method) &#123;
  // 缓存原生数组方法
  const original = arrayProto[method];
  def(arrayMethods, method, function mutator(...args) &#123;
    // 执行并缓存原生数组功能
    const result = original.apply(this, args);
    // 响应式处理
    const ob = this.__ob__;
    let inserted;
    switch (method) &#123;
    // push、unshift会新增索引，所以要手动observer
      case &quot;push&quot;:
      case &quot;unshift&quot;:
        inserted = args;
        break;
      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。
      case &quot;splice&quot;:
        inserted = args.slice(2);
        break;
    &#125;
    // 
    if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听
    // notify change
    ob.dep.notify();// 通知依赖更新
    // 返回原生数组方法的执行结果
    return result;
  &#125;);
&#125;);
复制代码
</code></pre>
<p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
<h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p>
<ul>
<li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li>
<li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li>
</ul>
<p><strong>区别：</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3d747986e45e096abaf64faf5e332~tplv-k3u1fbpfcp-watermark.awebp" alt="775316ebb4c727f7c8771cc2c06e06dd.jpg"></p>
<h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p>
<p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p>
<pre><code class="javascript">// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)
复制代码
</code></pre>
<p>CompileToFunctions中的主要逻辑如下∶ <strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p>
<pre><code class="javascript">constast = parse(template.trim(), options)
复制代码
</code></pre>
<ul>
<li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li>
<li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li>
</ul>
<p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p>
<p><strong>（2）对静态节点做优化</strong></p>
<pre><code class="javascript">optimize(ast,options)
复制代码
</code></pre>
<p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p>
<p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p>
<p><strong>（3）生成代码</strong></p>
<pre><code class="javascript">const code = generate(ast, options)
复制代码
</code></pre>
<p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p>
<h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p>
<ul>
<li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li>
<li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7df745017242a7beaba81e854a0f97~tplv-k3u1fbpfcp-watermark.awebp" alt="bb253b1d177f421741af0e7dd0f52b5e.jpg"> <strong>（2）mergeOptions 的执行过程</strong></p>
<ul>
<li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li>
<li>对未合并的选项，进行判断</li>
</ul>
<pre><code class="javascript">if(!child._base) &#123;    if(child.extends) &#123;        parent = mergeOptions(parent, child.extends, vm)    &#125;    if(child.mixins) &#123;        for(let i = 0, l = child.mixins.length; i &lt; l; i++)&#123;            parent = mergeOptions(parent, child.mixins[i], vm)        &#125;    &#125;&#125;
复制代码
</code></pre>
<ul>
<li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li>
<li>返回合并结果 options。</li>
</ul>
<h3 id="25-描述下Vue自定义指令"><a href="#25-描述下Vue自定义指令" class="headerlink" title="25. 描述下Vue自定义指令"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p>
<p><strong>（1）自定义指令基本内容</strong></p>
<ul>
<li><p>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p>
</li>
<li><p>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p>
</li>
<li><p>钩子函数：指令定义对象提供钩子函数</p>
<p>o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p>o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p>o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>
<p>o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>
<p>o unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
<li><p>钩子函数参数 o el：绑定元素</p>
<p>o bing： 指令核心对象，描述指令全部信息属性</p>
<p>o name</p>
<p>o value</p>
<p>o oldValue</p>
<p>o expression</p>
<p>o arg</p>
<p>o modifers</p>
<p>o vnode  虚拟节点</p>
<p>o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>
</li>
</ul>
<p><strong>（2）使用场景</strong></p>
<ul>
<li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li>
<li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li>
</ul>
<p><strong>（3）使用案例</strong></p>
<p>初级应用：</p>
<ul>
<li>鼠标聚焦</li>
<li>下拉菜单</li>
<li>相对时间转换</li>
<li>滚动动画</li>
</ul>
<p>高级应用：</p>
<ul>
<li>自定义指令实现图片懒加载</li>
<li>自定义指令集成第三方插件</li>
</ul>
<h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p>
<p><strong>只能通过 *<em><code>$emit</code>*</em> 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p>
<h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p>
<pre><code class="javascript">function defieneReactive (obj, key, val)&#123;
  const dep = new Dep();
  ...
  Object.defineProperty(obj, key, &#123;
    ...
    get: function reactiveGetter () &#123;
      if(Dep.target)&#123;
        dep.depend();
        ...
      &#125;
      return val
    &#125;
    ...
  &#125;)
&#125;
复制代码
</code></pre>
<p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 <strong>（1）Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p>
<pre><code class="javascript">class Dep &#123;
  static target;
  subs;

  constructor () &#123;
    ...
    this.subs = [];
  &#125;
  addSub (sub) &#123;
    this.subs.push(sub)
  &#125;
  removeSub (sub) &#123;
    remove(this.sub, sub)
  &#125;
  depend () &#123;
    if(Dep.target)&#123;
      Dep.target.addDep(this)
    &#125;
  &#125;
  notify () &#123;
    const subs = this.subds.slice();
    for(let i = 0;i &lt; subs.length; i++)&#123;
      subs[i].update()
    &#125;
  &#125;
&#125;
复制代码
</code></pre>
<p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p>
<p><strong>（2）Watcher</strong></p>
<pre><code class="javascript">class Watcher &#123;
  getter;
  ...
  constructor (vm, expression)&#123;
    ...
    this.getter = expression;
    this.get();
  &#125;
  get () &#123;
    pushTarget(this);
    value = this.getter.call(vm, vm)
    ...
    return value
  &#125;
  addDep (dep)&#123;
        ...
    dep.addSub(this)
  &#125;
  ...
&#125;
function pushTarget (_target) &#123;
  Dep.target = _target
&#125;
复制代码
</code></pre>
<p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p>
<p><strong>（3）过程</strong></p>
<p>在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p>
<pre><code class="javascript">updateComponent = () =&gt; &#123;
  vm._update(vm._render())
&#125;
new Watcher(vm, updateComponent)
复制代码
</code></pre>
<p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p>
<p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p>
<h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p>
<ul>
<li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li>
<li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li>
<li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li>
<li>都有props的概念，允许组件间的数据传递；</li>
<li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li>
</ul>
<p><strong>不同之处 ：</strong></p>
<p><strong>1）数据流</strong></p>
<p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p>
<p><strong>2）虚拟DOM</strong></p>
<p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p>
<ul>
<li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>
<li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>
</ul>
<p><strong>3）组件化</strong></p>
<p>React与Vue最大的不同是模板的编写。</p>
<ul>
<li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li>
<li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li>
</ul>
<p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 <strong>4）监听数据变化的实现原理不同</strong></p>
<ul>
<li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>
<li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li>
</ul>
<p><strong>5）高阶组件</strong></p>
<p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p>
<p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p>
<p><strong>6）构建工具</strong></p>
<p>两者都有自己的构建工具：</p>
<ul>
<li>React ==&gt; Create React APP</li>
<li>Vue ==&gt; vue-cli</li>
</ul>
<p><strong>7）跨平台</strong></p>
<ul>
<li>React ==&gt; React Native</li>
<li>Vue ==&gt; Weex</li>
</ul>
<h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul>
<li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li>
<li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>
<li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li>
<li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li>
<li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>
<li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li>
<li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li>
</ul>
<h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p>
<p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p>
<p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>
<h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul>
<li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li>
<li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li>
</ul>
<h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p>
<p>解决方式：</p>
<ul>
<li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li>
</ul>
<pre><code class="javascript">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象
复制代码
</code></pre>
<ul>
<li>调用以下几个数组的方法</li>
</ul>
<pre><code class="javascript">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()
复制代码
</code></pre>
<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p>
<p>vm.<code>$set</code> 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul>
<li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li>
<li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li>
<li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li>
</ul>
<h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<ul>
<li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li>
<li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li>
<li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li>
</ul>
<h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>
<p>SSR的优势：</p>
<ul>
<li>更好的SEO</li>
<li>首屏加载速度更快</li>
</ul>
<p>SSR的缺点：</p>
<ul>
<li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li>
<li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li>
<li>更多的服务端负载。</li>
</ul>
<h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p>
<ul>
<li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li>
<li>v-if和v-for不能连用</li>
<li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li>
<li>SPA 页面采用keep-alive缓存组件</li>
<li>在更多的情况下，使用v-if替代v-show</li>
<li>key保证唯一</li>
<li>使用路由懒加载、异步组件</li>
<li>防抖、节流</li>
<li>第三方模块按需导入</li>
<li>长列表滚动到可视区域动态加载</li>
<li>图片懒加载</li>
</ul>
<p><strong>（2）SEO优化</strong></p>
<ul>
<li>预渲染</li>
<li>服务端渲染SSR</li>
</ul>
<p><strong>（3）打包优化</strong></p>
<ul>
<li>压缩代码</li>
<li>Tree Shaking/Scope Hoisting</li>
<li>使用cdn加载第三方模块</li>
<li>多线程打包happypack</li>
<li>splitChunks抽离公共文件</li>
<li>sourceMap优化</li>
</ul>
<p><strong>（4）用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li>PWA</li>
<li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>
</ul>
<h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
<h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p>
<p>首先：在css里加上以下代码：</p>
<pre><code class="javascript">[v-cloak] &#123;    display: none;&#125;
复制代码
</code></pre>
<p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p>
<h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
<pre><code class="javascript">// 创建组件构造器let Component = Vue.extend(&#123;  template: &#39;&lt;div&gt;test&lt;/div&gt;&#39;&#125;)// 挂载到 #app 上new Component().$mount(&#39;#app&#39;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123;    created() &#123;        console.log(1)    &#125;&#125;)new SuperComponent().$mount(&#39;#app&#39;)
复制代码
</code></pre>
<h3 id="41-mixin-和-mixins-区别"><a href="#41-mixin-和-mixins-区别" class="headerlink" title="41. mixin 和 mixins 区别"></a>41. mixin 和 mixins 区别</h3><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<pre><code class="javascript">Vue.mixin(&#123;    beforeCreate() &#123;        // ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    &#125;&#125;)
复制代码
</code></pre>
<p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p>
<p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p>
<h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点?"></a>42. <strong>MVVM</strong>的优缺点?</h3><p>优点:</p>
<ul>
<li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li>
<li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li>
<li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li>
</ul>
<p>缺点:</p>
<ul>
<li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li>
<li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li>
<li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li>
</ul>
<h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p>
<ol>
<li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li>
<li><strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li>
<li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li>
<li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li>
<li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li>
<li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li>
<li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li>
</ol>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>
<h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p>
<ol>
<li>父组件 beforeCreate</li>
<li>父组件 created</li>
<li>父组件 beforeMount</li>
<li>子组件 beforeCreate</li>
<li>子组件 created</li>
<li>子组件 beforeMount</li>
<li>子组件 mounted</li>
<li>父组件 mounted</li>
</ol>
<p><strong>更新过程：</strong></p>
<ol>
<li>父组件 beforeUpdate</li>
<li>子组件 beforeUpdate</li>
<li>子组件 updated</li>
<li>父组件 updated</li>
</ol>
<p><strong>销毁过程：</strong></p>
<ol>
<li>父组件 beforeDestroy</li>
<li>子组件 beforeDestroy</li>
<li>子组件 destroyed</li>
<li>父组件 destoryed</li>
</ol>
<h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul>
<li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>
</ul>
<h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 </p>
<p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li>
<li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>
</ul>
<h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>
<p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p>
<p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p>
<h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p>
<h3 id="（1）-props-emit"><a href="#（1）-props-emit" class="headerlink" title="（1） props  /  $emit"></a>（1） props  /  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p>
<h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul>
<li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li>
<li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li>
<li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li>
</ul>
<pre><code class="javascript">// 父组件
&lt;template&gt;
    &lt;div id=&quot;father&quot;&gt;
        &lt;son :msg=&quot;msgData&quot; :fn=&quot;myFunction&quot;&gt;&lt;/son&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import son from &quot;./son.vue&quot;;
export default &#123;
    name: father,
    data() &#123;
        msgData: &quot;父组件数据&quot;;
    &#125;,
    methods: &#123;
        myFunction() &#123;
            console.log(&quot;vue&quot;);
        &#125;
    &#125;,
    components: &#123;
        son
    &#125;
&#125;;
&lt;/script&gt;
复制代码
// 子组件
&lt;template&gt;
    &lt;div id=&quot;son&quot;&gt;
        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;
        &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
    name: &quot;son&quot;,
    props: [&quot;msg&quot;, &quot;fn&quot;]
&#125;;
&lt;/script&gt;
复制代码
</code></pre>
<h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul>
<li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li>
</ul>
<pre><code class="javascript">// 父组件
&lt;template&gt;
  &lt;div class=&quot;section&quot;&gt;
    &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt;
    &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import comArticle from &#39;./test/article.vue&#39;
export default &#123;
  name: &#39;comArticle&#39;,
  components: &#123; comArticle &#125;,
  data() &#123;
    return &#123;
      currentIndex: -1,
      articleList: [&#39;红楼梦&#39;, &#39;西游记&#39;, &#39;三国演义&#39;]
    &#125;
  &#125;,
  methods: &#123;
    onEmitIndex(idx) &#123;
      this.currentIndex = idx
    &#125;
  &#125;
&#125;
&lt;/script&gt;
复制代码
//子组件
&lt;template&gt;
  &lt;div&gt;
    &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  props: [&#39;articles&#39;],
  methods: &#123;
    emitIndex(index) &#123;
      this.$emit(&#39;onEmitIndex&#39;, index) // 触发父组件的方法，并传递参数index
    &#125;
  &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit / $on）"></a>（2）eventBus事件总线（<code>$emit / $on</code>）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下： <strong>（1）创建事件中心管理组件之间的通信</strong></p>
<pre><code class="javascript">// event-bus.js

import Vue from &#39;vue&#39;
export const EventBus = new Vue()
复制代码
</code></pre>
<p><strong>（2）发送事件</strong> 假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;first-com&gt;&lt;/first-com&gt;
    &lt;second-com&gt;&lt;/second-com&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import firstCom from &#39;./firstCom.vue&#39;
import secondCom from &#39;./secondCom.vue&#39;
export default &#123;
  components: &#123; firstCom, secondCom &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<p>在<code>firstCom</code>组件中发送事件：</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;add&quot;&gt;加法&lt;/button&gt;    
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &#39;./event-bus.js&#39; // 引入事件中心

export default &#123;
  data()&#123;
    return&#123;
      num:0
    &#125;
  &#125;,
  methods:&#123;
    add()&#123;
      EventBus.$emit(&#39;addition&#39;, &#123;
        num:this.num++
      &#125;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<p><strong>（3）接收事件</strong> 在<code>secondCom</code>组件中发送事件：</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;求和: &#123;&#123;count&#125;&#125;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; EventBus &#125; from &#39;./event-bus.js&#39;
export default &#123;
  data() &#123;
    return &#123;
      count: 0
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&#39;addition&#39;, param =&gt; &#123;
      this.count = this.count + param.num;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p>
<p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p>
<h3 id="（3）依赖注入（provide-inject）"><a href="#（3）依赖注入（provide-inject）" class="headerlink" title="（3）依赖注入（provide / inject）"></a>（3）依赖注入（provide / inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p>
<p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p>
<ul>
<li><code>provide</code> 钩子用来发送数据或方法</li>
<li><code>inject</code>钩子用来接收数据或方法</li>
</ul>
<p>在父组件中：</p>
<pre><code class="javascript">provide() &#123; 
    return &#123;     
        num: this.num  
    &#125;;
&#125;
复制代码
</code></pre>
<p>在子组件中：</p>
<pre><code class="javascript">inject: [&#39;num&#39;]
复制代码
</code></pre>
<p>还可以这样写，这样写就可以访问父组件中的所有属性：</p>
<pre><code class="javascript">provide() &#123;
 return &#123;
    app: this
  &#125;;
&#125;
data() &#123;
 return &#123;
    num: 1
  &#125;;
&#125;

inject: [&#39;app&#39;]
console.log(this.app.num)
复制代码
</code></pre>
<p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p>
<h3 id="（3）ref-refs"><a href="#（3）ref-refs" class="headerlink" title="（3）ref / $refs"></a>（3）ref / $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p>
<p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p>
<p>在子组件中：</p>
<pre><code class="javascript">export default &#123;
  data () &#123;
    return &#123;
      name: &#39;JavaScript&#39;
    &#125;
  &#125;,
  methods: &#123;
    sayHello () &#123;
      console.log(&#39;hello&#39;)
    &#125;
  &#125;
&#125;
复制代码
</code></pre>
<p>在父组件中：</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;child ref=&quot;child&quot;&gt;&lt;/component-a&gt;
&lt;/template&gt;
&lt;script&gt;
  import child from &#39;./child.vue&#39;
  export default &#123;
    components: &#123; child &#125;,
    mounted () &#123;
      console.log(this.$refs.child.name);  // JavaScript
      this.$refs.child.sayHello();  // hello
    &#125;
  &#125;
&lt;/script&gt;
复制代码
</code></pre>
<h3 id="（4）-parent-children"><a href="#（4）-parent-children" class="headerlink" title="（4）$parent / $children"></a>（4）<code>$parent / $children</code></h3><ul>
<li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li>
<li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li>
</ul>
<p>在子组件中：</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;
    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      message: &#39;Vue&#39;
    &#125;
  &#125;,
  computed:&#123;
    parentVal()&#123;
      return this.$parent.msg;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<p>在父组件中：</p>
<pre><code class="javascript">// 父组件中
&lt;template&gt;
  &lt;div class=&quot;hello_world&quot;&gt;
    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;
    &lt;child&gt;&lt;/child&gt;
    &lt;button @click=&quot;change&quot;&gt;点击改变子组件值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import child from &#39;./child.vue&#39;
export default &#123;
  components: &#123; child &#125;,
  data() &#123;
    return &#123;
      msg: &#39;Welcome&#39;
    &#125;
  &#125;,
  methods: &#123;
    change() &#123;
      // 获取到子组件
      this.$children[0].message = &#39;JavaScript&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。 <strong>需要注意：</strong></p>
<ul>
<li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li>
<li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li>
<li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li>
<li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li>
</ul>
<h3 id="（5）-attrs-listeners"><a href="#（5）-attrs-listeners" class="headerlink" title="（5）$attrs / $listeners"></a>（5）<code>$attrs / $listeners</code></h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p>
<p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p>
<p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p>
<p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p>
<ul>
<li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li>
<li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li>
</ul>
<p>A组件（<code>APP.vue</code>）：</p>
<pre><code class="javascript">&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        //此处监听了两个事件，可以在B组件或者C组件中直接触发 
        &lt;child1 :p-child1=&quot;child1&quot; :p-child2=&quot;child2&quot; @test1=&quot;onTest1&quot; @test2=&quot;onTest2&quot;&gt;&lt;/child1&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Child1 from &#39;./Child1.vue&#39;;
export default &#123;
    components: &#123; Child1 &#125;,
    methods: &#123;
        onTest1() &#123;
            console.log(&#39;test1 running&#39;);
        &#125;,
        onTest2() &#123;
            console.log(&#39;test2 running&#39;);
        &#125;
    &#125;
&#125;;
&lt;/script&gt;
复制代码
</code></pre>
<p>B组件（<code>Child1.vue</code>）：</p>
<pre><code class="javascript">&lt;template&gt;
    &lt;div class=&quot;child-1&quot;&gt;
        &lt;p&gt;props: &#123;&#123;pChild1&#125;&#125;&lt;/p&gt;
        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt;
        &lt;child2 v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/child2&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Child2 from &#39;./Child2.vue&#39;;
export default &#123;
    props: [&#39;pChild1&#39;],
    components: &#123; Child2 &#125;,
    inheritAttrs: false,
    mounted() &#123;
        this.$emit(&#39;test1&#39;); // 触发APP.vue中的test1方法
    &#125;
&#125;;
&lt;/script&gt;
复制代码
</code></pre>
<p>C 组件 (<code>Child2.vue</code>)：</p>
<pre><code class="javascript">&lt;template&gt;
    &lt;div class=&quot;child-2&quot;&gt;
        &lt;p&gt;props: &#123;&#123;pChild2&#125;&#125;&lt;/p&gt;
        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
    props: [&#39;pChild2&#39;],
    inheritAttrs: false,
    mounted() &#123;
        this.$emit(&#39;test2&#39;);// 触发APP.vue中的test2方法
    &#125;
&#125;;
&lt;/script&gt;
复制代码
</code></pre>
<p>在上述代码中：</p>
<ul>
<li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li>
<li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li>
</ul>
<h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p>
<ul>
<li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li>
<li>通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li>
<li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li>
</ul>
<p><strong>（2）兄弟组件间通信</strong></p>
<ul>
<li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li>
<li>通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li>
</ul>
<p><strong>（3）任意组件之间</strong></p>
<ul>
<li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li>
</ul>
<p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-11 fetch和axios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/11%20fetch%E5%92%8Caxios/" class="article-date">
  	<time datetime="2022-08-25T02:56:40.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/11%20fetch%E5%92%8Caxios/">
        Vue-fetch&amp;axios
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="fetch-amp-axios"><a href="#fetch-amp-axios" class="headerlink" title="fetch&amp;axios"></a>fetch&amp;axios</h1><p>XMLHttpRequest 是一个设计粗糙的 API，配置和调用方式非常混乱 ，基于事件的异步模型写起来不友好且兼容性不好。</p>
<p>因此我们可以学习去使用fetch&amp;axios。</p>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a>方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>
<p>这种功能以前是使用  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 <code>Service Workers</code>。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。</p>
<p>请注意，<code>fetch</code>规范与<code>jQuery.ajax()</code>主要有三种方式的不同，牢记：</p>
<ul>
<li>当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code>返回的 Promise <strong>不会被标记为 reject，</strong> 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 <code>ok</code> 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li><code>fetch()</code> <strong>不会接受跨域 cookies；</strong>你也不能使用<code>fetch()</code> 建立起跨域会话。其他网站的<code>Set-Cookie</code>头部字段将会被无视。</li>
<li><code>fetch</code> <strong>不会发送 cookies</strong>。除非你使用了<em>credentials</em>的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters">初始化选项</a>。（自2017年8月25日以后，默认的credentials政策变更为<code>same-origin</code>。Firefox也在61.0b13版本中，对默认值进行修改）</li>
<li></li>
</ul>
<h3 id="get方式"><a href="#get方式" class="headerlink" title="get方式"></a>get方式</h3><p>一个基本的 fetch请求设置起来很简单。看看下面的代码：</p>
<pre><code class="js">fetch(&#39;http://example.com/movies.json&#39;).then(response=&gt;response.json()).then(function(myJson) &#123;
    console.log(myJson);
&#125;);
</code></pre>
<p>这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想<code>fetch()</code>到的资源路径，然后返回一个包含响应结果的promise(一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象)。</p>
<p>当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body/json"><code>json()</code></a>方法（在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body"><code>Body</code></a>mixin 中定义，被 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象实现）。</p>
<h3 id="post方式"><a href="#post方式" class="headerlink" title="post方式"></a>post方式</h3><ol>
<li>form编码</li>
</ol>
<pre><code class="js">fetch(&#39;http://example.com/movies.json&#39;,&#123;
    method:&#39;post&#39;,
    headers:&#123;
        &#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;
    &#125;,
    body:&#39;name=retr0&amp;age=1&#39;
&#125;).then(res=&gt;res.json()).then(res=&gt;&#123;
    console.log(res)
&#125;)
</code></pre>
<ol start="2">
<li>json编码</li>
</ol>
<pre><code class="js">fetch(&#39;http://example.com/movies.json&#39;,&#123;
    method:&#39;post&#39;,
    headers:&#123;
        &#39;Content-Type&#39;:&#39;application/json&#39;
    &#125;,
    body:JSON.stringify(&#123;
        name:&#39;retr0&#39;,
        age:12
    &#125;)
&#125;).then(res=&gt;res.json()).then(res=&gt;&#123;
    console.log(res);
&#125;)
</code></pre>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Using npm:</p>
<pre><code>$ npm install axios
</code></pre>
<p>Using bower:</p>
<pre><code>$ bower install axios
</code></pre>
<p>Using yarn:</p>
<pre><code>$ yarn add axios
</code></pre>
<p>Using cdn:</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><pre><code class="js">axios.get(&#39;https://......&#39;).then(res=&gt;&#123;
    console.log(res.data) //数据在res.data中
&#125;)
</code></pre>
<h3 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h3><ol>
<li>form编码</li>
</ol>
<pre><code class="js">axios.post(&#39;https://....&#39;,&#39;name=retr0&amp;age=1&#39;).then(res=&gt;&#123;
    console.log(res.data)
&#125;)
</code></pre>
<ol start="2">
<li>json编码</li>
</ol>
<pre><code class="js">axios.post(&#39;https://...&#39;,&#123; //第二个参数直接传对象，不需要JSON.stringify()
    name:&#39;retr0&#39;,
    age:1
&#125;).then(res=&gt;&#123;
    console.log(res.data)
&#125;)
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-10 Mixins" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/10%20Mixins/" class="article-date">
  	<time datetime="2022-08-25T02:56:26.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/10%20Mixins/">
        Vue-Mixins
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h1><ul>
<li><p><strong>类型</strong>：<code>Array</code></p>
</li>
<li><p><strong>详细</strong>：</p>
<p><code>mixins</code> 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 <code>Vue.extend()</code> 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。</p>
<p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p>
</li>
<li><p><strong>示例</strong>：</p>
<pre><code class="html">&lt;body&gt;
    &lt;div id=&quot;box&quot;&gt;
        &lt;button @click=&#39;getName&#39;&gt;click&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="js">// 定义一个混入对象
let myMixin = &#123;
    methods:&#123;
        getName()&#123;
            console.log(1)
        &#125;
    &#125;
&#125;
new Vue(&#123;
    el:&#39;#box&#39;,
    mixins:[myMixin]
&#125;)
</code></pre>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/mixins.html">混入</a></p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/12/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/14/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>