<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/11/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-12 react-router" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/12%20react-router/" class="article-date">
  	<time datetime="2022-08-25T03:08:06.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/12%20react-router/">
        React-react-router路由
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p>React Router 是一个基于 <a target="_blank" rel="noopener" href="http://facebook.github.io/react/">React</a> 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="j">npm i --save react-router-dom
</code></pre>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><pre><code class="js">import &#123;HashRouter as Router,Route,Redirect,Switch,Link&#125; from &#39;react-router-dom&#39;
</code></pre>
<h2 id="定义路由及重定向"><a href="#定义路由及重定向" class="headerlink" title="定义路由及重定向"></a>定义路由及重定向</h2><pre><code class="jsx">const MyRouter = ()=&gt;(
    &lt;Router&gt;
        &lt;Switch&gt;
            &lt;Route path=&#39;/home&#39; component=&#123;Home&#125;&gt;&lt;/Route&gt;
             &lt;Route path=&#39;/user&#39; component=&#123;User&#125;&gt;&lt;/Route&gt;
             &lt;Redirect from=&#39;/&#39; to=&#39;/home&#39; exact &gt;&lt;/Redirect&gt;
        &lt;/Switch&gt;
    &lt;/Router&gt;
)
</code></pre>
<h3 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h3><p>注意事项：exact 精确匹配 (Redirect 即使使用了exact, 外面还要嵌套Switch 来用)</p>
<h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>注意事项：Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack,这个警告只有在hash 模式会出现。在NavLink 加上 replace 来解决</p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><pre><code class="jsx">const MyRouter = ()=&gt;(
    &lt;Router&gt;
        &lt;Switch&gt;
            &lt;Route path=&#39;/home&#39; component=&#123;Home&#125;&gt;&lt;/Route&gt;
             &lt;Route path=&#39;/user&#39; component=&#123;User&#125;&gt;&lt;/Route&gt;
             &lt;Route path=&#39;/right&#39; render=&#123;()=&gt;(
                    &lt;Right&gt;
                        &lt;Route path=&#39;/right/roles&#39; component=&#123;Roles&#125;&gt;&lt;/Route&gt;
                        &lt;Route path=&#39;/right/find&#39; component=&#123;Find&#125;&gt;&lt;/Route&gt;
                    &lt;/Right&gt;
                )&#125;&lt;/Route&gt;
             &lt;Redirect from=&#39;/&#39; to=&#39;/home&#39; exact &gt;&lt;/Redirect&gt;
        &lt;/Switch&gt;
    &lt;/Router&gt;
)
</code></pre>
<h2 id="路由跳转方式"><a href="#路由跳转方式" class="headerlink" title="路由跳转方式"></a>路由跳转方式</h2><p>声明式导航</p>
<pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import &#123;NavLink&#125; from &#39;react-router-dom&#39;
export default class Right extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;NavLink to=&#39;/right/roles&#39;&gt;roles&lt;/NavLink&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;NavLink to=&#39;/right/find&#39;&gt;find&lt;/NavLink&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><pre><code class="js">handleClick = (data)=&gt;&#123;
    this.props.history.push(`/right/preview/$&#123;data&#125;`)
&#125;
</code></pre>
<pre><code class="jsx">&lt;Route path=&#39;/home/:id&#39;&gt;&lt;/Route&gt;
</code></pre>
<pre><code class="jsx">&lt;div&gt;&#123;this.props.match.params.id&#125;&lt;/div&gt;
</code></pre>
<h2 id="路由匹配原理"><a href="#路由匹配原理" class="headerlink" title="路由匹配原理"></a>路由匹配原理</h2><p><a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#route">路由</a>拥有三个属性来决定是否“匹配“一个 URL：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteMatching.html#nesting">嵌套关系</a> 和</li>
<li>它的 <a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteMatching.html#path-syntax"><code>路径语法</code></a></li>
<li>它的 <a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteMatching.html#precedence">优先级</a></li>
</ol>
<h3 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h3><p>React Router 使用路由嵌套的概念来让你定义 view 的嵌套集合，当一个给定的 URL 被调用时，整个集合中（命中的部分）都会被渲染。嵌套路由被描述成一种树形结构。React Router 会深度优先遍历整个<a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#routeconfig">路由配置</a>来寻找一个与给定的 URL 相匹配的路由。</p>
<h3 id="路径语法"><a href="#路径语法" class="headerlink" title="路径语法"></a>路径语法</h3><p>路由路径是匹配一个（或一部分）URL 的 <a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#routepattern">一个字符串模式</a>。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p>
<ul>
<li><code>:paramName</code> – 匹配一段位于 <code>/</code>、<code>?</code> 或 <code>#</code> 之后的 URL。 命中的部分将被作为一个<a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#params">参数</a></li>
<li><code>()</code> – 在它内部的内容被认为是可选的</li>
<li><code>*</code> – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 <code>splat</code> <a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#params">参数</a></li>
</ul>
<pre><code class="js">&lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg
</code></pre>
<p>如果一个路由使用了相对<code>路径</code>，那么完整的路径将由它的所有祖先节点的<code>路径</code>和自身指定的相对<code>路径</code>拼接而成。<a target="_blank" rel="noopener" href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteConfiguration.html#decoupling-the-ui-from-the-url">使用绝对<code>路径</code></a>可以使路由匹配行为忽略嵌套关系。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>最后，路由算法会根据定义的顺序自顶向下匹配路由。因此，当你拥有两个兄弟路由节点配置时，你必须确认前一个路由不会匹配后一个路由中的<code>路径</code>。例如，千万<strong>不要</strong>这么做：</p>
<pre><code class="js">&lt;Route path=&quot;/comments&quot; ... /&gt;
&lt;Redirect from=&quot;/comments&quot; ... /&gt;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-11 slot" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/11%20slot/" class="article-date">
  	<time datetime="2022-08-25T03:07:38.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/11%20slot/">
        React-slot插槽
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h1><p>插槽的应用场景大致分为2种：</p>
<h2 id="子组件通信-this-props-children"><a href="#子组件通信-this-props-children" class="headerlink" title="子组件通信-this.props.children"></a>子组件通信-this.props.children</h2><p>插槽可以很好地把按钮的事件处理函数留在父组件，但是插槽又可以将按钮插入子组件，非常方便的实现了2个子组件之间的通信</p>
<pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;

class Navbar extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &#123;this.props.children&#125;
            &lt;/div&gt;
        )
    &#125;
&#125;

class Sidebar extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                Sidebar
            &lt;/div&gt;
        )
    &#125;
&#125;

export default class App extends Component &#123;
    state= &#123;
        isShow:true
    &#125;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;Navbar&gt;
                    &lt;button onClick=&#123;()=&gt;&#123;
                            this.setState(&#123;
                                isShow:!this.state.isShow
                            &#125;)
                        &#125;&#125;&#125;&gt;&lt;/button&gt;
                &lt;/Navbar&gt;
                &#123;
                    this.state.isShow?&lt;Sidebar/&gt;:null
                &#125;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<h2 id="嵌套路由-this-props-children"><a href="#嵌套路由-this-props-children" class="headerlink" title="嵌套路由-this.props.children"></a>嵌套路由-this.props.children</h2><p>插槽可以很好地时间路由配置中，在父路由js中通过{this.props.children}实现子路由的插入</p>
<p>router.js</p>
<pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import &#123;HashRouter as Router,Route,Redirect,Switch&#125; from &#39;react-router-dom&#39;
import Home from &#39;....&#39;
import Homelist from &#39;....&#39;
import Homenav from &#39;....&#39;
export default class MyRouter extends Component &#123;
    render () &#123;
        return (
            &lt;Router&gt;
                &lt;Swtich&gt;
                    &lt;Route path=&#39;/home&#39; render=&#123;()=&gt;(
                        &lt;Home&gt;
                              &lt;Route path=&#39;/home/list&#39; compoennt=&#123;Homelist&#125;&gt;&lt;/Route&gt;
                             &lt;Route path=&#39;/home/nav&#39; compoennt=&#123;Homenav&#125;&gt;&lt;/Route&gt;
                        &lt;/Home&gt;
                    )&#125;&gt;&lt;/Route&gt;
                &lt;/Swtich&gt;
            &lt;/Router&gt;
        )
    &#125;
&#125;
</code></pre>
<p>Home.js</p>
<pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
export default class Home extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                Home
                &#123;this.props.children&#125; &#123;//通过this.props.children即可引入路由中定义的component=&#123;&#125;中的组件&#125;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-10 性能优化方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/10%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/" class="article-date">
  	<time datetime="2022-08-25T03:07:14.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/10%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">
        React-性能优化方案
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a>性能优化方案</h1><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>作为一个性能调优函数，控制组件自身或者子组件是否需要更新，尤其在子组件非常多的情况下， 需要进行优化</p>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>PureComponent按以下流程进行操作：</p>
<ol>
<li>比较新props跟旧的props</li>
<li>比较新的state和老的state（值相等,或者对象含有相同的属性、且属性值相等  ）</li>
<li>决定shouldcomponentUpdate 返回true或者false，</li>
<li>从而决定要不要呼叫 render function。</li>
</ol>
<p>注意：如果你的 state 或 props 『永远都会变』，那 PureComponent 并不会比较快，因为 shallowEqual 也需要花时间。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-09 pureComponent" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/09%20pureComponent/" class="article-date">
  	<time datetime="2022-08-25T03:06:58.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/09%20pureComponent/">
        React-pureComponent
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="pureComponent"><a href="#pureComponent" class="headerlink" title="pureComponent"></a>pureComponent</h1><p>React15.3中新加了一个 <code>PureComponent</code> 类，顾名思义， <code>pure</code> 是纯的意思，<code>PureComponent</code> 也就是纯组件，取代其前身 <code>PureRenderMixin</code> ,<code>PureComponent</code> 是优化 <code>React</code> 应用程序最重要的方法之一，易于实施，只要把继承类从 <code>Component</code> 换成 <code>PureComponent</code> 即可，可以减少不必要的 <code>render</code> 操作的次数，从而提高性能，而且可以少写 <code>shouldComponentUpdate</code> 函数，节省了点代码。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当组件更新时，如果组件的 <code>props</code> 和 <code>state</code> 都没发生改变，<code>render</code> 方法就不会触发，省去 <code>Virtual DOM</code> 的生成和比对过程，达到提升性能的目的。具体就是 <code>React</code> 自动帮我们做了一层浅比较：</p>
<pre><code class="jsx">if (this._compositeType === CompositeTypes.PureClass) &#123;
  shouldUpdate = !shallowEqual(prevProps, nextProps)
  || !shallowEqual(inst.state, nextState);
&#125;
</code></pre>
<p>而 <code>shallowEqual</code> 又做了什么呢？会比较 <code>Object.keys(state | props)</code> 的长度是否一致，每一个 <code>key</code>是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</p>
<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="易变数据不能使用一个引用"><a href="#易变数据不能使用一个引用" class="headerlink" title="易变数据不能使用一个引用"></a>易变数据不能使用一个引用</h3><p>案例：</p>
<pre><code class="jsx">class App extends PureComponent &#123;
  state = &#123;
    items: [1, 2, 3]
  &#125;
  handleClick = () =&gt; &#123;
    const &#123; items &#125; = this.state;
    items.pop();
    this.setState(&#123; items &#125;);
  &#125;
  render() &#123;
    return (&lt; div&gt;
      &lt; ul&gt;
        &#123;this.state.items.map(i =&gt; &lt; li key=&#123;i&#125;&gt;&#123;i&#125;&lt; /li&gt;)&#125;
      &lt; /ul&gt;
      &lt; button onClick=&#123;this.handleClick&#125;&gt;delete&lt; /button&gt;
    &lt; /div&gt;)
  &#125;
&#125;
</code></pre>
<p>会发现，无论怎么点 <code>delete</code> 按钮，<code>li</code>都不会变少，因为用的是一个引用，<code>shallowEqual</code> 的结果为 <code>true</code>。改正：</p>
<pre><code class="jsx">handleClick = () =&gt; &#123;
  const &#123; items &#125; = this.state;
  items.pop();
  this.setState(&#123; items: [].concat(items) &#125;);
&#125;
</code></pre>
<p>这样每次改变都会产生一个新的数组，也就可以 <code>render</code> 了。这里有一个矛盾的地方，如果没有 <code>items.pop();</code> 操作，每次 <code>items</code> 数据并没有变，但还是 <code>render</code> 了，这不就很操蛋么？呵呵，数据都不变，你 <code>setState</code> 干嘛？</p>
<h3 id="不变数据使用一个引用"><a href="#不变数据使用一个引用" class="headerlink" title="不变数据使用一个引用"></a>不变数据使用一个引用</h3><h4 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h4><p>我们在给组件传一个函数的时候，有时候总喜欢:</p>
<pre><code class="jsx">&lt; MyInput onChange=&#123;e =&gt; this.props.update(e.target.value)&#125; /&gt;
//或者
update(e) &#123;
  this.props.update(e.target.value)
&#125;
render() &#123;
  return &lt; MyInput onChange=&#123;this.update.bind(this)&#125; /&gt;
&#125;
</code></pre>
<p>由于每次 <code>render</code> 操作 <code>MyInput</code> 组件的 <code>onChange</code> 属性都会返回一个新的函数，由于引用不一样，所以父组件的 <code>render</code> 也会导致 <code>MyInput</code> 组件的 <code>render</code>，即使没有任何改动，所以需要尽量避免这样的写法，最好这样写：</p>
<pre><code class="jsx">update = (e) =&gt; &#123;
  this.props.update(e.target.value)
&#125;
render() &#123;
  return &lt; MyInput onChange=&#123;this.update&#125; /&gt;
&#125;
</code></pre>
<h4 id="空对象或空数组"><a href="#空对象或空数组" class="headerlink" title="空对象或空数组"></a>空对象或空数组</h4><p>有时候后台返回的数据中，数组长度为0或者对象没有属性会直接给一个 <code>null</code>，这时候我们需要做一些容错：</p>
<pre><code class="jsx">class App extends PureComponent &#123;
  state = &#123;
    items: [&#123; name: &#39;test1&#39; &#125;, null, &#123; name: &#39;test3&#39;  &#125;]
  &#125;
  store = (id, value) =&gt; &#123;
    const &#123; items &#125; = this.state;
    items[id]  = assign(&#123;&#125;, items[id], &#123; name: value &#125;);
    this.setState(&#123; items: [].concat(items) &#125;);
  &#125;
  render() &#123;
    return (&lt; div&gt;
      &lt; ul&gt;
        &#123;this.state.items.map((i, k) =&gt;
          &lt; Item store=&#123;this.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || &#123;&#125;&#125; /&gt;)
        &#125;
      &lt; /ul&gt;
    &lt; /div&gt;)
  &#125;
&#125;
</code></pre>
<p>当某一个子组件调用 <code>store</code> 函数改变了自己的那条属性，触发 <code>render</code> 操作，如果数据是 <code>null</code> 的话 <code>data</code> 属性每次都是一个 <code>&#123;&#125;</code>，<code>&#123;&#125; ==== &#123;&#125;</code> 是 <code>false</code> 的，这样无端的让这几个子组件重新 <code>render</code> 了。</p>
<p>最好设置一个 <code>defaultValue</code> 为 <code>&#123;&#125;</code>,如下：</p>
<pre><code class="jsx">defaultValue = &#123;&#125;
&lt; Item store=&#123;this.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || defaultValue&#125; /&gt;
</code></pre>
<h3 id="复杂状态与简单状态不要共用一个组件"><a href="#复杂状态与简单状态不要共用一个组件" class="headerlink" title="复杂状态与简单状态不要共用一个组件"></a>复杂状态与简单状态不要共用一个组件</h3><p>这点可能和<code>PureComponent</code>没多少关系，但做的不好可能会浪费很多性能，比如一个页面上面一部分是一个复杂的列表，下面是一个输入框，抽象代码：</p>
<pre><code class="jsx">change = (e) =&gt; &#123;
  this.setState(&#123; value: e.target.value &#125;);
&#125;
render() &#123;
  return (&lt; div&gt;
    &lt; ul&gt;
      &#123;this.state.items.map((i, k) =&gt; &lt; li key=&#123;k&#125;&gt; &#123;...&#125;&lt; /li&gt;)&#125;
    &lt; /ul&gt;
    &lt; input value=&#123;this.state.value&#125; onChange=&#123;this.change&#125; /&gt;
  &lt; /div&gt;)
&#125;
</code></pre>
<p>表单和列表其实是没有什么关联的，表单的值也可能经常变动，但它的会给列表也带来必然的<code>diff</code>操作，这是没必要的，最好是给列表抽出成一个单独的 <code>PureComponent</code> 组件，这样 <code>state.items</code> 不变的话，列表就不会重新 <code>render</code> 了。</p>
<h3 id="与shouldComponentUpdate共存"><a href="#与shouldComponentUpdate共存" class="headerlink" title="与shouldComponentUpdate共存"></a>与<code>shouldComponentUpdate</code>共存</h3><p>如果 <code>PureComponent</code> 里有 <code>shouldComponentUpdate</code> 函数的话，直接使用 <code>shouldComponentUpdate</code> 的结果作为是否更新的依据，没有<code>shouldComponentUpdate</code> 函数的话，才会去判断是不是 <code>PureComponent</code> ，是的话再去做 <code>shallowEqual</code>浅比较。</p>
<pre><code class="jsx">// 这个变量用来控制组件是否需要更新
var shouldUpdate = true;
// inst 是组件实例
if (inst.shouldComponentUpdate) &#123;
  shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
&#125; else &#123;
  if (this._compositeType === CompositeType.PureClass) &#123;
    shouldUpdate = !shallowEqual(prevProps, nextProps) ||
      !shallowEqual(inst.state, nextState);
  &#125;
&#125;
</code></pre>
<h3 id="老版本兼容写法"><a href="#老版本兼容写法" class="headerlink" title="老版本兼容写法"></a>老版本兼容写法</h3><pre><code class="jsx">import React &#123; PureComponent, Component &#125; from &#39;react&#39;;
class Foo extends (PureComponent || Component) &#123;
  //...
&#125;
</code></pre>
<p>这样在老版本的 <code>React</code> 里也不会挂掉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>PureComponent</code>真正起作用的，只是在一些纯展示组件上，复杂组件用了也没关系，反正<code>shallowEqual</code>那一关就过不了，不过记得 <code>props</code> 和 <code>state</code> 不能使用同一个引用哦。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-08 生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/08%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  	<time datetime="2022-08-25T03:05:50.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/08%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
        React-生命周期
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="https://segmentfault.com/img/bVbrzRm?w=800&h=799" alt="53884612-fa2b0800-4056-11e9-879f-050e0b33e0e9.png?ynotemdtimestamp=1551878671356"></p>
<p><strong>初始化阶段</strong></p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><blockquote>
<p>只能访问this.props和this.state，不允许修改状态和DOM输出</p>
</blockquote>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><blockquote>
<p>render之前最后一次修改状态的机会</p>
</blockquote>
<p>在ssr中 这个方法将会被多次调用，所以会重复触发多少遍，同时在这里如果绑定事件，将无法解绑，导致内存泄漏，变得不够安全高效逐步废弃。</p>
<p>因此需要加上UNSAFE</p>
<pre><code class="jsx">UNSAFE_componentWillMount () &#123;

&#125;
</code></pre>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><blockquote>
<p>成功render并渲染完成真实DOM之后触发，可以修改DOM</p>
</blockquote>
<pre><code>componentWillMount () &#123;

&#125;
</code></pre>
<p><strong>运行中阶段</strong></p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><p>外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求</p>
<h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p><code>UNSAFE_componentWillReceiveProps(nextProps)</code> 在组件接收到新的参数时被触发，当父组件导致子组件更新的时候, 即使接收的 props 并没有变化, 这个函数也会被调用.</p>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>参数是组件接收到的新的 props , 用于比对新的 props 和原有的 props, 用户需要在函数体中调用 setState() 来更新组件的数据.</p>
<pre><code class="jsx">UNSAFE_componentWillReceiveProps(nextProps)&#123;
    if (this.props.currentExercise.id !== nextProps.currentExercise.id)&#123;
        this.setState(&#123;...nextProps.currentExercise&#125;)
    &#125;
&#125;
</code></pre>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><ol>
<li><p>setState()函数在任何情况下都会导致组件重渲染吗？如果setState()中参数还是原来没有发生任何变化的state呢？</p>
</li>
<li><p>如果组件的state没有变化，并且从父组件接受的props也没有变化，那它就一定不会重渲染吗？</p>
</li>
<li><p>如果1，2两种情况下都会导致重渲染，我们该如何避免这种冗余的操作，从而优化性能？</p>
</li>
</ol>
<p><strong>没有导致state的值发生变化的setState是否会导致重渲染 ——【会！】</strong></p>
<p>shouldComponentUpdate是一个性能调优函数，是重渲染时render()函数调用前被调用的函数，它<strong>接受两个参数：nextProps和nextState</strong>，分别表示下一个props和下一个state的值。并且<strong>，当函数返回false时候，阻止接下来的render()函数的调用，阻止组件重渲染</strong>，而返回true时，组件照常重渲染。</p>
<p>nextProps：修改后的属性</p>
<p>nextState：修改后的状态</p>
<p>可以根据状态和参数中的状态的对比，返回true/false来判断是否需要更新</p>
<pre><code>shouldComponentUpdate (nextProps,nextState) &#123;
    return !(this.state.myname === nextState.myname) ||!(this.state.myage === nextState.myage) 
&#125;
</code></pre>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><p>更新前记录DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致状态不太信</p>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;

export default class App extends Component &#123;
  state= &#123;
    myname:&#39;retr0&#39;
  &#125;
  UNSAFE_componentWillUpdate () &#123;
    console.log(&#39;componentWillUpdate&#39;);
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &#123;this.state.myname&#125;
        &lt;button onClick=&#123;()=&gt;&#123;
          this.setState(&#123;
            myname:&#39;xiaoming&#39;
          &#125;)
        &#125;&#125;&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;

export default class App extends Component &#123;
  state= &#123;
    myname:&#39;retr0&#39;
  &#125;
  componentDidUpdate () &#123;
    console.log(&#39;componentDidUpdate&#39;);
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &#123;this.state.myname&#125;
        &lt;button onClick=&#123;()=&gt;&#123;
          this.setState(&#123;
            myname:&#39;xiaoming&#39;
          &#125;)
        &#125;&#125;&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<p><strong>销毁阶段</strong></p>
<h2 id="componentWillUnMount"><a href="#componentWillUnMount" class="headerlink" title="componentWillUnMount"></a>componentWillUnMount</h2><p>用于清除计时器，window.scroll=null等操作</p>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;
class Navar extends Component &#123;
  render () &#123;
    return (
      &lt;div style=&#123;&#123;background:'#f99'&#125;&#125;&gt;
         navbar-&lt;button onClick=&#123;this.handleClick&#125;&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
  handleClick = ()=&gt;&#123;
    this.props.onEvent();
  &#125;
&#125;
class Slidebar extends Component &#123;
  render () &#123;
    return (
      &lt;div style=&#123;&#123;background:'#99f'&#125;&#125;&gt;
        slidebar
        &lt;ul&gt;
          &lt;li&gt;11111&lt;/li&gt;
          &lt;li&gt;22222&lt;/li&gt;
          &lt;li&gt;33333&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  &#125;
  //销毁声明周期
  componentWillUnmount () &#123;
    console.log(&#39;componentWillUnmount&#39;);
  &#125;
&#125;
export default class 子传父 extends Component &#123;
  state = &#123;
    isShow:true
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        App
        &lt;Navar onEvent=&#123;()=&gt;&#123;
          this.setState(&#123;
            isShow : !this.state.isShow
          &#125;)
        &#125;&#125;/&gt;
        &#123;this.state.isShow?&lt;Slidebar/&gt;:&#39;&#39;&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<p><strong>新增</strong></p>
<h2 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps"></a>static getDerivedStateFromProps</h2><p><code>getDerivedStateFromProps</code> 是一个静态方法, 是一个和组件自身”不相关”的角色. 在这个静态方法中, 除了两个默认的位置参数 nextProps 和 currentState 以外, 你无法访问任何组件上的数据。第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子) ，返回一个对象作为新的state，返回null则说明不需要在这里更新state</p>
<h3 id="会被频繁地触发"><a href="#会被频繁地触发" class="headerlink" title="会被频繁地触发"></a>会被频繁地触发</h3><p>无论是组件调用了 setState(), 接收的 props 发生了变化, 或是父组件的更新都会导致子组件上的 <code>getDerivedStateFromProps</code>被触发.</p>
<h3 id="使用的时候必须非常小心"><a href="#使用的时候必须非常小心" class="headerlink" title="使用的时候必须非常小心"></a>使用的时候必须非常小心</h3><p>由于 <code>getDerivedStateFromProps</code> 会在 setState() 后被调用, 并且它的返回值会被用于更新数据. 这意味着你会在 setState() 之后触发 <code>getDerivedStateFromProps</code>, 然后可能意外地再次 “setState()”.</p>
<p><code>getDerivedStateFromProps(nextProps)</code> 函数中的第一个位置参数未必是 “新” 的 props. 在组件内调用了 setState() 时, <code>getDerivedStateFromProps</code> 会被调用. 但是此时的组件其实并没有获得 “新” 的 props, 是的, 这个 nextProps 的值和原来的 props 是一样的.</p>
<p>这就导致了我们在使用 <code>getDerivedStateFromProps</code> 时, 必须添加很多逻辑判断语句来处理 props 上的更新和 state 上的更新, 避免意外地返回了一个 Updater 再次更新数据, 导致数据异常.</p>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;

class Child extends Component &#123;
  state=&#123;
    ajax:&#39;&#39;
  &#125;
  // UNSAFE_componentWillReceiveProps () &#123;
  //   console.log(&#39;componentWillReceiveProps&#39;);
  // &#125;
  componentDidUpdate () &#123;
    console.log(this.state.ajax);
  &#125;
  static getDerivedStateFromProps (nextProps,currentState)&#123;
    return &#123;
      ajax:nextProps.ajax
    &#125;
  &#125;
  render () &#123;
    return (
      &lt;div&gt;
        child - &#123;this.props.ajax&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;

export default class App extends Component &#123;
  state= &#123;
    ajax:9000
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;Child ajax=&#123;this.state.ajax&#125;/&gt;
        &lt;button onClick=&#123;()=&gt;&#123;
          this.setState(&#123;
            ajax:1000
          &#125;)
        &#125;&#125;&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="更优雅的做法"><a href="#更优雅的做法" class="headerlink" title="更优雅的做法"></a>更优雅的做法</h3><p>React 官方博客中提供了以下几种方案:</p>
<ol>
<li>让表单控件变成完全受控组件, 不论是 onChange 处理函数还是 value 都由父组件控制, 这样用户无需再考虑这个组件 props 的变化和 state 的更新.</li>
</ol>
<pre><code class="jsx">function EmailInput(props) &#123;
  return &lt;input onChange=&#123;props.onChange&#125; value=&#123;props.email&#125; /&gt;;
&#125;
</code></pre>
<ol start="2">
<li>让表单控件变成完全不受控组件, 但是具有 key 属性.<br> 仍然用自身的数据来控制 value. 但是接收 props 中的某个字段作为 key 属性的值, 以此响应 props 的更新: 当 key 的值变化时 React 会替换 (reset)组件, 从而重新生成初始化数据.</li>
</ol>
<blockquote>
<p>When a key changes, React will create a new component instance rather than update the current one.</p>
</blockquote>
<p>示例代码:</p>
<pre><code class="jsx">//组件内的代码
class EmailInput extends Component &#123;
  state = &#123; email: this.props.defaultEmail &#125;;

  handleChange = event =&gt; &#123;
    this.setState(&#123; email: event.target.value &#125;);
  &#125;;

  render() &#123;
    return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;
  &#125;
&#125;
</code></pre>
<pre><code class="kotlin">// 在父组件中接收 props 中的数据作为 key
&lt;EmailInput
  defaultEmail=&#123;this.props.user.email&#125;
  key=&#123;this.props.user.id&#125;
/&gt;
</code></pre>
<ul>
<li>其他方法请参考 <a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#alternative-1-reset-uncontrolled-component-with-an-id-prop">这里</a></li>
</ul>
<h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>取代了 componetWillUpdate ,触发时间为update发生的时候，在<code>render之后,dom渲染之前</code>返回一个值，作为componentDidUpdate的第三个参数。</p>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;

export default class App extends Component &#123;
  state = &#123;
    mytext :&#39;retr0&#39;,
  &#125;
  // componentWillUpdate () &#123;
  //   console.log(this.state.mytext);
  // &#125;
  getSnapshotBeforeUpdate () &#123;
    console.log(this.state.mytext,&#39;获取滚动条的位置&#39;);
    return &#123;
      y:100
    &#125;
  &#125;
  componentDidUpdate(prevProps, prevState,data) &#123;
    console.log(prevProps,prevState,data);
  &#125;
  
  render() &#123;
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        &#123;this.state.mytext&#125;
        &lt;button onClick=&#123;()=&gt;&#123;
          this.setState(&#123;
            mytext:&#39;xiaoming&#39;
          &#125;)
        &#125;&#125;&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-07 context" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/07%20context/" class="article-date">
  	<time datetime="2022-08-25T03:05:30.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/07%20context/">
        React-Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="context"><a href="#context" class="headerlink" title="context"></a>context</h1><blockquote>
<p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p>
</blockquote>
<p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>跨组件访问数据</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>react组件树种某个<strong>上级组件shouldComponetUpdate返回false</strong>,当 context更新时，<strong>不会引起下级组件更新</strong></p>
<h2 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h2><pre><code>const MyContext = React.createContext(defaultValue);
</code></pre>
<p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p>
<p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a><code> </code></h3><h2 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h2><pre><code>&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;
</code></pre>
<p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p>
<p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>
<p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p>
<p>通过新旧值检测来确定变化，使用了与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code></a> 相同的算法。</p>
<h2 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h2><p>注意：Context.Consumer内必须是回调函数，通过context方法改变根组件状态</p>
<pre><code>&lt;MyContext.Consumer&gt;
  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;
&lt;/MyContext.Consumer&gt;
</code></pre>
<p>这里，React 组件也可以订阅到 context 变更。这能让你在<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/components-and-props.html#function-and-class-components">函数式组件</a>中完成订阅 context。</p>
<p>这需要<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child）</a>这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 <code>value</code> 值等同于往上组件树离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
const myContext = React.createContext()

class Child extends Component&#123;
  UNSAFE_componentWillUpdate ()&#123;
    console.log(&#39;componentWillUpdate1&#39;);
  &#125;
  componentDidUpdate () &#123;
    console.log(&#39;componentDidUpdate1&#39;);
  &#125;
  render () &#123;
    return (
      &lt;myContext.Consumer&gt;
        &#123;
          context=&gt;(
            &lt;div&gt;
              child -- &#123;context.myname&#125; -- &#123;context.age&#125;  -- &#123;context.sex&#125;
              &lt;button onClick=&#123;this.handleClick.bind(this,context)&#125;&gt;change&lt;/button&gt;
            &lt;/div&gt;
          )
        &#125;
      &lt;/myContext.Consumer&gt;
    )
  &#125;
  handleClick = (context)=&gt;&#123;
    context.changeState(&#39;xiaoming&#39;)
  &#125;
&#125;

export default class App extends Component &#123;
  state=&#123;
    myname:&#39;retr0&#39;
  &#125;
  UNSAFE_componentWillUpdate ()&#123;
    console.log(&#39;componentWillUpdate&#39;);
  &#125;
  componentDidUpdate () &#123;
    console.log(&#39;componentDidUpdate&#39;);
  &#125;
  shouldComponentUpdate (nextProps,nextState) &#123;
    return !(this.state.myname===nextState.myname)
  &#125;
  changeState = (data)=&gt;&#123;
    this.setState(&#123;
      myname:data
    &#125;)
  &#125;
  render () &#123;
    return (
      &lt;myContext.Provider value=&#123;&#123;
        myname:this.state.myname,
        age:12,
        sex:1,
        changeState:this.changeState
      &#125;&#125;&gt;
         &lt;div&gt;
          app
          &lt;Child&gt;&lt;/Child&gt;
        &lt;/div&gt;
      &lt;/myContext.Provider&gt;
    )
  &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-06 ref通信" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/06%20ref%E9%80%9A%E4%BF%A1/" class="article-date">
  	<time datetime="2022-08-25T03:04:52.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/06%20ref%E9%80%9A%E4%BF%A1/">
        React-ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ref通信"><a href="#ref通信" class="headerlink" title="ref通信"></a>ref通信</h1><p>ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)</p>
<pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;

class Navbar extends Component &#123;
        state = &#123;
            mytext = &#39;&#39;
        &#125;
        reset= ()=&gt;&#123;
            this.setState(&#123;
                mytext:&#39;&#39;
            &#125;)
        &#125;
        render () &#123;
            return (
                &lt;div&gt;
                    &lt;input type=&#39;text&#39; onChange=&#123;this.saveText&#125;/&gt;
                &lt;/div&gt;
            )
        &#125;
        saveText= (eve)=&gt;&#123;
            this.setState(&#123;
                mytext:eve.target.value
        &#125;)
    &#125;
&#125;

export default class App extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                 &#123;//建立子组件ref的引用&#125;
                &lt;Navbar ref=&#39;text&#39;/&gt; 
              
                &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt;
            &lt;/div&gt;
        )
    &#125;
    handleClick = ()=&gt;&#123;
        console.log(this.refs.text.state.mytext)&#123;//查询子组件的state&#125;
        this.refs.text.reset()&#123;//调用子组件的方法&#125;
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-05 onEvent" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/05%20onEvent/" class="article-date">
  	<time datetime="2022-08-25T03:04:34.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/05%20onEvent/">
        React-onEvent通过调用父的函数，实现由子组件控制父组件状态的变化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="onEvent"><a href="#onEvent" class="headerlink" title="onEvent"></a>onEvent</h1><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;

class Navbar extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt;
            &lt;/div&gt;
        )
    &#125;
    handleClick = ()=&gt;&#123;
        this.props.onEvent() //通过调用父的函数，实现由子组件控制父组件状态的变化
    &#125;
&#125;

class Slidebar extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;ul&gt;
                    &lt;li&gt;1111&lt;/li&gt;
                    &lt;li&gt;2222&lt;/li&gt;
                    &lt;li&gt;3333&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default class App extends Component &#123;
    state = &#123;
        isShow:true
    &#125;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;Navbar onEvent=&#123;()=&gt;&#123;
                        this.setState(&#123;
                            isShow:!this.state.isShow
                        &#125;)
                    &#125;&#125;/&gt;
                &#123;
                    this.state.isShow?&lt;Slidebar&gt;&lt;/Slidebar&gt;:null
                &#125;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-04 props" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/04%20props/" class="article-date">
  	<time datetime="2022-08-25T03:04:06.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/04%20props/">
        React-父子通信-父传子
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><h2 id="父子通信-父传子"><a href="#父子通信-父传子" class="headerlink" title="父子通信-父传子"></a>父子通信-父传子</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;

class Navbar extends Component &#123;
    render () &#123;
        return (
            &lt;button&gt;back&lt;/button&gt;
            &lt;div&gt;Navbar&lt;/div&gt;
            &lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;
        )
    &#125;
&#125;

export default class App extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;Navbar mytitle=&#39;home&#39;&gt;&lt;/Navbar&gt;
                &lt;Navbar mytitle=&#39;list&#39;&gt;&lt;/Navbar&gt;
                &lt;Navbar mytitle=&#39;shopbar&#39;&gt;&lt;/Navbar&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><ol>
<li>引入’prop-types’模块</li>
<li>利用static声明符定义类属性</li>
<li>在类中定义一个属性：propTypes，值为一个对象</li>
</ol>
<pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import MyPropType from &#39;prop-types&#39;

class Navbar extends Component &#123;
   static propTypes = &#123;
       isShow:MyPropType.bool,
       mytitle:MyPropType.string
   &#125;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;button&gt;left&lt;/button&gt;
                &lt;div&gt;Navbar&lt;/div&gt;
                &#123;
                    this.props.isShow?&lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;:null
                &#125;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default class App extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;Navbar mytitle=&#39;home&#39; isShow=&#123;true&#125;/&gt;
                &lt;Navbar mytitle=&#39;list&#39; isShow=&#123;false&#125;/&gt;
                &lt;Navbar mytitle=&#39;shopbar&#39; isShow=&#123;&#39;false&#39;&#125;/&gt;
                &#123;//这里传入的是字符串而非布尔值&#125;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<h2 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import MyPropTypes from &#39;prop-types&#39;

class Navbar extends Component &#123;
    static propTypes = &#123;
        mytitle:MyPropTypes.string
    &#125;
    static defaultProps = &#123;
        mytitle:&#39;Click&#39;
    &#125;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;button&gt;left&lt;/button&gt;
                &lt;div&gt;Navbar&lt;/div&gt;
                &lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default class App extends Component &#123;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;Navbar mytitle=&#39;Home&#39;&gt;&lt;/Navbar&gt;
                &lt;Navbar&gt;&lt;/Navbar&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<h2 id="React自带的属性展开语法"><a href="#React自带的属性展开语法" class="headerlink" title="React自带的属性展开语法"></a>React自带的属性展开语法</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import MyPropTypes from &#39;prop-types&#39;

class Navbar extends Component &#123;
    static propTypes = &#123;
        mytitle:MyPropTypes.string,
        myshow:MyPropTypes.bool
    &#125;
    static defaultProps = &#123;
        mytitle:&#39;Click&#39;,
        myshow:true
    &#125;
    render () &#123;
        return (
            &lt;div&gt;
                &lt;button&gt;left&lt;/button&gt;
                &lt;div&gt;Navbar&lt;/div&gt;
                &lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default class App extends Component &#123;
    render () &#123;
        let obj = &#123;
            mytitle:&#39;list&#39;,
            myshow:false
        &#125;
        return (
            &lt;div&gt;
                &lt;Navbar mytitle=&#39;Home&#39;&gt;&lt;/Navbar&gt;
                &lt;Navbar&gt;&lt;/Navbar&gt;
                &lt;Navbar &#123;...obj&#125;/&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/10/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/12/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>