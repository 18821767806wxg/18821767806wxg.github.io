<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/3/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-13 JS的执行和编译过程的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/13%20JS%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.577Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/13%20JS%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-13 JS的执行和编译过程的副本
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><blockquote>
<p>基于事件驱动并独立于平台的脚本/客户端语言</p>
</blockquote>
<h3 id="JS的执行和编译过程"><a href="#JS的执行和编译过程" class="headerlink" title="JS的执行和编译过程"></a>JS的执行和编译过程</h3><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><blockquote>
<ol>
<li><p>没有执行，检查：提升，语法</p>
</li>
<li><p>提升：提升到一个临时空间内，</p>
</li>
<li><p>语法：语法不对，抛出错误，直接终止一切</p>
</li>
</ol>
</blockquote>
<p>提升：提升到一个临时空间内，</p>
<p>语法：语法不对，抛出错误，直接终止一切</p>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><blockquote>
<ol>
<li><p>执行</p>
</li>
<li><p>如果解析器没有遇到报错，并且把所有的提升都做好了，才会执行编译器</p>
</li>
<li><p>当编译器执行时，会先去临时空间中读取要操作的变量，直接使用</p>
</li>
</ol>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-09 JSON的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/09%20JSON%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.564Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/09%20JSON%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-JSON
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote>
<p> JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 </p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ol>
<li>必须是字符</li>
<li>这个字符的格式与js中的数组和对象大体一致</li>
<li>但是如果与对象一致，对象的key必须加双引号</li>
<li>不允许出现没有意义的,号</li>
<li>不允许出现undefined，function，NaN</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>number：和JavaScript的<code>number</code>完全一致；</li>
<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>
<li>string：就是JavaScript的<code>string</code>；</li>
<li>null：就是JavaScript的<code>null</code>；</li>
<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>
<li>object：就是JavaScript的<code>&#123; ... &#125;</code>表示方式。</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code class="js">var xiaoming = &#123;
    name: &#39;小明&#39;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,
    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;]
&#125;;
var s = JSON.stringify(xiaoming);
console.log(s);
</code></pre>
<pre><code class="js">JSON.stringify(xiaoming, null, &#39;  &#39;);//要输出得好看一些，可以加上参数，按缩进输出：
</code></pre>
<ul>
<li><code>JSON.stringify()</code> 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>:</li>
</ul>
<pre><code class="js">JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;  &#39;);
</code></pre>
<ul>
<li>还可以传入一个函数，这样对象的每个键值对都会被函数先处理。</li>
</ul>
<pre><code class="js">function convert(key, value) &#123;
    if (typeof value === &#39;string&#39;) &#123;
        return value.toUpperCase();
    &#125;
    return value;
&#125;

JSON.stringify(xiaoming, convert, &#39;  &#39;);
</code></pre>
<ul>
<li> 给<code>对象</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据： </li>
</ul>
<pre><code class="js">var xiaoming = &#123;
    name: &#39;小明&#39;,
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,
    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;],
    toJSON: function () &#123;
        return &#123; // 只输出name和age，并且改变了key：
            &#39;Name&#39;: this.name,
            &#39;Age&#39;: this.age
        &#125;;
    &#125;
&#125;;

JSON.stringify(xiaoming); // &#39;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#39;
</code></pre>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p> 拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象 。</p>
<pre><code class="js">JSON.parse(&#39;[1,2,3,true]&#39;); // [1, 2, 3, true]
JSON.parse(&#39;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#39;); // Object &#123;name: &#39;小明&#39;, age: 14&#125;
JSON.parse(&#39;true&#39;); // true
JSON.parse(&#39;123.45&#39;); // 123.45
</code></pre>
<p> <code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性： </p>
<pre><code class="js">var obj = JSON.parse(&#39;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#39;, function (key, value) &#123;
    if (key === &#39;name&#39;) &#123;
        return value + &#39;同学&#39;;
    &#125;
    return value;
&#125;);
console.log(JSON.stringify(obj)); // &#123;name: &#39;小明同学&#39;, age: 14&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-08 BOM的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/08%20BOM%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.551Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/08%20BOM%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-BOM
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><blockquote>
<p>浏览器对象模型</p>
</blockquote>
<h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><blockquote>
<p> <code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。 </p>
</blockquote>
<p> <code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于<code>显示网页的净宽高</code>。 </p>
<pre><code class="js">console.log(&#39;window inner size: &#39; + window.innerWidth + &#39; x &#39; + window.innerHeight);
</code></pre>
<p> //<strong>window inner size: 1280 x 613</strong> </p>
<p> 对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以<code>获取浏览器窗口的整个宽高</code>。</p>
<h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><blockquote>
<p><code>navigator</code>对象表示浏览器的信息</p>
</blockquote>
<p>最常用的属性包括：</p>
<h5 id="navigator-appName"><a href="#navigator-appName" class="headerlink" title="navigator.appName"></a>navigator.appName</h5><p>​    浏览器名称</p>
<h5 id="navigator-appVersion"><a href="#navigator-appVersion" class="headerlink" title="navigator.appVersion"></a>navigator.appVersion</h5><p>​    浏览器版本</p>
<h5 id="navigator-language"><a href="#navigator-language" class="headerlink" title="navigator.language"></a>navigator.language</h5><p>​    浏览器设置的语言</p>
<h5 id="navigator-platform"><a href="#navigator-platform" class="headerlink" title="navigator.platform"></a>navigator.platform</h5><p>​    操作系统类型</p>
<h5 id="navigator-userAgent"><a href="#navigator-userAgent" class="headerlink" title="navigator.userAgent"></a>navigator.userAgent</h5><p>​    浏览器设定的<code>User-Agent</code>字符串</p>
<p>请注意，以上属性返回的均为<strong>字符串</strong>`</p>
<p><em>请注意</em>，<code>navigator</code>的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用<code>if</code>判断浏览器版本，例如：</p>
<pre><code class="js">var width;
if (getIEVersion(navigator.userAgent) &lt; 9) &#123;
    width = document.body.clientWidth;
&#125; else &#123;
    width = window.innerWidth;
&#125;
</code></pre>
<p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回<code>undefined</code>的特性，直接用短路运算符<code>||</code>计算：</p>
<pre><code class="js">var width = window.innerWidth || document.body.clientWidth;
</code></pre>
<h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><blockquote>
<p><code>screen</code>对象表示屏幕的信息</p>
</blockquote>
<p>常用的属性有：</p>
<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
<pre><code class="js">console.log(&#39;Screen size = &#39; + screen.width + &#39; x &#39; + screen.height);
</code></pre>
<p>// <strong>Screen size = 1920 x 1080</strong> </p>
<h4 id="history-不推荐使用"><a href="#history-不推荐使用" class="headerlink" title="history//不推荐使用"></a>history//不推荐使用</h4><blockquote>
<p><code>history</code>对象保存了浏览器的历史记录</p>
</blockquote>
<p>JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用<code>history.back()</code>可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用<code>history.back()</code>，试图回到登录前的页面。这是一种错误的方法。</p>
<p>任何情况，你都不应该使用<code>history</code>这个对象了。</p>
<h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><blockquote>
<p>历史记录的个数</p>
</blockquote>
<h5 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h5><blockquote>
<p>back() 方法可加载历史列表中的前一个 URL（如果存在）。</p>
<p>调用该方法的效果等价于点击后退按钮或调用 history.go(-1)。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">history.back()
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">history.back();//回退上一个页面
</code></pre>
</li>
</ul>
<h5 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h5><blockquote>
<p>forward() 方法可加载历史列表中的下一个 URL。</p>
<p>调用该方法的效果等价于点击前进按钮或调用 history.go(1)。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">history.forward();
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">history.forward();//前进一个页面
</code></pre>
</li>
</ul>
<h5 id="go"><a href="#go" class="headerlink" title="go()"></a>go()</h5><blockquote>
<p> go() 方法可加载历史列表中的某个具体的页面。 跳转指定的步数，负为退，正为进，0为刷新</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">history.go(number|URL)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">window.history.go(-1);//回退上一个页面
window.history.go(5);//前进5个页面
</code></pre>
</li>
</ul>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><blockquote>
<p> <code>location</code>对象表示当前页面的URL信息 </p>
</blockquote>
<p>例如一个完整的URL：<a target="_blank" rel="noopener" href="http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</a></p>
<p>可以用<code>location.href</code>获取。要获得URL各个部分的值，可以这么写：</p>
<pre><code class="js">location.protocol; // &#39;http&#39;
location.host; // &#39;www.example.com&#39;
location.port; // &#39;8080&#39;
location.pathname; // &#39;/path/index.html&#39;
location.search; // &#39;?a=1&amp;b=2&#39;
location.hash; // &#39;TOP&#39;
</code></pre>
<p>要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用<code>location.reload()</code>方法非常方便。</p>
<pre><code class="js">if (confirm(&#39;重新加载当前页&#39; + location.href + &#39;?&#39;)) &#123;
    location.reload();
&#125; else &#123;
    location.assign(&#39;/&#39;); // 设置一个新的URL地址
&#125;
</code></pre>
<h5 id="href"><a href="#href" class="headerlink" title="href"></a>href</h5><blockquote>
<p> href 属性是一个可读可写的字符串，可设置或返回当前显示的文档的完整 URL。</p>
<p> 因此，我们可以通过为该属性设置新的 URL，使浏览器读取并显示新的 URL 的内容。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">location.href = URL
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">console.log(location.href);//当前页面完整的URL
</code></pre>
</li>
</ul>
<h5 id="search"><a href="#search" class="headerlink" title="search"></a>search</h5><blockquote>
<p>  search 属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号 ? 之后的部分）。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">location.search = path_from_questionmark
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">console.log(location.href);//返回当前 URL 的查询部分（问号 ? 之后的部分）
</code></pre>
</li>
</ul>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><blockquote>
<p>  hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分） </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">location.hash = anchorname
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">console.log(location.hash);// URL 的锚部分（从 # 号开始的部分）
location.hash = &quot;#3_2&quot;//改变锚点#ID,可以到达指定位置
</code></pre>
</li>
</ul>
<h5 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h5><blockquote>
<p>  reload() 方法用于重新加载当前文档。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">location.reload(force)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">window.location.reload()//刷新页面
</code></pre>
</li>
</ul>
<h5 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h5><blockquote>
<p>  assign() 方法可加载一个新的文档。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">location.assign(URL)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js"> window.location.assign(&quot;http://www.w3school.com.cn&quot;)//重新加载新的网页
 window.location.assign(&quot;&quot;)//刷新页面
</code></pre>
</li>
</ul>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><blockquote>
<p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p>
</blockquote>
<p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>xxx</code>读取的，但是可以动态改变：</p>
<pre><code class="js">document.title = &#39;努力学习JavaScript!&#39;;
</code></pre>
<h5 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h5><blockquote>
<p> 按ID获得一个DOM节点 </p>
</blockquote>
<h5 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h5><blockquote>
<p> 按Tag名称获得一组DOM节点 </p>
</blockquote>
<h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><blockquote>
<p> 可以获取当前页面的Cookie</p>
</blockquote>
<p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p>
<p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p>
<p>JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p>
<pre><code class="js">document.cookie; // &#39;v=123; remember=true; prefer=zh&#39;
</code></pre>
<p>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
<pre><code class="js">&lt;!-- 当前页面在wwwexample.com --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src=&quot;http://www.foo.com/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    ...
&lt;/html&gt;
</code></pre>
<p>如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<code>www.example.com</code>网站的用户登录信息。</p>
<p>为了解决这个问题，服务器在设置Cookie时可以使用<code>httpOnly</code>，设定了<code>httpOnly</code>的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持<code>httpOnly</code>选项，IE从IE6 SP1开始支持。</p>
<p>为了确保安全，服务器端在设置Cookie时，应该始终坚持使用<code>httpOnly</code>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-07 DOM的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/07%20DOM%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.544Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/07%20DOM%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-DOM
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h4><blockquote>
<p> getElementById() 方法可返回对拥有指定 ID 的第一个对象的引用。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">document.getElementById(id)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var c = document.body.children;
</code></pre>
</li>
</ul>
<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h4><blockquote>
<p> getElementsByClassName() 方法可返回带有指定标签名的对象的<strong>集合</strong>。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">document.getElementsByTagName(classname)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var aCont = document.getElementsByClassName(&quot;cont&quot;);//返回的是一个集合
</code></pre>
</li>
</ul>
<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h4><blockquote>
<p> getElementsByTagName() 方法可返回带有指定标签名的对象的<strong>集合</strong>。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">document.getElementsByTagName(tagname)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var aSpan = document.getElementsByTagName(&quot;span&quot;);//返回的是一个集合
</code></pre>
</li>
</ul>
<h4 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h4><blockquote>
<p> getElementsByName() 方法可返回带有指定名称的对象的<strong>集合</strong>。  </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">document.getElementsByName(name)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var x=document.getElementsByName(&quot;myInput&quot;);//返回的是一个集合
</code></pre>
</li>
</ul>
<h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h4><blockquote>
<p> querySelector() 方法返回文档中匹配指定 CSS 选择器的<strong>一个元素</strong>。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">elementList = document.querySelectorAll(selector);
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var ele = document.querySelector(&quot;#box&quot;);
var ele = document.querySelector(&quot;.cont&quot;);
var ele = document.querySelector(&quot;span&quot;);
var ele = document.querySelector(&quot;.msg h2&quot;);
var ele = document.querySelector(&quot;.msg&gt;h2&quot;);
var ele = document.querySelector(&quot;input[name=pass]&quot;);
</code></pre>
</li>
</ul>
<h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h4><blockquote>
<p> querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的<strong>所有元素</strong>，返回NodeList对象。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">elementList = document.querySelectorAll(selectors);
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var ele = document.querySelectorAll(&quot;#box&quot;);
var ele = document.querySelectorAll(&quot;.cont&quot;);
var ele = document.querySelectorAll(&quot;span&quot;);
var ele = document.querySelectorAll(&quot;.msg h2&quot;);
var ele = document.querySelectorAll(&quot;.msg&gt;h2&quot;);
var ele = document.querySelectorAll(&quot;input[name=pass]&quot;);
var ele = document.querySelectorAll(&quot;span,p,input,div,#box,.cont&quot;)
</code></pre>
</li>
</ul>
<h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><h4 id="children"><a href="#children" class="headerlink" title=".children"></a>.children</h4><blockquote>
<p>children 属性返回元素的子元素的集合，是一个 HTMLCollection 对象。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">element.children
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var c = document.body.children;
</code></pre>
</li>
</ul>
<h4 id="parentNode"><a href="#parentNode" class="headerlink" title=".parentNode"></a>.parentNode</h4><blockquote>
<p>parentNode 属性以 Node 对象的形式返回指定节点的父节点。</p>
<p>如果指定节点没有父节点，则返回 null。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.parentNode
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.getElementById(&quot;item1&quot;).parentNode;
</code></pre>
</li>
</ul>
<h4 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title=".firstElementChild"></a>.firstElementChild</h4><blockquote>
<p>firstElementChild 返回指定节点的第一个子元素节点</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var last = oXbox.lastElementChild;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var last = oXbox.lastElementChild;
</code></pre>
</li>
</ul>
<h4 id="lastElementChild"><a href="#lastElementChild" class="headerlink" title=".lastElementChild"></a>.lastElementChild</h4><blockquote>
<p>lastElementChild 返回指定节点的最后一个子元素节点</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var last = oXbox.lastElementChild;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var last = oXbox.lastElementChild;
</code></pre>
</li>
</ul>
<h4 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title=".previousElementSibling"></a>.previousElementSibling</h4><blockquote>
<p> previousElementSibling 属性返回指定元素的前一个兄弟元素（相同节点树层中的前一个元素节点）。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.previousElementSibling
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var x = document.getElementById(&quot;item2&quot;).previousElementSibling.innerHTML;
</code></pre>
</li>
</ul>
<h4 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title=".nextElementSibling"></a>.nextElementSibling</h4><blockquote>
<p> nextElementSibling 属性返回指定元素之后的下一个兄弟元素（相同节点树层中的下一个元素节点）</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.nextElementSibling
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var x = document.getElementById(&quot;item1&quot;).nextElementSibling.innerHTML;
</code></pre>
</li>
</ul>
<h3 id="其他节点选择器"><a href="#其他节点选择器" class="headerlink" title="其他节点选择器"></a>其他节点选择器</h3><h4 id="childNodes"><a href="#childNodes" class="headerlink" title=".childNodes"></a>.childNodes</h4><blockquote>
<p>  <strong>Node.childNodes</strong> 返回包含指定节点的子节点的集合，该集合为即时更新的集合（live collection）</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var ndList = elementNodeReference.childNodes; 
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var child = oxbox.childNodes;
console.log(child);
console.log(child[0]);
console.log(child[1]);
console.log(child[2]);
console.log(child[3]);
</code></pre>
</li>
</ul>
<h4 id="firstChild"><a href="#firstChild" class="headerlink" title=".firstChild"></a>.firstChild</h4><blockquote>
<p> firstChild 属性返回指定节点的首个子节点，以 Node 对象。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var childNode = node.firstChild;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.firstChild;//&lt;!DOCTYPE html&gt;(是一个对象)
</code></pre>
</li>
</ul>
<h4 id="lastChild"><a href="#lastChild" class="headerlink" title=".lastChild"></a>.lastChild</h4><blockquote>
<p> lastChild 属性返回指定节点的最后一个子节点，以 Node 对象。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.lastChild;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.firstChild;//&lt;html&gt;&lt;/html&gt;
</code></pre>
</li>
</ul>
<h4 id="previousSibling"><a href="#previousSibling" class="headerlink" title=".previousSibling"></a>.previousSibling</h4><blockquote>
<p>  返回当前节点的前一个兄弟节点,没有则返回<code>null.</code> </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">previousNode = node.previousSibling
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">// &lt;a&gt;&lt;b1 id=&quot;b1&quot;/&gt;&lt;b2 id=&quot;b2&quot;/&gt;&lt;/a&gt;
alert(document.getElementById(&quot;b1&quot;).previousSibling); // null
alert(document.getElementById(&quot;b2&quot;).previousSibling.id); // &quot;b1&quot;
</code></pre>
</li>
</ul>
<h4 id="nextSibling"><a href="#nextSibling" class="headerlink" title=".nextSibling"></a>.nextSibling</h4><blockquote>
<p>  Node.nextSibling 是一个只读属性，返回其父节点的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/childNodes"><code>childNodes</code></a> 列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回 <code>null</code>。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">nextNode = node.nextSibling
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">// &lt;a&gt;&lt;b1 id=&quot;b1&quot;/&gt;&lt;b2 id=&quot;b2&quot;/&gt;&lt;/a&gt;
alert(document.getElementById(&quot;b1&quot;).nextSibling.id); // &quot;b2&quot;
alert(document.getElementById(&quot;b2&quot;).nextSibling); // null
</code></pre>
</li>
</ul>
<h4 id="attributes"><a href="#attributes" class="headerlink" title=".attributes"></a>.attributes</h4><blockquote>
<p> <code>Element.attributes</code> 属性返回该元素所有属性节点的一个实时集合。该集合是一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/NamedNodeMap"><code>NamedNodeMap</code></a> 对象，不是一个数组，所以它没有 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>数组</code></a> 的方法，其包含的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Attr"><code>属性</code></a> 节点的索引顺序随浏览器不同而不同。更确切地说，<code>attributes</code> 是字符串形式的名/值对，每一对名/值对对应一个属性节点。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var attr = element.attributes;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);
console.log(obox.attributes);
console.log(obox.attributes[0]);
console.log(obox.attributes[1]);
console.log(obox.attributes[2]);
console.log(obox.attributes[3]);
console.log(obox.attributes[3].abc);
console.log(obox.attributes[4]);
</code></pre>
</li>
</ul>
<h3 id="元素的操作"><a href="#元素的操作" class="headerlink" title="元素的操作"></a>元素的操作</h3><h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h4><blockquote>
<p><strong><code>Document.createElement() </code><strong>方法创建由</strong>tagName</strong> 指定的HTML元素，或一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLUnknownElement"><code>HTMLUnknownElement</code></a>，如果tagName不被识别。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">let element = document.createElement(tagName[, options]);
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">新的元素[Element]
</code></pre>
<ul>
<li>element 是创建的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element"><code>Element</code></a>对象。</li>
<li>tagName 指定将要创建的元素类型的字符串。创建的element的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName"><code>nodeName</code></a>会被初始化为tagName的值。该方法不接受带条件的元素名字(例如: html:a)。</li>
<li>options 是一个可选的 ElementCreationOptions 对象. 如果这个对象被定义并赋予了一个 is 特性，则创建的element的 is 属性会被初始化为这个特性的值. 如果这个对象没有 is 特性，则值为空.</li>
</ul>
</li>
<li><p>实例</p>
<pre><code class="js">var mydiv = document.createElement(&quot;div&quot;);//创建了一个div元素节点
</code></pre>
</li>
</ul>
<h4 id="childNode-remove"><a href="#childNode-remove" class="headerlink" title="childNode.remove()"></a>childNode.remove()</h4><blockquote>
<p><code>ChildNode.remove()</code> 方法，把对象从它所属的 DOM 树中删除。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.remove();
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var el = document.getElementById(&#39;div-02&#39;);
el.remove();//&quot;id为&#39;div-02&quot;的元素被删掉了
</code></pre>
<p>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新。删除多个节点时，要注意<code>children</code>属性时刻都在变化。</p>
</li>
</ul>
<h4 id="node-removeChild"><a href="#node-removeChild" class="headerlink" title="node.removeChild()"></a>node.removeChild()</h4><blockquote>
<p><strong>Node.removeChild()</strong> 方法从DOM中删除一个子节点。返回删除的节点。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">let oldChild = node.removeChild(child);
//OR
element.removeChild(child);
</code></pre>
</li>
<li><p>返回值</p>
<p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。<br>因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量取得它的返回值。</p>
</li>
<li><p>实例</p>
<pre><code class="js">// 拿到待删除节点:
var self = document.getElementById(&#39;to-be-removed&#39;);
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
console.log(removed === self )// true
</code></pre>
</li>
</ul>
<h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute()"></a>setAttribute()</h4><blockquote>
<p>  setAttribute() 方法添加指定的属性，并为其赋指定的值。</p>
<p>  如果这个指定的属性已存在，则仅设置/更改值。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">element.setAttribute(attributename,attributevalue)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.getElementsByTagName(&quot;INPUT&quot;)[0].setAttribute(&quot;type&quot;,&quot;button&quot;);
</code></pre>
</li>
</ul>
<h4 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute()"></a>getAttribute()</h4><blockquote>
<p>   getAttribute() 方法返回指定属性名的属性值。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">element.getAttribute(attributename)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.getElementsByTagName(&quot;a&quot;)[0].getAttribute(&quot;target&quot;);//_blank
</code></pre>
</li>
</ul>
<h4 id="removeAttribute"><a href="#removeAttribute" class="headerlink" title="removeAttribute()"></a>removeAttribute()</h4><blockquote>
<p>  removeAttribute() 方法删除指定的属性。</p>
<p>  此方法与 removeAttributeNode() 方法的差异是：removeAttributeNode() 方法删除指定的 Attr 对象，而此方法删除具有指定名称的属性。结果是相同的。同时此方法不返回值，而 removeAttributeNode() 方法返回被删除的属性，以 Attr 对象的形式</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">element.getAttribute(attributename)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.getElementsByTagName(&quot;H1&quot;)[0].removeAttribute(&quot;style&quot;);
</code></pre>
</li>
</ul>
<h4 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h4><p>可见</p>
<ul>
<li><p>作为对象操作（点语法,中括号语法）</p>
<pre><code class="js">var obox = document.getElementsByClassName(&quot;box&quot;)[0];
var a = document.getElementsByTagName(&quot;a&quot;)[0];
var img = document.getElementsByTagName(&quot;img&quot;)[0];
obox.className;
obox[&quot;title&quot;];
obox.id;
a.href;
img.src;
img[&quot;alt&quot;];
</code></pre>
</li>
<li><p>Attribute系列：set，get，remove</p>
<pre><code class="js">console.log(obox.getAttribute(&quot;title&quot;))//可获得内置可见属性
obox.setAttribute(&quot;title&quot;,&quot;123123132&quot;)//可设置内置可见属性
obox.removeAttribute(&quot;title&quot;)//可删除内置可见属性
</code></pre>
</li>
</ul>
<p>不可见</p>
<ul>
<li><p>作为对象操作（点语法,中括号语法）</p>
<pre><code class="js">innerHTML,innerText,tagName
console.log(obox.innerHTML)
console.log(obox.innerText)
console.log(obox.tagName)
obox.tagName = &quot;SPAN&quot;;//不可更改
</code></pre>
</li>
</ul>
<h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p>可见</p>
<ul>
<li><p>Attribute系列：set，get，remove</p>
<pre><code class="js">console.log(obox.abc)
console.log(obox.href)
console.log(obox.getAttribute(&quot;abc&quot;))//可以获得自定义可见属性的值
console.log(obox.getAttribute(&quot;href&quot;))
obox.setAttribute(&quot;qwe&quot;,&quot;hahahahah&quot;)//可以设置或修改自定义可见属性的值
obox.setAttribute(&quot;abc&quot;,&quot;world&quot;)
obox.removeAttribute(&quot;abc&quot;)//可以删除自定义可见属性的值
obox.removeAttribute(&quot;href&quot;)
</code></pre>
</li>
</ul>
<p>不可见</p>
<ul>
<li><p>作为对象操作（点语法,中括号语法）</p>
<pre><code class="js">obox.aaa = &quot;bbb&quot;
console.log(obox.aaa);//bbb
</code></pre>
</li>
</ul>
<h3 id="样式的操作"><a href="#样式的操作" class="headerlink" title="样式的操作"></a>样式的操作</h3><h4 id="element-style"><a href="#element-style" class="headerlink" title="element.style"></a>element.style</h4><blockquote>
<p>由.style设置的所有样式都会以行内样式的形式体现</p>
<p><strong>获取的也是行内样式</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">element.style.attribute =  &quot;&quot;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">obox.style.width = 20 + &quot;px&quot;;
</code></pre>
</li>
</ul>
<h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h4><blockquote>
<p> <code>Window.getComputedStyle()</code>方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。 </p>
<p><strong>注意：该属性只能获取属性不能设置属性</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">let style = window.getComputedStyle(element, [pseudoElt]);//第二个参数是fasle,为true的情况下查看的是元素的伪类或者伪元素
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">返回的style是一个实时的CSSStyleDeclaration对象，当元素的样式更改时，它会自动更新本身。
</code></pre>
</li>
<li><p>实例</p>
</li>
</ul>
<h4 id="element-currentStyle"><a href="#element-currentStyle" class="headerlink" title="element.currentStyle"></a>element.currentStyle</h4><blockquote>
<p> <strong><code>Element.currentStyle</code></strong> 是一个与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a>方法功能相同的属性。这个属性实现在旧版本的IE浏览器（IE8及以下）中。</p>
<p><strong>注意：该属性只能获取属性不能设置属性</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">element.currentStyle.attribute
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">obox.currentStyle.width;
</code></pre>
</li>
</ul>
<h4 id="兼容性获取样式方法"><a href="#兼容性获取样式方法" class="headerlink" title="兼容性获取样式方法"></a>兼容性获取样式方法</h4><pre><code class="js">function getStyle(ele,attr)&#123;
    if(ele.currentStyle)&#123;//判断获取到的是不是true，那么就执行IE的currentStyle，如果是undefined那么就是false，那就执行getComputedStyle()
        return ele.currentStyle[attr];//IE8及以下支持
    &#125;else&#123;
        return getComputedStyle(ele,false)[attr];//其他正常浏览器支持
    &#125;
&#125;
</code></pre>
<h3 id="尺寸类样式的获取"><a href="#尺寸类样式的获取" class="headerlink" title="尺寸类样式的获取"></a>尺寸类样式的获取</h3><h4 id="offsetWidth"><a href="#offsetWidth" class="headerlink" title="offsetWidth"></a>offsetWidth</h4><blockquote>
<p> <strong>HTMLElement.offsetWidth</strong> 是一个只读属性，返回一个元素的布局宽度。一个典型的（译者注：各浏览器的offsetWidth可能有所不同）offsetWidth是测量包含元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值。 </p>
<p> <strong>content+padding+border</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var offsetWidth =element.offsetWidth;
</code></pre>
<p>这个属性将会 round(四舍五入)为一个整数。如果你想要一个fractional(小数)值,请使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>element.getBoundingClientRect()</code></a></p>
</li>
<li><p>分类</p>
<ol>
<li><p>假如元素无padding无滚动无border </p>
<pre><code>offsetWidth = clientWidth = style.width
</code></pre>
</li>
<li><p>假如元素有padding无滚动有border</p>
<pre><code>offsetWidth = style.width + style.padding*2 + border宽度*2
offsetWidth = clientWidth + border宽度*2
</code></pre>
</li>
<li><p>假如元素有padding有滚动，有border，且滚动是显示的 </p>
<pre><code>offsetWidth = style.width + style.padding*2 + (border-width)*2
offsetWidth = clientWidth + 滚轴宽度 + border宽度*2
</code></pre>
<p> <strong>offsetHeight同理</strong> </p>
</li>
</ol>
</li>
<li><p>实例</p>
<pre><code class="js">var wid = obox.offsetWidth;//返回一个整数数值
</code></pre>
<p> <img src="https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png" alt="Image:Dimensions-offset.png"> </p>
</li>
</ul>
<h4 id="offsetHeight"><a href="#offsetHeight" class="headerlink" title="offsetHeight"></a>offsetHeight</h4><blockquote>
<p> <strong><code>HTMLElement.offsetHeight</code></strong> 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。**(content+padding+border)**</p>
<p>通常，元素的offsetHeight是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。</p>
<p>对于文档的body对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。 </p>
<p>如果元素被隐藏（例如 元素或者元素的祖先之一的元素的style.display被设置为none），则返回0</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var intElemOffsetHeight = document.getElementById(id_attribute_value).offsetHeight;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var hei = obox.offsetHeight;//返回一个整数数值
</code></pre>
<p> <img src="https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png" alt="Image:Dimensions-offset.png"></p>
<p> 上面的图片中显示了scollbar和窗口高度的offsetHeight.但是不能滚动的元素可能会有一个很大的高度值，大于可以看见的内容。这些元素原则上是被包含在滚动元素之中的。所以，这些不能滚动的元素可能会因为scrollTop的值会被完全隐藏或者部分隐藏； </p>
</li>
</ul>
<h4 id="clientWidth"><a href="#clientWidth" class="headerlink" title="clientWidth"></a>clientWidth</h4><blockquote>
<p>clientWeight是一个只读属性。尺寸范围为：<strong>padding+content</strong></p>
<p>内联元素以及没有 CSS 样式的元素的 <code>**clientWidth**</code> 属性值为 0。<code>**Element.clientWidth**</code> 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var intElemClientWidth = element.clientWidth;
//intElemClientWidth 是一个整数，表示元素的 clientWidth。
</code></pre>
</li>
<li><p>分类</p>
<ol>
<li><p>假如元素无padding无滚动</p>
<pre><code>clientWidth = style.width
</code></pre>
</li>
<li><p>假如元素有padding无滚动</p>
<pre><code>clientWidth = style.width + style.padding*2
</code></pre>
</li>
<li><p>假如元素有padding有滚动，且滚动是显示的</p>
<pre><code>clientWidth = style.width + style.padding*2 - 滚动轴宽度
</code></pre>
<p><strong>clientHeight同理</strong></p>
</li>
</ol>
</li>
<li><p>实例</p>
<pre><code class="js">var cw = obox.clientWidth;//返回一个整数数值
</code></pre>
<p> <img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="Image:Dimensions-client.png"> </p>
</li>
</ul>
<h4 id="clientHeight"><a href="#clientHeight" class="headerlink" title="clientHeight"></a>clientHeight</h4><blockquote>
<p>clientHeight是一个只读属性。尺寸范围为：<strong>padding+content</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">var intElemClientHeight = element.clientHeight;
//intElemClientHeight 是一个整数，表示元素的 clientHeight。
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var ch = obox.clientHeight;//返回一个整数数值
</code></pre>
<p> <img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="Image:Dimensions-client.png"> </p>
</li>
</ul>
<h4 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h4><blockquote>
<p> <strong>HTMLElement.offsetTop</strong> 为只读属性，它返回当前元素相对于其 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的顶部内边距的距离。 </p>
<p>相对于页面或包含块偏移的位置</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">topPos = element.offsetTop;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var d = document.getElementById(&quot;div1&quot;);
var topPos = d.offsetTop;
 
if (topPos &gt; 10) &#123;
  // div1 距离它的 offsetParent 元素的顶部的距离大于 10 px
&#125;
</code></pre>
</li>
</ul>
<h4 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h4><blockquote>
<p> <strong>HTMLElement.offsetLeft</strong> 为只读属性，它返回当前元素相对于其 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的左边内边距的距离。 </p>
<p>相对于页面或包含块偏移的位置</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">leftPos = element.offsetLeft;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var d = document.getElementById(&quot;div1&quot;);
var topLeft = d.offsetLeft;
 
if (topLeft &gt; 10) &#123;
  // div1 距离它的 offsetParent 元素的顶部的距离大于 10 px
&#125;
</code></pre>
</li>
</ul>
<h4 id="以上属性只能获取不能设置"><a href="#以上属性只能获取不能设置" class="headerlink" title="以上属性只能获取不能设置"></a>以上属性只能获取不能设置</h4><h4 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h4><blockquote>
<p><code>Element.scrollTop</code> 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>
<p>一个元素的 <code>scrollTop</code> 值是这个元素的顶部到视口可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 <code>scrollTop 值为0。</code></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">// 获得滚动的像素数
var  intElemScrollTop = someElement.scrollTop;

// 设置滚动的距离
element.scrollTop = intValue;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.onclick = function()&#123;
    // console.log(obox.scrollTop);
    obox.scrollTop = 666;
&#125;
</code></pre>
<p>​                                 <img src="https://developer.mozilla.org/@api/deki/files/842/=ScrollTop.png" alt="Image:scrollTop.png"></p>
</li>
</ul>
<h4 id="scrolLeft"><a href="#scrolLeft" class="headerlink" title="scrolLeft"></a>scrolLeft</h4><blockquote>
<p><strong><code>Element.scrollLeft</code></strong> 属性可以读取或设置元素滚动条到元素左边的距离。</p>
<p>注意如果这个元素的内容排列方向（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>） 是<code>rtl</code> (right-to-left) ，那么滚动条会位于最右侧（内容开始处），并且scrollLeft值为0。此时，当你从右到左拖动滚动条时，scrollLeft会从0变为负数（这个特性在chrome浏览器中不存在）。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">//获取滚动条到元素左边的距离
var sLeft = element.scrollLeft;

//设置滚动条滚动了多少像素
element.scrollLeft = 10;
</code></pre>
<p><code>scrollLeft</code> 可以是任意整数，然而：</p>
<ul>
<li>如果元素不能滚动（比如：元素没有溢出），那么<code>scrollLeft</code> 的值是0。</li>
<li>如果给<code>scrollLeft</code> 设置的值小于0，那么<code>scrollLeft</code> 的值将变为0。</li>
<li>如果给<code>scrollLeft</code> 设置的值大于元素内容最大宽度，那么<code>scrollLeft</code> 的值将被设为元素最大宽度。</li>
</ul>
</li>
<li><p>实例</p>
<pre><code class="js">document.onclick = function()&#123;
    // console.log(obox.scrollLeft);
    obox.scrollLeft = 666;
&#125;
</code></pre>
<p> <img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="Image:Dimensions-client.png"> </p>
</li>
</ul>
<h3 id="Node类型的操作"><a href="#Node类型的操作" class="headerlink" title="Node类型的操作"></a>Node类型的操作</h3><blockquote>
<p> DOM将任何HTML和XML文档描绘成一个由多层节点构成的结构。有几个不同类型的节点，节点又有各自的特点、数据和方法，同时节点之间存在着某种关系，这些关系构成层次。 </p>
</blockquote>
<p>DOM内的节点分为四种：元素，文本，注释和属性</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>除 IE 之外，在其他所有浏览器中都可以访问到Node类型。<br>JavaScript 中的所有节点类型都继承 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<h4 id="12种节点类型"><a href="#12种节点类型" class="headerlink" title="12种节点类型"></a>12种节点类型</h4><blockquote>
<p><strong>Node.ELEMENT_NODE(1);（常用）            //元素节点</strong><br><strong>Node.ATTRIBUTE_NODE(2);                        //属性节点</strong><br><strong>Node.TEXT_NODE(3);（常用）                    //文本节点</strong><br>Node.CDATA_SECTION_NODE(4);<br>Node.ENTITY_REFERENCE_NODE(5)<br>Node.ENTITY_NODE(6) ;<br>Node.PROCESSING_INSTRUCTION_NODE(7);<br><strong>Node.COMMENT_NODE(8)                            //注释节点</strong><br>Node.DOCUMENT_NODE(9);<br>Node.DOCUMENT_TYPE_NODE(10);<br>Node.DOCUMEN_FRAGME_NODE(11);<br>Node.NOTATION_NODE(12)</p>
</blockquote>
<h4 id="nodeType-属性"><a href="#nodeType-属性" class="headerlink" title="nodeType 属性"></a>nodeType 属性</h4><blockquote>
<p>nodeType 属性返回以数字值返回指定节点的节点类型。</p>
<p>如果节点是元素节点，则 nodeType 属性将返回 1。</p>
<p>如果节点是属性节点，则 nodeType 属性将返回 2。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.nodeName
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.body.nodeType;//1
</code></pre>
</li>
</ul>
<h4 id="nodeName属性"><a href="#nodeName属性" class="headerlink" title="nodeName属性"></a>nodeName属性</h4><blockquote>
<p>nodeName 属性指定节点的节点名称。</p>
<p>如果节点是元素节点，则 nodeName 属性返回标签名。</p>
<p>如果节点是属性节点，则 nodeName 属性返回属性的名称。</p>
<p>对于其他节点类型，nodeName 属性返回不同节点类型的不同名称。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.nodeName
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">document.body.nodeName;//BODY
</code></pre>
</li>
</ul>
<h4 id="nodeValue属性"><a href="#nodeValue属性" class="headerlink" title="nodeValue属性"></a>nodeValue属性</h4><blockquote>
<p>nodeValue 属性设置或返回指定节点的节点值。</p>
<p><strong>注释：</strong>如果您希望返回元素的文本，<strong>请记住文本始终位于文本节点中</strong>，并且您必须返回文本节点的值（element.childNodes[0].nodeValue）。</p>
<p><strong>提示：</strong>nodeValue 属性的替代选择是 textContent 属性。</p>
<p><strong>更改文本节点的nodeValue属性值即可改变文本节点的内容</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">node.nodeValue = value;
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var txt = document.createTextNode(&quot;123&quot;);
txt.nodeValue = &quot;456&quot;;
console.log(txt)//内容变成了456；
</code></pre>
<p>```</p>
</li>
</ul>
<h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ul>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ul>
<p>在操作一个DOM节点前，我们需要通过各种方式<code>先拿到这个DOM节点</code>。</p>
<p><strong>第一种方法</strong>或者<strong>最常用的方法</strong>是：</p>
<ul>
<li><p><strong>document.getElementById()</strong></p>
</li>
<li><p><strong>document.getElementsByTagName()</strong></p>
</li>
<li><p><strong>CSS选择器document.getElementsByClassName()</strong></p>
</li>
</ul>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p>
<p>​```js<br>// 返回ID为’test’的节点：<br>var test = document.getElementById(‘test’);</p>
<p>// 先定位ID为’test-table’的节点，再返回其内部所有tr节点：<br>var trs = document.getElementById(‘test-table’).getElementsByTagName(‘tr’);</p>
<p>// 先定位ID为’test-div’的节点，再返回其内部所有class包含red的节点：<br>var reds = document.getElementById(‘test-div’).getElementsByClassName(‘red’);</p>
<p>// 获取节点test下的所有直属子节点:<br>var cs = test.children;</p>
<p>// 获取节点test下第一个、最后一个子节点：<br>var first = test.firstElementChild;<br>var last = test.lastElementChild;</p>
<pre><code>


**第二种方法**是使用`querySelector()`和`querySelectorAll()`，需要了解selector语法，然后使用条件来获取节点，更加方便：
</code></pre>
<p>// 通过querySelector获取ID为q1的节点：<br>var q1 = document.querySelector(‘#q1’);</p>
<p>// 通过querySelectorAll获取q1节点内的符合条件的所有节点：<br>var ps = q1.querySelectorAll(‘div.highlighted &gt; p’);</p>
<pre><code>
注意：低版本的IE&lt;8不支持`querySelector`和`querySelectorAll`。IE8仅有限支持。

严格地讲，我们这里的DOM节点是指`Element`，但是DOM节点实际上是`Node`，在HTML中，`Node`包括`Element`、`Comment`、`CDATA_SECTION`等很多种，以及根节点`Document`类型，但是，绝大多数时候我们只关心`Element`，也就是实际控制页面结构的`Node`，其他类型的`Node`忽略即可。根节点`Document`已经自动绑定为全局变量`document`。

#### 更新DOM

#####  innerHTML 

&gt;  可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树 

```js
// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&#39;p-id&#39;);
// 设置文本为abc:
p.innerHTML = &#39;ABC&#39;; // &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;
// 设置HTML:
p.innerHTML = &#39;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#39;;
// &lt;p&gt;...&lt;/p&gt;的内部结构已修改
</code></pre>
<p> 用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 </p>
<p>通过<strong>innerHTML</strong>和<strong>数组遍历</strong>实现多行多列的商品列表： <a href="..%5C%E4%BD%9C%E4%B8%9A%5Cday08%5C%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8.html">商品列表.html</a> </p>
<h5 id="innerText-textContent"><a href="#innerText-textContent" class="headerlink" title="innerText || textContent"></a>innerText || textContent</h5><blockquote>
<p> 可以自动对字符串进行HTML编码，保证无法设置任何HTML标签 </p>
</blockquote>
<pre><code class="js">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&#39;p-id&#39;);
// 设置文本:
p.innerText = &#39;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#39;;
// HTML被自动编码，无法设置一个&lt;script&gt;节点:
// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;
</code></pre>
<p> 两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意IE&lt;9不支持<code>textContent</code>。 </p>
<h5 id="修改CSS"><a href="#修改CSS" class="headerlink" title="修改CSS"></a>修改CSS</h5><blockquote>
<p> DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置 </p>
</blockquote>
<p> 因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为<strong>驼峰式命名</strong><code>fontSize</code> ：</p>
<pre><code class="js">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;
var p = document.getElementById(&#39;p-id&#39;);
// 设置CSS:
p.style.color = &#39;#ff0000&#39;;
p.style.fontSize = &#39;20px&#39;;
p.style.paddingTop = &#39;2em&#39;;
</code></pre>
<h4 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h4><h5 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h5><blockquote>
<p> 把一个子节点添加到父节点的最后一个子节点 </p>
</blockquote>
<pre><code class="js">&lt;!-- HTML结构 --&gt;
&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">var
    js = document.getElementById(&#39;js&#39;),
    list = document.getElementById(&#39;list&#39;);
list.appendChild(js);
</code></pre>
<p>现在，HTML结构变成了这样：</p>
<pre><code class="js">&lt;!-- HTML结构 --&gt;
&lt;div id=&quot;list&quot;&gt;
    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;
    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;
    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;
    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p> 因为我们插入的<code>js</code>节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。 </p>
<h5 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h5><blockquote>
<p> 把子节点插入到指定的位置 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">document.getElementById(&quot;myList&quot;).insertBefore(newItem,existingItem);
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var
    list = document.getElementById(&#39;list&#39;),
    ref = document.getElementById(&#39;python&#39;),
    haskell = document.createElement(&#39;p&#39;);
haskell.id = &#39;haskell&#39;;
haskell.innerText = &#39;Haskell&#39;;
list.insertBefore(haskell, ref);//把haskell节点 放在ref节点之前
</code></pre>
</li>
</ul>
<ul>
<li>。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-03 JS对象的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/03%20JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.530Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/03%20JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-JavaScript对象Math
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="aJavaScript对象"><a href="#aJavaScript对象" class="headerlink" title="aJavaScript对象"></a>aJavaScript对象</h2><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h5 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h5><h6 id="Math-round-3-6"><a href="#Math-round-3-6" class="headerlink" title="Math.round(3.6);"></a>Math.round(3.6);</h6><blockquote>
<p>四舍五入  </p>
</blockquote>
<h6 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random();"></a>Math.random();</h6><blockquote>
<p>​     //返回一个大于等于0到小于1的随机数  </p>
</blockquote>
<h6 id="Math-max-a-b"><a href="#Math-max-a-b" class="headerlink" title="Math.max(a,b)"></a>Math.max(a,b)</h6><blockquote>
<p>返回较大的值  </p>
</blockquote>
<h6 id="Math-min-a-b"><a href="#Math-min-a-b" class="headerlink" title="Math.min(a,b);"></a>Math.min(a,b);</h6><blockquote>
<p>返回较小的值  </p>
</blockquote>
<h6 id="Math-abs-num"><a href="#Math-abs-num" class="headerlink" title="Math.abs(num)"></a>Math.abs(num)</h6><blockquote>
<p>返回绝对值  </p>
</blockquote>
<h6 id="Math-ceil-3-6"><a href="#Math-ceil-3-6" class="headerlink" title="Math.ceil(3.6)"></a>Math.ceil(3.6)</h6><blockquote>
<p>向上取整  </p>
</blockquote>
<h6 id="Math-floor-3-6"><a href="#Math-floor-3-6" class="headerlink" title="Math.floor(3.6)"></a>Math.floor(3.6)</h6><blockquote>
<p>向下取整  </p>
</blockquote>
<h6 id="Math-pow-x-y"><a href="#Math-pow-x-y" class="headerlink" title="Math.pow(x,y)"></a>Math.pow(x,y)</h6><blockquote>
<p>x的y次方  </p>
</blockquote>
<h6 id="Math-sqrt-num"><a href="#Math-sqrt-num" class="headerlink" title="Math.sqrt(num)"></a>Math.sqrt(num)</h6><blockquote>
<p>开平方  </p>
</blockquote>
<h6 id="Math-sin-x"><a href="#Math-sin-x" class="headerlink" title="Math.sin(x)"></a>Math.sin(x)</h6><blockquote>
<p>x的正弦值，返回值在-1到1之间  </p>
</blockquote>
<h6 id="Math-cos-x"><a href="#Math-cos-x" class="headerlink" title="Math.cos(x)"></a>Math.cos(x)</h6><blockquote>
<p>x的余弦值，返回值在-1到1之间</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_abs.asp">abs(x)</a></td>
<td align="left">返回数的绝对值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_acos.asp">acos(x)</a></td>
<td align="left">返回数的反余弦值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_asin.asp">asin(x)</a></td>
<td align="left">返回数的反正弦值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_atan.asp">atan(x)</a></td>
<td align="left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_atan2.asp">atan2(y,x)</a></td>
<td align="left">返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_ceil.asp">ceil(x)</a></td>
<td align="left">对数进行上舍入。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_cos.asp">cos(x)</a></td>
<td align="left">返回数的余弦。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_exp.asp">exp(x)</a></td>
<td align="left">返回 e 的指数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_floor.asp">floor(x)</a></td>
<td align="left">对数进行下舍入。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_log.asp">log(x)</a></td>
<td align="left">返回数的自然对数（底为e）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_max.asp">max(x,y)</a></td>
<td align="left">返回 x 和 y 中的最高值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_min.asp">min(x,y)</a></td>
<td align="left">返回 x 和 y 中的最低值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_pow.asp">pow(x,y)</a></td>
<td align="left">返回 x 的 y 次幂。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_random.asp">random()</a></td>
<td align="left">返回 0 ~ 1 之间的随机数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_round.asp">round(x)</a></td>
<td align="left">把数四舍五入为最接近的整数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_sin.asp">sin(x)</a></td>
<td align="left">返回数的正弦。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_sqrt.asp">sqrt(x)</a></td>
<td align="left">返回数的平方根。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_tan.asp">tan(x)</a></td>
<td align="left">返回角的正切。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_tosource_math.asp">toSource()</a></td>
<td align="left">返回该对象的源代码。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_valueof_math.asp">valueOf()</a></td>
<td align="left">返回 Math 对象的原始值。</td>
</tr>
</tbody></table>
<h5 id="Math属性"><a href="#Math属性" class="headerlink" title="Math属性"></a>Math属性</h5><h6 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h6><blockquote>
<p> PI 属性就是 π，即圆的周长和它的直径之比。这个值近似为 3.141592653589793。 </p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_e.asp">E</a></td>
<td align="left">返回算术常量 e，即自然对数的底数（约等于2.718）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_ln2.asp">LN2</a></td>
<td align="left">返回 2 的自然对数（约等于0.693）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_ln10.asp">LN10</a></td>
<td align="left">返回 10 的自然对数（约等于2.302）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_log2e.asp">LOG2E</a></td>
<td align="left">返回以 2 为底的 e 的对数（约等于 1.414）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_log10e.asp">LOG10E</a></td>
<td align="left">返回以 10 为底的 e 的对数（约等于0.434）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_pi.asp">PI</a></td>
<td align="left">返回圆周率（约等于3.14159）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_sqrt1_2.asp">SQRT1_2</a></td>
<td align="left">返回返回 2 的平方根的倒数（约等于 0.707）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_sqrt2.asp">SQRT2</a></td>
<td align="left">返回 2 的平方根（约等于 1.414）。</td>
</tr>
</tbody></table>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><blockquote>
<p> Date 对象用于处理日期和时间。 </p>
</blockquote>
<h5 id="创建-Date-对象的语法"><a href="#创建-Date-对象的语法" class="headerlink" title="创建 Date 对象的语法"></a>创建 Date 对象的语法</h5><pre><code class="js">var myDate = new Date();
</code></pre>
<p><strong>注释：</strong>Date 对象会自动把当前日期和时间保存为其初始值。</p>
<h5 id="设置Date对象的语法"><a href="#设置Date对象的语法" class="headerlink" title="设置Date对象的语法"></a>设置Date对象的语法</h5><ul>
<li><p>创建日期对象时设置</p>
<ul>
<li><p>单个参数：<strong>参数为字符</strong>,没有设置的部分为0，超出上限就：Invalid Date</p>
<pre><code class="js">var d = new Date(&quot;2008.08.08 8:8:8&quot;);
var d = new Date(&quot;2008.08.08&quot;);
var d = new Date(&quot;2008.13.08&quot;);
var d = new Date(&quot;2008/08/08&quot;);
var d = new Date(&quot;2008-08-08&quot;);
var d = new Date(&quot;2008,08,08&quot;);
var d = new Date(&quot;2008 08 08&quot;);
console.log(d);
</code></pre>
</li>
<li><p>多个参数：<strong>参数为数值</strong>，月的范围是0~11，没有设置的部分为0，超出上限，向前进1</p>
<pre><code class="js">var d = new Date(2008,8,8,8,8,8);
var d = new Date(2008,8,8);
var d = new Date(2008,12,33);//2009-2-02，33号自动进1个月，12（超过了0-11反胃）自动进1个年，相当于进了2个月
console.log(d);
</code></pre>
</li>
</ul>
</li>
<li><p>创建日期对象后</p>
<ul>
<li><p>使用set系列方法单独设置：没有设置的部分，以当前日期为准,超出上限，向前进1</p>
<pre><code class="js">var d = new Date();
d.setFullYear(2008);
d.setMonth(12);     //0~11
d.setDate(56);
//不能设置星期几，因为星期几是自动计算得出的
d.setHours(35);
d.setMinutes(78);
d.setSeconds(86);

d.setMilliseconds(666);
console.log(d)
console.log(d.getMilliseconds());
</code></pre>
</li>
<li><p>使用设置时间戳</p>
<pre><code class="js">var d = new Date();
d.setTime(1000000000000);
console.log(d);
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_constructor_date.asp">constructor</a></td>
<td align="left">返回对创建此对象的 Date 函数的引用。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_prototype_date.asp">prototype</a></td>
<td align="left">使您有能力向对象添加属性和方法。</td>
</tr>
</tbody></table>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_Date.asp">Date()</a></td>
<td align="left">返回当日的日期和时间。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getDate.asp">getDate()</a></td>
<td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getDay.asp">getDay()</a></td>
<td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getMonth.asp">getMonth()</a></td>
<td align="left">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getFullYear.asp">getFullYear()</a></td>
<td align="left">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getYear.asp">getYear()</a></td>
<td align="left">请使用 getFullYear() 方法代替。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getHours.asp">getHours()</a></td>
<td align="left">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getMinutes.asp">getMinutes()</a></td>
<td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getSeconds.asp">getSeconds()</a></td>
<td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getMilliseconds.asp">getMilliseconds()</a></td>
<td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getTime.asp">getTime()</a></td>
<td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getTimezoneOffset.asp">getTimezoneOffset()</a></td>
<td align="left">返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCDate.asp">getUTCDate()</a></td>
<td align="left">根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCDay.asp">getUTCDay()</a></td>
<td align="left">根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCMonth.asp">getUTCMonth()</a></td>
<td align="left">根据世界时从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCFullYear.asp">getUTCFullYear()</a></td>
<td align="left">根据世界时从 Date 对象返回四位数的年份。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCHours.asp">getUTCHours()</a></td>
<td align="left">根据世界时返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCMinutes.asp">getUTCMinutes()</a></td>
<td align="left">根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCSeconds.asp">getUTCSeconds()</a></td>
<td align="left">根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_getUTCMilliseconds.asp">getUTCMilliseconds()</a></td>
<td align="left">根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_parse.asp">parse()</a></td>
<td align="left">返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setDate.asp">setDate()</a></td>
<td align="left">设置 Date 对象中月的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setMonth.asp">setMonth()</a></td>
<td align="left">设置 Date 对象中月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setFullYear.asp">setFullYear()</a></td>
<td align="left">设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setYear.asp">setYear()</a></td>
<td align="left">请使用 setFullYear() 方法代替。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setHours.asp">setHours()</a></td>
<td align="left">设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setMinutes.asp">setMinutes()</a></td>
<td align="left">设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setSeconds.asp">setSeconds()</a></td>
<td align="left">设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setMilliseconds.asp">setMilliseconds()</a></td>
<td align="left">设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setTime.asp">setTime()</a></td>
<td align="left">以毫秒设置 Date 对象。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setUTCDate.asp">setUTCDate()</a></td>
<td align="left">根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setUTCMonth.asp">setUTCMonth()</a></td>
<td align="left">根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setUTCFullYear.asp">setUTCFullYear()</a></td>
<td align="left">根据世界时设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setutchours.asp">setUTCHours()</a></td>
<td align="left">根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setUTCMinutes.asp">setUTCMinutes()</a></td>
<td align="left">根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setUTCSeconds.asp">setUTCSeconds()</a></td>
<td align="left">根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_setUTCMilliseconds.asp">setUTCMilliseconds()</a></td>
<td align="left">根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_tosource_boolean.asp">toSource()</a></td>
<td align="left">返回该对象的源代码。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toString_date.asp">toString()</a></td>
<td align="left">把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toTimeString.asp">toTimeString()</a></td>
<td align="left">把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toDateString.asp">toDateString()</a></td>
<td align="left">把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toGMTString.asp">toGMTString()</a></td>
<td align="left">请使用 toUTCString() 方法代替。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toUTCString.asp">toUTCString()</a></td>
<td align="left">根据世界时，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toLocaleString.asp">toLocaleString()</a></td>
<td align="left">根据本地时间格式，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toLocaleTimeString.asp">toLocaleTimeString()</a></td>
<td align="left">根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_toLocaleDateString.asp">toLocaleDateString()</a></td>
<td align="left">根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_utc.asp">UTC()</a></td>
<td align="left">根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_valueOf_date.asp">valueOf()</a></td>
<td align="left">返回 Date 对象的原始值。</td>
</tr>
</tbody></table>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><blockquote>
<p>值 <code>null</code> 特指对象的值未设置。它是 JavaScript <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">基本类型</a> 之一。</p>
</blockquote>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">null
</code></pre>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>值 <code>null</code> 是一个字面量，不像 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>，它不是全局对象的一个属性。<code>null</code> 是表示缺少的标识，指示变量未指向任何对象。把 <code>null</code> 作为尚未创建的对象，也许更好理解。在 API 中，<code>null</code> 常在返回类型应是一个对象，但没有关联的值的地方使用。</p>
<pre><code class="js">// foo 不存在，它从来没有被定义过或者是初始化过：
foo;
&quot;ReferenceError: foo is not defined&quot;

// foo 现在已经是知存在的，但是它没有类型或者是值：
var foo = null; 
foo;
null
</code></pre>
<h4 id="null-与-undefined-的不同点："><a href="#null-与-undefined-的不同点：" class="headerlink" title="null 与 undefined 的不同点："></a><code>null</code> 与 <code>undefined</code> 的不同点：</h4><p>当检测 <code>null</code> 或 <code>undefined</code> 时，注意<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">相等（==）与全等（===）两个操作符的区别</a> ，前者会执行类型转换：</p>
<pre><code class="js">typeof null        // &quot;object&quot; (因为一些以前的原因而不是&#39;null&#39;)
typeof undefined   // &quot;undefined&quot;
null === undefined // false
null  == undefined // true
null === null // true
null == null // true
!null //true
isNaN(1 + null) // false
isNaN(1 + undefined) // true
</code></pre>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-02 引用数据类型的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/02%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.514Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/02%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-引用数据类型
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h3><ul>
<li>对象的概念：对象事物的描述</li>
<li>对象的语法（组成，本质）：属性名和属性值，<strong>键值对</strong></li>
</ul>
<pre><code class="JS">var people = &#123;
    name:&quot;admin&quot;,
    age:18,
    sex:&quot;男&quot;,
    like:&quot;ball&quot;,
    sayhello:function()&#123;
        console.log(&quot;我叫&quot;+people.name+&quot;今年&quot;+people.age+&quot;性别&quot;+people.sex+&quot;爱好&quot;+people.like)
    &#125;
&#125;

people.sayhello();
</code></pre>
<ul>
<li>对象的作用（意义）:储存数据，编程</li>
<li>对象中的值的叫法和操作：对象里的变量叫<strong>属性</strong>，对象里的函数叫<strong>方法</strong></li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li><strong>.语法</strong>：对象.属性（方法名），当属性名和方法名确定</li>
</ul>
<pre><code class="js">obj1.name = &quot;hello&quot;;
console.log(obj1.name);
</code></pre>
<ul>
<li> <strong>[ ]语法</strong>，当属性名和方法名不确定</li>
</ul>
<pre><code class="js">var obj1 = &#123;&#125;;
var str = &quot;age&quot;;
console.log(obj1[str]);
obj1[str] = &quot;男&quot;;
console.log(obj1[&quot;name&quot;]);
console.log(obj1);
</code></pre>
<h3 id="函数Function"><a href="#函数Function" class="headerlink" title="函数Function"></a>函数Function</h3><blockquote>
<p>函数是由事件驱动的或者当他被调用时可执行的可重复使用的代码块。</p>
</blockquote>
<h4 id="函数的好处"><a href="#函数的好处" class="headerlink" title="函数的好处"></a>函数的好处</h4><ol>
<li>重复使用－－－－空调不可能是一次性的，可以重复使用</li>
<li>忽略细节－－－－会用空调不一定会生产空调</li>
<li>选择执行－－－－夏冬使用，春秋不用</li>
</ol>
<h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><ol>
<li><p><strong>声明式</strong></p>
<table>
<thead>
<tr>
<th>function</th>
<th>为声明函数的关键字，指出这是一个函数</th>
</tr>
</thead>
<tbody><tr>
<td>fn</td>
<td>是函数名，类似于永来存储函数的变量</td>
</tr>
<tr>
<td>()</td>
<td>为函数的参数，多个参数用 , 隔开</td>
</tr>
<tr>
<td>{}</td>
<td>放置函数体，用于执行时，所要编译的代码段</td>
</tr>
</tbody></table>
</li>
<li><p><strong>赋值式</strong></p>
<pre><code class="js">var fn = function()&#123;&#125;;
</code></pre>
<p>​    这种方式下，虽然这个函数没有名字，但是这个函数赋值给了fn，因此通过变量fn也能调用到这个函数，以上两种声明方式等价都可以使用，函数名/变量名＋()  调用执行。</p>
</li>
</ol>
<h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><ol>
<li><p>自身执行</p>
<ul>
<li>函数名(),任何情况下，只要函数名()了，函数立即执行</li>
</ul>
</li>
<li><p>事件调用</p>
<ul>
<li><p>元素.事件 = 函数名</p>
<pre><code class="js">box.onclick = fn;
</code></pre>
</li>
<li><p>元素.事件 = 函数的内容</p>
<pre><code class="js">box.onclick = function()&#123;...&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="函数写法的分类"><a href="#函数写法的分类" class="headerlink" title="函数写法的分类"></a>函数写法的分类</h4><ol>
<li><p>有名函数</p>
<ul>
<li>声明式创建的函数：function fn(){}</li>
</ul>
</li>
<li><p>无名函数</p>
<p>注意：无名函数不允许直接存在，必须作为值使用，是一种表达式，或值</p>
<pre><code class="js">function()&#123;
  console.log(1)
&#125;
</code></pre>
<p>使用:</p>
<ol>
<li><strong>作为赋值式创建函数的值</strong>：<strong>var fn = function(){}</strong></li>
<li><strong>事件处理函数</strong>，直接作为事件执行函数存在：<strong>元素.事件 = function(){}</strong></li>
<li><strong>回调函数</strong>：作为函数的参数存在，也是一个值：</li>
</ol>
<pre><code class="js">function fn(a)&#123;a(1)&#125;; fn(function(b)&#123;...&#125;)；
</code></pre>
<ol start="4">
<li><strong>作为匿名函数的函数体存在</strong>：**(function(){})()**  </li>
</ol>
</li>
<li><p>匿名函数</p>
<pre><code class="js">(function()&#123;&#125;)()
</code></pre>
<p>特点：自动执行</p>
</li>
</ol>
<h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><ol>
<li><p><strong>形参</strong></p>
<ol>
<li>定义时的参数叫形参，</li>
<li>形参保存了实参</li>
<li>形参是变量</li>
<li>形参相当于赋值元素运算符=号，左边的内容</li>
</ol>
</li>
<li><p><strong>实参</strong></p>
<ol>
<li>执行时的参数叫实参</li>
<li>实参被形参接收</li>
<li>实参是值</li>
<li>实参相当于赋值元素运算符=号，右边的内容</li>
</ol>
</li>
<li><p><strong>参数的个数</strong></p>
<ul>
<li><p>可以传无限个</p>
</li>
<li><p>关系：实参和形参，数量一致，按照顺序一一对应</p>
</li>
<li><p>形参多，多出来的形参是undefined</p>
</li>
<li><p>实参多，多出来的实参，被传到arguments（实参全部都会比传到arguments)</p>
</li>
</ul>
</li>
<li><p><strong>参数的类型</strong></p>
<ul>
<li>任何类型</li>
</ul>
</li>
</ol>
<h4 id="函数的回调"><a href="#函数的回调" class="headerlink" title="函数的回调"></a>函数的回调</h4><blockquote>
<p>​    回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。</p>
<p>​    在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数</p>
</blockquote>
<pre><code class="js">   function sum(x,y,callback)&#123;
                var sum = x+y;
                callback(sum);
        &#125;
        sum(1,3,function(sum)&#123;
                console.log(sum)
        &#125;)
</code></pre>
<h4 id="函数的return"><a href="#函数的return" class="headerlink" title="函数的return"></a>函数的return</h4><blockquote>
<p>将函数的执行或处理结果，返回到执行语句上，方便二次使用</p>
</blockquote>
<ol start="3">
<li><p><strong>默认情况下，函数返回undefined</strong></p>
</li>
<li><p>如果需要有返回值，要在函数中使用关键字：return</p>
</li>
<li><p>return 值</p>
</li>
</ol>
<ul>
<li>为什么要有返回值，如果是处理数据的函数，处理之后的数据，有可能需要二次使用，需要有返回值，返回处理好的数据</li>
</ul>
<ol start="6">
<li><p>通过return来返回无名函数</p>
<pre><code class="js">    function fn(a)&#123;
            return function(b)&#123;
                    return function (c)&#123;
                            return function (d)&#123;
                                    return a+b+c+d;
                            &#125;
                    &#125;
            &#125;
    &#125;
    fn(3)(4)(5)(6)=3+4+5+6;
</code></pre>
</li>
<li><p>return 可以返回几次数据:<strong>1次</strong></p>
<ul>
<li>函数中，可以写多个return，但是函数只能执行一次return，执行之后，函数会立即结束，后面代码不再执行</li>
</ul>
</li>
</ol>
<h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>arguments是函数中专有的一个对象，只有在函数中能拿到，用来保存函数所有的实参。</p>
<ol>
<li>arguments其实是一个伪数组，可以使用数组的所有方法和属性（length)。</li>
<li>arguments.length实际上就是实参的个数。</li>
<li>借助arguments找到所有的实参：console.log(arguments);</li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote>
<p>变量生效的区域</p>
<p>能不能跨作用域访问：</p>
<ol>
<li>同级局部不能跨</li>
<li>不能拿子，子能拿父</li>
<li>多个父子级作用域内都有，找最近的作用域</li>
</ol>
</blockquote>
<h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5><blockquote>
<p>区域：每个函数都是一个局部</p>
</blockquote>
<ol>
<li><p>生命周期：朝生暮死，作用域声明时被创建，作用域结束时被释放</p>
</li>
<li><p>缺点：更麻烦，每个局部都需要定义某个变量，甚至是几个局部都相同的变量</p>
</li>
</ol>
<h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><blockquote>
<p>整个代码文件，不属于任何一个函数，就是全局</p>
</blockquote>
<ol>
<li>生命周期：一直存在，在任何位置都可以拿到</li>
<li>缺点：更浪费性能</li>
</ol>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><blockquote>
<p>递归算法：在函数内部，执行自己</p>
</blockquote>
<pre><code class="js">    function fn(n)&#123;
        if(n == 1 || n == 2)&#123;
            return 1
        &#125;else&#123;
            return fn(n-1) + fn(n-2);
        &#125;
    &#125;
    console.log(fn(8));
</code></pre>
<p><strong>递归最重要的就是停止条件</strong></p>
<h4 id="Function-prototype方法"><a href="#Function-prototype方法" class="headerlink" title="Function.prototype方法"></a>Function.prototype方法</h4><h5 id="blind"><a href="#blind" class="headerlink" title="blind()"></a>blind()</h5><blockquote>
<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">function.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
</li>
<li><p>返回值</p>
<p>​    返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。</p>
</li>
<li><p>实例</p>
<pre><code class="js">this.x = 9;    // 在浏览器中，this 指向全局的 &quot;window&quot; 对象
var module = &#123;
  x: 81,
  getX: function() &#123; return this.x; &#125;
&#125;;

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
</code></pre>
</li>
</ul>
<h5 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h5><blockquote>
<p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">function.call(thisArg, arg1, arg2, ...)
</code></pre>
</li>
<li><p>返回值</p>
<p>​    使用调用者提供的 <code>this</code> 值和参数调用该函数的返回值。若该方法没有返回值，则返回 <code>undefined</code>。</p>
</li>
<li><p>实例</p>
<pre><code class="js">//使用call 方法调用父构造函数
function Product(name, price) &#123;
  this.name = name;
  this.price = price;
&#125;

function Food(name, price) &#123;
  Product.call(this, name, price);
  this.category = &#39;food&#39;;
&#125;

function Toy(name, price) &#123;
  Product.call(this, name, price);
  this.category = &#39;toy&#39;;
&#125;

var cheese = new Food(&#39;feta&#39;, 5);
var fun = new Toy(&#39;robot&#39;, 40);

//使用call方法调用匿名函数
var animals = [
  &#123; species: &#39;Lion&#39;, name: &#39;King&#39; &#125;,
  &#123; species: &#39;Whale&#39;, name: &#39;Fail&#39; &#125;
];

for (var i = 0; i &lt; animals.length; i++) &#123;
  (function(i) &#123;
    this.print = function() &#123;
      console.log(&#39;#&#39; + i + &#39; &#39; + this.species
                  + &#39;: &#39; + this.name);
    &#125;
    this.print();
  &#125;).call(animals[i], i);
&#125;
</code></pre>
</li>
</ul>
<h5 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h5><blockquote>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">func.apply(thisArg, [argsArray])
</code></pre>
</li>
<li><p>返回值</p>
<p>​    调用有指定<code>this</code>值和参数的函数的结果。</p>
</li>
<li><p>实例</p>
<pre><code class="js">//用 apply 将数组添加到另一个数组
var array = [&#39;a&#39;, &#39;b&#39;];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]
</code></pre>
</li>
</ul>
<h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><blockquote>
<p>概念：一组数据，数据的组合</p>
<p>意义：可以操作多个数据</p>
</blockquote>
<h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><ul>
<li><p>字面量</p>
<pre><code class="js">var arr = [];
</code></pre>
</li>
<li><p>构造函数：</p>
<pre><code class="js">var arr = new Array();
</code></pre>
</li>
<li><p>二者的唯一区别：</p>
<p>字面量：当只有一个数据，还是数值时，字面量会在数组中保存这个数值</p>
<p>构造函数：会将这个数值作为长度</p>
<pre><code class="js"> var arr = [6];
    var arr2 = new Array(6);
    console.log(arr);//[6]
    console.log(arr2);//(6) [empty × 6]
    console.log(arr.length)//1
    console.log(arr2.length)//6
</code></pre>
</li>
</ul>
<h4 id="Array-prototype方法"><a href="#Array-prototype方法" class="headerlink" title="Array.prototype方法"></a>Array.prototype方法</h4><p>索引操作</p>
<ul>
<li><p>增：给不存在的索引赋值</p>
<pre><code class="js">var arr = [1,2,3];
arr[5] = 5;
console.log(arr);//(6) [1, 2, 3, empty × 2, 5]
console.log(arr.length);//6
</code></pre>
</li>
<li><p>删</p>
<pre><code class="js">var arr = [1,2,3];
arr.length = 2;
console.log(arr);//(2) [1, 2]
</code></pre>
</li>
<li><p>改</p>
<pre><code class="js">var arr = [1,2,3];
arr[1] = 4;
console.log(arr);//(3) [1,4,3]
</code></pre>
</li>
<li><p>查：数组的遍历</p>
<pre><code class="js">var arr = [1,2,3];
for(var i=0;i&lt;3;i++)
    &#123;
        console.log(arr[i]);
    &#125;
</code></pre>
</li>
</ul>
<p><strong>方法操作(方法：对象中的函数属性)</strong></p>
<h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p><strong>功能：</strong>用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br> <strong>参数：</strong>concat(data1,data2,…);所有参数可选，要合并的数据；data为数组时，将data合并到原数组；data为具体数据时直接添加到原数组尾部；省略时创建原数组的副本。</p>
<pre><code class="js">var arr1 = [1,2,3]
var arr2 = arr1.concat();
console.log(arr1);           //[1,2,3]---原数组
console.log(arr1 === arr2);  //false
console.log(arr2);           //[1,2,3]---原数组的副本

console.log(arr1.concat(&quot;hello&quot;,&quot;world&quot;));           //[1,2,3,&quot;hello&quot;,&quot;world&quot;]
console.log(arr1.concat([&quot;a&quot;,&quot;b&quot;],[[3,4],&#123;&quot;name&quot;:&quot;admin&quot;&#125;]));   //[1,2,3,&quot;a&quot;,&quot;b&quot;,[3,4],&#123;&quot;name&quot;:&quot;admin&quot;&#125;]
console.log(arr1);           //[1,2,3]---原数组未改变

1,2,3,4].concat(1,2,3,[1,[1,2,3,4,5],3]);//(10) [1, 2, 3, 4, 1, 2, 3, 1, Array(5), 3]
</code></pre>
<h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p><strong>功能：</strong>根据指定分隔符将数组中的所有元素放入一个字符串，并返回这个字符串。<br> <strong>参数：</strong>join(str);参数可选，默认为”,”号，以传入的字符作为分隔符。</p>
<pre><code class="jsx">    var arr = [1,2,3];
    console.log(arr.join());         //1,2,3
    console.log(arr.join(&quot;-&quot;));      //1-2-3
    console.log(arr);                //[1,2,3]---原数组未改变
</code></pre>
<h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p><strong>功能：</strong>方法用于删除并返回数组的最后一个元素。<br> <strong>参数：</strong>无</p>
<pre><code class="jsx">    var arr = [1,2,3];
    console.log(arr.pop());     //3
    console.log(arr);           //[1,2]---原数组改变
</code></pre>
<h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p><strong>功能：</strong>方法用于删除并返回数组的第一个元素。<br> <strong>参数：</strong>无</p>
<pre><code class="jsx">    var arr = [1,2,3]
    console.log(arr.shift());       //1
    console.log(arr);               //[2,3]---原数组改变
</code></pre>
<h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p><strong>功能：</strong>向数组的开头添加一个或更多元素，并返回新的长度。<br> <strong>参数：</strong>unshift(newData1, newData2, ……)</p>
<pre><code class="jsx">    var arr = [1,2,3];
    console.log(arr.unshift(&quot;hello&quot;));  //4
    console.log(arr);                   //[&quot;hello&quot;,1,2,3]---原数组改变
    console.log(arr.unshift(&quot;a&quot;,&quot;b&quot;));  //6
    console.log(arr);                   //[&quot;a&quot;,&quot;b&quot;,&quot;hello&quot;,1,2,3]---原数组改变
</code></pre>
<h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p><strong>功能：</strong>向数组的末尾添加一个或更多元素，并返回新的长度。<br> <strong>参数：</strong>push(newData1, newData2, ……)</p>
<pre><code class="jsx">    var arr = [1,2,3];
    console.log(arr.push(&quot;hello&quot;));  //4
    console.log(arr);                //[1,2,3,&quot;hello&quot;]---原数组改变
    console.log(arr.push(&quot;a&quot;,&quot;b&quot;));  //6
    console.log(arr);                //[1,2,3,&quot;hello&quot;,&quot;a&quot;,&quot;b&quot;]---原数组改变
</code></pre>
<h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p><strong>功能：</strong>颠倒数组中元素的顺序。<br> <strong>参数：</strong>无</p>
<pre><code class="jsx">    var arr = [1,2,3];
    console.log(arr.reverse());     //[3,2,1]
    console.log(arr);               //[3,2,1]---原数组改变
</code></pre>
<h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p><strong>功能：</strong>可从已有的数组中返回选定的元素。该方法接收两个参数slice(start,end)，strat为必选，表示从第几位开始；end为可选，表示到第几位结束(不包含end位)，省略表示到最后一位；start和end都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。<br> <strong>参数：</strong>slice(startIndex, endIndex)</p>
<pre><code class="ruby">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    console.log(arr.slice(1,3));        //[&quot;Jack&quot;,&quot;Lucy&quot;]
    console.log(arr.slice(1));          //[&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;]
    console.log(arr.slice(-4,-1));      //[&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;]
    console.log(arr.slice(-2));         //[&quot;Lily&quot;,&quot;May&quot;]
    console.log(arr.slice(1,-2));       //[&quot;Jack&quot;,&quot;Lucy&quot;]
    console.log(arr);                   //[&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;]---原数组未改变
</code></pre>
<h6 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h6><p><strong>功能：</strong>对数组中的元素进行排序，默认是升序。</p>
<pre><code class="jsx">    var arr = [6,1,5,2,3];
    console.log(arr.sort());    //[1, 2, 3, 5, 6]
    console.log(arr);           //[1, 2, 3, 5, 6]---原数组改变
</code></pre>
<p>但是在排序前，会先调用数组的toString方法，将每个元素都转成字符之后，再进行排序，此时会按照字符串的排序，逐位比较，进行排序。</p>
<pre><code class="jsx">    var arr = [6,1024,52,256,369];
    console.log(arr.sort());    //[1024, 256, 369, 52, 6]
    console.log(arr);           //[1024, 256, 369, 52, 6]---原数组改变
</code></pre>
<p><strong>参数：</strong>sort(callback)<br> 如果需要按照数值排序，需要传参。sort(callback)，callback为回调函数，该函数应该具有两个参数，比较这两个参数，然后返回一个用于说明这两个值的相对顺序的数字（a-b）。其返回值如下：<br> 若 a 小于 b，返回一个小于 0 的值。<br> 若 a 等于 b，则返回 0。<br> 若 a 大于 b，则返回一个大于 0 的值。</p>
<pre><code class="jsx">    var arr = [6,1024,52,256,369];
    console.log(arr.sort(fn));  //[6, 52, 256, 369, 1024]
    console.log(arr);           //[6, 52, 256, 369, 1024]---原数组改变
    function fn(a,b)&#123;
        return a-b;
    &#125;
</code></pre>
<h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p><strong>功能：</strong>向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。<br> <strong>参数：</strong>splice(start,num,data1,data2,…); 所有参数全部可选。</p>
<ol>
<li>不传参时：无操作</li>
</ol>
<pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    console.log(arr.splice());      //[]
    console.log(arr);               //[&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;]---无操作
</code></pre>
<ol start="2">
<li>只传入start：表示从索引为start的数据开始删除，直到数组结束</li>
</ol>
<pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    
    console.log(arr.splice(2));     //[&quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]
    console.log(arr);               //[&quot;Tom&quot;, &quot;Jack&quot;]---原数组改变
</code></pre>
<ol start="3">
<li>传入start和num：表示从索引为start的数据开始删除，删除num个</li>
</ol>
<pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    
    console.log(arr.splice(2,2));   //[&quot;Lucy&quot;, &quot;Lily&quot;]
    console.log(arr);               //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;May&quot;]---原数组改变
</code></pre>
<ol start="4">
<li>删除和替换更多：表示从索引为start的数据开始删除，删除num个，并将第三个参数及后面所有参数，插入到start的位置</li>
</ol>
<pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    
    console.log(arr.splice(2,2,&quot;a&quot;,&quot;b&quot;));  //[&quot;Lucy&quot;, &quot;Lily&quot;]
    console.log(arr);                      //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;a&quot;, &quot;b&quot;, &quot;May&quot;]---原数组改变
</code></pre>
<ol start="5">
<li>增加更多：表示从索引为start的数据开始删除，删除num个，并将第三个参数及后面所有参数，插入到start的位置</li>
</ol>
<pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    
    console.log(arr.splice(2,0,&quot;a&quot;,&quot;b&quot;));  //[]
    console.log(arr);    //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;a&quot;, &quot;b&quot;, &quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]---原数组改变
</code></pre>
<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h6><p><strong>功能：</strong>转换成字符串，类似于没有参数的join()。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。<br> <strong>参数：</strong>无</p>
<pre><code class="js">    var arr = [1,2,3];
    console.log(arr.toString());     //1,2,3
    console.log(arr);                //[1,2,3]---原数组未改变
</code></pre>
<h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h6><p><strong>功能：</strong>返回数组的原始值（一般情况下其实就是数组自身），一般由js在后台调用，并不显式的出现在代码中<br> <strong>参数：</strong>无</p>
<pre><code class="jsx">    var arr = [1,2,3];
    console.log(arr.valueOf());         //[1,2,3]
    console.log(arr);                   //[1,2,3]
    //为了证明返回的是数组自身
    console.log(arr.valueOf() == arr);  //true
</code></pre>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><p><strong>功能：</strong>根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1。该方法是查询方法，不会对数组产生改变。<br> <strong>参数：</strong>indexOf(value, start);value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1</p>
<pre><code class="jsx">    var arr = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];
    console.log(arr.indexOf(&quot;l&quot;));        //2
    console.log(arr.indexOf(&quot;l&quot;,3));      //3
    console.log(arr.indexOf(&quot;l&quot;,4));      //-1
    console.log(arr.indexOf(&quot;l&quot;,-1));     //-1
    console.log(arr.indexOf(&quot;l&quot;,-3));     //2
</code></pre>
<h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h6><p><strong>功能：</strong>根据指定的数据，从右向左，查询在数组中出现的位置，如果不存在指定的数据，返回-1。该方法是查询方法，不会对数组产生改变。<br> <strong>参数：</strong>lastIndexOf(value, start);value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1</p>
<pre><code class="jsx">    var arr = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];
    console.log(arr.lastIndexOf(&quot;l&quot;));        //3
    console.log(arr.lastIndexOf(&quot;l&quot;,3));      //3
    console.log(arr.lastIndexOf(&quot;l&quot;,1));      //-1
    console.log(arr.lastIndexOf(&quot;l&quot;,-3));     //2
    console.log(arr.lastIndexOf(&quot;l&quot;,-4));     //-1
</code></pre>
<h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h6><p><strong>功能：</strong>ES5新增方法，用来遍历数组，该方法没有返回值。forEach接收的回调函数会根据数组的每一项执行，该回调函数默认有三个参数，分别为：遍历到的数组的数据，对应的索引，数组自身。<br> <strong>参数：</strong>forEach(callback);callback默认有三个参数，分别为value，index，self。</p>
<pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.forEach(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self));
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // Jack--1--true
    // Lucy--2--true
    // Lily--3--true
    // May--4--true
    console.log(a);     //undefined---forEach没有返回值
    //该方法为遍历方法，不会修改原数组
</code></pre>
<h6 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h6><p><strong>功能：</strong>1.同forEach功能；2.map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。<br> <strong>参数：</strong>map(callback);callback默认有三个参数，分别为value，index，self。</p>
<pre><code class="js">    //功能1：同forEach
    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.map(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self))
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // Jack--1--true
    // Lucy--2--true
    // Lily--3--true
    // May--4--true

    //功能2：每次回调函数的返回值被map组成新数组返回
    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.map(function(value,index,self)&#123;
        return &quot;hi:&quot;+value;
    &#125;)
    console.log(a);     //[&quot;hi:Tom&quot;, &quot;hi:Jack&quot;, &quot;hi:Lucy&quot;, &quot;hi:Lily&quot;, &quot;hi:May&quot;]
    console.log(arr);   //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]---原数组未改变
</code></pre>
<h6 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h6><p><strong>功能：</strong>1.同forEach功能；2.filter的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）。<br> <strong>参数：</strong>filter(callback);callback默认有三个参数，分别为value，index，self。</p>
<pre><code class="js">    //功能1：同forEach
    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.filter(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self))
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // Jack--1--true
    // Lucy--2--true
    // Lily--3--true
    // May--4--true

    //功能2：当回调函数的返回值为true时，本次的数组值返回给filter，被filter组成新数组返回
    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.filter(function(value,index,self)&#123;
        return value.length &gt; 3;
    &#125;)
    console.log(a);         //[&quot;Jack&quot;, &quot;Lucy&quot;, &quot;Lily&quot;]
    console.log(arr);       //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]---原数组未改变
</code></pre>
<h6 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h6><blockquote>
<p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">arr.includes(valueToFind[, fromIndex])
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">返回一个布尔值 Boolean ，如果在数组中找到了（如果传入了 fromIndex ，表示在 fromIndex 指定的索引范围中找到了）则返回 true 。
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var arr = [1,2,2,4,5,6,7];
console.log(arr.includes(8));//false
console.log(arr.includes(1));//true
console.log(arr.includes(2));//true
</code></pre>
</li>
</ul>
<h6 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h6><p><strong>功能：</strong>判断数组中每一项是否都满足条件，只有所有项都满足条件，才会返回true。<br> <strong>参数：</strong>every()接收一个回调函数作为参数，这个回调函数需要有返回值，every(callback);callback默认有三个参数，分别为value，index，self。</p>
<p><strong>功能1：</strong>当回调函数的返回值为true时，类似于forEach的功能，遍历所有；如果为false，那么停止执行，后面的数据不再遍历，停在第一个返回false的位置。</p>
<pre><code class="jsx">    //demo1:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.every(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
    &#125;)
    // 打印结果为：
    // Tom--0--true
    //因为回调函数中没有return true，默认返回undefined，等同于返回false

    //demo2:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.every(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
        return value.length &lt; 4;
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true
    //因为当遍历到Jack时，回调函数到return返回false，此时Jack已经遍历，但是后面数据就不再被遍历了

    //demo3:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.every(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
        return true;
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true
    // Lucy--3--true
    // Lily--4--true
    // May--5--true
    //因为每个回调函数的返回值都是true，那么会遍历数组所有数据，等同于forEach功能
</code></pre>
<p><strong>功能2：</strong>当每个回调函数的返回值都为true时，every的返回值为true，只要有一个回调函数的返回值为false，every的返回值都为false</p>
<pre><code class="jsx">    //demo1:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.every(function(value,index,self)&#123;
        return value.length &gt; 3;
    &#125;)
    console.log(a);           //false

    //demo2:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.every(function(value,index,self)&#123;
        return value.length &gt; 2;
    &#125;)
    console.log(a);           //true
</code></pre>
<h6 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h6><p><strong>功能：</strong>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。<br> <strong>参数：</strong>some()接收一个回调函数作为参数，这个回调函数需要有返回值，some(callback);callback默认有三个参数，分别为value，index，self。</p>
<p><strong>功能1：</strong>因为要判断数组中的每一项，只要有一个回调函数返回true，some都会返回true，所以与every正好相反，当遇到一个回调函数的返回值为true时，可以确定结果，那么停止执行，后面都数据不再遍历，停在第一个返回true的位置；当回调函数的返回值为false时，需要继续向后执行，到最后才能确定结果，所以会遍历所有数据，实现类似于forEach的功能，遍历所有。</p>
<pre><code class="jsx">    //demo1:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.some(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
        return value.length &gt; 3;
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true

    //demo2:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.some(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
        return true;
    &#125;)
    // 打印结果为：
    // Tom--0--true

    //demo3:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.some(function(value,index,self)&#123;
        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
        return false;
    &#125;)
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true
    // Lucy--3--true
    // Lily--4--true
    // May--5--true
</code></pre>
<p><strong>功能2：</strong>与every相反，只要有一个回调函数的返回值都为true，some的返回值为true，所有回调函数的返回值为false，some的返回值才为false</p>
<pre><code class="jsx">    //demo1:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.some(function(value,index,self)&#123;
        return value.length &gt; 3;
    &#125;)
    console.log(a);             //true

    //demo2:
    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];
    var a = arr.some(function(value,index,self)&#123;
        return value.length &gt; 4;
    &#125;)
    console.log(a);             //false
</code></pre>
<h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h6><p><strong>功能：</strong>从数组的第一项开始，逐个遍历到最后，迭代数组的所有项，然后构建一个最终返回的值。</p>
<p><strong>参数：</strong>reduce()接收一个或两个参数：第一个是回调函数，表示在数组的每一项上调用的函数；第二个参数（可选的）作为归并的初始值，被回调函数第一次执行时的第一个参数接收。<br> reduce(callback,initial);callback默认有四个参数，分别为prev，now，index，self。<br> callback返回的任何值都会作为下一次执行的第一个参数。<br> 如果initial参数被省略，那么第一次迭代发生在数组的第二项上，因此callback的第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<pre><code class="jsx">    //demo1:不省略initial参数，回调函数没有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self)&#123;
        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
    &#125;, 2019)
    // 打印结果为：
    // 2019--10--0--true
    // undefined--20--1--true
    // undefined--30--2--true
    // undefined--40--3--true
    // undefined--50--4--true
    // 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined

    //demo2:省略initial参数，回调函数没有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self)&#123;
        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self))
    &#125;)
    // 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项
    // 10--20--1--true
    // undefined--30--2--true
    // undefined--40--3--true
    // undefined--50--4--true
    // 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined

    //demo3:不省略initial参数，回调函数有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self)&#123;
        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self));
        return &quot;hello&quot;;
    &#125;, 2019)
    // 打印结果为：
    // 2019--10--0--true
    // hello--20--1--true
    // hello--30--2--true
    // hello--40--3--true
    // hello--50--4--true
    // 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值

    //demo4:省略initial参数，回调函数有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self)&#123;
        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self));
        return &quot;hello&quot;;
    &#125;)
    // 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项
    // 10--20--1--true
    // hello--30--2--true
    // hello--40--3--true
    // hello--50--4--true
    // 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值

    //demo5：使用reduce计算数组中所有数据的和
    var arr = [10,20,30,40,50];
    var sum = arr.reduce(function(prev,now,index,self)&#123;
        return prev + now;
    &#125;)
    console.log(sum);      //150
    // 回调函数的最后一次return的结果被返回到reduce方法的身上

    //demo6：使用reduce计算数组中所有数据的和
    var arr = [10,20,30,40,50];
    var sum = arr.reduce(function(prev,now,index,self)&#123;
        return prev + now;
    &#125;, 8)
    console.log(sum);      //158
    // 回调函数的最后一次return的结果被返回到reduce方法的身上
    // 因为reduce有第二个参数initial，在第一次执行时被计算，所以最终结果被加上8
</code></pre>
<h6 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h6><p><strong>功能：</strong>（与reduce类似）从数组的最后一项开始，向前逐个遍历到第一位，迭代数组的所有项，然后构建一个最终返回的值。<br> <strong>参数：</strong>同reduce。<br> <strong>demo：</strong>同reduce</p>
<h5 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h5><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h6><pre><code class="js">var arr = [5,99,2,9,1,5,67,7,10,23]      //定义一个杂乱的数组
    for(var i=0;i&lt;arr.length-1;i++)&#123;         //大循环，用于遍历数组每个元素
        for(var j=0;j&lt;arr.length-i-1;j++)&#123;   //小循环，用于将数组中的某个元素与其它所有元素相比较
            var temp;                         //声明一个局部变量，当作第三个空瓶子
            if(arr[j]&gt;arr[j+1])&#123;           //判断当前元素和后一个元素的大小，如果当前元素比后一个元素大
                temp = arr[j+1];           //将后一个元素（小元素）放在空瓶子里
                arr[j+1] = arr[j];         //将当前元素（大元素）放在后一个元素的位置
                arr[j] = temp;             //将小元素从空瓶子中拿出来，放在当前元素的位置
            &#125;
        &#125; 
    &#125;
    console.log(arr);                      //完成循环之后，初始数组的顺序已经发生改变
</code></pre>
<h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h6><pre><code class="js">    var arr = [5,99,2,9,1,5,67,7,10,23]
    for(var i=0;i&lt;arr.length-1;i++)&#123;       //大循环，需要比对的次数
        var min = arr[i];                  //假定一个最小值
        var minIndex = i;                  //假定最小值的索引
        for(var j=i+1;j&lt;arr.length;j++)&#123;   //小循环，每次需要比对的次数
            if(min&gt;arr[j])&#123;                //判断最小值是否为真的最小值
                min = arr[j];              //获取真正的最小值
                minIndex = j;              //获取真正最小值的索引
            &#125;
        &#125;

        arr[minIndex] = arr[i];            //将当前元素放在最小值的位置
        arr[i] = min;                      //将最小值放在当前元素的位置
    &#125;
    console.log(arr);                      //输入排序好的数组 
</code></pre>
<h1 id="数组的方法some和includes"><a href="#数组的方法some和includes" class="headerlink" title="数组的方法some和includes"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wwwxxjsyy/p/12558954.html">数组的方法some和includes</a></h1><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p>
<p>some() 方法会依次执行数组的每个元素：</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回<em>true</em> , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回false。</li>
<li></li>
</ul>
<p><strong>注意：</strong> some() 不会对空数组进行检测。</p>
<p>​      some() 不会改变原始数组。</p>
<p>includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false</p>
<p>两者经常会搭配使用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-01 基本数据类型的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/01%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.490Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/01%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-基本数据类型
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>字符串的标志：引号</p>
</blockquote>
<ul>
<li><p>字符串的拼接过程中：引号要配对，变量不能放在引号中</p>
<pre><code class="js">var a = &quot;很好&quot;;
console.log(&quot;今天天气&quot;+ a +&quot;适合出去玩&quot;);
</code></pre>
</li>
<li><p>创建字符</p>
<ul>
<li>字面量创建</li>
<li>构造函数创建</li>
</ul>
<pre><code class="js">var str = &quot;&quot;;
var str2 = new String(&quot;&quot;);
console.log(str);
console.log(str2);
</code></pre>
</li>
</ul>
<h4 id="String-prototype方法"><a href="#String-prototype方法" class="headerlink" title="String.prototype方法"></a>String.prototype方法</h4><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h5><blockquote>
<p> indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.indexOf(searchvalue,fromindex)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str = &quot;hello world&quot;;
str.indexOf(&quot;o&quot;);//4，存在即返回索引
str.indexOf(&quot;o&quot;,5);//7,从索引为5的数据开始往后找
str.indexOf(&quot;a&quot;);//-1,不存在即返回-1
</code></pre>
</li>
</ul>
<h5 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h5><blockquote>
<p>charAt() 方法可返回指定位置的字符。</p>
<p>请注意，JavaScript 并没有一种有别于字符串类型的字符数据类型，所以返回的字符是长度为 1 的字符串。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js"> stringObject.charAt(index)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str = &quot;hello world&quot;;
str.charAt(2);//&quot;l&quot;
str.charAt(-1);//&quot;&quot;
</code></pre>
</li>
</ul>
<h5 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h5><blockquote>
<p> slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.slice(start,end)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;Hello happy world!&quot;;
document.write(str.slice(6));//&quot;happy world!&quot;
document.write(str.slice(2,4));//&quot;ll&quot;
</code></pre>
</li>
</ul>
<h5 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h5><blockquote>
<p> substr() 方法可在字符串中抽取从 <em>start</em> 下标开始的指定数目的字符。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.substr(start,length)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;Hello happy world!&quot;;
document.write(str.substr(6));//&quot;happy world!&quot;
document.write(str.substr(2,4));//&quot;lo h&quot;
</code></pre>
</li>
</ul>
<h5 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h5><blockquote>
<p> substring() 方法用于提取字符串中介于两个指定下标之间的字符。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.substring(start,stop)，取start到（stop-1）范围内的字符
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;Hello world!&quot;
document.write(str.substring(3));//&quot;lo world!&quot;
document.write(str.substring(3,7))//&quot;lo w&quot;
</code></pre>
</li>
</ul>
<h5 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h5><blockquote>
<p> split() 方法用于把一个字符串分割成字符串数组。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.split(separator,howmany)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;How are you doing today?&quot;
console.log(str.split(&quot; &quot;) + &quot;&lt;br /&gt;&quot;)//&quot;How,are,you,doing,today?&lt;br /&gt;&quot;
console.log(str.split(&quot;&quot;) + &quot;&lt;br /&gt;&quot;)//&quot;H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?&lt;br /&gt;&quot;
console.log(str.split(&quot; &quot;,3))//(3) [&quot;How&quot;, &quot;are&quot;, &quot;you&quot;]

&quot;2:3:4:5&quot;.split(&quot;:&quot;)    //将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]
&quot;|a|b|c&quot;.split(&quot;|&quot;)    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

&quot;hello&quot;.split(&quot;&quot;, 3)    //可返回 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;]
</code></pre>
</li>
</ul>
<h5 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h5><blockquote>
<p> toLowerCase() 方法用于把字符串转换为小写。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.toLowerCase()
</code></pre>
</li>
<li><p>返回值</p>
<p>​    一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了小写字符。</p>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;Hello World!&quot;
console.log(str.toLowerCase());//&quot;hello world!&quot;
</code></pre>
</li>
</ul>
<h5 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h5><blockquote>
<p> toUpperCase() 方法用于把字符串转换为大写。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="JS">stringObject.toUpperCase()
</code></pre>
</li>
<li><p>返回值</p>
<p>​    一个新的字符串，在其中 stringObject 的所有小写字符全部被转换为了大写字符。 </p>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;Hello World!&quot;
console.log(str.toUpperCase());//&quot;HELLO WORLD!&quot;
</code></pre>
</li>
</ul>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><blockquote>
<p> concat() 方法用于连接两个或多个字符串。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.concat(stringX,stringX,...,stringX)
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str1=&quot;Hello &quot;
var str2=&quot;world!&quot;
document.write(str1.concat(str2));//&quot;Hello world!&quot;
</code></pre>
</li>
</ul>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><blockquote>
<p><strong><code>includes()</code></strong> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">str.includes(searchString[, position])
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str = &#39;To be, or not to be, that is the question.&#39;;

console.log(str.includes(&#39;To be&#39;)); // true
console.log(str.includes(&#39;question&#39;)); // true
console.log(str.includes(&#39;not tobe&#39;)); // false
console.log(str.includes(&#39;To be&#39;, 1)); // false
console.log(str.includes(&#39;o be&#39;, 1)); // true
console.log(str.includes(&#39;TO BE&#39;)); // false
</code></pre>
</li>
</ul>
<h5 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h5><blockquote>
<p> replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 </p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">stringObject.replace(regexp/substr,replacement)
</code></pre>
</li>
<li><p>返回值</p>
<p>​     一个新的字符串，是用 <em>replacement</em> 替换了 regexp 的第一次匹配或所有匹配之后得到的。 </p>
</li>
<li><p>实例</p>
<pre><code class="js">var str=&quot;Visit Microsoft!,Microsoft&quot;
console.log(str.replace(/Microsoft/, &quot;W3School&quot;));//&quot;Visit Microsoft&quot;
</code></pre>
</li>
</ul>
<h4 id="字符编码的介绍和转换"><a href="#字符编码的介绍和转换" class="headerlink" title="字符编码的介绍和转换"></a>字符编码的介绍和转换</h4><h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><ul>
<li> American Standard Code for Information Interchange，美国信息交换标准代码。 </li>
</ul>
<h5 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h5><ul>
<li>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。</li>
<li>Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符。 </li>
</ul>
<h5 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h5><ul>
<li>GBK全称《汉字内码扩展规范》（GBK即“国标”、“扩展”汉语拼音的第一个字母，英文名称：Chinese Internal Code Specification）</li>
<li>GBK 向下与GB2312编码兼容，向上支持 ISO 10646.1国际标准，是前者向后者过渡过程中的一个承上启下的产物。 </li>
</ul>
<h6 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h6><ul>
<li> UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码。</li>
<li> UTF-8用1到4个字节编码UNICODE字符。用在网页上可以同一页面显示中文简体繁体及其它语言（如英文，日文，韩文） </li>
</ul>
<h4 id="字符串常见API"><a href="#字符串常见API" class="headerlink" title="字符串常见API"></a>字符串常见API</h4><h5 id="myStr-charCodeAt-num"><a href="#myStr-charCodeAt-num" class="headerlink" title="myStr.charCodeAt(num)"></a>myStr.charCodeAt(num)</h5><p>返回指定位置的字符的Unicode（是字符编码的一种模式）编码。</p>
<pre><code class="js">var str=&quot;Hello world!&quot;
console.log(str.charCodeAt(1));//&quot;101&quot;
</code></pre>
<h5 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h5><p>String的意思就是不能用自己定义的字符串名字来调用，只能用String来定义调用。可以识别十进制和十六进制的编码，但是不识别u编码然后返回一个或多个字符串。(把unicode编码转换为字符串)。</p>
<pre><code class="js">var n = String.fromCharCode(65);//A
</code></pre>
<h4 id="ES6新增"><a href="#ES6新增" class="headerlink" title="ES6新增"></a>ES6新增</h4><h5 id="str-codePointAt"><a href="#str-codePointAt" class="headerlink" title="str.codePointAt()"></a>str.codePointAt()</h5><blockquote>
<p> <strong><code>codePointAt()</code></strong> 方法返回 一个 Unicode 编码点值的非负整数。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">str.codePointAt(pos)//支持5位unicode编码
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">&#39;ABC&#39;.codePointAt(1);          // 66
&#39;\uD800\uDC00&#39;.codePointAt(0); // 65536

&#39;XYZ&#39;.codePointAt(42); // undefined

`𠮶`.codePointAt();//134070
</code></pre>
</li>
</ul>
<h5 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h5><blockquote>
<p> <code>String.fromCodePoint()</code> 静态方法返回使用指定的代码点序列创建的字符串。**</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">String.fromCodePoint(num1[, ...[, numN]])
</code></pre>
</li>
<li><p>返回值</p>
<p><strong>使用指定的 Unicode 编码位置创建的字符串。</strong></p>
</li>
<li><p>实例</p>
<pre><code class="js">String.fromCodePoint(42);       // &quot;*&quot;
String.fromCodePoint(65, 90);   // &quot;AZ&quot;
String.fromCodePoint(0x404);    // &quot;\u0404&quot;
String.fromCodePoint(0x2F804);  // &quot;\uD87E\uDC04&quot;
String.fromCodePoint(194564);   // &quot;\uD87E\uDC04&quot;
String.fromCodePoint(0x1D306, 0x61, 0x1D307) // &quot;\uD834\uDF06a\uD834\uDF07&quot;
</code></pre>
</li>
</ul>
<h5 id="str-includes"><a href="#str-includes" class="headerlink" title="str.includes()"></a>str.includes()</h5><blockquote>
<p><strong><code>includes()</code></strong> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">str.includes(searchString[, position])
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str = &#39;To be, or not to be, that is the question.&#39;;

console.log(str.includes(&#39;To be&#39;)); // true
console.log(str.includes(&#39;question&#39;)); // true
console.log(str.includes(&#39;not tobe&#39;)); // false
console.log(str.includes(&#39;To be&#39;, 1)); // false
console.log(str.includes(&#39;o be&#39;, 1)); // true
console.log(str.includes(&#39;TO BE&#39;)); // false
</code></pre>
</li>
</ul>
<h5 id="str-startsWith"><a href="#str-startsWith" class="headerlink" title="str.startsWith()"></a>str.startsWith()</h5><blockquote>
<p><code>startsWith()</code> 方法用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 <code>true</code> 或 <code>false</code>。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">str.startsWith(searchString[, position])
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">如果在字符串的开头找到了给定的字符则返回true;否则, 返回false.
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str = &quot;To be, or not to be, that is the question.&quot;;

alert(str.startsWith(&quot;To be&quot;));         // true
alert(str.startsWith(&quot;not to be&quot;));     // false
alert(str.startsWith(&quot;not to be&quot;, 10)); // true
</code></pre>
</li>
</ul>
<h5 id="str-endsWith"><a href="#str-endsWith" class="headerlink" title="str.endsWith()"></a>str.endsWith()</h5><blockquote>
<p><code>endsWith()</code>方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 <code>true</code> 或 <code>false</code>。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">str.endsWith(searchString[, length])
</code></pre>
</li>
<li><p>返回值</p>
<pre><code class="js">如果传入的子字符串在搜索字符串的末尾则返回true；否则将返回 false。
</code></pre>
</li>
<li><p>实例</p>
<pre><code class="js">var str = &quot;To be, or not to be, that is the question.&quot;;

alert( str.endsWith(&quot;question.&quot;) );  // true
alert( str.endsWith(&quot;to be&quot;) );      // false
alert( str.endsWith(&quot;to be&quot;, 19) );  // true
</code></pre>
</li>
</ul>
<h5 id="str-repeat"><a href="#str-repeat" class="headerlink" title="str.repeat()"></a>str.repeat()</h5><blockquote>
<p><strong><code>repeat()</code></strong> 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code class="js">/** 
 * str: String
 * count: Number
 */

let resultString = str.repeat(count);
</code></pre>
</li>
<li><p>返回值</p>
<p><strong>包含指定字符串的指定数量副本的新字符串</strong></p>
</li>
<li><p>实例</p>
<pre><code class="js">&quot;abc&quot;.repeat(-1)     // RangeError: repeat count must be positive and less than inifinity
&quot;abc&quot;.repeat(0)      // &quot;&quot;
&quot;abc&quot;.repeat(1)      // &quot;abc&quot;
&quot;abc&quot;.repeat(2)      // &quot;abcabc&quot;
&quot;abc&quot;.repeat(3.5)    // &quot;abcabcabc&quot; 参数count将会被自动转换成整数.
&quot;abc&quot;.repeat(1/0)    // RangeError: repeat count must be positive and less than inifinity
</code></pre>
</li>
</ul>
<h5 id="反引号语法"><a href="#反引号语法" class="headerlink" title="反引号语法"></a>反引号语法</h5><ul>
<li><p>支持换行</p>
<pre><code class="js">var name = &quot;root&quot;;
var str = `hello
world`;
console.log(str);
</code></pre>
</li>
<li><p>配合<code>$&#123;&#125;</code>支持变量拼接</p>
<pre><code class="js">var name = &quot;root&quot;;
var str = `hello&quot;&quot;&#39;&#39;&#39;&quot;&quot;$&#123;name&#125;&quot;
world`;
console.log(str)
</code></pre>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Object-assign" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/Object-assign/" class="article-date">
  	<time datetime="2022-09-15T08:26:43.500Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/Object-assign/">
        js原生-Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="jsx">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】
举个栗子：
const object1 = &#123;
  a: 1,
  b: 2,
  c: 3
&#125;;

const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);

console.log(object2.c, object2.d);
console.log(object1)  // &#123; a: 1, b: 2, c: 3 &#125;
console.log(object2)  // &#123; c: 3, d: 5, a: 1, b: 2 &#125;

注意：
1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性
2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标
对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如
果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到
原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。
</code></pre>
<h4 id="二、Object-assign-对象的深拷贝"><a href="#二、Object-assign-对象的深拷贝" class="headerlink" title="二、Object.assign()对象的深拷贝"></a>二、Object.assign()对象的深拷贝</h4><pre><code class="jsx">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。
let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; 
let obj2 = Object.assign(&#123;&#125;, obj1); 
console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 

obj1.a = 1; 
console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; 
console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 

obj2.a = 2; 
console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; 
console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;
 
obj2.b.c = 3; 
console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; 
console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; 
最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响

// Deep Clone （深拷贝）
obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; 
let obj3 = JSON.parse(JSON.stringify(obj1)); 
obj1.a = 4; 
obj1.b.c = 4; 
console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;
</code></pre>
<h4 id="3、对象的合并"><a href="#3、对象的合并" class="headerlink" title="3、对象的合并"></a>3、对象的合并</h4><pre><code class="jsx">const o1 = &#123; a: 1 &#125;;
const o2 = &#123; b: 2 &#125;;
const o3 = &#123; c: 3 &#125;;

const obj = Object.assign(o1, o2, o3);
console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;
console.log(o1);  // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。
其实就是对象的拷贝，o1就是目标对象，后面的是源对象，后面的属性等会拷贝到目标对象
</code></pre>
<h4 id="4、合并具有相同属性的对象"><a href="#4、合并具有相同属性的对象" class="headerlink" title="4、合并具有相同属性的对象"></a>4、合并具有相同属性的对象</h4><pre><code class="jsx">const o1 = &#123; a: 1, b: 1, c: 1 &#125;;
const o2 = &#123; b: 2, c: 2 &#125;;
const o3 = &#123; c: 3 &#125;;

const obj = Object.assign(&#123;&#125;, o1, o2, o3);
console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;
1.属性被后续参数中具有相同属性的其他对象覆盖。
2.目标对象的属性与源对象的属性相同，源的会覆盖目标的属性
</code></pre>
<h4 id="5-继承属性和不可枚举属性是不能拷贝"><a href="#5-继承属性和不可枚举属性是不能拷贝" class="headerlink" title="5.继承属性和不可枚举属性是不能拷贝"></a>5.继承属性和不可枚举属性是不能拷贝</h4><pre><code class="jsx">const obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。
    bar: &#123;
        value: 2  // bar 是个不可枚举属性。
    &#125;,
    baz: &#123;
        value: 3,
        enumerable: true  // baz 是个自身可枚举属性。
    &#125;
&#125;);
创建对象时，如果没有设置enumerable的值，默认为false（不可枚举属性），设置为true，则为可枚举属性
const copy = Object.assign(&#123;&#125;, obj);
console.log(copy); // &#123; baz: 3 &#125;
</code></pre>
<h4 id="6-原始类型会被包装为对象"><a href="#6-原始类型会被包装为对象" class="headerlink" title="6.原始类型会被包装为对象"></a>6.原始类型会被包装为对象</h4><pre><code class="jsx">const v1 = &quot;abc&quot;;
const v2 = true;
const v3 = 10;
const v4 = Symbol(&quot;foo&quot;)

const obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); 
// 原始类型会被包装，null 和 undefined 会被忽略。
// 注意，只有字符串的包装对象才可能有自身可枚举属性。
console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;
</code></pre>
<h4 id="7-异常会打断后续拷贝任务"><a href="#7-异常会打断后续拷贝任务" class="headerlink" title="7.异常会打断后续拷贝任务"></a>7.异常会打断后续拷贝任务</h4><pre><code class="jsx">const target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;
    value: 1,
    writable: false
&#125;); // target 的 foo 属性是个只读属性。

Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);
// TypeError: &quot;foo&quot; is read-only
// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。

console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。
console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。
console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。
console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。
console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-ie8 浏览器 js兼容问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/ie8%20%E6%B5%8F%E8%A7%88%E5%99%A8%20js%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/" class="article-date">
  	<time datetime="2022-09-15T08:24:27.077Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/ie8%20%E6%B5%8F%E8%A7%88%E5%99%A8%20js%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/">
        js-ie8 浏览器 js兼容问题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为项目需要，客户设备上都是IE8，总结了一些IE8上容易出现的兼容性错误</p>
<p>\1. jQuery使用2.0以下版本</p>
<p>2.document.getElementsByClassName 不能使用</p>
<p>3.console.log()不支持</p>
<p>4.iframe 的 onload 事件，需要通过 attachEvent 来注册</p>
<p>5.因为jq使用版本低，所以注意on ,是在1.7版本才出现的</p>
<p>6.IE8(Q) 中的 getElementById 方法能以 name 属性为参数获取某些元素</p>
<p>7.使用apped动态加载元素时候，注意标记元素必须是规范的html标记,不能是自创元素或者标记未关闭</p>
<p>8.remove()不能再IE8中正常使用,使用removeNode(true);</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>