<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/10/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/10/">React博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-22 react hooks" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/22%20react%20hooks/" class="article-date">
  	<time datetime="2022-08-25T03:11:50.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/22%20react%20hooks/">
        React- React Hooks
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><h2 id="使用hooks的理由"><a href="#使用hooks的理由" class="headerlink" title="使用hooks的理由"></a>使用hooks的理由</h2><ol>
<li>高阶组件为了复用，导致代码层级复杂</li>
<li>生命周期的复杂</li>
<li>写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高</li>
</ol>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><pre><code class="js">import React , &#123;useState&#125; from &#39;react&#39;
</code></pre>
<pre><code class="jsx">export default function App () &#123;
    const [name,setname] = useState(&#39;xiaoming&#39;)
    const changeName = ()=&gt;&#123;
        setname(&#39;retr0&#39;)
    &#125;
    return (
        &lt;div&gt;
            &#123;name&#125;
            &lt;button onClick=&#123;changeName&#125;&gt;&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><pre><code class="js">import React, &#123;useRef&#125; from &#39;react&#39;
</code></pre>
<pre><code class="jsx">export default function App () &#123;
    const ref = useRef(null)
    return (
        &lt;div&gt;
            &lt;input type=&#39;text&#39; ref=&#123;ref&#125;/&gt;
             &lt;button onClick=&#123;()=&gt;&#123;
                       console.log(ref.current)
                &#125;&#125;&gt;&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><blockquote>
<p>Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。</p>
<p>useEffect(处理函数，[依赖]) 副作用方法:每次依赖改变都会执行一次，如果没有依赖只有一个空数组，那么只会执行一次（有点像componentDidmount）</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>回调函数</li>
<li>数组<ul>
<li>不传数组：无法起到只渲染一次的作用</li>
<li>空数组：一次生命周期中只调用一次回调函数</li>
<li>[text,name]：如果text状态或者name状态变化，就会调用该回调函数</li>
</ul>
</li>
</ol>
<pre><code class="js">import React , &#123;useState,useEffect&#125; from &#39;react&#39;
</code></pre>
<pre><code class="jsx">export default function App () &#123;
    const [name,setname] = useState(&#39;xiaoming&#39;)
    useEffect(()=&gt;&#123;
        let index =1
        let t = setInterval(()=&gt;&#123;
            console.log(++index)
        &#125;,500)
        return ()=&gt;&#123;
            console.log(&#39;销毁&#39;)
            clearInterval(t)
        &#125;
    &#125;,[])
    return (
        &lt;div&gt;&lt;/div&gt;
    )
&#125;
</code></pre>
<p>不要对 Dependencies 撒谎, 如果你明明使用了某个变量，却没有申明在依赖中，你等于向 React撒了谎，后果就是，当依赖的变量改变时，useEffect 也不会再次执行, eslint会报警告</p>
<p>Preview页面改造成函数式组件，在路径上从id=1切换到id=2也会自动重新加载，比class组件方便,class组件需要通过componentWillMout和</p>
<pre><code class="jsx">useEffect(()=&gt;&#123;
    axios.get(`/articles/$&#123;props.match.params.id&#125;`)
    .then(res =&gt; &#123;
        settitle(res.data.title)
        setcontent(res.data.content)
        setcategory(res.data.category)
    &#125;)&#125;,[props])
</code></pre>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><blockquote>
<p>防止因为组件重新渲染，导致方法被重新创建，起到缓存作用; 只有第二个参数变化了，才重新声明一次</p>
</blockquote>
<pre><code class="js">import React , &#123;useState,useCallback&#125; from &#39;react&#39;
</code></pre>
<pre><code class="jsx">export default function App () &#123;
    const [text,settext] = useState(&#39;xxx&#39;)
    useCallback(()=&gt;&#123;
        console.log(text)
    &#125;,[text])
    return (
        &lt;div&gt;
            &#123;text&#125;
            &lt;button onClick=&#123;()=&gt;&#123;
                    settext(&#39;retr0&#39;)
                &#125;&#125;&gt;&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<h2 id="useReducer和useContext"><a href="#useReducer和useContext" class="headerlink" title="useReducer和useContext"></a>useReducer和useContext</h2><blockquote>
<p>redux-react-hook 无缝使用原来的 redux,和中间件 promise,thunk,saga</p>
</blockquote>
<pre><code class="js">import React, &#123;useReducer,useContext&#125; from &#39;react&#39;
import reducer from &#39;./reducer&#39;
const GlobalContext = React.createContext()
</code></pre>
<h3 id="reducer-js"><a href="#reducer-js" class="headerlink" title="reducer.js"></a>reducer.js</h3><pre><code class="js">// 纯函数设计 reudx中的reducer一个概念
const reducer = (prevState,action)=&gt;&#123;
  let &#123;type,payload&#125; = action
  switch(type)&#123;
    case &quot;isShow&quot;:
      //深复制老状态，返回新状态
    return &#123;
      ...prevState,
      isShow:payload
    &#125; // immutable
    case &quot;list&quot;:
      //深复制老状态，返回新状态
    return &#123;
      ...prevState,
      list:payload
    &#125;
  &#125;
&#125;
export default reducer
</code></pre>
<h3 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a>App.js</h3><pre><code class="jsx">const Child1 = ()=&gt;&#123;
    const &#123;state,dispatch&#125; = useContext(GlobalContext)
       return (
        &lt;div&gt;
            &lt;button onClick=&#123;()=&gt;&#123;
                    dispatch(&#123;
                        type:&#39;isShow&#39;,
                        payload:!state.isShow
                    &#125;)
                &#125;&#125;&gt;&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;
const Child2 = ()=&gt;&#123;
    
&#125;
export default function App () &#123;
    let [state,dispatch] = useReducer(reducer,&#123;
        isShow:false,
        list:[]
    &#125;)
    return (
        &lt;GlobalContext.Provider value=&#123;&#123;
                state,
                dispatch
            &#125;&#125;&gt;
            &lt;Child1/&gt;
            &#123;
                state.isShow?&lt;Child2/&gt;:null
            &#125;
        &lt;/GlobalContext.Provider&gt;
    )
&#125;
</code></pre>
<h2 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h2><blockquote>
<p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。必须以“use”开头吗？必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则</p>
</blockquote>
<pre><code class="jsx">import React, &#123; useState, useEffect &#125; from &#39;react&#39;
import axios from &#39;axios&#39;
import &#123; PageHeader &#125; from &#39;antd&#39;;
import store from &#39;../../mobx/store&#39;
//为preview提供数据
const usePreviewData = (props)=&gt;&#123;
  const [title, setTitle] = useState(&#39;&#39;)
  const [category, setCategory] = useState(&#39;&#39;)
  const [content, setContent] = useState(&#39;&#39;)
  useEffect(() =&gt; &#123;
    store.set(&#39;isShow&#39;, false)
    axios.get(`http://localhost:12138/articles/$&#123;props.match.params.myid&#125;`).then(res =&gt; &#123;
      let &#123; title, category, content &#125; = res.data
      setTitle(title)
      setCategory(category)
      setContent(content)
    &#125;)
  &#125;, [props.match.params.myid])
  return &#123;
    title,
    category,
    content
  &#125;
&#125;
export default function HookPreview(props) &#123;
   // console.log(this.props);//函数式组件从函数的形参中就能拿到属性
  let &#123;title,category,content&#125; = usePreviewData(props)
  return (
    &lt;div&gt;
      &lt;PageHeader
        className=&quot;site-page-header&quot;
        onBack=&#123;() =&gt; &#123;
          props.history.goBack()
        &#125;&#125;
        title=&#123;title&#125;
        subTitle=&#123;category ? category.join(&#39;/&#39;) : null&#125;
      /&gt;
      &lt;div style=&#123;&#123; padding: '24px' &#125;&#125; dangerouslySetInnerHTML=&#123;&#123;
        __html: content
      &#125;&#125;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-21 redux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/21%20redux/" class="article-date">
  	<time datetime="2022-08-25T03:11:28.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/21%20redux/">
        React- Redux最主要是用作应用状态的管理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（state对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers），这样就可以进行数据追踪，实现时光旅行。</p>
<h2 id="redux介绍及设计和使用的三大原则"><a href="#redux介绍及设计和使用的三大原则" class="headerlink" title="redux介绍及设计和使用的三大原则"></a>redux介绍及设计和使用的三大原则</h2><ul>
<li>state以单一对象存储在store对象中</li>
<li>state只读（每次都返回一个新对象）</li>
<li>使用纯函数reducer执行state更新</li>
</ul>
<h2 id="redux工作流"><a href="#redux工作流" class="headerlink" title="redux工作流"></a>redux工作流</h2><p><img src="https://upload-images.jianshu.io/upload_images/2547292-cae4b69ca467d0f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/638/format/webp" alt="img"></p>
<p>我个人粗浅的理解是：<br> Store的角色是整个应用的数据存储中心，集中大部分页面需要的状态数据；<br> ActionCreators ,view 层与data层的介质；<br> Reduce ，接收action并更新Store。<br> 所以流程是 用户通过界面组件 触发ActionCreator，携带Store中的旧State与Action 流向Reducer,Reducer返回新的state，并更新界面。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>首先，让我们来给 action 下个定义。</p>
<p><strong>Action</strong> 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。一般来说你会通过 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 将 action 传到 store。</p>
<p>添加新 todo 任务的 action 是这样的：</p>
<pre><code class="js">const ADD_TODO = &#39;ADD_TODO&#39;
&#123;
  type: ADD_TODO,
  text: &#39;Build my first Redux app&#39;
&#125;
</code></pre>
<p>Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作。多数情况下，<code>type</code> 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<pre><code class="js">import &#123; ADD_TODO, REMOVE_TODO &#125; from &#39;../actionTypes&#39;
</code></pre>
<blockquote>
<h5 id="样板文件使用提醒"><a href="#样板文件使用提醒" class="headerlink" title="样板文件使用提醒"></a>样板文件使用提醒</h5><p>使用单独的模块或文件来定义 action type 常量并不是必须的，甚至根本不需要定义。对于小应用来说，使用字符串做 action type 更方便些。不过，在大型应用中把它们显式地定义成常量还是利大于弊的。参照 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/recipes/ReducingBoilerplate.html">减少样板代码</a> 获取更多保持代码简洁的实践经验。</p>
</blockquote>
<p>除了 <code>type</code> 字段外，action 对象的结构完全由你自己决定。参照 <a target="_blank" rel="noopener" href="https://github.com/acdlite/flux-standard-action">Flux 标准 Action</a> 获取关于如何构造 action 的建议。</p>
<p>这时，我们还需要再添加一个 action index 来表示用户完成任务的动作序列号。因为数据是存放在数组中的，所以我们通过下标 <code>index</code> 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。</p>
<pre><code class="js">&#123;
  type: TOGGLE_TODO,
  index: 5
&#125;
</code></pre>
<p><strong>我们应该尽量减少在 action 中传递的数据</strong>。比如上面的例子，传递 <code>index</code> 就比把整个任务对象传过去要好。</p>
<p>最后，再添加一个 action type 来表示当前的任务展示选项。</p>
<pre><code class="js">&#123;
  type: SET_VISIBILITY_FILTER,
  filter: SHOW_COMPLETED
&#125;
</code></pre>
<p>Action 创建函数</p>
<p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p>
<p>在 Redux 中的 action 创建函数只是简单的返回一个 action:</p>
<pre><code class="js">function addTodo(text) &#123;
  return &#123;
    type: ADD_TODO,
    text
  &#125;
&#125;
</code></pre>
<p>这样做将使 action 创建函数更容易被移植和测试。</p>
<p>在 <a target="_blank" rel="noopener" href="http://facebook.github.io/flux">传统的 Flux</a> 实现中，当调用 action 创建函数时，一般会触发一个 dispatch，像这样：</p>
<pre><code class="js">function addTodoWithDispatch(text) &#123;
  const action = &#123;
    type: ADD_TODO,
    text
  &#125;
  dispatch(action)
&#125;
</code></pre>
<p>不同的是，Redux 中只需把 action 创建函数的结果传给 <code>dispatch()</code> 方法即可发起一次 dispatch 过程。</p>
<pre><code class="js">dispatch(addTodo(text))
dispatch(completeTodo(index))
</code></pre>
<p>或者创建一个 <strong>被绑定的 action 创建函数</strong> 来自动 dispatch：</p>
<pre><code class="js">const boundAddTodo = text =&gt; dispatch(addTodo(text))
const boundCompleteTodo = index =&gt; dispatch(completeTodo(index))
</code></pre>
<p>然后直接调用它们：</p>
<pre><code>boundAddTodo(text);
boundCompleteTodo(index);
</code></pre>
<p>store 里能直接通过 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 调用 <code>dispatch()</code> 方法，但是多数情况下你会使用 <a target="_blank" rel="noopener" href="http://github.com/gaearon/react-redux">react-redux</a> 提供的 <code>connect()</code> 帮助器来调用。<a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/bindActionCreators.html"><code>bindActionCreators()</code></a> 可以自动把多个 action 创建函数 绑定到 <code>dispatch()</code> 方法上。</p>
<p>Action 创建函数也可以是异步非纯函数。你可以通过阅读 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/advanced/">高级教程</a> 中的 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/advanced/AsyncActions.html">异步 action</a>章节，学习如何处理 AJAX 响应和如何把 action 创建函数组合进异步控制流。因为基础教程中包含了阅读高级教程和异步 action 章节所需要的一些重要基础概念, 所以请在移步异步 action 之前, 务必先完成基础教程。</p>
<p>源码</p>
<h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a><code>actions.js</code></h3><pre><code class="js">/*
 * action 类型
 */

export const ADD_TODO = &#39;ADD_TODO&#39;;
export const TOGGLE_TODO = &#39;TOGGLE_TODO&#39;
export const SET_VISIBILITY_FILTER = &#39;SET_VISIBILITY_FILTER&#39;

/*
 * 其它的常量
 */

export const VisibilityFilters = &#123;
  SHOW_ALL: &#39;SHOW_ALL&#39;,
  SHOW_COMPLETED: &#39;SHOW_COMPLETED&#39;,
  SHOW_ACTIVE: &#39;SHOW_ACTIVE&#39;
&#125;

/*
 * action 创建函数
 */

export function addTodo(text) &#123;
  return &#123; type: ADD_TODO, text &#125;
&#125;

export function toggleTodo(index) &#123;
  return &#123; type: TOGGLE_TODO, index &#125;
&#125;

export function setVisibilityFilter(filter) &#123;
  return &#123; type: SET_VISIBILITY_FILTER, filter &#125;
&#125;
</code></pre>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><strong>Reducers</strong> 指定了应用状态的变化如何响应 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/basics/Actions.html">actions</a> 并发送到 store 的，记住 actions 只是描述了<em>有事情发生了</em>这一事实，并没有描述应用如何更新 state。</p>
<h3 id="设计-State-结构"><a href="#设计-State-结构" class="headerlink" title="设计 State 结构"></a>设计 State 结构</h3><p>在 Redux 应用中，所有的 state 都被保存在一个单一对象中。建议在写代码前先想一下这个对象的结构。如何才能以最简的形式把应用的 state 用对象描述出来？</p>
<p>以 todo 应用为例，需要保存两种不同的数据：</p>
<ul>
<li>当前选中的任务过滤条件；</li>
<li>完整的任务列表。</li>
</ul>
<p>通常，这个 state 树还需要存放其它一些数据，以及一些 UI 相关的 state。这样做没问题，但尽量把这些数据与 UI 相关的 state 分开。</p>
<pre><code class="js">&#123;
  visibilityFilter: &#39;SHOW_ALL&#39;,
  todos: [
    &#123;
      text: &#39;Consider using Redux&#39;,
      completed: true,
    &#125;,
    &#123;
      text: &#39;Keep all state in a single tree&#39;,
      completed: false
    &#125;
  ]
&#125;
</code></pre>
<blockquote>
<h5 id="处理-Reducer-关系时的注意事项"><a href="#处理-Reducer-关系时的注意事项" class="headerlink" title="处理 Reducer 关系时的注意事项"></a>处理 Reducer 关系时的注意事项</h5><p>开发复杂的应用时，不可避免会有一些数据相互引用。建议你尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 state 想像成数据库。这种方法在 <a target="_blank" rel="noopener" href="https://github.com/gaearon/normalizr">normalizr</a> 文档里有详细阐述。例如，实际开发中，在 state 里同时存放 <code>todosById: &#123; id -&gt; todo &#125;</code> 和 <code>todos: array</code> 是比较好的方式，本文中为了保持示例简单没有这样处理。</p>
</blockquote>
<h3 id="Action-处理"><a href="#Action-处理" class="headerlink" title="Action 处理"></a>Action 处理</h3><p>现在我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</p>
<pre><code class="js">(previousState, action) =&gt; newState
</code></pre>
<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a> 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。<strong>永远不要</strong>在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li>
</ul>
<p>在<a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/advanced/">高级篇</a>里会介绍如何执行有副作用的操作。现在只需要谨记 reducer 一定要保持纯净。<strong>只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p>
<p>明白了这些之后，就可以开始编写 reducer，并让它来处理之前定义过的 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/basics/Actions.html">action</a>。</p>
<p>我们将以指定 state 的初始状态作为开始。Redux 首次执行时，state 为 <code>undefined</code>，此时我们可借机设置并返回应用的初始 state。</p>
<pre><code class="js">import &#123; VisibilityFilters &#125; from &#39;./actions&#39;

const initialState = &#123;
  visibilityFilter: VisibilityFilters.SHOW_ALL,
  todos: []
&#125;;

function todoApp(state, action) &#123;
  if (typeof state === &#39;undefined&#39;) &#123;
    return initialState
  &#125;

  // 这里暂不处理任何 action，
  // 仅返回传入的 state。
  return state
&#125;
</code></pre>
<p>这里一个技巧是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters">ES6 参数默认值语法</a> 来精简代码。</p>
<pre><code class="js">function todoApp(state = initialState, action) &#123;
  // 这里暂不处理任何 action，
  // 仅返回传入的 state。
  return state
&#125;
</code></pre>
<p>现在可以处理 <code>SET_VISIBILITY_FILTER</code>。需要做的只是改变 state 中的 <code>visibilityFilter</code>。</p>
<pre><code class="js">function todoApp(state = initialState, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return Object.assign(&#123;&#125;, state, &#123;
        visibilityFilter: action.filter
      &#125;)
    default:
      return state
  &#125;
&#125;
</code></pre>
<p>注意:</p>
<ol>
<li><strong>不要修改 <code>state</code>。</strong> 使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> 新建了一个副本。不能这样使用 <code>Object.assign(state, &#123; visibilityFilter: action.filter &#125;)</code>，因为它会改变第一个参数的值。你<strong>必须</strong>把第一个参数设置为空对象。你也可以开启对ES7提案<a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/recipes/UsingObjectSpreadOperator.html">对象展开运算符</a>的支持, 从而使用 <code>&#123; ...state, ...newState &#125;</code> 达到相同的目的。</li>
<li><strong>在 <code>default</code> 情况下返回旧的 <code>state</code>。</strong>遇到未知的 action 时，一定要返回旧的 <code>state</code>。</li>
</ol>
<blockquote>
<h5 id="Object-assign-须知"><a href="#Object-assign-须知" class="headerlink" title="Object.assign 须知"></a><code>Object.assign</code> 须知</h5><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，<a target="_blank" rel="noopener" href="https://github.com/babel-plugins/babel-plugin-object-assign">Babel 插件</a>，或者使用其它库如 <a target="_blank" rel="noopener" href="https://lodash.com/docs#assign"><code>_.assign()</code></a> 提供的帮助方法。</p>
<h5 id="switch-和样板代码须知"><a href="#switch-和样板代码须知" class="headerlink" title="switch 和样板代码须知"></a><code>switch</code> 和样板代码须知</h5><p><code>switch</code> 语句并不是严格意义上的样板代码。Flux 中真实的样板代码是概念性的：更新必须要发送、Store 必须要注册到 Dispatcher、Store 必须是对象（开发同构应用时变得非常复杂）。为了解决这些问题，Redux 放弃了 event emitters（事件发送器），转而使用纯 reducer。</p>
<p>很不幸到现在为止，还有很多人存在一个误区：根据文档中是否使用 <code>switch</code> 来决定是否使用它。如果你不喜欢 <code>switch</code>，完全可以自定义一个 <code>createReducer</code> 函数来接收一个事件处理函数列表，参照<a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/recipes/ReducingBoilerplate.html#reducers">“减少样板代码”</a>。</p>
</blockquote>
<h3 id="处理多个-action"><a href="#处理多个-action" class="headerlink" title="处理多个 action"></a>处理多个 action</h3><p>还有两个 action 需要处理。就像我们处理 <code>SET_VISIBILITY_FILTER</code> 一样，我们引入 <code>ADD_TODO</code> 和 <code>TOGGLE_TODO</code> 两个actions 并且扩展我们的 reducer 去处理 <code>ADD_TODO</code>.</p>
<pre><code class="js">import &#123;
  ADD_TODO,
  TOGGLE_TODO,
  SET_VISIBILITY_FILTER,
  VisibilityFilters
&#125; from &#39;./actions&#39;

...

function todoApp(state = initialState, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return Object.assign(&#123;&#125;, state, &#123;
        visibilityFilter: action.filter
      &#125;)
    case ADD_TODO:
      return Object.assign(&#123;&#125;, state, &#123;
        todos: [
          ...state.todos,
          &#123;
            text: action.text,
            completed: false
          &#125;
        ]
      &#125;)
    default:
      return state
  &#125;
&#125;
</code></pre>
<p>如上，不直接修改 <code>state</code> 中的字段，而是返回新对象。新的 <code>todos</code> 对象就相当于旧的 <code>todos</code> 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的。</p>
<p>最后，<code>TOGGLE_TODO</code> 的实现也很好理解：</p>
<pre><code class="js">case TOGGLE_TODO:
  return Object.assign(&#123;&#125;, state, &#123;
    todos: state.todos.map((todo, index) =&gt; &#123;
      if (index === action.index) &#123;
        return Object.assign(&#123;&#125;, todo, &#123;
          completed: !todo.completed
        &#125;)
      &#125;
      return todo
    &#125;)
  &#125;)
</code></pre>
<p>我们需要修改数组中指定的数据项而又不希望导致<strong>突变</strong>, 因此我们的做法是在创建一个新的数组后, 将那些无需修改的项原封不动移入, 接着对需修改的项用新生成的对象替换。(译者注：Javascript中的对象存储时均是由值和指向值的引用两个部分构成。此处<strong>突变</strong>指直接修改引用所指向的值, 而引用本身保持不变。) 如果经常需要这类的操作，可以选择使用帮助类 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/update.html">React-addons-update</a>，<a target="_blank" rel="noopener" href="https://github.com/substantial/updeep">updeep</a>，或者使用原生支持深度更新的库 <a target="_blank" rel="noopener" href="http://facebook.github.io/immutable-js/">Immutable</a>。最后，时刻谨记永远不要在克隆 <code>state</code> 前修改它。</p>
<h3 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 Reducer</h3><p>目前的代码看起来有些冗长：</p>
<pre><code class="js">function todoApp(state = initialState, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return Object.assign(&#123;&#125;, state, &#123;
        visibilityFilter: action.filter
      &#125;)
    case ADD_TODO:
      return Object.assign(&#123;&#125;, state, &#123;
        todos: [
          ...state.todos,
          &#123;
            text: action.text,
            completed: false
          &#125;
        ]
      &#125;)
    case TOGGLE_TODO:
      return Object.assign(&#123;&#125;, state, &#123;
        todos: state.todos.map((todo, index) =&gt; &#123;
          if (index === action.index) &#123;
            return Object.assign(&#123;&#125;, todo, &#123;
              completed: !todo.completed
            &#125;)
          &#125;
          return todo
        &#125;)
      &#125;)
    default:
      return state
  &#125;
&#125;
</code></pre>
<p>上面代码能否变得更通俗易懂？这里的 <code>todos</code> 和 <code>visibilityFilter</code> 的更新看起来是相互独立的。有时 state 中的字段是相互依赖的，需要认真考虑，但在这个案例中我们可以把 <code>todos</code> 更新的业务逻辑拆分到一个单独的函数里：</p>
<pre><code class="js">function todos(state = [], action) &#123;
  switch (action.type) &#123;
    case ADD_TODO:
      return [
        ...state,
        &#123;
          text: action.text,
          completed: false
        &#125;
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) =&gt; &#123;
        if (index === action.index) &#123;
          return Object.assign(&#123;&#125;, todo, &#123;
            completed: !todo.completed
          &#125;)
        &#125;
        return todo
      &#125;)
    default:
      return state
  &#125;
&#125;

function todoApp(state = initialState, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return Object.assign(&#123;&#125;, state, &#123;
        visibilityFilter: action.filter
      &#125;)
    case ADD_TODO:
      return Object.assign(&#123;&#125;, state, &#123;
        todos: todos(state.todos, action)
      &#125;)
    case TOGGLE_TODO:
      return Object.assign(&#123;&#125;, state, &#123;
        todos: todos(state.todos, action)
      &#125;)
    default:
      return state
  &#125;
&#125;
</code></pre>
<p>注意 <code>todos</code> 依旧接收 <code>state</code>，但它变成了一个数组！现在 <code>todoApp</code> 只把需要更新的一部分 state 传给 <code>todos</code> 函数，<code>todos</code> 函数自己确定如何更新这部分数据。<strong>这就是所谓的 *reducer 合成*，它是开发 Redux 应用最基础的模式。</strong></p>
<p>下面深入探讨一下如何做 reducer 合成。能否抽出一个 reducer 来专门管理 <code>visibilityFilter</code>？当然可以：</p>
<p>首先引用, 让我们使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 对象结构</a> 去声明 <code>SHOW_ALL</code>:</p>
<pre><code class="js">const &#123; SHOW_ALL &#125; = VisibilityFilters
</code></pre>
<p>接下来：</p>
<pre><code class="js">function visibilityFilter(state = SHOW_ALL, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  &#125;
&#125;
</code></pre>
<p>现在我们可以开发一个函数来做为主 reducer，它调用多个子 reducer 分别处理 state 中的一部分数据，然后再把这些数据合成一个大的单一对象。主 reducer 并不需要设置初始化时完整的 state。初始时，如果传入 <code>undefined</code>, 子 reducer 将负责返回它们的默认值。</p>
<pre><code class="js">function todos(state = [], action) &#123;
  switch (action.type) &#123;
    case ADD_TODO:
      return [
        ...state,
        &#123;
          text: action.text,
          completed: false
        &#125;
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) =&gt; &#123;
        if (index === action.index) &#123;
          return Object.assign(&#123;&#125;, todo, &#123;
            completed: !todo.completed
          &#125;)
        &#125;
        return todo
      &#125;)
    default:
      return state
  &#125;
&#125;

function visibilityFilter(state = SHOW_ALL, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  &#125;
&#125;

function todoApp(state = &#123;&#125;, action) &#123;
  return &#123;
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  &#125;
&#125;
</code></pre>
<p><strong>注意每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 <code>state</code> 参数都不同，分别对应它管理的那部分 state 数据。</strong></p>
<p>现在看起来好多了！随着应用的膨胀，我们还可以将拆分后的 reducer 放到不同的文件中, 以保持其独立性并用于专门处理不同的数据域。</p>
<p>最后，Redux 提供了 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers()</code></a> 工具类来做上面 <code>todoApp</code> 做的事情，这样就能消灭一些样板代码了。有了它，可以这样重构 <code>todoApp</code>：</p>
<pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;

const todoApp = combineReducers(&#123;
  visibilityFilter,
  todos
&#125;)

export default todoApp
</code></pre>
<p>注意上面的写法和下面完全等价：</p>
<pre><code class="js">export default function todoApp(state = &#123;&#125;, action) &#123;
  return &#123;
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  &#125;
&#125;
</code></pre>
<p>你也可以给它们设置不同的 key，或者调用不同的函数。下面两种合成 reducer 方法完全等价：</p>
<pre><code class="js">const reducer = combineReducers(&#123;
  a: doSomethingWithA,
  b: processB,
  c: c
&#125;)
function reducer(state = &#123;&#125;, action) &#123;
  return &#123;
    a: doSomethingWithA(state.a, action),
    b: processB(state.b, action),
    c: c(state.c, action)
  &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers()</code></a> 所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer <strong>根据它们的 key 来筛选出 state 中的一部分数据并处理</strong>，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。<a target="_blank" rel="noopener" href="https://github.com/gaearon/redux/issues/428#issuecomment-129223274">没有任何魔法。</a>正如其他 reducers，如果 combineReducers() 中包含的所有 reducers 都没有更改 state，那么也就不会创建一个新的对象。</p>
<blockquote>
<h5 id="ES6-用户使用注意"><a href="#ES6-用户使用注意" class="headerlink" title="ES6 用户使用注意"></a>ES6 用户使用注意</h5><p><code>combineReducers</code> 接收一个对象，可以把所有顶级的 reducer 放到一个独立的文件中，通过 <code>export</code> 暴露出每个 reducer 函数，然后使用 <code>import * as reducers</code> 得到一个以它们名字作为 key 的 object：</p>
<pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;
import * as reducers from &#39;./reducers&#39;

const todoApp = combineReducers(reducers)
</code></pre>
<p>由于 <code>import *</code> 还是比较新的语法，为了避免<a target="_blank" rel="noopener" href="https://github.com/gaearon/redux/issues/428#issuecomment-129223274">困惑</a>，我们不会在本文档中使用它。但在一些社区示例中你可能会遇到它们。</p>
</blockquote>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="reducers-js"><a href="#reducers-js" class="headerlink" title="reducers.js"></a><code>reducers.js</code></h4><pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;
import &#123;
  ADD_TODO,
  TOGGLE_TODO,
  SET_VISIBILITY_FILTER,
  VisibilityFilters
&#125; from &#39;./actions&#39;
const &#123; SHOW_ALL &#125; = VisibilityFilters

function visibilityFilter(state = SHOW_ALL, action) &#123;
  switch (action.type) &#123;
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  &#125;
&#125;

function todos(state = [], action) &#123;
  switch (action.type) &#123;
    case ADD_TODO:
      return [
        ...state,
        &#123;
          text: action.text,
          completed: false
        &#125;
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) =&gt; &#123;
        if (index === action.index) &#123;
          return Object.assign(&#123;&#125;, todo, &#123;
            completed: !todo.completed
          &#125;)
        &#125;
        return todo
      &#125;)
    default:
      return state
  &#125;
&#125;

const todoApp = combineReducers(&#123;
  visibilityFilter,
  todos
&#125;)

export default todoApp
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-20 mobx" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/20%20mobx/" class="article-date">
  	<time datetime="2022-08-25T03:10:58.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/20%20mobx/">
        React- mobx
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://cn.mobx.js.org/">https://cn.mobx.js.org/</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol>
<li>Mobx是一个功能强大，上手非常容易的状态管理工具。</li>
<li>Mobx背后的哲学很简单: 任何源自应用状态的东西都应该自动地获得。</li>
<li>Mobx利用getter和setter来收集组件的数据依赖关系，从而在数据发生变化的时候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更 新。</li>
</ol>
<h2 id="Mobx与redux的区别"><a href="#Mobx与redux的区别" class="headerlink" title="Mobx与redux的区别"></a>Mobx与redux的区别</h2><ul>
<li>Mobx写法上更偏向于OOP </li>
<li>对一份数据直接进行修改操作，不需要始终返回一个新的数据 </li>
<li>并非单一store,可以多store</li>
<li> Redux默认以JavaScript原生对象形式存储数据，而Mobx使 用可观察对象</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>学习成本小 </li>
<li>面向对象编程 </li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>过于自由：Mobx提供的约定及模版代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一</li>
<li>相关的中间件很少，逻辑层业务整合是问题。</li>
</ul>
<h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h2><pre><code class="js">import &#123;observable&#125; from &#39;mobx&#39;
</code></pre>
<h3 id="box"><a href="#box" class="headerlink" title=".box"></a>.box</h3><pre><code class="js">const store = observable.box(true) //生成一个可以观察的布尔值,box只能观察简单数据类型
</code></pre>
<h3 id="map"><a href="#map" class="headerlink" title=".map"></a>.map</h3><pre><code class="js">const store = observable.map(&#123;
    isShow:true,
    age:12,
    roleList:[],
    rightList:[]
&#125;)
//如果要观察复杂数据类型，需要用map方法
</code></pre>
<h2 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h2><pre><code class="js">import &#123;autorun&#125; from &#39;mobx&#39;
import store from &#39;../../mobx/store&#39;
</code></pre>
<pre><code class="js">autorun(()=&gt;&#123;
    console.log(store.get())
&#125;)
</code></pre>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="js">import &#123; observable, autorun &#125; from &#39;mobx&#39;;
const value = observable.box(0);
const number = observable.box(100);
autorun(() =&gt; &#123;
    console.log(value.get());
&#125;);
value.set(1);
value.set(2);
number.set(101);
//0,1,2。 // autorun 使用到才能被执行
//只能是同步，异步需要处理
//观察对象，通过map
const map = observable.map(&#123; key: &quot;value&quot;&#125;);
//map.set(&quot;key&quot;, &quot;new value&quot;);
//map.get(&quot;key&quot;)
//观察对象，不通过map
const map = observable(&#123; key: &quot;value&quot;&#125;);
// map.key map.key=&quot;xiaoming&quot;
//观察数组
const list = observable([1, 2, 4]);
list[2] = 3;
</code></pre>
<h2 id="mobx取消绑定"><a href="#mobx取消绑定" class="headerlink" title="mobx取消绑定"></a>mobx取消绑定</h2><pre><code class="js">componentWillMount () &#123;
    this.cancel = autorun(()=&gt;&#123;
        this.setState(&#123;
            isShow:store.get(&#39;isShow&#39;)
        &#125;)
    &#125;)
&#125;
componentWillUnMount () &#123;
    this.cancel()
    //或者直接更改setState函数，这样就不会触发上一个组件销毁，但上一个组件中定义的autorun没销毁，导致进行setState操作，但上个组件已经销毁，因此会报一个warning：无法设置一个状态到unmount的组件
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-19 redux-persist" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/19%20redux-persist/" class="article-date">
  	<time datetime="2022-08-25T03:10:36.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/19%20redux-persist/">
        React- redux-persist实现redux持久化，存到localStorage
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="redux-persist"><a href="#redux-persist" class="headerlink" title="redux-persist"></a>redux-persist</h1><blockquote>
<p>实现redux持久化，存到localStorage</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install redux-persist
</code></pre>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre><code class="js">// configureStore.js

import &#123; createStore &#125; from &#39;redux&#39;
import &#123; persistStore, persistReducer &#125; from &#39;redux-persist&#39;
import storage from &#39;redux-persist/lib/storage&#39; // defaults to localStorage for web

import rootReducer from &#39;./reducers&#39;

const persistConfig = &#123;
  key: &#39;root&#39;,
  storage,
&#125;

const persistedReducer = persistReducer(persistConfig, rootReducer)

export default () =&gt; &#123;
  let store = createStore(persistedReducer)
  let persistor = persistStore(store)
  return &#123; store, persistor &#125;
&#125;
</code></pre>
<h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code class="js">import &#123;createStore,applyMiddleware,combineReducers,compose &#125; from &#39;redux&#39; //createStore 方法创建一个store对象
//创建一个reducer，“修改状态”，（老状态，修改的值）深复制之后，再返回一个新的状态
import reduxThunk from &#39;redux-thunk&#39;
import reduxPromise from &#39;redux-promise&#39;
import roleListReducer from &#39;./reducess/role&#39;
import rightListReducer from &#39;./reducess/right&#39;
import sliderReducer from &#39;./reducess/slider&#39;
import &#123; persistStore, persistReducer &#125; from &#39;redux-persist&#39;
import storage from &#39;redux-persist/lib/storage&#39; // defaults to localStorage for web
const persistConfig = &#123;
  key: &#39;root&#39;,
  storage,
&#125;

const reducer = combineReducers(&#123;
  isCollapsed : sliderReducer,
  rightList:rightListReducer,
  roleList:roleListReducer
&#125;)
const persistedReducer = persistReducer(persistConfig, reducer) //把reducer进行包裹


//store，只能接受一个reducer
//app开发，只能有一个store
//轮船运货车（reducer拆开一个一个，每个reducer一个文件，combineReducer：合并所有的reducer）
//redux devtools的配置：Advanced store setup
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(persistedReducer,/* preloadedState, */ composeEnhancers(applyMiddleware(reduxThunk,reduxPromise)))
const persistor = persistStore(store)
//默认action是普通对象
//创建store，顺便应用中间件thunk,如果action是函数，我来处理
//创建store，顺便应用中间件promise,那么action就变成了promise对象
export  &#123;
  store,
  persistor
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-18 immutable" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/18%20immutable/" class="article-date">
  	<time datetime="2022-08-25T03:09:56.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/18%20immutable/">
        React-immutable
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/immutable-js/immutable-js">https://github.com/immutable-js/immutable-js</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>每次修改一个 Immutable 对象时都会创建一个新的不可变的对象，在新对象上操作并不会影响到原对象的数据。这个库的实现是深拷贝还是浅拷贝？</p>
<h2 id="深拷贝和浅拷贝的关系"><a href="#深拷贝和浅拷贝的关系" class="headerlink" title="深拷贝和浅拷贝的关系"></a>深拷贝和浅拷贝的关系</h2><ol>
<li><pre><code class="js">var arr = &#123;&#125;;
var arr2 = arr
//浅拷贝，引用地址相同
</code></pre>
</li>
<li><p> Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。</p>
</li>
<li><pre><code class="js">const obj1 = JSON.parse(JSON.stringify(obj))
//数组，对象都好用(缺点: 不能有undefined)
</code></pre>
</li>
</ol>
<h2 id="Immutable优化性能的方式"><a href="#Immutable优化性能的方式" class="headerlink" title="Immutable优化性能的方式"></a>Immutable优化性能的方式</h2><p>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构）， 也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p>
<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772">https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772</a></p>
<pre><code class="js">import &#123;Map&#125; from &#39;immutable&#39;
let a = Map(&#123;
    select:&#39;users&#39;,
    filter:Map(&#123;name:&#39;Cam&#39;&#125;)
&#125;)
let b = a.set(&#39;select&#39;,&#39;people&#39;);
a===b; //false
a.get(&#39;filter&#39;) === b.get(&#39;filter&#39;); // true
</code></pre>
<p>延伸：如果上述select 属性 给一个组件用，因为此值改变了，shouldComponentUpdate 应该返回true, 而filter 属性给另一个组件用，通过判断并无变化，shouldComponentUpdate 应该返回false，此组件就避免了重复进行diff对比</p>
<h2 id="Immutable中常用类型（Map，List）"><a href="#Immutable中常用类型（Map，List）" class="headerlink" title="Immutable中常用类型（Map，List）"></a>Immutable中常用类型（Map，List）</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code class="js">const &#123;Map&#125; = require(&quot;immutable&quot;)
const preState = &#123;
  a:1,
  b:2
&#125;
let map1 = Map(preState)
let map2 = map1.set(&#39;b&#39;,&#39;3&#39;)
console.log(map1.toJS(),map2.toJS());
//&#123; a: 1, b: 2 &#125; &#123; a: 1, b: &#39;3&#39; &#125;
</code></pre>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code class="js">const &#123;List&#125; = require(&quot;immutable&quot;)
const preState = [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;]
let arr1 = List(preState)
//List内置绝大部分的数组方法
let arr2 = arr1.push(444)
console.log(arr1.toJS(),arr2.toJS());
//[&#39;111&#39;,&#39;222&#39;,&#39;333&#39;]   [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;,444]
</code></pre>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><pre><code class="js">const &#123;Map&#125; = require(&quot;immutable&quot;)
const preState = &#123;
  a:1,
  b:2
&#125;
let map1 = Map(preState)
let map2 = map1.merge(&#123;name:&#39;admin&#39;&#125;)
console.log(map1.toJS(),map2.toJS());
//&#123; a: 1, b: 2 &#125; &#123; a: 1, b: 2, name: &#39;admin&#39; &#125;
</code></pre>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><pre><code class="js">const &#123;List&#125; = require(&quot;immutable&quot;)
const preState = [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;]
let arr1 = List(preState)
//List内置绝大部分的数组方法
let arr2 = arr1.concat([444,555,666])
console.log(arr1.toJS(),arr2.toJS());
//[&#39;111&#39;,&#39;222&#39;,&#39;333&#39;] [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;,444,555,666]
</code></pre>
<h3 id="fromJS"><a href="#fromJS" class="headerlink" title="fromJS"></a>fromJS</h3><pre><code class="js">const &#123;fromJS&#125; = require(&quot;immutable&quot;)
const prevState = &#123;
  name:&#39;retr0&#39;,
  age:1,
  location:&#123;
    city:1,
    sss:2,
    ddd:&#123;
      aaa:34
    &#125;
  &#125;
&#125; 
let map1 = fromJS(prevState)
let map2 = map1.setIn([&#39;location&#39;,&#39;city&#39;],231231)
console.log(map2.toJS());
/*
    &#123;
      name: &#39;retr0&#39;,
      age: 1,
      location: &#123; city: 231231, sss: 2, ddd: &#123; aaa: 34 &#125; &#125;
      &#125;
*/
</code></pre>
<h2 id="Immutable-Redux的开发方式"><a href="#Immutable-Redux的开发方式" class="headerlink" title="Immutable+Redux的开发方式"></a>Immutable+Redux的开发方式</h2><pre><code class="js">import &#123;fromJS&#125; from &#39;immutable&#39;
const righteducer = (prevState=[],action)=&gt;&#123;
  let &#123;type,payload&#125; = action;
  switch(type)&#123;
    case &quot;right&quot;:
      let newState = fromJS(prevState).concat(payload).toJS()
      return newState
    default:return prevState
  &#125;
  
&#125;
export default righteducer
</code></pre>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>容易跟原生混淆</li>
<li>文档与调试不方便</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-17 redux-thunk" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/17%20redux-thunk/" class="article-date">
  	<time datetime="2022-08-25T03:09:40.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/17%20redux-thunk/">
        React-redux-thunk
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><h1 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm i --save redux-thunk
</code></pre>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><pre><code class="js">import ReduxThunk from &#39;redux-promise&#39;
</code></pre>
<h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code class="js">import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;
const reducer = ()=&gt;&#123;
    ....
&#125;
const store = createStore(reducer,applyMiddleware(ReduxThunk))
</code></pre>
<h2 id="组件-js"><a href="#组件-js" class="headerlink" title="组件.js"></a>组件.js</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import store from &#39;.....&#39;

class App extends Component &#123;
    actionCreator = ()=&gt;&#123;
        return dispatch =&gt;&#123;  //返回一个函数,并传了一个dispath函数到回调函数的形参中
            axios....then(res=&gt;&#123;
                dispatch(...) //就可以在任意自己想return的地方运行dispatch函数
            &#125;)
        &#125;
    &#125;
    componentWillMount()&#123;
        if(store.getState().xxxx.length===0)&#123;
            //  store.dispath只能接受一个普通对象
            store.dispatch(this.actionCreator())
        &#125;else&#123;
               this.setState(&#123;
                xxx:store.getState().xxxx
            &#125;)
        &#125;
        //要抓第一次redux改变的的时候，因此要订阅一下
        this.unsub = store.subscribe(&#123;
            this.setState(&#123;
                ...:store.getState().xxxx
            &#125;)
        &#125;)
    &#125;
    render () &#123;
        return (
            &lt;div&gt;&lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-16 redux-promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/16%20redux-promise/" class="article-date">
  	<time datetime="2022-08-25T03:09:06.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/16%20redux-promise/">
        React-redux-promise
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm i --save redux-promise
</code></pre>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><pre><code class="js">import ReduxPromise from &#39;redux-promise&#39;
</code></pre>
<h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code class="js">import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;
const reducer = ()=&gt;&#123;
    ....
&#125;
const store = createStore(reducer,applyMiddleware(ReduxPromise))
</code></pre>
<h2 id="组件-js"><a href="#组件-js" class="headerlink" title="组件.js"></a>组件.js</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;
import store from &#39;.....&#39;

class App extends Component &#123;
    actionCreator = ()=&gt;&#123;
        return ( //返回一个promise对象
            axios.....
        )
    &#125;
    componentWillMount()&#123;
        if(store.getState().xxxx.length===0)&#123;
            //  store.dispath只能接受一个普通对象
            store.dispatch(this.actionCreator())
            .then(res=&gt;&#123;
                this.setState(&#123;
                     ...:res.payload
                &#125;)
            &#125;)
        &#125;else&#123;
               this.setState(&#123;
                xxx:store.getState().xxxx
            &#125;)
        &#125;
    &#125;
    render () &#123;
        return (
            &lt;div&gt;&lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-15 react-redux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/15%20react-redux/" class="article-date">
  	<time datetime="2022-08-25T03:08:46.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/15%20react-redux/">
        React-React-Radux
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="React-Radux"><a href="#React-Radux" class="headerlink" title="React-Radux"></a>React-Radux</h2><p>实际项目中，需要权衡是直接使用Redux还是用React-Redux。<br> React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）</p>
<h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h3><ul>
<li>只负责 UI 的呈现，不带有任何业务逻辑</li>
<li>没有状态（即不使用this.state这个变量）</li>
<li>所有数据都由参数（this.props）提供</li>
<li>不使用任何 Redux 的 API</li>
</ul>
<h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><ul>
<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>
<li>带有内部状态</li>
<li>使用 Redux 的 API</li>
</ul>
<p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p>
<p>如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p>
<p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><pre><code class="javascript">import &#123; connect &#125; from &#39;react-redux&#39;
const VisibleTodoList = connect()(TodoList);
</code></pre>
<p>上面VisibleTodoList 便是通过UI组件TodoList,通过connect方法自动生成的容器组件。<br> 但需要定义业务逻辑，组件才有意义。</p>
<pre><code class="javascript">import &#123; connect &#125; from &#39;react-redux&#39;

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)
</code></pre>
<p>connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h3><p>它是一个函数，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。<br> mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。</p>
<pre><code class="jsx">const mapStateToProps = (state) =&gt; &#123;
  return &#123;
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  &#125;
&#125;
</code></pre>
<p>mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。</p>
<h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h3><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>
<ul>
<li>是函数则会得到dispatch和ownProps（容器组件的props对象）两个参数。</li>
</ul>
<pre><code class="tsx">const mapDispatchToProps = (
  dispatch,
  ownProps
) =&gt; &#123;
  return &#123;
    onClick: () =&gt; &#123;
      dispatch(&#123;
        type: &#39;SET_VISIBILITY_FILTER&#39;,
        filter: ownProps.filter
      &#125;);
    &#125;
  &#125;;
&#125;
</code></pre>
<p>从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p>
<ul>
<li>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。</li>
</ul>
<pre><code class="tsx">const mapDispatchToProps = &#123;
  onClick: (filter) =&gt; &#123;
    type: &#39;SET_VISIBILITY_FILTER&#39;,
    filter: filter
  &#125;;
&#125;
</code></pre>
<h3 id="组件"><a href="#组件" class="headerlink" title=" 组件"></a><Provider> 组件</h3><p>connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。<br> React-Redux 提供Provider组件，可以让容器组件拿到state。</p>
<pre><code class="jsx">import &#123; Provider &#125; from &#39;react-redux&#39;
import &#123; createStore &#125; from &#39;redux&#39;
import todoApp from &#39;./reducers&#39;
import App from &#39;./components/App&#39;

let store = createStore(todoApp);

render(
  &lt;Provider store=&#123;store&#125;&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&#39;root&#39;)
)
</code></pre>
<p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p>
<h2 id="简单计数器"><a href="#简单计数器" class="headerlink" title="简单计数器"></a>简单计数器</h2><pre><code class="javascript">import React, &#123; Component &#125; from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;   //类型检查
import ReactDOM from &#39;react-dom&#39;
import &#123; createStore &#125; from &#39;redux&#39;
import &#123; Provider, connect &#125; from &#39;react-redux&#39;

// 定义counter组件
class Counter extends Component &#123;
  render() &#123;
    const &#123; value, onIncreaseClick &#125; = this.props
    // const value = this.props.value
    return (
      &lt;div&gt;
        &lt;span&gt;&#123;value&#125;&lt;/span&gt;
        &lt;button onClick=&#123;onIncreaseClick&#125;&gt; +1&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
//对Counter组件接受的props进行类型检查
Counter.propTypes = &#123;
  value: PropTypes.number.isRequired,   //要求数字类型，没有提供会警告
  onIncreaseClick: PropTypes.func.isRequired //要求函数类型
&#125;

// Action  
const increaseAction = &#123; type: &#39;increase&#39; &#125;

// Reducer   基于原有state根据action得到新的state
function counter(state = &#123; count: 0 &#125;, action) &#123;
  const count = state.count
  switch (action.type) &#123;
    case &#39;increase&#39;:
      return &#123; count: count + 1 &#125;
    default:
      return state
  &#125;
&#125;

// 根据reducer函数通过createStore()创建store
const store = createStore(counter)

//  将state映射到Counter组件的props
function mapStateToProps(state) &#123;
  return &#123;
    value: state.count
  &#125;
&#125;

//  将action映射到Counter组件的props
function mapDispatchToProps(dispatch) &#123;
  return &#123;
    onIncreaseClick: () =&gt; dispatch(increaseAction)
  &#125;
&#125;

//  传入上面两个函数参数，将Counter组件变为App组件
const App = connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter)

ReactDOM.render(
  &lt;Provider store=&#123;store&#125;&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&#39;root&#39;)
)
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-14 纯函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/14%20%E7%BA%AF%E5%87%BD%E6%95%B0/" class="article-date">
  	<time datetime="2022-08-25T03:08:26.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/14%20%E7%BA%AF%E5%87%BD%E6%95%B0/">
        React-纯函数
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？</p>
<p>除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。我们可以花个 5 分钟一起来看以下。</p>
<h3 id="什么函数是纯的？"><a href="#什么函数是纯的？" class="headerlink" title="什么函数是纯的？"></a>什么函数是纯的？</h3><p>纯函数的定义是：</p>
<ol>
<li>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</li>
<li>该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。</li>
</ol>
<p>这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。</p>
<p>在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。</p>
<h3 id="什么是可观察的副作用？"><a href="#什么是可观察的副作用？" class="headerlink" title="什么是可观察的副作用？"></a>什么是可观察的副作用？</h3><p>一个可以被观察的副作用是在函数内部与其外部的<strong>任意</strong>交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。</p>
<p><strong>注:</strong> 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。</p>
<p>副作用来自，但不限于：</p>
<ul>
<li>进行一个 HTTP 请求</li>
<li>Mutating data</li>
<li>输出数据到屏幕或者控制台</li>
<li>DOM 查询/操作</li>
<li>Math.random()</li>
<li>获取的当前时间</li>
</ul>
<p>副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。</p>
<p>不过首先，让我们来看一些纯的和不纯的函数对比的例子……</p>
<h3 id="纯函数的例子"><a href="#纯函数的例子" class="headerlink" title="纯函数的例子"></a><strong>纯函数的例子</strong></h3><p>以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：</p>
<pre><code class="js">function priceAfterTax(productPrice) &#123; return (productPrice * 0.20) + productPrice;&#125;
</code></pre>
<p>它符合我们所说的两条纯函数的定义。不依赖于任何外部输入，不改变任何外部数据、没有副作用。</p>
<p>即使你用同样的输入运行运行这个函数 100,000,000 次它<strong>依旧产生同样的结果</strong>。</p>
<h3 id="非纯函数"><a href="#非纯函数" class="headerlink" title="非纯函数"></a><strong>非纯函数</strong></h3><p>我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:</p>
<pre><code class="js">var tax = 20;
function calculateTax(productPrice) &#123;
    return (productPrice * (tax/100)) + productPrice;
&#125;
</code></pre>
<p>暂停片刻，看看你是否能看出为什么这个函数不纯。</p>
<p>其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。</p>
<h3 id="为什么说纯函数在-JavaScript-很重要？"><a href="#为什么说纯函数在-JavaScript-很重要？" class="headerlink" title="为什么说纯函数在 JavaScript 很重要？"></a>为什么说纯函数在 JavaScript 很重要？</h3><p>纯函数在函数式编程中被大量使用。而且诸如 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/components-and-props.html">ReactJS</a> 和 <a target="_blank" rel="noopener" href="http://redux.js.org/docs/introduction/ThreePrinciples.html">Redux</a> 等优质的库都需要使用纯函数。</p>
<p>不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。</p>
<p>并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。</p>
<h4 id="可测试性和重构"><a href="#可测试性和重构" class="headerlink" title="可测试性和重构"></a>可测试性和重构</h4><p>另一个使用纯函数的原因是测试以及重构。</p>
<p>使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。</p>
<p>同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）</p>
<p>正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。</p>
<p>此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pure_function">Wiki</a>。同时也推荐阅读 <a target="_blank" rel="noopener" href="https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html">开发建议手册</a> 以及 <a target="_blank" rel="noopener" href="https://toddmotto.com/pure-versus-impure-functions">纯函数 vs. 非纯函数</a>.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/9/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>