<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/14/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-09 计算属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/09%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/" class="article-date">
  	<time datetime="2022-08-25T02:56:16.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/09%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/">
        Vue-计算属性
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>
<pre><code class="html">&lt;div id=&quot;example&quot;&gt;
  &#123;&#123; message.split('').reverse().join('') &#125;&#125;
&lt;/div&gt;
</code></pre>
<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="html">&lt;div id=&quot;box&quot;&gt;
    &#123;&#123;myname.substring(0,1).toUpperCase() + myname.substring(1)&#125;&#125;

    &lt;p&gt;计算属性：&#123;&#123;getName&#125;&#125;&lt;/p&gt;
    &lt;p&gt;计算属性：&#123;&#123;getName&#125;&#125;&lt;/p&gt;

    &lt;p&gt;方法：&#123;&#123;getNameMethod()&#125;&#125;&lt;/p&gt;
    &lt;p&gt;方法：&#123;&#123;getNameMethod()&#125;&#125;&lt;/p&gt;
&lt;/div&gt;    
</code></pre>
<pre><code class="js">var vm =  new Vue(&#123;
    el:&quot;#box&quot;,
    data:&#123;
        myname:&quot;retr0&quot;
    &#125;,
    methods: &#123;
        getNameMethod()&#123;
            console.log(&quot;getNameMethod&quot;)
            return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)
        &#125;
    &#125;,
    computed: &#123;
        getName()&#123;
            console.log(&quot;getName-computed&quot;)
            return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)
        &#125;
    &#125;,
&#125;)
</code></pre>
<h2 id="计算缓存-VS-methods"><a href="#计算缓存-VS-methods" class="headerlink" title="计算缓存 VS methods"></a>计算缓存 VS methods</h2><ol>
<li>计算属性是基于它们的依赖进行缓存的</li>
<li>计算属性只有在它的相关依赖发生改变时才会重新求值</li>
</ol>
<h2 id="get-set"><a href="#get-set" class="headerlink" title="get() set()"></a>get() set()</h2><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;input type=&#39;checkbox&#39; v-model=&#39;isAllChecked&#39;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        check:false
    &#125;,
    computed:&#123;
        isAllChecked:&#123;
            get()&#123;
                //...doSomeThings
                return some //必须要return
            &#125;,
            set(newvalue)&#123;
                //doSomeThing(newValue)
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-08 表单绑定&amp;双向绑定" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/08%20%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A&%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/" class="article-date">
  	<time datetime="2022-08-25T02:56:04.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/08%20%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A&%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/">
        Vue-表单控件绑定&amp;双向数据绑定
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="表单控件绑定-amp-双向数据绑定"><a href="#表单控件绑定-amp-双向数据绑定" class="headerlink" title="表单控件绑定&amp;双向数据绑定"></a>表单控件绑定&amp;双向数据绑定</h1><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h4><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;input type=&#39;checkbox&#39; v-model=&#39;check&#39;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        check:true
    &#125;
&#125;)
</code></pre>
<p>通过v-model绑定了一个数组checkgroup，这样实现每个复选框被点击时，Vue会将该复选框的value值按顺序push到checkgroup中</p>
<pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkgroup&quot; value=&quot;vue&quot;/&gt;vue
    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkgroup&quot; value=&quot;react&quot;/&gt;react
    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkgroup&quot; value=&quot;jquery&quot;/&gt;jquery
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        checkgroup:[];
    &#125;
&#125;)
</code></pre>
<h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;vue&quot; name=&quot;aaa&quot;/&gt;vue
    &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;react&quot;     name=&quot;aaa&quot;/&gt;react
    &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;jquery&quot; name=&quot;aaa&quot;/&gt;jquery
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        picked:&quot;&quot;
    &#125;
&#125;)
</code></pre>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><blockquote>
<p>取代 <code>input</code> 监听 <code>change</code> 事件</p>
</blockquote>
<pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;input v-model.lazy=&#39;mytext&#39;&gt;
    &lt;!-- 这里的mytext不会实时修改而是在input失去焦点的时候才会修改--&gt;
    &#123;&#123;mytext&#125;&#125; 
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        mytext:&#39;&#39;
    &#125;
&#125;)
</code></pre>
<h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><blockquote>
<p>输入字符串转为有效的数字</p>
</blockquote>
<pre><code class="html">&lt;input type=&quot;number&quot; v-model.number=&quot;mynumber&quot;/&gt;
&#123;&#123;mynumber&#125;&#125;
</code></pre>
<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><blockquote>
<p> 输入首尾空格过滤</p>
</blockquote>
<pre><code class="html">&lt;input type=&quot;text&quot; v-model.trim=&quot;myusername&quot;/&gt;
|&#123;&#123;myusername&#125;&#125;|  
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-07 事件处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/07%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" class="article-date">
  	<time datetime="2022-08-25T02:55:50.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/07%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">
        Vue-事件处理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><blockquote>
<p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
</blockquote>
<p>实例：</p>
<pre><code class="html">&lt;div id=&quot;box&quot;&gt;
  &lt;button v-on:click=&quot;counter++&quot;&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">var example1 = new Vue(&#123;
    el: &#39;#box&#39;,
    data: &#123;
        counter: 0
    &#125;
&#125;)
</code></pre>
<h2 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h2><blockquote>
<p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 还可以接收一个需要调用的方法名称。</p>
</blockquote>
<p>实例：</p>
<pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;button @click=&#39;fn&#39;&gt;
        click
    &lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">let vm = new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        name:&#39;retr0&#39;
    &#125;
    method:&#123;
    //当@click=&#39;fn&#39;不加括号时，可以直接使用形参eve
    //eve是原生 DOM 事件
    //当@click=&#39;fn($event)&#39;加括号时，需要传入实参$event
        fn(eve)&#123;
            alert(`hello $&#123;this.name&#125;`);
            if(eve)&#123;
                alert(eve.target.tagName);
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h2 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h2><blockquote>
<p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p>
</blockquote>
<pre><code class="html">&lt;div id=&quot;example-3&quot;&gt;
  &lt;button v-on:click=&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;/button&gt;
  &lt;button v-on:click=&quot;say(&#39;what&#39;)&quot;&gt;Say what&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el: &#39;#example-3&#39;,
    methods: &#123;
        say: function (message) &#123;
            alert(message)
        &#125;
    &#125;
&#125;)
</code></pre>
<p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p>
<pre><code class="html">&lt;button v-on:click=&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;
    Submit
&lt;/button&gt;
</code></pre>
<pre><code class="js">// ...
methods: &#123;
    warn: function (message, event) &#123;
        // 现在我们可以访问原生事件对象
        if (event) &#123;
            event.preventDefault()
        &#125;
        alert(message)
    &#125;
&#125;
</code></pre>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<h3 id="stop"><a href="#stop" class="headerlink" title=".stop"></a>.stop</h3><pre><code class="html">&lt;!-- 阻止事件冒泡 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;
&lt;!-- 阻止事件冒泡，没有表达式 --&gt;
&lt;a v-on:click.stop&gt;&lt;/a&gt;
</code></pre>
<h3 id="prevent"><a href="#prevent" class="headerlink" title=".prevent"></a>.prevent</h3><pre><code class="html">&lt;!-- 阻止浏览器默认行为 --&gt;
&lt;div :click.prevent=&#39;fn()&#39;&gt;&lt;/div&gt;
&lt;!-- 阻止默认行为，没有表达式 --&gt;
&lt;div :click.prevent&gt;&lt;/div&gt;
</code></pre>
<h3 id="self"><a href="#self" class="headerlink" title=".self"></a>.self</h3><pre><code class="html">&lt;!-- 只当事件是从侦听器绑定的元素本身触发时才触发回调 --&gt;
&lt;ul @click.self=&#39;fn2()&#39;&gt;
    &lt;li v-for=&#39;data in datalist&#39; @click=&#39;fn()&#39;&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h3 id="once"><a href="#once" class="headerlink" title=".once"></a>.once</h3><pre><code class="html">&lt;!-- 只触发一次回调 --&gt;
&lt;div @click.once=&#39;fn&#39;&gt;&lt;/div&gt;
</code></pre>
<p>如何不用once做到解绑事件：</p>
<pre><code class="html">&lt;!-- 通过状态isActive进行短路 --&gt;
&lt;!-- 需要注意，这里的函数表达式必须加（） --&gt;
&lt;div @click=&#39;isActive &amp;&amp; fn()&#39;&gt;解绑测试&lt;/div&gt;
</code></pre>
<h3 id="passive"><a href="#passive" class="headerlink" title=".passive"></a>.passive</h3><p>每次事件产生，浏览器都会去查询一下是否有<code>preventDefault</code>阻止该次事件的默认动作。我们加上passive就是为了告诉浏览器，不用查询了，我们没用 preventDefault阻止默认动作。这里一般用在滚动监听，@scroll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度</p>
<pre><code class="html">&lt;!-- 以 &#123; passive: true &#125; 模式添加侦听器 --&gt;
&lt;div @click.passive=&#39;fn&#39;&gt;&lt;/div&gt;
</code></pre>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><pre><code class="html">&lt;!-- 只有在按下回车键的时才会触发该事件 --&gt;
&lt;input @keyup.enter=&#39;fn()&#39;&gt;
&lt;!-- 支持连缀 --&gt;
&lt;input @keyup.enter.ctrl=&#39;fn()&#39;&gt;
&lt;!-- 支持keyCode --&gt;
&lt;input @keyup.13=&#39;fn()&#39;&gt;
</code></pre>
<p>其实通过以下方法完成的：</p>
<pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;input @keyup=&#39;fn1($event)&#39;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    methods:&#123;
        fn1(eve)&#123;
            if(eve.keyCode == 13)&#123;
                ......
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-06 列表渲染" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/06%20%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/" class="article-date">
  	<time datetime="2022-08-25T02:55:40.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/06%20%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/">
        Vue-列表渲染
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul>
<li><p><strong>预期</strong>：<code>Array | Object | number | string | Iterable (2.6 新增)</code></p>
</li>
<li><p><strong>用法</strong>：</p>
<p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名：</p>
<pre><code class="html">&lt;div v-for=&quot;item in items&quot;&gt;
  &#123;&#123; item.text &#125;&#125;
&lt;/div&gt;
</code></pre>
<p>另外也可以为数组索引指定别名 (或者用于对象的键)：</p>
<pre><code class="html">&lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;
&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;
&lt;div v-for=&quot;(val, name, index) in object&quot;&gt;&lt;/div&gt;
</code></pre>
<p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊属性 <code>key</code> 来提供一个排序提示：</p>
<pre><code class="html">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
  &#123;&#123; item.text &#125;&#125;
&lt;/div&gt;
</code></pre>
<p>从 2.6 起，<code>v-for</code> 也可以在实现了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">可迭代协议</a>的值上使用，包括原生的 <code>Map</code> 和 <code>Set</code>。不过应该注意的是 Vue 2.x 目前并不支持可响应的 <code>Map</code> 和 <code>Set</code> 值，所以无法自动探测变更。</p>
<p>当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if">列表渲染教程</a></p>
<p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p>
</li>
<li><p><strong>参考</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html">列表渲染</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#key">key</a></li>
</ul>
</li>
</ul>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ol>
<li><p>跟踪每个节点的身份，从而重用和重新排序现有元素</p>
</li>
<li><p>理想的 key 值是每项都有的且唯一的 id。data.id</p>
</li>
</ol>
<h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><ol>
<li><p>使用以下方法操作数组，可以检测变动：</p>
<ul>
<li>push()</li>
<li> pop() </li>
<li>shift() </li>
<li>unshift() </li>
<li>splice() </li>
<li>sort() </li>
<li>reverse()</li>
</ul>
</li>
<li><p> 使用以下方法操作数组，无法检测到变动</p>
</li>
</ol>
<ul>
<li>filter()</li>
<li>concat()</li>
<li>slice() </li>
<li>map()</li>
<li>新数组替换旧数组</li>
</ul>
<ol start="3">
<li><p>不能检测以下变动的数组</p>
<pre><code class="js">vm.items[indexOfItem] = newValue//是无法渲染页面的
</code></pre>
<p>解决方案</p>
<ol>
<li><p>Vue.set(example1.items, indexOfItem, newValue)    </p>
</li>
<li><p>splice</p>
<pre><code class="js">vm.items.splice(indexOfItem,1,newValue)
</code></pre>
</li>
</ol>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-05 条件渲染" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/05%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/" class="article-date">
  	<time datetime="2022-08-25T02:54:38.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/05%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/">
        Vue-条件渲染
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><blockquote>
<p>动态创建和删除</p>
</blockquote>
<ul>
<li><p><strong>用法</strong>：</p>
<p>根据表达式的值的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthiness</a> 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 ` ，将提出它的内容作为条件块。</p>
<p>当条件变化时该指令触发过渡效果。</p>
<p>当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if">列表渲染教程</a></p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html">条件渲染 - v-if</a></p>
</li>
</ul>
<pre><code class="html">&lt;div id=&quot;box&quot;&gt;
    &lt;div v-if=&quot;datalist.length&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&#39;data in datalist&#39;&gt;
                &#123;&#123;data&#125;&#125;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><ul>
<li><p><strong>不需要表达式</strong></p>
</li>
<li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>
</li>
<li><p><strong>用法</strong>：</p>
<p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加“else 块”。</p>
<p><strong>可以用于购物车空空如也和有数据的状态切换</strong></p>
<pre><code class="html">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;
    Now you see me
&lt;/div&gt;
&lt;div v-else&gt;
    Now you don&#39;t
&lt;/div&gt;
</code></pre>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html#v-else">条件渲染 - v-else</a></p>
</li>
</ul>
<h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><blockquote>
<p>2.1.0 新增</p>
</blockquote>
<ul>
<li><p><strong>类型</strong>：<code>any</code></p>
</li>
<li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>
</li>
<li><p><strong>用法</strong>：</p>
<p>表示 <code>v-if</code> 的 “else if 块”。可以链式调用。</p>
<p><strong>可以用于购物车的状态</strong></p>
<pre><code class="html">&lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;
  A
&lt;/div&gt;
&lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;
  B
&lt;/div&gt;
&lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;
  C
&lt;/div&gt;
&lt;div v-else&gt;
  Not A/B/C
&lt;/div&gt;
</code></pre>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html#v-else-if">条件渲染 - v-else-if</a></p>
</li>
</ul>
<h2 id="template-v-if"><a href="#template-v-if" class="headerlink" title="template v-if"></a>template v-if</h2><h3 id="在元素上使用-v-if-条件渲染分组"><a href="#在元素上使用-v-if-条件渲染分组" class="headerlink" title="在元素上使用 v-if 条件渲染分组"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html#%E5%9C%A8-lt-template-gt-%E5%85%83%E7%B4%A0%E4%B8%8A%E4%BD%BF%E7%94%A8-v-if-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%86%E7%BB%84">在元素上使用 <code>v-if</code> 条件渲染分组</a></h3><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>元素当做不可见的包裹元素，并在上面使用</code>v-if<code>。最终的渲染结果将不包含 </code> 元素。</p>
<pre><code class="html">&lt;template v-if=&quot;ok&quot;&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Paragraph 1&lt;/p&gt;
    &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><ul>
<li><p><strong>预期</strong>：<code>any</code></p>
</li>
<li><p><strong>用法</strong>：</p>
<p>根据表达式之真假值，切换元素的 <code>display</code> CSS 属性。</p>
<p>当条件变化时该指令触发过渡效果。</p>
</li>
<li><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html#v-show">条件渲染 - v-show</a></p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-04 class与style" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/04%20class%E4%B8%8Estyle/" class="article-date">
  	<time datetime="2022-08-25T02:54:30.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/04%20class%E4%B8%8Estyle/">
        Vue-class与style
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="class与style"><a href="#class与style" class="headerlink" title="class与style"></a>class与style</h1><h2 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;div :class=&#39;classObj&#39;&gt;动态绑定ClassName&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        classObj:&#123;
            aa:1,//true则显示该class名，false则不会
               bb:0,
            cc:1
        &#125;
    &#125;
&#125;)
</code></pre>
<h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;div :class=&#39;classArr&#39;&gt;动态绑定ClassName&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        classArr:[&#39;aa&#39;,&#39;cc&#39;]//数组里有的都会显示为className
    &#125;
&#125;)
</code></pre>
<h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;div :style=&#39;styleObj&#39;&gt;动态修改样式&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        styleObj:&#123;
            backgroundColor:&#39;#14c145&#39;
        &#125;
        //注意，直接用this.styleObj.属性=val，是无法渲染页面的，必须要使用
        // Vue.set(this.styleObj,属性,val)才可以渲染页面
    &#125;
&#125;)
</code></pre>
<h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;
    &lt;div :class=&#39;styleArr&#39;&gt;动态修 改样式&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">new Vue(&#123;
    el:&#39;#box&#39;,
    data:&#123;
        styleArr:[&#123;
            backgroundColor:&quot;#14c145&quot;,
            fontSize:&#39;12px&#39;
        &#125;]//注意，往数组中push对象，可以渲染页面
        //this.styleArr.push(&#123;color:&#39;red&#39;&#125;)
    &#125;
&#125;)
</code></pre>
<p>#####对象方法<br>-最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）</p>
<pre><code>:class=&quot;&#123; &#39;active&#39;: isActive &#125;&quot;
</code></pre>
<p>1<br>判断是否绑定一个active</p>
<pre><code>:class=&quot;&#123;&#39;active&#39;:isActive===-1&#125;&quot;  
或者
:class=&quot;&#123;&#39;active&#39;:isActive===index&#125;&quot;
</code></pre>
<p>绑定并判断多个</p>
<pre><code>第一种（用逗号隔开）
:class=&quot;&#123; &#39;active&#39;: isActive, &#39;sort&#39;: isSort &#125;&quot;
第二种（放在data里面）
//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样
:class=&quot;classObject&quot;
data() &#123;
  return &#123;
    classObject:&#123; active: true, sort:false &#125;
  &#125;
&#125;
第三种（使用computed属性）
:class=&quot;classObject&quot;
data() &#123;
  return &#123;
    isActive: true,
    isSort: false
  &#125;
&#125;,
computed: &#123;
  classObject: function () &#123;
    return &#123;
      active: this.isActive,
      sort:this.isSort
    &#125;
  &#125;
&#125;
</code></pre>
<p>#####数组方法</p>
<pre><code>单纯数组
:class=&quot;[isActive,isSort]&quot;
data() &#123;
  return&#123;
    isActive:&#39;active&#39;,
    isSort:&#39;sort&#39;
 &#125;
&#125;
</code></pre>
<p>数组与三元运算符结合判断选择需要的class<br>$$<br>（注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染）<br>:class=”[isActive?’active’:’’]”<br>或者<br>:class=”[isActive==1?’active’:’’]”<br>或者<br>:class=”[isActive==index?’active’:’’]”<br>或者<br>:class=”[isActive==index?’active’:’otherActiveClass’]”<br>$$<br>数组对象结合动态判断<br>//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p>
<pre><code>:class=&quot;[&#123; active: isActive &#125;, &#39;sort&#39;]&quot;
或者
:class=&quot;[&#123; active: isActive===1 &#125;, &#39;sort&#39;]&quot;
或者
:class=&quot;[&#123; active: isActive===index &#125;, &#39;sort&#39;]&quot;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-03 Vue中的虚拟DOM" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/03%20Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/" class="article-date">
  	<time datetime="2022-08-25T02:54:18.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/03%20Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/">
        Vue-什么是虚拟DOM?
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>摘要：</strong> 什么是虚拟DOM?</p>
<ul>
<li>作者：<a target="_blank" rel="noopener" href="https://segmentfault.com/u/langlixingzhou">浪里行舟</a></li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://www.fundebug.com/">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue.js 2.0引入Virtual DOM,比Vue.js 1.0的初始渲染速度提升了2-4倍，并大大降低了内存消耗。那么，什么是Virtual DOM？为什么需要Virtual DOM？它是通过什么方式去提升页面渲染效率的呢？这是本文所要探讨的问题。</p>
<h3 id="模板转换成视图的过程"><a href="#模板转换成视图的过程" class="headerlink" title="模板转换成视图的过程"></a>模板转换成视图的过程</h3><p>在正式介绍 Virtual Dom之前，我们有必要先了解下模板转换成视图的过程整个过程（如下图）：</p>
<ul>
<li>Vue.js通过编译将template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li>
<li>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行DOM操作来更新视图。</li>
</ul>
<p>简单点讲，在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上。</p>
<p><img src="https://image.fundebug.com/2019-06-26-01.png" alt="img"></p>
<p>我们先对上图几个概念加以解释:</p>
<ul>
<li><strong>渲染函数</strong>：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。</li>
<li><strong>VNode 虚拟节点</strong>：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成<strong>节点描述对象</strong>，它描述了应该怎样去创建真实的DOM节点。</li>
<li>**patch(也叫做patching算法)<strong>：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于</strong><a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">Snabbdom</a>**的实现，并在些基础上作了很多的调整和改进。</li>
</ul>
<h3 id="Virtual-DOM-是什么？"><a href="#Virtual-DOM-是什么？" class="headerlink" title="Virtual DOM 是什么？"></a>Virtual DOM 是什么？</h3><p>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p>
<p>简单来说，可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。</p>
<p>对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了<code>模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</code>的一个过程</p>
<p><img src="https://image.fundebug.com/2019-06-26-02.png" alt="img"></p>
<h3 id="Virtual-DOM-作用是什么？"><a href="#Virtual-DOM-作用是什么？" class="headerlink" title="Virtual DOM 作用是什么？"></a>Virtual DOM 作用是什么？</h3><p><strong>虚拟DOM的最终目标是将虚拟节点渲染到视图上</strong>。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p>
<p>为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无需改动的DOM。</p>
<p>其实虚拟DOM在Vue.js主要做了两件事：</p>
<ul>
<li>提供与真实DOM节点所对应的虚拟节点vnode</li>
<li>将虚拟节点vnode和旧虚拟节点oldVnode进行对比，然后更新视图</li>
</ul>
<p><strong>给大家推荐一个好用的BUG监控工具<a target="_blank" rel="noopener" href="https://www.fundebug.com/?utm_source=liao">Fundebug</a>，欢迎免费试用！</strong></p>
<h3 id="为何需要Virtual-DOM？"><a href="#为何需要Virtual-DOM？" class="headerlink" title="为何需要Virtual DOM？"></a>为何需要Virtual DOM？</h3><ul>
<li>具备跨平台的优势</li>
</ul>
<p>由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p>
<ul>
<li>操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。</li>
</ul>
<p>因为DOM操作的执行速度远不如Javascript的运算速度快，因此，把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。</p>
<p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</p>
<ul>
<li>提升渲染性能</li>
</ul>
<p>Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</p>
<p>为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。<strong>我们通过patch 的核心—-diff 算法，找出本次DOM需要更新的节点来更新，其他的不更新</strong>。比如修改某个model 100次，从1加到100，那么有了Virtual DOM的缓存之后，只会把最后一次修改patch到view上。那diff 算法的实现过程是怎样的？</p>
<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><p><img src="https://image.fundebug.com/2019-06-26-03.png" alt="img"></p>
<p>Vue的diff算法是基于snabbdom改造过来的，<strong>仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新</strong>。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从O(n3)变成O(n)。</p>
<p>diff 算法包括几个步骤：</p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了</li>
</ul>
<p><img src="https://image.fundebug.com/2019-06-26-04.png" alt="img"></p>
<h3 id="diff-算法的实现过程"><a href="#diff-算法的实现过程" class="headerlink" title="diff 算法的实现过程"></a>diff 算法的实现过程</h3><p>diff 算法本身非常复杂，实现难度很大。本文去繁就简，粗略介绍以下两个核心函数实现流程：</p>
<ul>
<li>patch(container,vnode) :初次渲染的时候，将VDOM渲染成真正的DOM然后插入到容器里面。</li>
<li>patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。</li>
</ul>
<h4 id="1-patch-container-vnode"><a href="#1-patch-container-vnode" class="headerlink" title="1. patch(container,vnode)"></a>1. patch(container,vnode)</h4><p>通过这个函数可以让VNode渲染成真正的DOM，我们通过以下模拟代码，可以了解大致过程：</p>
<pre><code>function createElement(vnode) &#123;    
var tag = vnode.tag  
var attrs = vnode.attrs || &#123;&#125;    
var children = vnode.children || []    
if (!tag) &#123;       
 return null  
  &#125;    
// 创建真实的 DOM 元素    
var elem = document.createElement(tag)   
 // 属性    
var attrName    
for (attrName in attrs) &#123;    
    if (attrs.hasOwnProperty(attrName)) &#123; 
           // 给 elem 添加属性
           elem.setAttribute(attrName, attrs[attrName])
        &#125;
    &#125;
    // 子元素
    children.forEach(function (childVnode) &#123;
        // 给 elem 添加子元素，如果还有子节点，则递归的生成子节点。
        elem.appendChild(createElement(childVnode))  // 递归
    &#125;)    // 返回真实的 DOM 元素   
 return elem
&#125;
</code></pre>
<h4 id="2-patch-vnode-newVnode"><a href="#2-patch-vnode-newVnode" class="headerlink" title="2. patch(vnode,newVnode)"></a>2. patch(vnode,newVnode)</h4><p>这里我们只考虑vnode与newVnode如何对比的情况：</p>
<pre><code>function updateChildren(vnode, newVnode) &#123;
    var children = vnode.children || []
    var newChildren = newVnode.children || []
  // 遍历现有的children
    children.forEach(function (childVnode, index) &#123;
        var newChildVnode = newChildren[index]
  // 两者tag一样
        if (childVnode.tag === newChildVnode.tag) &#123;
            // 深层次对比，递归
            updateChildren(childVnode, newChildVnode)
        &#125; else &#123; 
  // 两者tag不一样
           replaceNode(childVnode, newChildVnode) 
       &#125;
    &#125;
)&#125;
</code></pre>
<p><strong>给大家推荐一个好用的BUG监控工具<a target="_blank" rel="noopener" href="https://www.fundebug.com/?utm_source=liao">Fundebug</a>，欢迎免费试用！</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/06/17/handling-errors-in-vuejs/">5种处理Vue异常的方法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/06/21/3-core-ideas-of-vue-component/">深入理解Vue组件3大核心概念</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/01/17/release-fundebug-vue/">Fundebug发布Vue插件，简化BUG监控接入代码</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/06/03/vue-development-tutorial/">Vue开发入门看这篇文章就够了</a></li>
</ul>
<h3 id="关于Fundebug"><a href="#关于Fundebug" class="headerlink" title="关于Fundebug"></a>关于Fundebug</h3><p><a target="_blank" rel="noopener" href="https://www.fundebug.com/">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有阳光保险、核桃编程、荔枝FM、掌门1对1、微脉、青团社等众多品牌企业。欢迎大家<a target="_blank" rel="noopener" href="https://www.fundebug.com/team/create">免费试用</a>！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-01 Vue介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/25/01%20Vue%E4%BB%8B%E7%BB%8D/" class="article-date">
  	<time datetime="2022-08-25T02:53:58.000Z" itemprop="datePublished">2022-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/25/01%20Vue%E4%BB%8B%E7%BB%8D/">
        Vue-介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue介绍"><a href="#Vue介绍" class="headerlink" title="Vue介绍"></a>Vue介绍</h1><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p>Vue (读音 /vjuː/，类似于view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h2 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h2><p>框架做分层设计，每层都可选，不同层可以灵活接入其他方案。而当你都想用官方的实现时，会发现也早已准备好，各层之间包括配套工具都能比接入其他方案更便捷地协同工作。一个个放入,放多少就做多少。</p>
<h2 id="MV-模式（MVC-MVP-MVVM）"><a href="#MV-模式（MVC-MVP-MVVM）" class="headerlink" title="MV*模式（MVC/MVP/MVVM）"></a>MV*模式（MVC/MVP/MVVM）</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><blockquote>
<p>model view controller</p>
</blockquote>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller会对来自View数据进行预处理、决定调用哪个Model的接口；然后由Model执行相关的业务逻辑（数据请求）；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>把业务逻辑和展示逻辑分离，模块化程度高。但由于View是强依赖特定的Model的，所以View无法组件化，无法复用</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><blockquote>
<p>model view presenter</p>
</blockquote>
<h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，<strong>通过View提供的接口更新界面</strong>。</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>View不依赖Model，View可以进行组件化。但Model-&gt;View的手动同步逻辑麻烦，维护困难</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。<strong>可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染</strong>。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="script标签引入"><a href="#script标签引入" class="headerlink" title="script标签引入"></a>script标签引入</h3><pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue cli"></a>Vue cli</h3><p>Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架</p>
<pre><code>npm install ‐g @vue/cli
</code></pre>
<h2 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h2><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知watcher，从而使它关联的组件重新渲染。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><blockquote>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
</blockquote>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>Object.defineProperty(obj, prop, descriptor)
</code></pre>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul>
<li><p><strong>obj</strong></p>
<p>要在其上定义属性的对象。</p>
</li>
<li><p><strong>prop</strong></p>
<p>要定义或修改的属性的名称。</p>
</li>
<li><p><strong>descriptor</strong></p>
<p>将被定义或修改的属性描述符。</p>
</li>
</ul>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p> 被传递给函数的对象</p>
<blockquote>
<p>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而<code>Object.defineProperty</code> 是定义<code>key</code>为Symbol的属性的方法之一。</p>
</blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code class="js">let obj = &#123;&#125;;
    Object.defineProperty(obj,&quot;myname&quot;,&#123;
        get(data)&#123;
            console.log(&quot;被访问&quot; + data);
        &#125;,
        set(data)&#123;
            console.log(&quot;被修改&quot; + data)
        &#125;
    &#125;)
</code></pre>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Vue3 的 变化Object.defineProperty有以下缺点。</p>
<ol>
<li>无法监听es6的Set、Map 变化；</li>
<li>无法监听Class类型的数据；</li>
<li>属性的新加或者删除也无法监听；</li>
<li>数组元素的增加和删除也无法监听。</li>
</ol>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>针对Object.defineProperty的缺点，<code>ES6 Proxy</code>都能够完美得解决，它唯一的缺点就是，<code>对IE不友好</code>,所以vue3在检测到如果是使用IE的情况下（没错，IE11都不支持Proxy），会<code>自动降级</code>为<code>Object.defineProperty</code>的数据监听系统。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/13/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>