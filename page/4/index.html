<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/4/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=475479888&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/10/">React博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-兼容性写法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/" class="article-date">
  	<time datetime="2022-09-15T08:21:39.014Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/">
        js原生-事件，获取dom兼容写法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="获取事件对象的兼容性写法"><a href="#获取事件对象的兼容性写法" class="headerlink" title="获取事件对象的兼容性写法"></a>获取事件对象的兼容性写法</h3><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);
obox.onclick = function(eve)&#123;
    var e = eve || window.event;
&#125;
</code></pre>
<blockquote>
<p>IE支持：window.event</p>
</blockquote>
<h3 id="获取键盘按键值的兼容性写法"><a href="#获取键盘按键值的兼容性写法" class="headerlink" title="获取键盘按键值的兼容性写法"></a>获取键盘按键值的兼容性写法</h3><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);
obox.onclick = function(eve)&#123;
    var e = eve || window.event;
    var code = e.keyCode || e.which;
&#125;
</code></pre>
<h3 id="“阻止浏览器默认行为的”兼容性写法"><a href="#“阻止浏览器默认行为的”兼容性写法" class="headerlink" title="“阻止浏览器默认行为的”兼容性写法"></a>“阻止浏览器默认行为的”兼容性写法</h3><pre><code class="js">function stopDefault(e)&#123;
    if(e.preventDefault)    e.preventDefault();//兼容其他浏览器
    else    e.returnValue = false;//兼容IE
&#125;
</code></pre>
<h3 id="“事件冒泡”的兼容写法"><a href="#“事件冒泡”的兼容写法" class="headerlink" title="“事件冒泡”的兼容写法"></a>“事件冒泡”的兼容写法</h3><pre><code class="js">function stopBubble(e)&#123;
    if(e.stopPropagation)    e.stopPropagation();
    else    e.cancelBubble = true;
&#125;
</code></pre>
<h3 id="“添加事件监听器”兼容性写法"><a href="#“添加事件监听器”兼容性写法" class="headerlink" title="“添加事件监听器”兼容性写法"></a>“添加事件监听器”兼容性写法</h3><pre><code class="js">function addEvent(ele,type,callback)&#123;
    if(ele.attachEvent) ele.attachEvent(&quot;on&quot;+type,callback);
    else    ele.addEventListener(type,callback);
&#125;
</code></pre>
<h3 id="“删除事件监听器”兼容性写法"><a href="#“删除事件监听器”兼容性写法" class="headerlink" title="“删除事件监听器”兼容性写法"></a>“删除事件监听器”兼容性写法</h3><pre><code class="js">function removeEvent(ele,type,callback)&#123;
    if(ele.detachEvent) ele.detachEvent(&quot;on&quot;+type,callback);
    else    ele.removeEventListener(type,callback);
&#125;
</code></pre>
<h3 id="event-target的兼容问题"><a href="#event-target的兼容问题" class="headerlink" title="event.target的兼容问题"></a>event.target的兼容问题</h3><pre><code class="js"> otable.onclick = function(eve)&#123;
        var e = eve || window.event;
        var target = e.target || e.srcElement;//只看这行
        if(target.nodeName === &quot;TD&quot;)&#123;
            var ipt = document.createElement(&quot;input&quot;);
            ipt.value = target.innerHTML;
            target.innerHTML = &quot;&quot;;
            target.appendChild(ipt);
            ipt.focus();

            var that = target;
            ipt.onblur = function()&#123;
                that.innerHTML = this.value;
            &#125;
            ipt.onclick = function(eve)&#123;
                var e = eve || window.event;
                e.stopPropagation();
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="“获取样式”的兼容写法"><a href="#“获取样式”的兼容写法" class="headerlink" title="“获取样式”的兼容写法"></a>“获取样式”的兼容写法</h3><pre><code class="js">function getStyle(ele,attr)&#123;
    if(ele.currentStyle)&#123;//判断获取到的是不是true，那么就执行IE的currentStyle，如果是undefined那么就是false，那就执行getComputedStyle()
        return ele.currentStyle[attr];//IE8及以下支持
    &#125;else&#123;
        return getComputedStyle(ele,false)[attr];//其他正常浏览器支持
    &#125;
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-防抖和节流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="article-date">
  	<time datetime="2022-09-15T08:20:02.370Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/">
        js原生-节流与防抖
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <strong>防抖——触发高频事件后 n 秒后函数只会执行一次，如果 n 秒内高频事件再 次被触发，则重新计算时间；</strong></p>
<pre><code class="javascript"> function debounce(fn) &#123; 
   let timeout = null 

// 创建一个标记用来存放定时器的返回值 return function() &#123; clearTimeout(timeout) 

// 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; &#123; 

// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数

 fn.apply(this, arguments) &#125;, 500) &#125;&#125;

function sayHi() &#123; console.log(&#39;防抖成功&#39;)&#125;

var inp = document.getElementById(&#39;inp&#39;)inp.addEventListener(&#39;input&#39;, debounce(sayHi))
</code></pre>
<p> // <strong>防抖 节流——高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执 行频率</strong>。 </p>
<pre><code class="javascript">function throttle(fn) &#123; let canRun = true // 通过闭包保存一个标记 return function() &#123; if (!canRun) return // 在函数开头判断标记是否为 true，不为 true 则 return canRun = false // 立即设置为 false setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在 setTimeout 中 fn.apply(this, arguments) // 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表 示可以执行下一次循环了。当定时器没有执行的时候标记永远是 false，在开头 被 return 掉 canRun = true &#125;, 500) &#125;&#125;function sayHi(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight)&#125;window.addEventListener(&#39;resize&#39;, throttle(sayHi)) 

![1624604032862](C:\Users\94549\AppData\Roaming\Typora\typora-user-images\1624604032862.png)

![1624604059057](C:\Users\94549\AppData\Roaming\Typora\typora-user-images\1624604059057.png)

</code></pre>
<p>// 防抖</p>
<pre><code class="javascript">export function _debounce(fn, delay) &#123;



  var delay = delay || 200;

  var timer;

  return function () &#123;

​    var th = this;

​    var args = arguments;

​    if (timer) &#123;

​      clearTimeout(timer);

​    &#125;

​    timer = setTimeout(function () &#123;

​      timer = null;

​      fn.apply(th, args);

​    &#125;, delay);

  &#125;;

&#125;
</code></pre>
<p>// 节流</p>
<pre><code class="javascript">export function _throttle(fn, interval) &#123;

  var last;

  var timer;

  var interval = interval || 200;

  return function () &#123;

​    var th = this;

​    var args = arguments;

​    var now = +new Date();

​    if (last &amp;&amp; now - last &lt; interval) &#123;

​      clearTimeout(timer);

​      timer = setTimeout(function () &#123;

​        last = now;

​        fn.apply(th, args);

​      &#125;, interval);

​    &#125; else &#123;

​      last = now;

​      fn.apply(th, args);

​    &#125;

  &#125;

&#125;
</code></pre>
<p><strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p>
<p><strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-堆栈" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/%E5%A0%86%E6%A0%88/" class="article-date">
  	<time datetime="2022-09-15T08:14:47.366Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/%E5%A0%86%E6%A0%88/">
        js原生-js数据类型，堆和栈
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实一开始对栈、堆的概念特别模糊，只知道好像跟内存有关，又好像事件循环也沾一点边。面试薄荷的时候，面试官正好也问到了这个问题，当时只能大方的承认不会。痛定思痛，回去好好的研究一番。 我们将从<code>JS的内存机制</code>以及<code>事件机制</code>和<code>大量的🌰（例子）</code>来了解栈、堆究竟是个什么玩意。概念比较多，不用死读，所有的🌰心里想一遍，浏览器console看一遍就很清楚了。 let’s go</p>
<h2 id="JS内存机制"><a href="#JS内存机制" class="headerlink" title="JS内存机制"></a>JS内存机制</h2><p>因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不专业的朋友在进入到前端之后，会对内存空间的认知比较模糊。</p>
<p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，**栈内存(stack)**与**堆内存(heap)**。</p>
<h3 id="栈内存一般储存基础数据类型"><a href="#栈内存一般储存基础数据类型" class="headerlink" title="栈内存一般储存基础数据类型"></a>栈内存一般储存基础数据类型</h3><pre><code class="js"> Number String Null Undefined Boolean 
 (es6新引入了一种数据类型，Symbol)
</code></pre>
<h4 id="最简单的🌰"><a href="#最简单的🌰" class="headerlink" title="最简单的🌰"></a>最简单的🌰</h4><pre><code class="js">var a = 1 
</code></pre>
<p>我们定义一个变量a，系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。</p>
<p>数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循<strong>后进先出</strong>的原则。</p>
<h3 id="堆内存一般储存引用数据类型"><a href="#堆内存一般储存引用数据类型" class="headerlink" title="堆内存一般储存引用数据类型"></a>堆内存一般储存引用数据类型</h3><h4 id="堆内存的🌰"><a href="#堆内存的🌰" class="headerlink" title="堆内存的🌰"></a>堆内存的🌰</h4><pre><code class="js">var b = &#123; xi : 20 &#125;
</code></pre>
<p>与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript<strong>不允许直接访问堆内存中的位置</strong>，因此我们不能直接操作对象的堆内存空间。看一下下面的图，加深理解。</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>￼ </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b03478ae38a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg104"></p>
<pre><code class="js">var a1 = 0;   // 栈 
var a2 = &#39;this is string&#39;; // 栈
var a3 = null; // 栈

var b = &#123; m: 20 &#125;; // 变量b存在于栈中，&#123;m: 20&#125; 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
</code></pre>
<p>因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是<strong>从栈中获取了该对象的地址引用（或者地址指针）</strong>，然后再从堆内存中取得我们需要的数据。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="js">var a = 20;
var b = a;
b = 30;
console.log(a)

var m = &#123; a: 10, b: 20 &#125;
var n = m;
n.a = 15;
console.log(m.a)
</code></pre>
<p>同学们自己在console里打一遍，再结合下面的图例，就很好理解了</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b0347adb343?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg106"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ecdcf3a44f381?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="15282536739797"></p>
<p>内存机制我们了解了，又引出一个新的问题，栈里只能存基础数据类型吗，我们经常用的function存在哪里呢？</p>
<h2 id="浏览器的事件机制"><a href="#浏览器的事件机制" class="headerlink" title="浏览器的事件机制"></a>浏览器的事件机制</h2><h4 id="一个经常被搬上面试题的🌰"><a href="#一个经常被搬上面试题的🌰" class="headerlink" title="一个经常被搬上面试题的🌰"></a>一个经常被搬上面试题的🌰</h4><pre><code class="js">console.log(1)
let promise = new Promise(function(resolve,reject)&#123;
    console.log(3)
    resolve(100)
&#125;).then(function(data)&#123;
    console.log(100)
&#125;)
setTimeout(function()&#123;
    console.log(4);
&#125;)
console.log(2)
</code></pre>
<blockquote>
<p>上面这个demo的结果值是 1 3 2 100 4</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b033cff7849?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg105"></p>
<p><strong>对象</strong>放在<strong>heap（堆）**里，**常见的基础类型和函数**放在**stack（栈）**里，函数执行的时候在**栈<strong>里执行。栈里函数执行的时候可能会调一些</strong>Dom操作，ajax操作和setTimeout定时器</strong>，这时候要等stack（栈）里面的所有程序先走<strong>（注意：栈里的代码是先进后出）</strong>，走完后再走WebAPIs，WebAPIs执行后的结果放在callback queue（回调的队列里，注意：队列里的代码先放进去的先执行），也就是当栈里面的程序走完之后，再从任务队列中读取事件，将队列中的事件放到执行栈中依次执行，这个过程是循环不断的。</p>
<ul>
<li>1.所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>2.主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>3.一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行</li>
<li>4.主线程从任务队列中读取事件，这个过程是循环不断的</li>
</ul>
<p>概念又臭又长，没关系，我们先粗略的扫一眼，接着往下看。</p>
<h4 id="举一个🌰说明栈的执行方式"><a href="#举一个🌰说明栈的执行方式" class="headerlink" title="举一个🌰说明栈的执行方式"></a>举一个🌰说明栈的执行方式</h4><pre><code class="js">var a = &quot;aa&quot;;
function one()&#123;
    let a = 1;
    two();
    function two()&#123;
        let b = 2;
        three();
        function three()&#123;
            console.log(b)
        &#125;
    &#125;
&#125;
console.log(a);
one();
</code></pre>
<blockquote>
<p>demo的结果是 aa 2</p>
</blockquote>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b03477d89cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg107"></p>
<p>执行栈里面最先放的是全局作用域（代码执行有一个全局文本的环境），然后再放one， one执行再把two放进来，two执行再把three放进来，一层叠一层。</p>
<p>最先走的肯定是three，因为two要是先销毁了，那three的代码b就拿不到了，所以是<strong>先进后出</strong>（先进的后出），所以，three最先出，然后是two出，再是one出。</p>
<h3 id="那队列又是怎么一回事呢？"><a href="#那队列又是怎么一回事呢？" class="headerlink" title="那队列又是怎么一回事呢？"></a>那队列又是怎么一回事呢？</h3><h4 id="再举一个🌰"><a href="#再举一个🌰" class="headerlink" title="再举一个🌰"></a>再举一个🌰</h4><pre><code class="js">console.log(1);
console.log(2);
setTimeout(function()&#123;
    console.log(3);
&#125;)
setTimeout(function()&#123;
    console.log(4);
&#125;)
console.log(5);
</code></pre>
<blockquote>
<p>首先执行了栈里的代码，1 2 5。 前面说到的<strong>settimeout</strong>会被放在队列里，当栈执行完了之后，从队列里添加到栈里执行（此时是依次执行），得到 3 4</p>
</blockquote>
<h4 id="再再举一个🌰"><a href="#再再举一个🌰" class="headerlink" title="再再举一个🌰"></a>再再举一个🌰</h4><pre><code class="js">console.log(1);
console.log(2);

setTimeout(function()&#123;
    console.log(3);
    setTimeout(function()&#123;
        console.log(6);
    &#125;)
&#125;)
setTimeout(function()&#123;
    console.log(4);
    setTimeout(function()&#123;
        console.log(7);
    &#125;)
&#125;)
console.log(5)
</code></pre>
<blockquote>
<p>同样，先执行栈里的同步代码 1 2 5. 再同样，最外层的settimeout会放在队列里，当栈里面执行完成以后，放在栈中执行，3 4。 而嵌套的2个settimeout，会放在一个新的队列中，去执行 6 7.</p>
</blockquote>
<h4 id="再再再看一个🌰"><a href="#再再再看一个🌰" class="headerlink" title="再再再看一个🌰"></a>再再再看一个🌰</h4><pre><code class="js">console.log(1);
console.log(2);

setTimeout(function()&#123;
    console.log(3);
    setTimeout(function()&#123;
        console.log(6);
    &#125;)
&#125;,400)
setTimeout(function()&#123;
    console.log(4);
    setTimeout(function()&#123;
        console.log(7);
    &#125;)
&#125;,100)
console.log(5)
</code></pre>
<blockquote>
<p>如上：这里的顺序是1，2，5，4，7，3，6。也就是只要两个set时间不一样的时候 ，就set时间短的先走完，包括set里面的回调函数，再走set时间慢的。（因为只有当时间到了的时候，才会把set放到队列里面去）</p>
</blockquote>
<pre><code class="js">setTimeout(function()&#123;
    console.log(&#39;setTimeout&#39;)
&#125;,0)
for(var i = 0;i&lt;10;i++)&#123;
    console.log(i)
&#125;
</code></pre>
<blockquote>
<p>这个demo的结果是 0 1 2 3 4 5 6 7 8 9 setTimeout</p>
</blockquote>
<p>所以，得出结论，永远都是<strong>栈里的代码先行执行</strong>，再从队列中依次读事件，加入栈中执行</p>
<p>stack（栈）里面都走完之后，就会依次读取任务队列,将队列中的事件放到执行栈中依次执行，这个时候栈中又出现了事件，这个事件又去调用了WebAPIs里的异步方法，那这些异步方法会在再被调用的时候放在队列里，然后这个主线程（也就是stack）执行完后又将从任务队列中依次读取事件，这个过程是循环不断的。</p>
<h4 id="再回到我们的第一个🌰"><a href="#再回到我们的第一个🌰" class="headerlink" title="再回到我们的第一个🌰"></a>再回到我们的第一个🌰</h4><pre><code class="js">console.log(1)
let promise = new Promise(function(resolve,reject)&#123;
    console.log(3)
    resolve(100)
&#125;).then(function(data)&#123;
    console.log(100)
&#125;)
setTimeout(function()&#123;
    console.log(4);
&#125;)
console.log(2)
</code></pre>
<blockquote>
<p>上面这个demo的结果值是 1 3 2 100 4</p>
</blockquote>
<ul>
<li>为什么setTimeout要在Promise.then之后执行呢？</li>
<li>为什么new Promise又在console.log(2)之前执行呢？</li>
</ul>
<p>setTimeout是宏任务,而Promise.then是微任务 这里的new Promise()是同步的,所以是立即执行的。</p>
<h4 id="这就要引入一个新的话题宏任务和微任务（面试也会经常提及到）"><a href="#这就要引入一个新的话题宏任务和微任务（面试也会经常提及到）" class="headerlink" title="这就要引入一个新的话题宏任务和微任务（面试也会经常提及到）"></a>这就要引入一个新的话题<em>宏任务</em>和<em>微任务</em>（面试也会经常提及到）</h4><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><h5 id="参考-Tasks-microtasks-queues-and-schedules（https-jakearchibald-com-2015-tasks-microtasks-queues-and-schedules-utm-source-html5weekly）"><a href="#参考-Tasks-microtasks-queues-and-schedules（https-jakearchibald-com-2015-tasks-microtasks-queues-and-schedules-utm-source-html5weekly）" class="headerlink" title="参考  Tasks, microtasks, queues and schedules（https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly）"></a>参考  Tasks, microtasks, queues and schedules（<a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly%EF%BC%89">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly）</a></h5><p><strong>概念：微任务和宏任务都是属于队列，而不是放在栈中</strong></p>
<h4 id="一个新的🌰"><a href="#一个新的🌰" class="headerlink" title="一个新的🌰"></a>一个新的🌰</h4><pre><code class="js">console.log(&#39;1&#39;);

setTimeout(function() &#123;
  console.log(&#39;setTimeout&#39;);
&#125;, 0);

Promise.resolve().then(function() &#123;
  console.log(&#39;promise1&#39;);
&#125;).then(function() &#123;
  console.log(&#39;promise2&#39;);
&#125;);

console.log(&#39;2&#39;);
</code></pre>
<blockquote>
<p>1 2 promise1 promise2 setTimeout</p>
</blockquote>
<h3 id="宏任务（task）"><a href="#宏任务（task）" class="headerlink" title="宏任务（task）"></a>宏任务（task）</h3><p>浏览器为了能够使得JS内部宏任务与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;…） 鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTMl。但是，<strong>setTimeout不一样</strong>，<strong>setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务</strong>。这就是为什么打印‘<strong>setTimeout</strong>’在‘<strong>promise1</strong> , <strong>promise2</strong>’之后。因为打印‘<strong>promise1</strong> , <strong>promise2</strong>’是第一个宏任务里面的事情，而‘<strong>setTimeout</strong>’是<strong>另一个新的独立的</strong>任务里面打印的。</p>
<h3 id="微任务-Microtasks"><a href="#微任务-Microtasks" class="headerlink" title="微任务 (Microtasks)"></a>微任务 (Microtasks)</h3><p>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务 比如对一系列动作做出反馈，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以<strong>减小一点性能的开销</strong>。只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。微任务包括了mutation observe的回调还有接下来的例子<strong>promise的回调</strong>。</p>
<p>一旦一个pormise有了结果，或者早已有了结果（有了结果是指这个promise到了fulfilled或rejected状态），他就会为它的回调产生一个微任务，这就保证了回调异步的执行即使这个promise早已有了结果。所以对一个已经有了结果的**promise调用.then()**会立即产生一个微任务。这就是为什么‘promise1’,’promise2’会打印在‘script end’之后，因为所有微任务执行的时候，当前执行栈的代码必须已经执行完毕。‘promise1’,’promise2’会打印在‘setTimeout’之前是因为所有微任务总会在下一个宏任务之前全部执行完毕。</p>
<h4 id="还是🌰"><a href="#还是🌰" class="headerlink" title="还是🌰"></a>还是🌰</h4><pre><code class="js">&lt;div class=&quot;outer&quot;&gt;
  &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

//  elements
var outer = document.querySelector(&#39;.outer&#39;);
var inner = document.querySelector(&#39;.inner&#39;);


//监听element属性变化
new MutationObserver(function() &#123;
  console.log(&#39;mutate&#39;);
&#125;).observe(outer, &#123;
  attributes: true
&#125;);

// click listener…
function onClick() &#123;
  console.log(&#39;click&#39;);

  setTimeout(function() &#123;
    console.log(&#39;timeout&#39;);
  &#125;, 0);

  Promise.resolve().then(function() &#123;
    console.log(&#39;promise&#39;);
  &#125;);

  outer.setAttribute(&#39;data-random&#39;, Math.random());
&#125;

// 
inner.addEventListener(&#39;click&#39;, onClick);
outer.addEventListener(&#39;click&#39;, onClick);
</code></pre>
<blockquote>
<p>click promise mutate click promise mutate (2) timeout</p>
</blockquote>
<p>很好的解释了，setTimeout会在微任务（Promise.then、MutationObserver.observe）执行完成之后，加入一个新的宏任务中</p>
<h4 id="多看一些🌰"><a href="#多看一些🌰" class="headerlink" title="多看一些🌰"></a>多看一些🌰</h4><pre><code class="js">console.log(1);
setTimeout(function()&#123;
    console.log(2);
    Promise.resolve(1).then(function()&#123;
        console.log(&#39;promise1&#39;)
    &#125;)
&#125;)
setTimeout(function()&#123;
    console.log(3)
    Promise.resolve(1).then(function()&#123;
        console.log(&#39;promise2&#39;)
    &#125;)
&#125;)
setTimeout(function()&#123;
    console.log(4)
    Promise.resolve(1).then(function()&#123;
        console.log(&#39;promise3&#39;)
    &#125;)
&#125;)
</code></pre>
<blockquote>
<p>1 2 promise1 3 promise2 4 promise3</p>
</blockquote>
<pre><code class="js">console.log(1);
setTimeout(function()&#123;
    console.log(2);
    Promise.resolve(1).then(function()&#123;
        console.log(&#39;promise1&#39;)

        setTimeout(function()&#123;
            console.log(3)
            Promise.resolve(1).then(function()&#123;
                console.log(&#39;promise2&#39;)
            &#125;)
        &#125;)

    &#125;)
&#125;)
</code></pre>
<blockquote>
<p>1 2 promise1 3 promise2</p>
</blockquote>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><ul>
<li>栈：<ul>
<li>存储基础数据类型</li>
<li>按值访问</li>
<li>存储的值大小固定</li>
<li>由系统自动分配内存空间</li>
<li>空间小，运行效率高</li>
<li>先进后出，后进先出</li>
<li>栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。</li>
<li>微任务和宏任务</li>
</ul>
</li>
<li>堆:<ul>
<li>存储引用数据类型</li>
<li>按引用访问</li>
<li>存储的值大小不定，可动态调整</li>
<li>主要用来存放对象</li>
<li>空间大，但是运行效率相对较低</li>
<li>无序存储，可根据引用直接获取</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-01 react基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/14/01%20react%E5%9F%BA%E7%A1%80/" class="article-date">
  	<time datetime="2022-09-14T03:00:34.471Z" itemprop="datePublished">2022-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/14/01%20react%E5%9F%BA%E7%A1%80/">
        React- react基础
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="react基础"><a href="#react基础" class="headerlink" title="react基础"></a>react基础</h1><blockquote>
<p>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。</p>
</blockquote>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200310185038214.png" alt="image-20200310185038214"></p>
<h2 id="视图层的开发模式与函数式编程"><a href="#视图层的开发模式与函数式编程" class="headerlink" title="视图层的开发模式与函数式编程"></a>视图层的开发模式与函数式编程</h2><p>React 并不是完整的 MVC/MVVM 框架，它专注于提供清晰、简洁的 View（视图）层解决方案。</p>
<h3 id="函数式编程的好处"><a href="#函数式编程的好处" class="headerlink" title="函数式编程的好处"></a>函数式编程的好处</h3><ol>
<li>代码简洁，开发快速</li>
<li>接近自然语音，易于理解</li>
<li>更方便的代码管理</li>
<li>易于“并发编程”</li>
<li>代码的热更新</li>
</ol>
<h2 id="jsx语法与组件"><a href="#jsx语法与组件" class="headerlink" title="jsx语法与组件"></a>jsx语法与组件</h2><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由Babel 的 JSX 编译器实现。</p>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hello-world.html">https://reactjs.org/docs/hello-world.html</a></p>
<h2 id="如何创建react项目"><a href="#如何创建react项目" class="headerlink" title="如何创建react项目"></a>如何创建react项目</h2><pre><code class="javascript">1.npx create-react-app my-app
</code></pre>
<pre><code class="javascript"> （my-app：项目名称）

cd my-app  进入项目

npm run start 或者yarn start
</code></pre>
<h4 id="创建react-TypeScript的项目"><a href="#创建react-TypeScript的项目" class="headerlink" title="创建react+TypeScript的项目"></a>创建react+TypeScript的项目</h4><pre><code class="javascript">2.npx create-react-app my-app --template typescript
</code></pre>
<pre><code class="javascript">（my-app：项目名称）

cd my-app  进入项目

npm run start 或者yarn start
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-001VSCode 开发Vue必备插件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/07/001VSCode%20%E5%BC%80%E5%8F%91Vue%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/" class="article-date">
  	<time datetime="2022-09-07T01:33:35.514Z" itemprop="datePublished">2022-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/07/001VSCode%20%E5%BC%80%E5%8F%91Vue%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/">
        VSCode -开发Vue必备插件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="VSCode-开发Vue必备插件"><a href="#VSCode-开发Vue必备插件" class="headerlink" title="VSCode 开发Vue必备插件"></a>VSCode 开发Vue必备插件</h3><p>1.Vetur —— 语法高亮、智能感知、Emmet等<br>包含格式化功能， Alt+Shift+F （格式化全文），Ctrl+K Ctrl+F（格式化选中代码，两个Ctrl需要同时按着）</p>
<p>2.EsLint ——  检查代码是否符合规范</p>
<p>3.Debugger for Chrome —— 映射vscode上的断点到chrome上，方便调试（配置有点麻烦，其实我没用这个）</p>
<p>4.Auto Close Tag —— 自动闭合HTML/XML标签</p>
<p>5.Auto Rename Tag —— 自动完成另一侧标签的同步修改</p>
<p>6.JavaScript(ES6) code snippets —— ES6语法智能提示以及快速输入，除js外还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间</p>
<p>7.Path Intellisense —— 自动路径补全</p>
<p>8.HTML CSS Support —— 让 html 标签上写class 智能提示当前项目所支持的样式</p>
<p>9.Beautify—— 美化 javascript, JSON, CSS, Sass, 以及 HTML 。一般需要配合.jsbeautifyrc使用</p>
<p>10.Bracket Pair Colorizer——给括号加上不同的颜色，便于区分不同的区块，使用者可以定义不同括号类型和不同颜色</p>
<p>11.open in browser——直接右键项目单击启动<br>12.Material Icon Theme ———多样化的文件图标<br>13.One Dark Pro—— 一款深黑色的主题<br>14.Vue VSCode Snippets —— Vue 语法片段扩展<br>15.npm Intellisense—— import、require npm模块是自动补全</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-vue-移动端项目的搭建过程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/06/vue-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/" class="article-date">
  	<time datetime="2022-09-06T10:08:24.820Z" itemprop="datePublished">2022-09-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/06/vue-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/">
        vue-移动端项目的搭建过程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.新建项目文件夹</p>
<p>2.执行vue-cli命令：vue init webpack 项目名</p>
<p>适配：vw,vh 永远获取屏幕宽高</p>
<p>100vw=屏幕的宽度      100除以设计图的百分之1例如：100/(375x0.01)</p>
<p>1vw=1%屏幕尺寸（设计图的百分比）</p>
<p>这样更直观的获取百分比 但是少部分手机不支持 所以需要自己把控</p>
<p>vw,vh是未来的趋势</p>
<p>l要移动端尺寸显示正常需要加上以下meta</p>
<meta name="viewport“ content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>

<pre><code>width - viewport的宽度 height - viewport的高度
initial-scale - 初始的缩放比例
minimum-scale - 允许用户缩放到的最小比例
maximum-scale - 允许用户缩放到的最大比例
user-scalable - 用户是否可以手动缩放
</code></pre>
<p>html&lt;font-size=:vw;&gt;{}100除以设计图总宽度的百分之1.例如width:800px时，100除以(800乘以1%)等于12.5vw.所以总html{font-size:12.5vw}</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-36vue 前端代码风格指南" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/06/36vue%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/" class="article-date">
  	<time datetime="2022-09-06T02:53:49.996Z" itemprop="datePublished">2022-09-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/06/36vue%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/">
        Vue-36vue 前端代码风格
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h2><p>市面上常用的命名规范：</p>
<ul>
<li><code>camelCase</code>（小驼峰式命名法 —— 首字母小写）</li>
<li><code>PascalCase</code>（大驼峰式命名法 —— 首字母大写）</li>
<li><code>kebab-case</code>（短横线连接式）</li>
<li><code>Snake</code>（下划线连接式）</li>
</ul>
<h3 id="1-1-项目文件命名"><a href="#1-1-项目文件命名" class="headerlink" title="1.1 项目文件命名"></a>1.1 项目文件命名</h3><h4 id="1-1-1-项目名"><a href="#1-1-1-项目名" class="headerlink" title="1.1.1 项目名"></a>1.1.1 项目名</h4><p>全部采用小写方式， 以<strong>短横线</strong>分隔。 例：<code>my-project-name</code>。</p>
<h4 id="1-1-2-目录名"><a href="#1-1-2-目录名" class="headerlink" title="1.1.2 目录名"></a>1.1.2 目录名</h4><p><strong>参照项目命名规则，有复数结构时，要采用复数命名法</strong>。例：docs、assets、components、directives、mixins、utils、views。</p>
<pre><code class="js">my-project-name/
|- BuildScript    // 流水线部署文件目录
|- docs           // 项目的细化文档目录（可选）
|- nginx          // 部署在容器上前端项目 nginx 代理文件目录
|- node_modules   // 下载的依赖包
|- public         // 静态页面目录
    |- index.html // 项目入口
|- src            // 源码目录
    |- api        // http 请求目录
    |- assets     // 静态资源目录，这里的资源会被wabpack构建
        |- icon   // icon 存放目录
        |- img    // 图片存放目录
        |- js     // 公共 js 文件目录
        |- scss   // 公共样式 scss 存放目录
            |- frame.scss   // 入口文件
            |- global.scss  // 公共样式
            |- reset.scss   // 重置样式
    |- components     // 组件
    |- plugins        // 插件
    |- router         // 路由
    |- routes         // 详细的路由拆分目录（可选）
        |- index.js
    |- store          // 全局状态管理
    |- utils          // 工具存放目录
        |- request.js // 公共请求工具
    |- views          // 页面存放目录
    |- App.vue        // 根组件
    |- main.js        // 入口文件
    |- tests          // 测试用例
    |- .browserslistrc// 浏览器兼容配置文件
    |- .editorconfig  // 编辑器配置文件
    |- .eslintignore  // eslint 忽略规则
    |- .eslintrc.js   // eslint 规则
    |- .gitignore     // git 忽略规则
    |- babel.config.js // babel 规则
    |- Dockerfile // Docker 部署文件
    |- jest.config.js
    |- package-lock.json
    |- package.json // 依赖
    |- README.md // 项目 README
    |- vue.config.js // webpack 配置
复制代码
</code></pre>
<h4 id="1-1-3-图像文件名"><a href="#1-1-3-图像文件名" class="headerlink" title="1.1.3 图像文件名"></a>1.1.3 图像文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p>
<pre><code>banner_sina.gif
menu_aboutus.gif
menutitle_news.gif
logo_police.gif
logo_national.gif
pic_people.jpg
pic_TV.jpg
复制代码
</code></pre>
<h4 id="1-1-4-HTML-文件名"><a href="#1-1-4-HTML-文件名" class="headerlink" title="1.1.4 HTML 文件名"></a>1.1.4 HTML 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p>
<pre><code>|- error_report.html
|- success_report.html
复制代码
</code></pre>
<h4 id="1-1-5-CSS-文件名"><a href="#1-1-5-CSS-文件名" class="headerlink" title="1.1.5 CSS 文件名"></a>1.1.5 CSS 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p>
<pre><code class="lua">|- normalize.less
|- base.less
|- date-picker.scss
|- input-number.scss
复制代码
</code></pre>
<h4 id="1-1-6-JavaScript-文件名"><a href="#1-1-6-JavaScript-文件名" class="headerlink" title="1.1.6 JavaScript 文件名"></a>1.1.6 JavaScript 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p>
<pre><code class="scss">|- index.js
|- plugin.js
|- util.js
|- date-util.js
|- account-model.js
|- collapse-transition.js
复制代码
</code></pre>
<blockquote>
<p>上述规则可以快速记忆为“静态文件下划线，编译文件短横线”。</p>
</blockquote>
<h3 id="1-2-Vue-组件命名"><a href="#1-2-Vue-组件命名" class="headerlink" title="1.2 Vue 组件命名"></a>1.2 Vue 组件命名</h3><h4 id="1-2-1-单文件组件名"><a href="#1-2-1-单文件组件名" class="headerlink" title="1.2.1 单文件组件名"></a>1.2.1 单文件组件名</h4><p>文件扩展名为 <code>.vue</code> 的 <code>single-file components</code> (单文件组件)。单文件组件名应该始终是<strong>单词大写开头</strong> (PascalCase)。</p>
<pre><code class="json">components/
|- MyComponent.vue
复制代码
</code></pre>
<h4 id="1-2-2-单例组件名"><a href="#1-2-2-单例组件名" class="headerlink" title="1.2.2 单例组件名"></a>1.2.2 单例组件名</h4><p><strong>只拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p>
<p>这不意味着组件只可用于一个单页面，而是<em>每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em>只是目前</em>在每个页面里只使用一次。</p>
<p>比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。</p>
<pre><code>components/
|- TheHeading.vue
|- TheSidebar.vue
复制代码
</code></pre>
<h4 id="1-2-3-基础组件名"><a href="#1-2-3-基础组件名" class="headerlink" title="1.2.3 基础组件名"></a>1.2.3 基础组件名</h4><blockquote>
<p>基础组件：不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。</p>
</blockquote>
<p>应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。<strong>基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。</strong></p>
<pre><code>components/
|- BaseButton.vue
|- BaseTable.vue
|- BaseIcon.vue
复制代码
</code></pre>
<h4 id="1-2-4-业务组件"><a href="#1-2-4-业务组件" class="headerlink" title="1.2.4 业务组件"></a>1.2.4 业务组件</h4><blockquote>
<p>业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p>
</blockquote>
<p><strong>掺杂了复杂业务的组件（拥有自身 <code>data</code>、<code>prop</code> 的相关处理）即业务组件</strong>应该以 <code>Custom</code> 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。</p>
<pre><code>components/
|- CustomCard.vue
复制代码
</code></pre>
<h4 id="1-2-5-紧密耦合的组件名"><a href="#1-2-5-紧密耦合的组件名" class="headerlink" title="1.2.5 紧密耦合的组件名"></a>1.2.5 紧密耦合的组件名</h4><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong>  因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p>
<pre><code>components/
|- TodoList.vue
|- TodoListItem.vue
|- TodoListItemButton.vue
复制代码
</code></pre>
<h4 id="1-2-6-组件名中单词顺序"><a href="#1-2-6-组件名中单词顺序" class="headerlink" title="1.2.6 组件名中单词顺序"></a>1.2.6 组件名中单词顺序</h4><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong> 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。如下组件主要是用于搜索和设置功能。</p>
<pre><code>components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingsCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue
复制代码
</code></pre>
<p>还有另一种多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。</p>
<h4 id="1-2-7-完整单词的组件名"><a href="#1-2-7-完整单词的组件名" class="headerlink" title="1.2.7 完整单词的组件名"></a>1.2.7 完整单词的组件名</h4><p><strong>组件名应该倾向于而不是缩写。</strong> 编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p>
<pre><code>components/
|- StudentDashboardSettings.vue
|- UserProfileOptions.vue
复制代码
</code></pre>
<h3 id="1-3-代码参数命名"><a href="#1-3-代码参数命名" class="headerlink" title="1.3 代码参数命名"></a>1.3 代码参数命名</h3><h4 id="1-3-1-name"><a href="#1-3-1-name" class="headerlink" title="1.3.1 name"></a>1.3.1 name</h4><p><strong>组件名应该始终是多个单词，应该始终是 PascalCase 的。</strong> 根组件 App 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt; </code>之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p>
<pre><code class="javascript">export default &#123;
  name: &#39;ToDoList&#39;,
  // ...
&#125;
复制代码
</code></pre>
<h4 id="1-3-2-prop"><a href="#1-3-2-prop" class="headerlink" title="1.3.2 prop"></a>1.3.2 prop</h4><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case</strong>。我们单纯的遵循每个语言的约定，在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p>
<pre><code class="html">&lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt;
复制代码
export default &#123;
  name: &#39;MyComponent&#39;,
  // ...
  props: &#123;
    greetingText: &#123;
      type: String,
      required: true,
      validator: function (value) &#123;
        return [&#39;syncing&#39;, &#39;synced&#39;,].indexOf(value) !== -1
      &#125;
    &#125;
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="1-3-3-router"><a href="#1-3-3-router" class="headerlink" title="1.3.3 router"></a>1.3.3 router</h4><p><strong>Vue Router Path 命名采用 kebab-case 格式。</strong> 用 Snake（如：<code>/user_info</code>）或 camelCase（如：<code>/userInfo</code>)的单词会被当成一个单词，搜索引擎无法区分语义。</p>
<pre><code class="javascript">// bad
&#123;
  path: &#39;/user_info&#39;, // user_info 当成一个单词
  name: &#39;UserInfo&#39;,
  component: UserInfo,
  meta: &#123;
    title: &#39; - 用户&#39;,
    desc: &#39;&#39;
  &#125;
&#125;,

// good
&#123;
  path: &#39;/user-info&#39;, // 能解析成 user info
  name: &#39;UserInfo&#39;,
  component: UserInfo,
  meta: &#123;
    title: &#39; - 用户&#39;,
    desc: &#39;&#39;
  &#125;
&#125;,
复制代码
</code></pre>
<h4 id="1-3-4-模板中组件"><a href="#1-3-4-模板中组件" class="headerlink" title="1.3.4 模板中组件"></a>1.3.4 模板中组件</h4><p><strong>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。</strong></p>
<pre><code class="html">&lt;!-- 在单文件组件和字符串模板中 --&gt; 
&lt;MyComponent/&gt;

&lt;!-- 在 DOM 模板中 --&gt; 
&lt;my-component&gt;&lt;/my-component&gt;
复制代码
</code></pre>
<h4 id="1-3-5-自闭合组件"><a href="#1-3-5-自闭合组件" class="headerlink" title="1.3.5 自闭合组件"></a>1.3.5 自闭合组件</h4><p><strong>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p>
<pre><code class="html">&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;MyComponent/&gt;

&lt;!-- 在所有地方 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
复制代码
</code></pre>
<h4 id="1-3-6-变量"><a href="#1-3-6-变量" class="headerlink" title="1.3.6 变量"></a>1.3.6 变量</h4><ul>
<li>命名方法：camelCase</li>
<li>命名规范：类型 + 对象描述或属性的方式</li>
</ul>
<pre><code class="javascript">// bad
var getTitle = &quot;LoginTable&quot;

// good
let tableTitle = &quot;LoginTable&quot;
let mySchool = &quot;我的学校&quot;
复制代码
</code></pre>
<h4 id="1-3-7-常量"><a href="#1-3-7-常量" class="headerlink" title="1.3.7 常量"></a>1.3.7 常量</h4><ul>
<li>命名方法：全部大写下划线分割</li>
<li>命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词</li>
</ul>
<pre><code class="javascript">const MAX_COUNT = 10
const URL = &#39;http://test.host.com&#39;
复制代码
</code></pre>
<h4 id="1-3-8-方法"><a href="#1-3-8-方法" class="headerlink" title="1.3.8 方法"></a>1.3.8 方法</h4><ul>
<li>命名方法：camelCase</li>
<li>命名规范：统一使用动词或者动词 + 名词形式</li>
</ul>
<pre><code class="javascript">// 1、普通情况下，使用动词 + 名词形式
// bad
go、nextPage、show、open、login

// good
jumpPage、openCarInfoDialog

// 2、请求数据方法，以 data 结尾
// bad
takeData、confirmData、getList、postForm

// good
getListData、postFormData

// 3、单个动词的情况
init、refresh
复制代码
</code></pre>
<table>
<thead>
<tr>
<th>动词</th>
<th>含义</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>can</td>
<td>判断是否可执行某个动作 (权 )</td>
<td>函数返回一个布尔值。true：可执行；false：不可执行；</td>
</tr>
<tr>
<td>has</td>
<td>判断是否含有某个值</td>
<td>函数返回一个布尔值。true：含有此值；false：不含有此值；</td>
</tr>
<tr>
<td>is</td>
<td>判断是否为某个值</td>
<td>函数返回一个布尔值。true：为某个值；false：不为某个值；</td>
</tr>
<tr>
<td>get</td>
<td>获取某个值</td>
<td>函数返回一个非布尔值</td>
</tr>
<tr>
<td>set</td>
<td>设置某个值</td>
<td>无返回值、返回是否设置成功或者返回链式对象</td>
</tr>
</tbody></table>
<h4 id="1-3-9-自定义事件"><a href="#1-3-9-自定义事件" class="headerlink" title="1.3.9 自定义事件"></a>1.3.9 自定义事件</h4><p><strong>自定义事件应始终使用 kebab-case 的事件名。</strong></p>
<p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<pre><code class="javascript">this.$emit(&#39;my-event&#39;)
复制代码
&lt;MyComponent @my-event=&quot;handleDoSomething&quot; /&gt;
复制代码
</code></pre>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Events">原生事件参考列表</a></li>
</ul>
<p>由原生事件可以发现其使用方式如下：</p>
<pre><code class="html">&lt;div
  @blur=&quot;toggleHeaderFocus&quot;
  @focus=&quot;toggleHeaderFocus&quot;
  @click=&quot;toggleMenu&quot;
  @keydown.esc=&quot;handleKeydown&quot;
  @keydown.enter=&quot;handleKeydown&quot;
  @keydown.up.prevent=&quot;handleKeydown&quot;
  @keydown.down.prevent=&quot;handleKeydown&quot;
  @keydown.tab=&quot;handleKeydown&quot;
  @keydown.delete=&quot;handleKeydown&quot;
  @mouseenter=&quot;hasMouseHoverHead = true&quot;
  @mouseleave=&quot;hasMouseHoverHead = false&quot;&gt;
&lt;/div&gt;
复制代码
</code></pre>
<p>而为了区分<em>原生事件</em>和<em>自定义事件</em>在 Vue 中的使用，建议除了多单词事件名使用 kebab-case 的情况下，命名还需遵守为 <strong><code>on</code> + 动词</strong> 的形式，如下：</p>
<pre><code class="html">&lt;!-- 父组件 --&gt;
&lt;div
  @on-search=&quot;handleSearch&quot;
  @on-clear=&quot;handleClear&quot;
  @on-clickoutside=&quot;handleClickOutside&quot;&gt;
&lt;/div&gt;
复制代码
// 子组件
export default &#123;
  methods: &#123;
    handleTriggerItem () &#123;
      this.$emit(&#39;on-clear&#39;)
    &#125;
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="1-3-10-事件方法"><a href="#1-3-10-事件方法" class="headerlink" title="1.3.10 事件方法"></a>1.3.10 事件方法</h4><ul>
<li>命名方法：camelCase</li>
<li>命名规范：handle + 名称（可选）+ 动词</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div
    @click.native.stop=&quot;handleItemClick()&quot;
    @mouseenter.native.stop=&quot;handleItemHover()&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default &#123;
  methods: &#123;
    handleItemClick () &#123;
      //...
    &#125;,
    handleItemHover () &#123;
      //...
    &#125;
  &#125;
&#125;
&lt;/script&gt;
复制代码
</code></pre>
<h2 id="二、代码规范"><a href="#二、代码规范" class="headerlink" title="二、代码规范"></a>二、代码规范</h2><h3 id="2-1-Vue"><a href="#2-1-Vue" class="headerlink" title="2.1 Vue"></a>2.1 Vue</h3><h4 id="2-1-1-代码结构"><a href="#2-1-1-代码结构" class="headerlink" title="2.1.1 代码结构"></a>2.1.1 代码结构</h4><pre><code class="html">&lt;template&gt;
  &lt;div id=&quot;my-component&quot;&gt;
    &lt;DemoComponent /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import DemoComponent from &#39;../components/DemoComponent&#39;

export default &#123;
  name: &#39;MyComponent&#39;,
  components: &#123;
    DemoComponent
  &#125;,
  mixins: [],
  props: &#123;&#125;,
  data () &#123;
    return &#123;&#125;
  &#125;,
  computed: &#123;&#125;,
  watch: &#123;&#125;
  created () &#123;&#125;,
  mounted () &#123;&#125;,
  destroyed () &#123;&#125;,
  methods: &#123;&#125;,
&#125;
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
#my-component &#123;
&#125;
&lt;/style&gt;
复制代码
</code></pre>
<h4 id="2-1-2-data"><a href="#2-1-2-data" class="headerlink" title="2.1.2 data"></a>2.1.2 data</h4><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p>
<pre><code class="javascript">// In a .vue file
export default &#123;
  data () &#123;
    return &#123;
      foo: &#39;bar&#39;
    &#125;
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="2-1-3-prop"><a href="#2-1-3-prop" class="headerlink" title="2.1.3 prop"></a>2.1.3 prop</h4><p><strong>Prop 定义应该尽量详细。</strong></p>
<pre><code class="javascript">export default &#123;
  props: &#123;
    status: &#123;
      type: String,
      required: true,
      validator: function (value) &#123;
        return [
          &#39;syncing&#39;, 
          &#39;synced&#39;,
          &#39;version-conflict&#39;,
          &#39;error&#39;
        ].indexOf(value) !== -1
      &#125;
    &#125;
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="2-1-4-computed"><a href="#2-1-4-computed" class="headerlink" title="2.1.4 computed"></a>2.1.4 computed</h4><p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性。</strong> 小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p>
<pre><code class="javascript">// bad
computed: &#123; 
  price: function () &#123; 
    var basePrice = this.manufactureCost / (1 - this.profitMargin) 
    return ( 
      basePrice - 
      basePrice * (this.discountPercent || 0) 
    ) 
  &#125; 
&#125;

// good
computed: &#123;
  basePrice: function () &#123;
    return this.manufactureCost / (1 - this.profitMargin)
  &#125;,
  discount: function () &#123;
    return this.basePrice * (this.discountPercent || 0)
  &#125;,
  finalPrice: function () &#123;
    return this.basePrice - this.discount
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="2-1-5-为-v-for-设置键值"><a href="#2-1-5-为-v-for-设置键值" class="headerlink" title="2.1.5 为 v-for 设置键值"></a>2.1.5 为 <code>v-for</code> 设置键值</h4><p>**在组件上必须用 <code>key</code> 搭配 <code>v-for</code>**，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href="https://link.juejin.cn/?target=https://bost.ocks.org/mike/constancy/">对象固化 (object constancy)</a>。</p>
<pre><code class="html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in todos&quot;
    :key=&quot;todo.id&quot;&gt;
      &#123;&#123; todo.text &#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;
复制代码
</code></pre>
<h4 id="2-1-6-v-if-和-v-for-互斥"><a href="#2-1-6-v-if-和-v-for-互斥" class="headerlink" title="2.1.6 v-if 和 v-for 互斥"></a>2.1.6 <code>v-if</code> 和 <code>v-for</code> 互斥</h4><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p>
<pre><code class="html">&lt;!-- bad：控制台报错 --&gt;
&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;shouldShowUsers&quot;
    :key=&quot;user.id&quot;&gt;
      &#123;&#123; user.name &#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;
复制代码
</code></pre>
<p>一般我们在两种常见的情况下会倾向于这样做：</p>
<ul>
<li>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</li>
</ul>
<pre><code class="javascript">computed: &#123;
  activeUsers: function () &#123;
    return this.users.filter((user) =&gt; &#123;
      return user.isActive
    &#125;)
  &#125;
&#125;
复制代码
&lt;ul&gt;
  &lt;li
    v-for=&quot;user in activeUsers&quot;
    :key=&quot;user.id&quot;&gt;
      &#123;&#123; user.name &#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;
复制代码
</code></pre>
<ul>
<li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>, <code>ol</code>)。</li>
</ul>
<pre><code class="html">&lt;!-- bad --&gt;
&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;shouldShowUsers&quot;
    :key=&quot;user.id&quot;&gt;
      &#123;&#123; user.name &#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- good --&gt;
&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    :key=&quot;user.id&quot;&gt;
      &#123;&#123; user.name &#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;
复制代码
</code></pre>
<h4 id="2-1-7-多个-attribute-的元素"><a href="#2-1-7-多个-attribute-的元素" class="headerlink" title="2.1.7 多个 attribute 的元素"></a>2.1.7 多个 attribute 的元素</h4><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p>
<pre><code class="html">&lt;!-- bad --&gt;
&lt;img src=&quot;https://vuejs.org/images/logo.png&quot; alt=&quot;Vue Logo&quot;&gt;
&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;
复制代码
&lt;!-- good --&gt;
&lt;img
  src=&quot;https://vuejs.org/images/logo.png&quot;
  alt=&quot;Vue Logo&quot;&gt;

&lt;MyComponent
  foo=&quot;a&quot;
  bar=&quot;b&quot;
  baz=&quot;c&quot;/&gt;
复制代码
</code></pre>
<h4 id="2-1-8-模板中简单的表达式"><a href="#2-1-8-模板中简单的表达式" class="headerlink" title="2.1.8 模板中简单的表达式"></a>2.1.8 模板中简单的表达式</h4><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p>
<p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<strong>是什么</strong>，而非<strong>如何</strong>计算那个值。而且计算属性和方法使得代码可以重用。</p>
<pre><code class="javascript">// bad
&#123;&#123;
  fullName.split(' ').map((word) => &#123;
    return word[0].toUpperCase() + word.slice(1)
  &#125;).join(' ')
&#125;&#125;
复制代码
</code></pre>
<p>更好的做法：</p>
<pre><code class="html">&lt;!-- 在模板中 --&gt;
&#123;&#123; normalizedFullName &#125;&#125;
复制代码
// 复杂表达式已经移入一个计算属性
computed: &#123;
  normalizedFullName: function () &#123;
    return this.fullName.split(&#39; &#39;).map(function (word) &#123;
      return word[0].toUpperCase() + word.slice(1)
    &#125;).join(&#39; &#39;)
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="2-1-9-带引号的-attribute-值"><a href="#2-1-9-带引号的-attribute-值" class="headerlink" title="2.1.9 带引号的 attribute 值"></a>2.1.9 带引号的 attribute 值</h4><p><strong>非空 HTML 特性值应该始终带双引号。</strong></p>
<pre><code class="html">&lt;!-- bad --&gt;
&lt;input type=text&gt;
&lt;AppSidebar :style=&#123;width:sidebarWidth+&#39;px&#39;&#125;&gt;
复制代码
&lt;!-- good --&gt;
&lt;input type=&quot;text&quot;&gt;
&lt;AppSidebar :style=&quot;&#123; width: sidebarWidth + &#39;px&#39; &#125;&quot;&gt;
复制代码
</code></pre>
<h4 id="2-1-10-指令缩写"><a href="#2-1-10-指令缩写" class="headerlink" title="2.1.10 指令缩写"></a>2.1.10 指令缩写</h4><ul>
<li><strong>用 <code>:</code> 表示 <code>v-bind:</code></strong></li>
<li><strong>用 <code>@</code> 表示 <code>v-on:</code></strong></li>
<li><strong>用 <code>#</code> 表示 <code>v-slot:</code></strong></li>
</ul>
<pre><code class="html">&lt;input
  :value=&quot;newTodoText&quot;
  :placeholder=&quot;newTodoInstructions&quot;&gt;

&lt;input
  @input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;&gt;

&lt;template #header&gt;
  &lt;h1&gt;Here might be a page title&lt;/h1&gt;
&lt;/template&gt;

&lt;template #footer&gt;
  &lt;p&gt;Here&#39;s some contact info&lt;/p&gt;
&lt;/template&gt;
复制代码
</code></pre>
<h3 id="2-2-HTML"><a href="#2-2-HTML" class="headerlink" title="2.2 HTML"></a>2.2 HTML</h3><h4 id="2-2-1-文件模板"><a href="#2-2-1-文件模板" class="headerlink" title="2.2.1 文件模板"></a>2.2.1 文件模板</h4><p>HTML5 文件模板：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;zh-CN&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;HTML5标准模版&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
复制代码
</code></pre>
<p>移动端：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
        content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no&quot;&gt;
    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
    &lt;title&gt;移动端HTML模版&lt;/title&gt;

    &lt;!-- S DNS预解析 --&gt;
    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;&quot;&gt;
    &lt;!-- E DNS预解析 --&gt;

    &lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;
    &lt;!-- #include virtual=&quot;&quot; --&gt;
    &lt;!-- E 线上样式页面片 --&gt;

    &lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;
    &lt;!-- /本地调试方式 --&gt;

    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://srcPath/index.css&quot;&gt;
    &lt;!-- /开发机调试方式 --&gt;
    &lt;!-- E 本地调试 --&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
复制代码
</code></pre>
<p>PC 端：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;keywords&quot; content=&quot;your keywords&quot;&gt;
    &lt;meta name=&quot;description&quot; content=&quot;your description&quot;&gt;
    &lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;
    &lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt;
    &lt;title&gt;PC端HTML模版&lt;/title&gt;

    &lt;!-- S DNS预解析 --&gt;
    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;&quot;&gt;
    &lt;!-- E DNS预解析 --&gt;

    &lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;
    &lt;!-- #include virtual=&quot;&quot; --&gt;
    &lt;!-- E 线上样式页面片 --&gt;

    &lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;
    &lt;!-- /本地调试方式 --&gt;

    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://srcPath/index.css&quot;&gt;
    &lt;!-- /开发机调试方式 --&gt;
    &lt;!-- E 本地调试 --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
复制代码
</code></pre>
<h4 id="2-2-2-元素及标签闭合"><a href="#2-2-2-元素及标签闭合" class="headerlink" title="2.2.2 元素及标签闭合"></a>2.2.2 元素及标签闭合</h4><p>HTML 元素共有以下5种：</p>
<ul>
<li>空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</li>
<li>原始文本元素：script、style</li>
<li>RCDATA 元素：textarea、title</li>
<li>外来元素：来自 MathML 命名空间和 SVG 命名空间的元素</li>
<li>常规元素：其他 HTML 允许的元素都称为常规元素</li>
</ul>
<p>为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定：</p>
<ul>
<li>所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。</li>
<li>空元素标签都不加 “/” 字符。</li>
</ul>
<pre><code class="html">&lt;!-- good --&gt;
&lt;div&gt;
    &lt;h1&gt;我是h1标题&lt;/h1&gt;
    &lt;p&gt;我是一段文字，我有始有终，浏览器能正确解析&lt;/p&gt;
&lt;/div&gt;
    
&lt;br data-tomark-pass&gt;

&lt;!-- bad --&gt;
&lt;div&gt;
    &lt;h1&gt;我是h1标题&lt;/h1&gt;
    &lt;p&gt;我是一段文字，我有始无终，浏览器亦能正确解析
&lt;/div&gt;

&lt;br/&gt;
复制代码
</code></pre>
<h4 id="2-2-3-代码嵌套"><a href="#2-2-3-代码嵌套" class="headerlink" title="2.2.3 代码嵌套"></a>2.2.3 代码嵌套</h4><p>元素嵌套规范，每个块状元素独立一行，内联元素可选。</p>
<pre><code class="html">&lt;!-- good --&gt;
&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;    
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;!-- bad --&gt;
&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;/div&gt;    
&lt;p&gt; 
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/p&gt;
复制代码
</code></pre>
<p>段落元素与标题元素只能嵌套内联元素。</p>
<pre><code class="html">&lt;!-- good --&gt;
&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;!-- bad --&gt;
&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;
&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;
复制代码
</code></pre>
<h3 id="2-3-CSS"><a href="#2-3-CSS" class="headerlink" title="2.3 CSS"></a>2.3 CSS</h3><h4 id="2-3-1-样式文件"><a href="#2-3-1-样式文件" class="headerlink" title="2.3.1 样式文件"></a>2.3.1 样式文件</h4><p>样式文件必须写上 <code>@charset</code> 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 <code>“UTF-8”</code>。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">@charset &quot;UTF-8&quot;;
.jdc &#123;&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">/* @charset规则不在文件首行首个字符开始 */
@charset &quot;UTF-8&quot;;
.jdc &#123;&#125;

/* @charset规则没有用小写 */
@CHARSET &quot;UTF-8&quot;;
.jdc &#123;&#125;

/* 无@charset规则 */
.jdc &#123;&#125;
复制代码
</code></pre>
<h4 id="2-3-2-代码格式化"><a href="#2-3-2-代码格式化" class="headerlink" title="2.3.2 代码格式化"></a>2.3.2 代码格式化</h4><p>样式书写一般有两种：一种是紧凑格式 （Compact），一种是展开格式（Expanded）。</p>
<ul>
<li>推荐：展开格式（Expanded）</li>
</ul>
<pre><code class="css">.jdc &#123;
  display: block;
  width: 50px;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：紧凑格式 （Compact）</li>
</ul>
<pre><code class="css">.jdc &#123; display: block; width: 50px;&#125;
复制代码
</code></pre>
<h4 id="2-3-3-代码大小写"><a href="#2-3-3-代码大小写" class="headerlink" title="2.3.3 代码大小写"></a>2.3.3 代码大小写</h4><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  display: block;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.JDC &#123;
  DISPLAY: BLOCK;
&#125;
复制代码
</code></pre>
<h4 id="2-3-4-代码易读性"><a href="#2-3-4-代码易读性" class="headerlink" title="2.3.4 代码易读性"></a>2.3.4 代码易读性</h4><ol>
<li>左括号与类名之间一个空格，冒号与属性值之间一个空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  width: 100%;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc&#123;
  width:100%;
&#125;
复制代码
</code></pre>
<ol>
<li>逗号分隔的取值，逗号之后一个空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;
&#125;
复制代码
</code></pre>
<ol>
<li>为单个 CSS 选择器或新声明开启新行。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc, .jdc_logo, .jdc_hd &#123;
  color: #ff0;
&#125;

.nav&#123;
  color: #fff;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc, .jdc_logo, .jdc_hd &#123;
  color: #ff0;
&#125;.nav&#123;
  color: #fff;
&#125;
复制代码
</code></pre>
<ol>
<li>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  color: rgba(255,255,255,.5);
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  color: rgba( 255, 255, 255, 0.5 );
&#125;
复制代码
</code></pre>
<ol>
<li>属性值十六进制数值能用简写的尽量用简写。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  color: #fff;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  color: #ffffff;
&#125;
复制代码
</code></pre>
<ol>
<li>不要为 <code>0</code> 指明单位。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  margin: 0 10px;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  margin: 0px 10px;
&#125;
复制代码
</code></pre>
<h4 id="2-3-5-属性值引号"><a href="#2-3-5-属性值引号" class="headerlink" title="2.3.5 属性值引号"></a>2.3.5 属性值引号</h4><p>CSS 属性值需要用到引号时，统一使用单引号。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  font-family: &#39;Hiragino Sans GB&#39;;
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">.jdc &#123;
  font-family: &quot;Hiragino Sans GB&quot;;
&#125;
复制代码
</code></pre>
<h4 id="2-3-6-属性书写建议"><a href="#2-3-6-属性书写建议" class="headerlink" title="2.3.6 属性书写建议"></a>2.3.6 属性书写建议</h4><p>建议遵循以下顺序：</p>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient …</li>
</ol>
<pre><code class="css">.jdc &#123;
  display: block;
  position: relative;
  float: left;
  width: 100px;
  height: 100px;
  margin: 0 10px;
  padding: 20px 0;
  font-family: Arial, &#39;Helvetica Neue&#39;, Helvetica, sans-serif;
  color: #333;
  background: rgba(0,0,0,.5);
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  -o-border-radius: 10px;
  -ms-border-radius: 10px;
  border-radius: 10px;
&#125;
复制代码
</code></pre>
<h4 id="3-3-7-CSS3-浏览器私有前缀"><a href="#3-3-7-CSS3-浏览器私有前缀" class="headerlink" title="3.3.7 CSS3 浏览器私有前缀"></a>3.3.7 CSS3 浏览器私有前缀</h4><p>CSS3 浏览器私有前缀在前，标准前缀在后。</p>
<pre><code class="css">.jdc &#123;
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  -o-border-radius: 10px;
  -ms-border-radius: 10px;
  border-radius: 10px;
&#125;
复制代码
</code></pre>
<h3 id="2-4-JavaScript"><a href="#2-4-JavaScript" class="headerlink" title="2.4 JavaScript"></a>2.4 JavaScript</h3><h4 id="2-4-1-单行代码块"><a href="#2-4-1-单行代码块" class="headerlink" title="2.4.1 单行代码块"></a>2.4.1 单行代码块</h4><p>在单行代码块中使用空格。</p>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="JavaScript">function foo () &#123;return true&#125;
if (foo) &#123;bar = 0&#125;
复制代码
</code></pre>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">function foo () &#123; return true &#125;
if (foo) &#123; bar = 0 &#125;
复制代码
</code></pre>
<h4 id="2-4-2-大括号风格"><a href="#2-4-2-大括号风格" class="headerlink" title="2.4.2 大括号风格"></a>2.4.2 大括号风格</h4><p>在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下：</p>
<ul>
<li><strong>【推荐】One True Brace Style</strong></li>
</ul>
<pre><code class="javascript">if (foo) &#123;
  bar()
&#125; else &#123;
  baz()
&#125;
复制代码
</code></pre>
<ul>
<li><strong>Stroustrup</strong></li>
</ul>
<pre><code class="javascript">if (foo) &#123;
  bar()
&#125;
else &#123;
  baz()
&#125;
复制代码
</code></pre>
<ul>
<li><strong>Allman</strong></li>
</ul>
<pre><code class="javascript">if (foo)
&#123;
  bar()
&#125;
else
&#123;
  baz()
&#125;
复制代码
</code></pre>
<h4 id="2-4-3-代码中的空格"><a href="#2-4-3-代码中的空格" class="headerlink" title="2.4.3 代码中的空格"></a>2.4.3 代码中的空格</h4><ol>
<li>逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">var foo = 1, bar = 2
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">var foo = 1,bar = 2

var foo = 1 , bar = 2

var foo = 1 ,bar = 2
复制代码
</code></pre>
<ol>
<li>对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">var obj = &#123; &#39;foo&#39;: &#39;haha&#39; &#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">var obj = &#123; &#39;foo&#39; : &#39;haha&#39; &#125;
复制代码
</code></pre>
<ol>
<li>代码块前要添加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">if (a) &#123;
  b()
&#125;

function a () &#123;&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">if (a)&#123;
  b()
&#125;

function a ()&#123;&#125;
复制代码
</code></pre>
<ol>
<li>函数声明括号前要加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">function func (x) &#123;
  // ...
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">function func(x) &#123;
  // ...
&#125;
复制代码
</code></pre>
<ol>
<li>在函数调用时，禁止使用空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">fn()
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">fn ()

fn
()
复制代码
</code></pre>
<ol>
<li>在操作符前后都需要添加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="JavaScript">var sum = 1 + 2
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="JavaScript">var sum = 1+2
复制代码
</code></pre>
<h2 id="三、注释规范"><a href="#三、注释规范" class="headerlink" title="三、注释规范"></a>三、注释规范</h2><p><strong>注释的目的：</strong></p>
<ul>
<li><strong>提高代码的可读性，从而提高代码的可维护性</strong></li>
</ul>
<p><strong>注释的原则：</strong></p>
<ul>
<li><strong>如无必要，勿增注释 ( As short as possible )</strong></li>
<li><strong>如有必要，尽量详尽 ( As long as necessary )</strong></li>
</ul>
<h3 id="3-1-HTML-文件注释"><a href="#3-1-HTML-文件注释" class="headerlink" title="3.1 HTML 文件注释"></a>3.1 HTML 文件注释</h3><h4 id="3-1-1-单行注释"><a href="#3-1-1-单行注释" class="headerlink" title="3.1.1 单行注释"></a>3.1.1 单行注释</h4><p><strong>一般用于简单的描述，如某些状态描述、属性描述等。</strong></p>
<p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="html">&lt;!-- Comment Text --&gt;
&lt;div&gt;...&lt;/div&gt;
复制代码
</code></pre>
<ul>
<li>不推荐</li>
</ul>
<pre><code class="html">&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt;

&lt;div&gt;&lt;!-- Comment Text --&gt;
  ...
&lt;/div&gt;
复制代码
</code></pre>
<h4 id="3-1-2-模块注释"><a href="#3-1-2-模块注释" class="headerlink" title="3.1.2 模块注释"></a>3.1.2 模块注释</h4><p><strong>一般用于描述模块的名称以及模块开始与结束的位置。</strong></p>
<p>注释内容前后各一个空格字符， <code>&lt;!-- S Comment Text --&gt;</code>表示模块开始， <code>&lt;!-- E Comment Text --&gt;</code>表示模块结束，模块与模块之间相隔一行。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="html">&lt;!-- S Comment Text A --&gt;    
&lt;div class=&quot;mod_a&quot;&gt;
  ...
&lt;/div&gt;
&lt;!-- E Comment Text A --&gt;
    
&lt;!-- S Comment Text B --&gt;    
&lt;div class=&quot;mod_b&quot;&gt;
  ...
&lt;/div&gt;
&lt;!-- E Comment Text B --&gt;
复制代码
</code></pre>
<ul>
<li>不推荐</li>
</ul>
<pre><code class="html">&lt;!-- S Comment Text A --&gt;
&lt;div class=&quot;mod_a&quot;&gt;
  ...
&lt;/div&gt;
&lt;!-- E Comment Text A --&gt;
&lt;!-- S Comment Text B --&gt;    
&lt;div class=&quot;mod_b&quot;&gt;
  ...
&lt;/div&gt;
&lt;!-- E Comment Text B --&gt;
复制代码
</code></pre>
<h4 id="3-1-3-嵌套模块注释"><a href="#3-1-3-嵌套模块注释" class="headerlink" title="3.1.3 嵌套模块注释"></a>3.1.3 嵌套模块注释</h4><p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用。</p>
<pre><code class="html">&lt;!-- S Comment Text --&gt;
&lt;!-- E Comment Text --&gt;
复制代码
</code></pre>
<p>而改用</p>
<pre><code class="html">&lt;!-- /Comment Text --&gt;
复制代码
</code></pre>
<p>注释写在模块结尾标签底部，单独一行。</p>
<pre><code class="html">&lt;!-- S Comment Text A --&gt;
&lt;div class=&quot;mod_a&quot;&gt;
        
    &lt;div class=&quot;mod_b&quot;&gt;
        ...
    &lt;/div&gt;
    &lt;!-- /mod_b --&gt;
        
    &lt;div class=&quot;mod_c&quot;&gt;
        ...
    &lt;/div&gt;
    &lt;!-- /mod_c --&gt;
        
&lt;/div&gt;
&lt;!-- E Comment Text A --&gt;
复制代码
</code></pre>
<h3 id="3-2-CSS-文件注释"><a href="#3-2-CSS-文件注释" class="headerlink" title="3.2 CSS 文件注释"></a>3.2 CSS 文件注释</h3><h4 id="3-2-1-单行注释"><a href="#3-2-1-单行注释" class="headerlink" title="3.2.1 单行注释"></a>3.2.1 单行注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">/* Comment Text */ 
.jdc &#123;&#125; 

/* Comment Text */ 
.jdc &#123;&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">/*Comment Text*/
.jdc &#123;
  display: block;
&#125;

.jdc &#123;
  display: block;/*Comment Text*/
&#125;
复制代码
</code></pre>
<h4 id="3-2-2-模块注释"><a href="#3-2-2-模块注释" class="headerlink" title="3.2.2 模块注释"></a>3.2.2 模块注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，<code>/*</code> 与 模块信息描述占一行，多个横线分隔符 <code>-</code> 与 <code>*/</code> 占一行，行与行之间相隔两行。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="css">/* Module A
---------------------------------------------------------------- */
.mod_a &#123;&#125;


/* Module B
---------------------------------------------------------------- */
.mod_b &#123;&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="css">/* Module A ---------------------------------------------------- */
.mod_a &#123;&#125;
/* Module B ---------------------------------------------------- */
.mod_b &#123;&#125;
复制代码
</code></pre>
<h4 id="3-2-3-文件注释"><a href="#3-2-3-文件注释" class="headerlink" title="3.2.3 文件注释"></a>3.2.3 文件注释</h4><p>在样式文件编码声明 <code>@charset</code> 语句下面注明页面名称、作者、创建日期等信息。</p>
<pre><code class="css">@charset &quot;UTF-8&quot;;
/**
 * @desc File Info
 * @author Author Name
 * @date 2015-10-10
 */
复制代码
</code></pre>
<h3 id="3-3-JavaScript-文件注释"><a href="#3-3-JavaScript-文件注释" class="headerlink" title="3.3 JavaScript 文件注释"></a>3.3 JavaScript 文件注释</h3><h4 id="3-3-1-单行注释"><a href="#3-3-1-单行注释" class="headerlink" title="3.3.1 单行注释"></a>3.3.1 单行注释</h4><p>单行注释使用 <code>//</code>，注释应单独一行写在被注释对象的上方，不要追加在某条语句的后面。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">// is current tab
const active = true
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">const active = true // is current tab
复制代码
</code></pre>
<p>注释行的上方需要有一个空行（<strong>除非注释行上方是一个块的顶部</strong>），以增加可读性。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">function getType () &#123;  
  console.log(&#39;fetching type...&#39;)
  
  // set the default type to &#39;no type&#39;
  const type = this.type || &#39;no type&#39;
  return type
&#125;
复制代码
// 注释行上面是一个块的顶部时不需要空行
function getType () &#123;  
  // set the default type to &#39;no type&#39;
  const type = this.type || &#39;no type&#39;            
  return type
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">function getType () &#123;  
  console.log(&#39;fetching type...&#39;)
  // set the default type to &#39;no type&#39;
  const type = this.type || &#39;no type&#39;
  return type
&#125;
复制代码
</code></pre>
<h4 id="3-3-2-多行注释"><a href="#3-3-2-多行注释" class="headerlink" title="3.3.2 多行注释"></a>3.3.2 多行注释</h4><p>多行注释使用 <code>/** ... */</code>，而不是多行的 <code>//</code>。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">/**
 * make() returns a new element
 * based on the passed-in tag name
 */
function make (tag) &#123;
  // ...

  return element
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">// make() returns a new element
// based on the passed in tag name
function make (tag) &#123;
  // ...

  return element
&#125;
复制代码
</code></pre>
<h4 id="3-3-3-注释空格"><a href="#3-3-3-注释空格" class="headerlink" title="3.3.3 注释空格"></a>3.3.3 注释空格</h4><p>注释内容和注释符之间需要有一个空格，以增加可读性。eslint: <code>spaced-comment</code>。</p>
<ul>
<li>推荐：</li>
</ul>
<pre><code class="javascript">// is current tab
const active = true

/**
 * make() returns a new element
 * based on the passed-in tag name
 */
function make(tag) &#123;  
  // ...

  return element
&#125;
复制代码
</code></pre>
<ul>
<li>不推荐：</li>
</ul>
<pre><code class="javascript">//is current tab
const active = true

/**
 *make() returns a new element
 *based on the passed-in tag name
 */
function make(tag) &#123;  
  // ...

  return element
&#125;
复制代码
</code></pre>
<h4 id="3-3-4-特殊标记"><a href="#3-3-4-特殊标记" class="headerlink" title="3.3.4 特殊标记"></a>3.3.4 特殊标记</h4><p>有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种：</p>
<ul>
<li><code>// FIXME</code> : 说明问题是什么</li>
<li><code>// TODO</code> : 说明还要做什么或者问题的解决方案</li>
</ul>
<pre><code class="javascript">class Calculator extends Abacus &#123;
  constructor () &#123;
    super ()

      // FIXME: shouldn’t use a global here
      total = 0

      // TODO: total should be configurable by an options param
      this.total = 0
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="3-3-5-文档类注释"><a href="#3-3-5-文档类注释" class="headerlink" title="3.3.5 文档类注释"></a>3.3.5 文档类注释</h4><p>文档类注释，如函数、类、文件、事件等；都使用 jsdoc 规范。</p>
<pre><code class="javascript">/**
 * Book类，代表一个书本.
 * @constructor
 * @param &#123;string&#125; title - 书本的标题.
 * @param &#123;string&#125; author - 书本的作者.
 */
function Book (title, author) &#123;
  this.title = title
  this.author = author
&#125;

Book.prototype = &#123;
  /**
   * 获取书本的标题
   * @returns &#123;string|*&#125;
   */
  getTitle: function () &#123;
    return this.title
  &#125;,
  /**
   * 设置书本的页数
   * @param pageNum &#123;number&#125; 页数
   */
  setPageNum: function (pageNum) &#123;
    this.pageNum=pageNum
  &#125;
&#125;
复制代码
</code></pre>
<h4 id="3-3-6-注释工具"><a href="#3-3-6-注释工具" class="headerlink" title="3.3.6 注释工具"></a>3.3.6 注释工具</h4><p><code>ESLint</code> 是当下最流行的 JS 代码检查工具，<code>ESLint</code> 中有一些注释相关的规则，用户可选择开启：</p>
<ul>
<li><code>valid-jsdoc</code></li>
<li><code>require-jsdoc</code></li>
<li><code>no-warning-comments</code></li>
<li><code>capitalized-comments</code></li>
<li><code>line-comment-position</code></li>
<li><code>lines-around-comment</code></li>
<li><code>multiline-comment-style</code></li>
<li><code>no-inline-comments</code></li>
<li><code>spaced-comment</code></li>
</ul>
<h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><ul>
<li>缩进换行请使用两个空格。</li>
<li>大型团队多人协作项目推荐 JavaScript 代码末尾加分号。</li>
<li>小型个人创新练手项目可尝试使用 JavaScript 代码末尾不加分号的风格，更加清爽简练。</li>
</ul>
<p>作者：鱼酱<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6987349513836953607">https://juejin.cn/post/6987349513836953607</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-css-重置样式表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/css-%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%E8%A1%A8/" class="article-date">
  	<time datetime="2022-09-05T03:11:04.829Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/css-%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%E8%A1%A8/">
        Css-重置样式表
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>/* <a target="_blank" rel="noopener" href="http://meyerweb.com/eric/tools/css/reset/">http://meyerweb.com/eric/tools/css/reset/</a><br>   v2.0 | 20110126<br>   License: none (public domain)<br>*/</p>
<pre><code class="css">html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video &#123;
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
&#125;
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section &#123;
    display: block;
&#125;
body &#123;
    line-height: 1;
&#125;
ol, ul &#123;
    list-style: none;
&#125;
blockquote, q &#123;
    quotes: none;
&#125;
blockquote:before, blockquote:after,
q:before, q:after &#123;
    content: &#39;&#39;;
    content: none;
&#125;
table &#123;
    border-collapse: collapse;
    border-spacing: 0;
&#125;
</code></pre>
<p>/图片水平垂直居中/</p>
<pre><code class="css">.valign&#123;text-align:center;&#125;
.valign img&#123;vertical-align:middle;&#125;
.valign:after&#123;content:&quot;&quot;;display:inline-block;height:100%;vertical-align:middle;&#125;
</code></pre>
<p>/<em>单行文本出现省略号</em>/</p>
<pre><code class="css">.over&#123;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;&#125;
</code></pre>
<p>/<em>阻止margin-top向父元素传递</em>/</p>
<pre><code class="css">.clear:before&#123;content:&quot;&quot;;display:table;&#125;
</code></pre>
<p>/<em>边框圆角属性</em>/</p>
<pre><code class="css">.border-radius&#123;border-radius:50%;&#125;
</code></pre>
<p>/<em>清除浮动</em>/</p>
<pre><code class="css">.clear:after&#123;content:&quot;&quot;;clear:both;display:block;&#125;
</code></pre>
<p>/<em>弹性盒子,垂直居中，水平居中；水平两边分开对齐；换行；纵向排列；分开左右边距对齐;怪异盒模型</em>/</p>
<pre><code class="css">.display&#123;display:flex;align-items:center;justify-content:center;justify-content:space-between;flex-wrap:wrap;flex-direction:column; 
justify-content:space-around;box-sizing:border-box;&#125;
</code></pre>
<p>/<em>定位;1固定定位不占文档流，绝对定位不占文档流，相对定位占文档流</em>/</p>
<pre><code class="css">.position&#123;position:fixed;position:absolute;position:relative;&#125;
</code></pre>
<p>/<em>响应式移动端</em>/</p>
<pre><code class="css">@media screen and (width:640px)&#123;
    html&#123;font-size:64px;&#125;    
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-css-清除浮动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/05/css-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/" class="article-date">
  	<time datetime="2022-09-05T03:09:34.605Z" itemprop="datePublished">2022-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/05/css-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/">
        Css-清除浮动
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="css">.clearfix::after &#123;
  content: &quot;&quot;;
  clear: both;
  display: table;
&#125;
</code></pre>
<h4 id="1-上面伪类清除法"><a href="#1-上面伪类清除法" class="headerlink" title="1.上面伪类清除法"></a>1.上面伪类清除法</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>