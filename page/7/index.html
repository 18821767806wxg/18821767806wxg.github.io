<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/page/7/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-vue3快速上手" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" class="article-date">
  	<time datetime="2022-08-29T07:53:46.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">
        Vue3-Vue3快速上手
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />



<h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a target="_blank" rel="noopener" href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li>
<li>github上的tags地址：<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a target="_blank" rel="noopener" href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<pre><code class="bash">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;
    get () &#123;&#125;, 
    set () &#123;&#125;
&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li><p>实现原理: </p>
<ul>
<li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<pre><code class="js">new Proxy(data, &#123;
    // 拦截读取属性值
    get (target, prop) &#123;
        return Reflect.get(target, prop)
    &#125;,
    // 拦截设置属性值或添加新属性
    set (target, prop, value) &#123;
        return Reflect.set(target, prop, value)
    &#125;,
    // 拦截删除属性
    deleteProperty (target, prop) &#123;
        return Reflect.deleteProperty(target, prop)
    &#125;
&#125;)

proxy.name = &#39;tom&#39;   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<pre><code class="js">import &#123;computed&#125; from &#39;vue&#39;

setup()&#123;
    ...
    //计算属性——简写
    let fullName = computed(()=&gt;&#123;
        return person.firstName + &#39;-&#39; + person.lastName
    &#125;)
    //计算属性——完整
    let fullName = computed(&#123;
        get()&#123;
            return person.firstName + &#39;-&#39; + person.lastName
        &#125;,
        set(value)&#123;
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        &#125;
    &#125;)
&#125;
</code></pre>
</li>
</ul>
<h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<pre><code class="js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;sum变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true&#125;)

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;&#123;
    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)
&#125;) 

/* 情况三：监视reactive定义的响应式数据
            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;)

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
</ul>
<h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;&#123;
    const x1 = sum.value
    const x2 = person.age
    console.log(&#39;watchEffect配置的回调执行了&#39;)
&#125;)
</code></pre>
</li>
</ul>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div>





































<p>1</p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul>
<li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li>
<li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li>
<li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li>
</ul>
<ul>
<li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li>
</ul>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<pre><code class="vue">&lt;template&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
    import &#123;ref,customRef&#125; from &#39;vue&#39;
    export default &#123;
        name:&#39;Demo&#39;,
        setup()&#123;
            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref
            //自定义一个myRef
            function myRef(value,delay)&#123;
                let timer
                //通过customRef去实现自定义
                return customRef((track,trigger)=&gt;&#123;
                    return&#123;
                        get()&#123;
                            track() //告诉Vue这个value值是需要被“追踪”的
                            return value
                        &#125;,
                        set(newValue)&#123;
                            clearTimeout(timer)
                            timer = setTimeout(()=&gt;&#123;
                                value = newValue
                                trigger() //告诉Vue去更新界面
                            &#125;,delay)
                        &#125;
                    &#125;
                &#125;)
            &#125;
            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref
            return &#123;
                keyword
            &#125;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<pre><code class="js">setup()&#123;    ......    let car = reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)    provide(&#39;car&#39;,car)    ......&#125;
</code></pre>
</li>
<li><p>后代组件中：</p>
<pre><code class="js">setup(props,context)&#123;    ......    const car = inject(&#39;car&#39;)    return &#123;car&#125;    ......&#125;
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>
















<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>














<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="vue">&lt;teleport to=&quot;移动位置&quot;&gt;    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;
</code></pre>
</li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<pre><code class="js">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))
</code></pre>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="vue">&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;            &lt;template v-slot:default&gt;                &lt;Child/&gt;            &lt;/template&gt;            &lt;template v-slot:fallback&gt;                &lt;h3&gt;加载中.....&lt;/h3&gt;            &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="js">//注册全局组件Vue.component(&#39;MyButton&#39;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#39;&#125;)//注册全局指令Vue.directive(&#39;focus&#39;, &#123;  inserted: el =&gt; el.focus()&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<pre><code class="css">.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;
</code></pre>
</li>
<li><p>Vue3.x写法</p>
<pre><code class="css">.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<pre><code class="vue">&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;
</code></pre>
</li>
<li><p>子组件中声明自定义事件</p>
<pre><code class="vue">&lt;script&gt;  export default &#123;    emits: [&#39;close&#39;]  &#125;&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vuex入门（5）—— 为什么要用Action管理异步操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Action%E7%AE%A1%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/" class="article-date">
  	<time datetime="2022-08-29T07:48:06.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Action%E7%AE%A1%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/">
        Vue-vuex身上的要用Action管理异步操作
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Action 类似于 mutation，不同在于：</p>
<p>1.Action 提交的是 mutation，而不是直接变更状态。</p>
<p>2.Action 可以包含任意异步操作。</p>
<p>  官方给的定义我没什么意见,事实上我通过mutation异步操作,好像跟用action管理也没什么区别。关于为什么要用Action管理异步操作，我会通过一个简单的例子和一个复杂的例子来进行说明，事实上，如果初学者没有考虑到实际场景的复杂情况，会觉得Action根本没有一点软用，这个时候就要把问题想得复杂一些了，然后才能看到Action的作用。</p>
<p>  先来看一个简单的例子，也是我对如果不用Action进行异步操作的一些初步探索。</p>
<p>  第一步：我非常作死的重写了mutation状态管理器中对状态操作的一些写法，我使用了异步操作代替了之前的操作。</p>
<p>// mutation.js<br>const increment = (state) =&gt; {<br>  setTimeout(() =&gt; {<br>    state.count++<br>  }, 1000)<br>}<br>const decrement = (state) =&gt; {<br>  setTimeout(() =&gt; {<br>    state.count–<br>  }, 2000)<br>  state.count–<br>}<br>export {increment, decrement}<br>  第二步：试验一下能否成功</p>
<template>
  <div>
    <button @click="decrement">-</button>
    <span></span>
    <button @click="increment">+</button>
  </div>
</template>
 
<script>
import { mapState, mapMutations} from 'vuex'
export default {
  computed: {
    ...mapState(['count'])
  },
  methods: {
    ...mapMutations(['increment', 'decrement']),
  }
}
</script>
<style>
 
</style>

<p>  第三步：发现除了每次操作加减时候有一秒的延时，不管你怎么操作，结果都是正确的，是符合社会主义核心价值观的。</p>
<p> 第四步:用Action处理异步操作（先得把之前作死改掉的mutation的代码改回来）</p>
<p>// 正常的mutation<br>const increment = (state) =&gt; {<br>  state.count++<br>}<br>const decrement = (state) =&gt; {<br>  state.count–<br>}<br>export {increment, decrement}<br>// action.js处理一些异步操作<br>// Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象<br>let incrementAsync = (content) =&gt; {<br>  setTimeout(() =&gt; {<br>    content.commit(‘increment’)<br>  }, 1000)<br>}<br>let decrementAsync = (content) =&gt; {<br>  setTimeout(() =&gt; {<br>    content.commit(‘decrement’)<br>  }, 1000)<br>}<br>export {incrementAsync, decrementAsync}<br><template><br>  <div><br>    &lt;button @click=”decrementAsync”&gt;-</button><br>    <span></span><br>    &lt;button @click=”incrementAsync”&gt;+</button><br>  </div><br></template></p>
<script>
import { mapState, mapMutations, mapActions } from 'vuex'
export default {
  computed: {
    ...mapState(['count'])
  },
  methods: {
    ...mapMutations(['increment', 'decrement']),
    ...mapActions(['incrementAsync', 'decrementAsync']) //这里用了辅助函数，不了解的可以看这个系列的第二篇文章
  }
}
</script>
<style>
 
</style>
<p>第五步：测试一下效果，你会感觉跟没有用action直接用mutation的结果一毛一样。再看一下官网说明。</p>
<p> 所以，官网说的这句话有问题？<br> 确实有问题，因为在mutation中执行异步操作并不会报错，也能正确更改状态，所以并不是所谓的“必须同步执行”这么苛刻，只能说你最好不要这么做。（这里说一句题外话，我初学vuex的时候，大概去年，在mutaition中一旦有异步操作，控制台立马就会有警告，不知道是记错了还是现在删除了这个设定）</p>
<p>上面的例子可能太过简单，以至于Action看起来都发挥不了什么作用。</p>
<p>下面来看一个复杂的例子，这个例子有助于理解为什么要用Action管理异步操作<br>需求如下</p>
<p>state中存储了一个状态，我们还是复用刚才的count</p>
<p>现在有两个异步操作，他们都能改变count的值</p>
<p>第二个异步操作的条件依赖第一个异步操作的结果，比如第一个异步操作执行了count ++ ，count :0 = &gt;1，第二个异步操作会先判断当前count的值，if(count === 1) { do something…} else { do something… }</p>
<p> 当异步操作涉及互相依赖的情况的时候，我们肯定希望被依赖的操作执行完成之后，再执行依赖项，这样能保证程序执行得到正确的结果，但异步操作，如接口访问这种，往往是不能确定执行完成的时间的，</p>
<p>通常你在接口A中得到一个值，a</p>
<p>接口B需要使用这个值结合B接口返回的值进行一些判断操作，if(a&amp;&amp;b){ … }</p>
<p>这个时候如果B接口执行完毕了，A接口的值还没过来的话，就可能得到错误的结果。 a =&gt; undefined</p>
<p>  所以这里牵扯到了一个异步操作的顺序执行问题，既然是异步操作问题，基本都会用到ES6的promise函数去解决，有兴趣的可以用看一下我的文章——关于promise的一些使用和原理。</p>
<p>  下面我们重写一下代码</p>
<p>// Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象<br>let incrementAsync = (content) =&gt; {<br>  return new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; {<br>      content.commit(‘increment’)<br>      resolve()<br>    }, 1000)<br>  })<br>}<br>let decrementAsync = (content) =&gt; {<br>  return new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; {<br>      content.commit(‘decrement’)<br>      resolve()<br>    }, 1000)<br>  })<br>}<br>export {incrementAsync, decrementAsync}</p>
<template>
  <div>
    <button @click="dec">-</button>
    <span></span>
    <button @click="add">+</button>
  </div>
</template>
 
<script>
import { mapState, mapMutations, mapActions } from 'vuex'
export default {
  computed: {
    ...mapState(['count'])
  },
  methods: {
    ...mapMutations(['increment', 'decrement']),
    ...mapActions(['incrementAsync', 'decrementAsync']),
    add () {
      this.incrementAsync().then(() => {
        this.increment()
      })
    },
    dec () {
      this.decrementAsync().then(() => {
        // do something
      })
    }
  }
}
</script>
<style>
 
</style>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-32vuex" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/32vuex/" class="article-date">
  	<time datetime="2022-08-29T07:45:40.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/32vuex/">
        Vue-vuex-1, vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.state<br>  state是什么?</p>
<p>  定义:state(vuex) ≈ data (vue)</p>
<p>  vuex的state和vue的data有很多相似之处,都是用于存储一些数据,或者说状态值.这些值都将被挂载 数据和dom的双向绑定事件,也就是当你改变值的时候可以触发dom的更新.</p>
<p>  虽然state和data有很多相似之处,但state在使用的时候一般被挂载到子组件的computed计算属性上,这样有利于state的值发生改变的时候及时响应给子组件.如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题,那你可以针是一个杠精</p>
<p>  综上所述,请用computed去接收state,如下</p>
<p>//state.js<br>let state = {<br>  count: 1,<br>  name: ‘dkr’,<br>  sex: ‘男’,<br>  from: ‘china’<br>}<br>export default state</p>
<template>
  <div id="example">
    <button @click="decrement">-</button>
    
    
    <button @click="increment">+</button>
  </div>
</template>
<script>
export default {
  data () {
    return {
      dataCount: this.$store.state.count //用data接收
    }
  },
  computed:{
    count(){
      return this.$store.state.count //用computed接收
    }
  }
  methods: {
    increment () {
      this.$store.commit('increment')
    },
    decrement () {
      this.$store.commit('decrement')
    }
  }
}
</script>
结果如下,用data接收的值不能及时响应更新,用computed就可以.



 

<p>2.mapState 辅助函数<br>  mapState是什么?</p>
<p>  表面意思:mapState是state的辅助函数.这么说可能很难理解</p>
<p>  抽象形容:mapState是state的语法糖,这么说可能你还想骂我,因为你根本不了解什么叫做语法糖,事实上我说的语法糖有自己的定义,什么是语法糖?我对语法糖的理解就是,用之前觉得,我明明已经对一种操作很熟练了,并且这种操作也不存在什么问题,为什么要用所谓的”更好的操作”,用了一段时间后,真香!</p>
<p>  实际作用:当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键</p>
<p>  在使用mapState之前,要导入这个辅助函数.</p>
<p>import { mapState } from ‘vuex’<br>  然后就是使用方式了</p>
<template>
  <div id="example">
    <button @click="decrement">-</button>
    
    
    <button @click="increment">+</button>
    <div></div>
    <div></div>
    <div></div>
  </div>
</template>
<script>
import { mapState } from 'vuex'
export default {
  data () {
    return {
      str: '国籍',
      dataCount: this.$store.state.count
    }
  },
  computed: mapState({
    count: 'count', // 第一种写法
    sex: (state) => state.sex, // 第二种写法
    from: function (state) { // 用普通函数this指向vue实例,要注意
      return this.str + ':' + state.from
    },
    // 注意下面的写法看起来和上面相同,事实上箭头函数的this指针并没有指向vue实例,因此不要滥用箭头函数
    // from: (state) => this.str + ':' + state.from
    myCmpted: function () {
      // 这里不需要state,测试一下computed的原有用法
      return '测试' + this.str
    }
  }),
  methods: {
    increment () {
      this.$store.commit('increment')
    },
    decrement () {
      this.$store.commit('decrement')
    }
  },
  created () {
    // 写个定时器，发现computed依旧保持了只要内部有相关属性发生改变不管是当前实例data中的改变，还是vuex中的值改变都会触发dom和值更新
    setTimeout(() => {
      this.str = '国家'
    }, 1000)
  }
}
</script>

<p>  在使用的时候,computed接收mapState函数的返回值,你可以用三种方式去接收store中的值,具体可以看注释.</p>
<p>  事实上第二种和第三种是同一种,只是前者用了ES6的偷懒语法,箭头函数,在偷懒的时候要注意一个问题,this指针的指向问题,我已经在很多篇文章中提到不要在vue中为了偷懒使用箭头函数,会导致很多很难察觉的错误,如果你在用到state的同时还需要借助当前vue实例的this,请务必使用常规写法.</p>
<p>  当然computed不会因为引入mapState辅助函数而失去原有的功能—用于扩展当前vue的data,只是写法会有一些奇怪,如果你已经写了一大堆的computed计算属性,做了一半发现你要引入vuex,还想使用mapState辅助函数的方便,你可以需要做下列事情.</p>
<p>//之前的computed<br>computed:{<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……..<br>}<br>//引入mapState辅助函数之后</p>
<p>computed:mapState({<br>    //先复制粘贴<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……<br>    //再维护vuex<br>    count:’count’<br>    …….<br>})<br>   从上述写法可以看出来,这不符合代码的某些说不明道不清的特性,我们希望我们可以不用去做一些复制粘贴的无用操作,而是直接使用mapState,希望它能自动融入到当前生产环境中,ok,ES6+(或者说ES7)提供了这个方便.</p>
<p>3 …mapState<br>  事实上…mapState并不是mapState的扩展,而是…对象展开符的扩展.当然如果你把他用在这里会发现他能使得代码看起来变得,更加符合常规逻辑了,为什么这么说,你等下就会知道了.</p>
<p>  首先,来回顾一下…对象展开符在数组中的表现,这在ES6语法学习分类里有相关说明,如果有兴趣可以关注我的ES6分类中的文章.</p>
<p>let arr = [1,2,3]<br>console.log(…arr) //1,2,3<br> 然后来看一个例子.</p>
<p>let MapState = mapState({<br>      count: ‘count’,<br>      sex: (state) =&gt; state.sex<br>    })<br>    let json = {<br>      ‘a’: ‘我是json自带的’,<br>      …MapState<br>    }<br>    console.log(json)<br>这里的json可以成功将mapState return的json格式,和json自带的a属性成功融合成一个新的对象.你可以将这个称为对象混合</p>
<p>这样,你就可以自由的使用mapState了.</p>
<p>//之前的computed<br>computed:{<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……..<br>}<br>//引入mapState辅助函数之后</p>
<p>computed:{<br>    //原来的继续保留<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……<br>    //再维护vuex<br>    …mapState({  //这里的…不是省略号了,是对象扩展符<br>        count:’count’<br>    })<br>}</p>
<h1 id="vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现"><a href="#vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现" class="headerlink" title="vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现"></a>vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现</h1><p>Vuex 作为一个专为 Vue.js 应用程序开发的<strong>状态管理模式，</strong>在中大型项目中备受青睐，它有着天然的优势：<em>响应式的共享状态</em> 及<em>可跟踪的状态变化。</em>然而它也存在着明显的缺陷：<strong>页面刷新数据丢失</strong>。这非常容易理解，页面刷新重新加载需要重新实例化store：<em>const</em> store = new Vuex.Store({state: {}})，状态当然会变为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%88%9D%E5%A7%8B%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:143181165%7D">初始值</a>。那么如何在刷新页面后保存之前的状态呢？</p>
<p>一、使用vuex-persistedstate，只需简单的配置即可解决</p>
<p>1、安装vuex-persistedstate：npm install vuex-persistedstate -s    引入 import createPersistedState from ‘vuex-persistedstate’</p>
<p>2、实例化store时配置vuex-persistedstate插件：</p>
<p><img src="https://pic2.zhimg.com/80/v2-02ed572dfa687bee50dec2188cc46379_720w.jpg" alt="img"></p>
<p>3、选项配置：</p>
<p>vuex-persistedstate默认会将state缓存在localstorage里：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0306245559d65005dd26a6fcd4dd10b2_720w.jpg" alt="img"></p>
<p>这里只给出常用的两个配置选项，<a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/vuex-persistedstate">查看全部配置</a></p>
<p>（1）指定缓存的位置：storage: window.sessionStorage</p>
<p>（2）reducer: 指定需要缓存的状态</p>
<p><img src="https://pic2.zhimg.com/80/v2-3b17a543cffd5c0d49004e1fd06f6079_720w.jpg" alt="img"></p>
<p>如上图：将<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=state.user&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:143181165%7D">state.user</a>缓存到本地的sessionStorage。而state.tag并没有缓存，此时，刷新页面后state.user的状态得以保存，而state.tag的数据丢失。</p>
<p><img src="https://pic1.zhimg.com/80/v2-719583a160d7bbb13dfe8b2689a947d8_720w.jpg" alt="img"></p>
<p>二、自定义插件简单模拟vuex-persistedstate</p>
<p>现在我们自定义插件来缓存state.tag。</p>
<p>（1）缓存state.tag</p>
<p>Vuex 的 store 接受<code>plugins</code>选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ff1cbc3f6d5ce63a84e3ad93478d9660_720w.jpg" alt="img"></p>
<p>（2）初始化Store实例时获取缓存的state.tag</p>
<p><img src="https://pic1.zhimg.com/80/v2-d0e77e7ce038e7d12ac1e52d2ee86618_720w.jpg" alt="img"></p>
<p>（3）使用插件</p>
<p><img src="https://pic2.zhimg.com/80/v2-383a6f70713058cc605ca97e7b580dad_720w.jpg" alt="img"></p>
<p>（4）查看效果</p>
<p>刷新页面后state.user和state.tag的状态都得到保存</p>
<p><img src="https://pic1.zhimg.com/80/v2-5b9d66d6d82d22f69c09db4c25094ebc_720w.jpg" alt="img"></p>
<p>（5）带参数的插件</p>
<p>这类似于带参装饰器，即在上述插件函数作为一个带参函数的返回值</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d9b3735633fdca743465203844c588d_720w.jpg" alt="img"></p>
<p>使用插件时，调用插件函数并传递参数</p>
<p><img src="https://pic2.zhimg.com/80/v2-ddb08bc74ef5f5fa16085e3348f6bfb9_720w.jpg" alt="img"></p>
<p>打开控制台，输出‘带参插件的参数’</p>
<p><img src="https://pic3.zhimg.com/80/v2-ef685a2062218e8c78e3a5b7967bc656_720w.jpg" alt="img"></p>
<p>发布于 2020-05-24 14:53</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vuex入门（4）—— 用Mutation管理状态" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%20%E7%94%A8Mutation%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81/" class="article-date">
  	<time datetime="2022-08-29T07:45:14.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%20%E7%94%A8Mutation%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81/">
        Vue-vuex身上的mutation,mapMutations 辅助函数
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p>
<p>  关于vuex为什么这样做,先不要管,但请相信他这么做必然有很多的好处.在vue中,我们要修改data中的值,一般会怎么做.</p>
<p>this.count = 2 //count from 1 to 2,触发视图更新<br>   很简单,直接赋值,这也符合我们写代码的”一般规律”,很舒服.但如果我们要修改vuex store中的状态值,我们就不能简单的通过赋值的方式来做了,如果你这样做,控制台便会报错.</p>
<p>this.$store.state.count = 2 //控制台打印错误<br>   当然vuex的state是可以更改的,不然就太睿智了,vuex提供了mutation来追踪你对state的值的操作,这肯定有什么好处在里面,暂时先把为什么放一边,先了解一下mutation的用法.</p>
<p>   Vuex 中的 mutation 非常类似于vue中的$emit事件,</p>
<p>   每个 mutation 都有一个字符串的事件类型 (type) ,相当于当前事件的唯一标识,以便于你用commit触发它.</p>
<p>   每个mutation都有一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数.同时他也支持额外参数的传入,额外参数的术语叫’载荷’.</p>
<p>  直接看代码和注释吧,不想过多解释这个</p>
<p>//state.js<br>let state = {<br>  count: 1,<br>  name: ‘dkr’,<br>}<br>export default state</p>
<p>//mutation.js<br>// 第一个参数默认接收state对象<br>const increment = (state) =&gt; {<br>  state.count++<br>}<br>const decrement = (state) =&gt; {<br>  state.count–<br>}<br>//第二个参数接收’载荷’<br>const add = (state, n) =&gt; {<br>  state.count += n<br>}<br>const fn = (state, json) =&gt; {<br>  state.name = json.first + json.second + state.name<br>}<br>export {increment, decrement, add, fn}</p>
<template>
  <div>
    <div>
      <button @click="decrement">-</button>
      <span></span>
      <button @click="increment">+</button>
    </div>
    <div style="margin-top:20px;">
      <button @click="add(1)">+1</button>
      <button @click="add(2)">+2</button>
    </div>
    <button style="margin-top:20px" @click = "changeName('my ','name is ')"></button>
  </div>
</template>
 
<script>
export default {
  computed: {
    count () {
      return this.$store.state.count
    },
    name () {
      return this.$store.state.name
    }
  },
  methods: {
    decrement () {
      this.$store.commit('decrement')
    },
    increment () {
      this.$store.commit('increment')
    },
    add (n) {
      // 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）
      this.$store.commit('add', n)
    },
    changeName (first, second) {
      // this.$store.commit('fn', {
      //   'first': first,
      //   'second': second
      // })
      // 上面的写法等同于下面，对象风格的提交方式，个人觉得上面的写法更清晰
      this.$store.commit({
        'type': 'fn',
        'first': first,
        'second': second
      })
    }
  }
}
</script>
<p>结果如下:</p>
<p>关于mutation的辅助函数,我这里提供一下上述代码的辅助函数写法,具体原理请看本系列第二篇文章,不想过多赘述.</p>
<template>
  <div>
    <div>
      <button @click="decrement">-</button>
      <span></span>
      <button @click="increment">+</button>
    </div>
    <div style="margin-top:20px;">
      <button @click="add(1)">+1</button>
      <button @click="add(2)">+2</button>
    </div>
    <button style="margin-top:20px" @click = "changeName({'first':'my ',second:'name is '})"></button>
  </div>
</template>
 
<script>
import { mapMutations } from 'vuex'
export default {
  computed: {
    count () {
      return this.$store.state.count
    },
    name () {
      return this.$store.state.name
    }
  },
  // 辅助函数写法
  methods: {
    ...mapMutations({
      decrement: 'decrement',
      increment: 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`
      add: 'add',
      changeName: 'fn' // 将 `this.changeName(json)` 映射为 `this.$store.commit('fn', json)`
    })
  }
}
</script>
<style>
 
</style>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vuex入门（3）—— getters,mapGetters,...mapGetters详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%20getters,mapGetters,...mapGetters%E8%AF%A6%E8%A7%A3/" class="article-date">
  	<time datetime="2022-08-29T07:44:10.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%20getters,mapGetters,...mapGetters%E8%AF%A6%E8%A7%A3/">
        Vue-vuex身上的getters,mapGetters 辅助函数
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  Vuex提供了state这样的状态统一管理树,你可以在vue中用computed计算属性接收这些公共状态,以便使用,当然你也可以在接收原值的基础上对这个值做出一些改造,如</p>
<p>computed:{<br>  sex:function(){<br>      return this.$store.state.sex + ‘加个字符串,算是改造’<br>  }<br>}<br>  但是如果你的其他组件也要使用这种改造方式去改造这个值,那你可能不得不去复制粘贴这个函数到别的组件中,当然,为了解决这个问题,vuex本身就提供了类似于计算属性的方式,getters可以让你从store的state中派生出一些新的状态,当然如果不是多个组件要用到这个状态,或者说每个子组件用到的派生属性不一样,那么,你完全可以不用getters.(这里多说一句吧,vuex的出现是为了解决组件间的通信问题,如果你的操作或者数据不涉及到公共操作,只是单一组件操作,请务必不要把这些状态值或者function存储到vuex中,因为vuex会把自身挂载到所有组件上,不管当前组件是否用到里面的东西,因此这事实上肯定增加了性能的损耗,注意是肯定,因为你很难保证每个子组件都用到同一个状态,除非是路由这样的特殊状态,当然路由的事情也无需归vuex管理,在后面vue-router系列中会讲到.)</p>
<p>1.getters<br>  Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。说白了就是vue的computed,如果你了解computed的话,那你可以像使用computed一样去使用getters,当然还是有点区别的.</p>
<p>//state.js<br>let state = {<br>  from: ‘china’,<br>  arr: [2, 3, 1, 4, 6]<br>}<br>export default state<br>// getters.js<br>// 第一个参数是state<br>let address = (state) =&gt; {<br>  return ‘国籍:’ + state.from<br>}<br>// 第二个参数可以访问getters<br>let addressMore = (state, getters) =&gt; {<br>  return ‘其他描述’ + getters.address<br>}<br>// return 一个function,这个function可以传参,当然这个function最后会返回一个具体的数值<br>//本例中这个方法用于查询state中的arr数组是否存在某个值<br>let findArr = (state) =&gt; (number) =&gt; {<br>  let ifExit = state.arr.find((n) =&gt; n === number) // arr.find是ES6语法中数组的扩展<br>  if (typeof (ifExit) === ‘undefined’) {<br>    return false<br>  } else {<br>    return true<br>  }<br>}<br>export {address, addressMore, findArr}<br>  关于getters如何使用,可以看一下上面代码的注释,这里我重点介绍一下getters和computed的不同,就是上面的第三种用法,我之前在vue进阶系列中探讨过computed，filters两种数据处理工具的局限性,有兴趣的可以去看这篇文章,computed的一个缺点就是不能传参,假设你要去判断一个数组里是否存在某个值,那你没法将某个值传到computed中去,这其实是一个很蛋疼的事情,当然你可以通过某些特殊手段,这里我不展开,有兴趣的可以留言.而getters则没有这个烦恼,有些对ES6语法使用较为吃力的同学可以看下面的简易版本,来看看findArr究竟做了什么.</p>
<p>let findArr = function(state){<br>  // 返回一个匿名函数<br>  return function(number){<br>    // 如果有相同的则返回n，如果找不到则返回undefined<br>    let ifExit = state.arr.find(function(n){<br>      return n===number<br>    })<br>    if (typeof (ifExit) === ‘undefined’) {<br>      return false<br>    } else {<br>      return true<br>    }<br>  }<br>}<br>  最后我们在子组件中展示一下效果</p>
<template>
  <div>
    <div></div>
    <div></div>
  </div>
</template>

<script>
// import { mapGetters } from 'vuex'
export default {
  computed: {
    from: function () {
      return this.$store.getters.address
    },
    from2: function () {
      return this.$store.getters.addressMore
    }
  },
  created () {
    console.log(this.$store.getters.findArr(2))
    console.log(this.$store.getters.findArr(7))
  }
}
</script>
<p>结果如下所示.</p>
<p> 2.mapGetters 辅助函数<br>  关于辅助函数的使用和对象展开符的使用我在本系列的第二章中已经说的很明白了,有兴趣的可以看一下这个链接</p>
<template>
  <div>
    <div></div>
    <div></div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex'
export default {
  computed:  mapGetters({
      'from': 'address',
      'from2': 'addressMore',
      'find': 'findArr'
  }),
  created () {
    console.log(this.find(1)) // 由于getters已经通过computed挂载到当前组件实例,所以你不需要再通过this.$store.getters的方法去访问
    console.log(this.$store.getters.findArr(2))
    console.log(this.$store.getters.findArr(7))
  }
}
</script>
<p> 3….mapGetters<br><template><br>  <div><br>    <div></div><br>    <div></div><br>  </div><br></template></p>
<script>
import { mapGetters } from 'vuex'
export default {
  computed:  {
    ...mapGetters({
      'from': 'address',
      'from2': 'addressMore',
      'find': 'findArr'
    })
  },
  created () {
    console.log(this.find(1)) // 由于getters已经通过computed挂载到当前实例,所以你不需要再通过this.$store.getters的方法去访问
    console.log(this.$store.getters.findArr(2))
    console.log(this.$store.getters.findArr(7))
  }
}
</script>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vuex入门（2）—— state,mapState,...mapState对象展开符详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%20state,mapState,...mapState%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E7%AC%A6%E8%AF%A6%E8%A7%A3/" class="article-date">
  	<time datetime="2022-08-29T07:38:50.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%20state,mapState,...mapState%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E7%AC%A6%E8%AF%A6%E8%A7%A3/">
        Vue-vuex身上的state,mapState
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.state<br>  state是什么?</p>
<p>  定义:state(vuex) ≈ data (vue)</p>
<p>  vuex的state和vue的data有很多相似之处,都是用于存储一些数据,或者说状态值.这些值都将被挂载 数据和dom的双向绑定事件,也就是当你改变值的时候可以触发dom的更新.</p>
<p>  虽然state和data有很多相似之处,但state在使用的时候一般被挂载到子组件的computed计算属性上,这样有利于state的值发生改变的时候及时响应给子组件.如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题,那你可以针是一个杠精</p>
<p>  综上所述,请用computed去接收state,如下</p>
<p>//state.js<br>let state = {<br>  count: 1,<br>  name: ‘dkr’,<br>  sex: ‘男’,<br>  from: ‘china’<br>}<br>export default state</p>
<template>
  <div id="example">
    <button @click="decrement">-</button>
    
    
    <button @click="increment">+</button>
  </div>
</template>
<script>
export default {
  data () {
    return {
      dataCount: this.$store.state.count //用data接收
    }
  },
  computed:{
    count(){
      return this.$store.state.count //用computed接收
    }
  }
  methods: {
    increment () {
      this.$store.commit('increment')
    },
    decrement () {
      this.$store.commit('decrement')
    }
  }
}
</script>
结果如下,用data接收的值不能及时响应更新,用computed就可以.



 

<p>2.mapState 辅助函数<br>  mapState是什么?</p>
<p>  表面意思:mapState是state的辅助函数.这么说可能很难理解</p>
<p>  抽象形容:mapState是state的语法糖,这么说可能你还想骂我,因为你根本不了解什么叫做语法糖,事实上我说的语法糖有自己的定义,什么是语法糖?我对语法糖的理解就是,用之前觉得,我明明已经对一种操作很熟练了,并且这种操作也不存在什么问题,为什么要用所谓的”更好的操作”,用了一段时间后,真香!</p>
<p>  实际作用:当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键</p>
<p>  在使用mapState之前,要导入这个辅助函数.</p>
<p>import { mapState } from ‘vuex’<br>  然后就是使用方式了</p>
<template>
  <div id="example">
    <button @click="decrement">-</button>
    
    
    <button @click="increment">+</button>
    <div></div>
    <div></div>
    <div></div>
  </div>
</template>
<script>
import { mapState } from 'vuex'
export default {
  data () {
    return {
      str: '国籍',
      dataCount: this.$store.state.count
    }
  },
  computed: mapState({
    count: 'count', // 第一种写法
    sex: (state) => state.sex, // 第二种写法
    from: function (state) { // 用普通函数this指向vue实例,要注意
      return this.str + ':' + state.from
    },
    // 注意下面的写法看起来和上面相同,事实上箭头函数的this指针并没有指向vue实例,因此不要滥用箭头函数
    // from: (state) => this.str + ':' + state.from
    myCmpted: function () {
      // 这里不需要state,测试一下computed的原有用法
      return '测试' + this.str
    }
  }),
  methods: {
    increment () {
      this.$store.commit('increment')
    },
    decrement () {
      this.$store.commit('decrement')
    }
  },
  created () {
    // 写个定时器，发现computed依旧保持了只要内部有相关属性发生改变不管是当前实例data中的改变，还是vuex中的值改变都会触发dom和值更新
    setTimeout(() => {
      this.str = '国家'
    }, 1000)
  }
}
</script>

<p>  在使用的时候,computed接收mapState函数的返回值,你可以用三种方式去接收store中的值,具体可以看注释.</p>
<p>  事实上第二种和第三种是同一种,只是前者用了ES6的偷懒语法,箭头函数,在偷懒的时候要注意一个问题,this指针的指向问题,我已经在很多篇文章中提到不要在vue中为了偷懒使用箭头函数,会导致很多很难察觉的错误,如果你在用到state的同时还需要借助当前vue实例的this,请务必使用常规写法.</p>
<p>  当然computed不会因为引入mapState辅助函数而失去原有的功能—用于扩展当前vue的data,只是写法会有一些奇怪,如果你已经写了一大堆的computed计算属性,做了一半发现你要引入vuex,还想使用mapState辅助函数的方便,你可以需要做下列事情.</p>
<pre><code>//之前的computed
computed:&#123;
    fn1()&#123; return ...&#125;,
    fn2()&#123; return ...&#125;,
    fn3()&#123; return ...&#125;
    ........
&#125;
//引入mapState辅助函数之后

computed:mapState(&#123;
    //先复制粘贴
    fn1()&#123; return ...&#125;,
    fn2()&#123; return ...&#125;,
    fn3()&#123; return ...&#125;
    ......
    //再维护vuex
    count:&#39;count&#39;
    .......
&#125;)
</code></pre>
<p>   从上述写法可以看出来,这不符合代码的某些说不明道不清的特性,我们希望我们可以不用去做一些复制粘贴的无用操作,而是直接使用mapState,希望它能自动融入到当前生产环境中,ok,ES6+(或者说ES7)提供了这个方便.</p>
<p>3 …mapState<br>  事实上…mapState并不是mapState的扩展,而是…对象展开符的扩展.当然如果你把他用在这里会发现他能使得代码看起来变得,更加符合常规逻辑了,为什么这么说,你等下就会知道了.</p>
<p>  首先,来回顾一下…对象展开符在数组中的表现,这在ES6语法学习分类里有相关说明,如果有兴趣可以关注我的ES6分类中的文章.</p>
<pre><code>let arr = [1,2,3]
console.log(...arr) //1,2,3
 然后来看一个例子.

let MapState = mapState(&#123;
      count: &#39;count&#39;,
      sex: (state) =&gt; state.sex
    &#125;)
    let json = &#123;
      &#39;a&#39;: &#39;我是json自带的&#39;,
      ...MapState
    &#125;
    console.log(json)
</code></pre>
<p>这里的json可以成功将mapState return的json格式,和json自带的a属性成功融合成一个新的对象.你可以将这个称为对象混合</p>
<p>这样,你就可以自由的使用mapState了.</p>
<pre><code>//之前的computed
computed:&#123;
    fn1()&#123; return ...&#125;,
    fn2()&#123; return ...&#125;,
    fn3()&#123; return ...&#125;
    ........
&#125;
//引入mapState辅助函数之后

computed:&#123;
    //原来的继续保留
    fn1()&#123; return ...&#125;,
    fn2()&#123; return ...&#125;,
    fn3()&#123; return ...&#125;
    ......
    //再维护vuex
    ...mapState(&#123;  //这里的...不是省略号了,是对象扩展符
        count:&#39;count&#39;
    &#125;)
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-vueRouter(2)身上的属性和方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/vueRouter(2)%E8%BA%AB%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/" class="article-date">
  	<time datetime="2022-08-29T07:37:28.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/vueRouter(2)%E8%BA%AB%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/">
        Vue-vue-router身上的属性跟方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a><strong>vue-router</strong></h2><p>学习vue-router首先要认识的两个属性 $router 和 $route。</p>
<p>$router指的是router实例，$route则是当前激活的路由信息对象，是只读属性，不可更改，但是可以watch（监听）。</p>
<p>在浏览器中分别打印出$router 和 $route </p>
<p>$router：</p>
<p><img src="https://images2018.cnblogs.com/blog/1000555/201805/1000555-20180515115000885-1630475356.png" alt="img"></p>
<p>属性：</p>
<p>$router.app ：配置了router的Vue根实例</p>
<p>$router.mode：路由模式，这里是hash</p>
<p>$router.currentRoute：当前路由的路由信息对象，包含了当前匹配路由的信息</p>
<p>方法：</p>
<p>router.addRoutes(routes)：动态添加路由规则，参数为符合routes选项要求的数组。</p>
<p>router.beforeEach(to,from,next) ：全局前置守卫</p>
<pre><code>router.beforeEach((to,from,next)=&gt;&#123;
     //... 
&#125;)
</code></pre>
<p>　　当路由改变时，全局前置守卫执行，接受三个参数，to，from，next，分别代表即将要进入的目标路由，当前要离开的路由，和回调函数next()。next的执行效果依赖于参数。next()，执行下一个钩子，若钩子执行完毕，导航状态是confirm；next(false)中断当前导航，回到from路由对应的地址；next({path:’/‘}),跳转到自定义路由地址。next(error)，如果传入一个error实例，则导航终止并将错误传递给router.onError()注册过的回调。</p>
<p>router.beforeResolve()：全局解析守卫 , 在导航被确认之前，且在锁头组件内守卫和异步路由组件被解析之后调用，参数和全局前置守卫相同；</p>
<p>router.afterEach()：全局后置守卫</p>
<pre><code>router.afterEach((to,from)=&gt;&#123;
    //....没有next()函数参数，也不会改变导航本身
&#125;)
</code></pre>
<p>router.go(n)：接受一个整数作为参数，类似window.history.go(n)，在浏览器历史记录中前进或后退几步</p>
<p>router.push( location )：跳转导航的方法，这种方法会向history栈添加一个新的记录</p>
<p>router.replace( location )：和router.push()类似，但是它会替换掉当前的history记录，不会添加新的记录</p>
<p>router.back()：相当于router.go(-1)</p>
<p>router.forward()：相当于router.go(1)</p>
<p>router.resolve(location)：解析目标路由，接受一个地址参数，返回location,route,href等属性信息，还可以接受当前默认路由current和当前路由上附加路径append　两个参数</p>
<p>router.onReady(callback,[errorCallback]){}：把一个回调排队，在路由完成初始导航时调用。</p>
<p>router.onError(callback)：注册一个回调，该回调会在路由导航过程中出错的时候被调用，但是对被调用的错误情形有要求：</p>
<p>　　1、错误在一个路由守卫函数中被同步抛出</p>
<p>　　2、错误在一个路由守卫函数中通过调用next(error)的方式异步捕获并处理</p>
<p>　　3、渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误</p>
<p>$route：</p>
<p><img src="https://images2018.cnblogs.com/blog/1000555/201805/1000555-20180515143116376-1104044711.png" alt="img"></p>
<p>route是路由信息对象，包含了当前路由的各种信息。路由对象是不可更改的，每次路由导航成功后都会产生一个新的对象。router.match（location）的返回值也是一个路由信息对象，导航守卫的参数to，from也是路由信息对象。</p>
<p>属性：</p>
<p>$route.fullPath ：完成解析后的url，包含查询参数和hash的完整路径</p>
<p>$route.path：路径，字符串类型，解析为绝对路径</p>
<p>$route.hash： 当前路由的hash值（带#号的），如果没有hash值则为空字符串</p>
<p>$route.name：当前路由的名称，如果有的话（用于命名路由）</p>
<p>$route.params：一个键值对对象，路由参数</p>
<p>$route.query：一个键值对对象，表示url查询参数</p>
<p>$route.matched：一个包含了当前路由的所有嵌套路径片段的路由记录（routes配置数组中的对象副本）</p>
<p>$route.redirectedFrom：重定向来源的路由的名字，如果存在重定向的话。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-vue项目配置文件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="article-date">
  	<time datetime="2022-08-29T07:36:42.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">
        Vue-Vue项目配置文件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.当我们使用右键格式化的时候,就会自动帮我们补全符号,但是,有些符号在eslint中就会报语法错误,那我们需要怎么办呢?可以通过.prettierrc来进行文件配置</p>
<p>在文件的根目录建一个.prettierrc文件,在文件里写上如下代码:<br>{<br>    “semi”: false,    // 使用分号, 默认true<br>    “singleQuote”: true,   // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)<br>    “bracketSpacing”: true   // 对象中的空格 默认true<br>}<br>1<br>2<br>3<br>4<br>5</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-vue项目配置服务器的环境变量" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" class="article-date">
  	<time datetime="2022-08-29T07:36:16.000Z" itemprop="datePublished">2022-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">
        Vue-Vue项目配置服务器的环境变量
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>vue项目配置服务器的环境变量.md</p>
<p>1.配置vue项目开发环境跟生产环境的全局环境变量<br> 在vue根目录新建.env.development和.env.production两个文件，然后配置变量<br> .env.development文件放：<br> VUE_APP_ENV=’development’<br> VUE_APP_URL=’<a target="_blank" rel="noopener" href="http://www.baidu.com/api&#39;">www.baidu.com/api&#39;</a><br> .env.production文件放：<br> VUE_APP_ENV=’production’<br> VUE_APP_URL=’<a target="_blank" rel="noopener" href="http://www.baidu.com/api&#39;">www.baidu.com/api&#39;</a></p>
<p> 如何获取配置的全局变量：process.env.VUE_APP_ENV   / process.env.VUE_APP_URL</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>