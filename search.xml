<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3-解构赋值失去响应式</title>
      <link href="/2022/11/08/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E4%B8%A2%E5%A4%B1%E5%9C%BA%E6%99%AF/"/>
      <url>/2022/11/08/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E4%B8%A2%E5%A4%B1%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>vue3</code>发布以来经历两年风头正盛，现在大有和react 平分天下的势头，我们知道他是基于proxy 实现响应式的能力， 解决了<code>vue2</code>所遗留下来的一些问题，同时也正由于proxy的特性，也提高了运行时的性能</p><p>凡事有利有弊， <code>proxy</code>虽然无敌，但是他也有本身的局限，从而产生一些我认为的弊端（其实就是不符合js语言的自然书写方式，有的人觉得就是个特殊写法，他不属于弊端）</p><ul><li>1、 原始值的响应式系统的实现 导致必须将他包装为一个对象， 通过 <code>.value</code> 的方式访问</li><li>2、 ES6 解构，不能随意使用。会破坏他的响应式特性</li></ul><p>好奇心驱使，研究琢磨了一下，为什么他会造成这两个弊端</p><h1 id="原始值的响应式系统的实现"><a href="#原始值的响应式系统的实现" class="headerlink" title="原始值的响应式系统的实现"></a>原始值的响应式系统的实现</h1><p>在理解原始值的响应式系统的实现，我们先来温习一下proxy 的能力！</p><pre><code class="js">const obj = &#123;  name: &#39;win&#39;&#125;const handler = &#123;  get: function(target, key)&#123;    console.log(&#39;get--&#39;, key)    return Reflect.get(...arguments)    &#125;,  set: function(target, key, value)&#123;    console.log(&#39;set--&#39;, key, &#39;=&#39;, value)    return Reflect.set(...arguments)  &#125;&#125;const data = new Proxy(obj, handler)data.name = &#39;ten&#39;console.log(data.name,&#39;data.name22&#39;)复制代码</code></pre><p>上述代码中，我们发现，proxy 的使用本身就是对于 对象的拦截， 通过<code>new Proxy</code>  的返回值，拦截了obj 对象</p><p>如此一来，当你 访问对象中的值的时候，他会触发 <code>get</code> 方法， 当你修改对象中的值的时候 他会触发 <code>set</code>方法</p><p>但是到了原始值的时候，他没有对象啊，咋办呢，<code>new proxy</code> 排不上用场了。</p><p>无奈之下，我们只能包装一下了，所以就有了使用<code>.value</code>访问了</p><p>我们来看看具体实现</p><pre><code class="js">import &#123; reactive &#125; from &quot;./reactive&quot;;import &#123; trackEffects, triggerEffects &#125; from &#39;./effect&#39;export const isObject = (value) =&gt; &#123;    return typeof value === &#39;object&#39; &amp;&amp; value !== null&#125;// 将对象转化为响应式的function toReactive(value) &#123;    return isObject(value) ? reactive(value) : value&#125;class RefImpl &#123;    public _value;    public dep = new Set; // 依赖收集    public __v_isRef = true; // 是ref的标识    // rawValue 传递进来的值    constructor(public rawValue, public _shallow) &#123;        // 1、判断如果是对象 使用reactive将对象转为响应式的        // 浅ref不需要再次代理        this._value = _shallow ? rawValue : toReactive(rawValue);    &#125;    get value() &#123;        // 取值的时候依赖收集        trackEffects(this.dep)        return this._value;    &#125;    set value(newVal) &#123;        if (newVal !== this.rawValue) &#123;            // 2、set的值不等于初始值 判断新值是否是对象 进行赋值            this._value = this._shallow ? newVal : toReactive(newVal);            // 赋值完 将初始值变为本次的            this.rawValue = newVal            triggerEffects(this.dep)        &#125;    &#125;&#125;复制代码</code></pre><p>上述代码，就是对于原始值，的包装，他被包装为一个对象，通过<code>get value</code> 和<code>set value</code> 方法来进行原始值的访问，从而导致必须有<code>.value</code> 的操作 ，这其实也是个无奈的选择</p><p><code>相当于两瓶毒药，你得选一瓶</code> 鱼与熊掌不可兼得</p><h1 id="为什么ES6-解构，不能随意使用会破坏他的响应式特性"><a href="#为什么ES6-解构，不能随意使用会破坏他的响应式特性" class="headerlink" title="为什么ES6 解构，不能随意使用会破坏他的响应式特性"></a>为什么ES6 解构，不能随意使用会破坏他的响应式特性</h1><p>第一个问题终于整明白了，那么我们来看看最重要的第二个问题，<code>为什么结构赋值，会破坏响应式特性</code></p><h2 id="proxy背景"><a href="#proxy背景" class="headerlink" title="proxy背景"></a>proxy背景</h2><p>在开始之前，我们先来讨论一下为什么要更改<code>响应式方案</code></p><p>vue2 基于<strong>Object.defineProperty</strong> ，但是他有很多缺陷，比如 <strong>无法监听数组基于下标的修改，不支持 Map、Set、WeakMap 和 WeakSet等缺陷</strong> ，</p><p>其实这些也也不耽误我们开发， vue2到现在还是主流，</p><p>我的理解就是<code>与时俱进</code>， <code>新一代的版本，一定要紧跟语言的特性，一定要符合新时代的书写风格</code>，虽然<code>proxy</code>相对于Object.defineProperty 有很多进步， 但是也不是一点缺点都没有，你比如说 <code>不兼容IE</code></p><p>天底下的事情，哪有完美的呢？</p><p>尤大的魄力就在于，舍弃一点现在，博一个未来！</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在理解了背景之后，我们再来假模假式的温习一下<code>proxy</code> 原理，虽然这个都被讲烂了。</p><p>但是，写水文，讲究什么：俩字-连贯</p><pre><code class="js">        const obj = &#123;            count: 1        &#125;;        const proxy = new Proxy(obj, &#123;            get(target, key, receiver) &#123;                console.log(&quot;这里是get&quot;);                return Reflect.get(target, key, receiver);            &#125;,            set(target, key, value, receiver) &#123;                console.log(&quot;这里是set&quot;);                return Reflect.set(target, key, value, receiver);            &#125;        &#125;);                console.log(proxy)        console.log(proxy.count)复制代码</code></pre><p>以上代码就是Proxy的具体使用方式，通过和Reflect 的配合，  就能实现对于对象的拦截</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727e02e8b32849b0802f94cfc71ff660~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>如此依赖，就能实现响应式了，大家可以发现，这个obj的整个对象就被拦截了，但是你发现对象在嵌套深一层</p><p>比如：</p><pre><code class="js">    const obj = &#123;            count: 1,            b: &#123;                c: 2            &#125;        &#125;;                     console.log(proxy.b)     console.log(proxy.b.c)复制代码</code></pre><p>他就无法拦截了，我们必须要来个包装</p><pre><code class="js">    const obj = &#123;            a: &#123;                count: 1            &#125;        &#125;;                function reactive(obj) &#123;            return new Proxy(obj, &#123;                get(target, key, receiver) &#123;                    console.log(&quot;这里是get&quot;);                    // 判断如果是个对象在包装一次，实现深层嵌套的响应式                    if (typeof target[key] === &quot;object&quot;) &#123;                        return reactive(target[key]);                    &#125;;                    return Reflect.get(target, key, receiver);                &#125;,                set(target, key, value, receiver) &#123;                    console.log(&quot;这里是set&quot;);                    return Reflect.set(target, key, value, receiver);                &#125;            &#125;);        &#125;;        const proxy = reactive(obj);复制代码</code></pre><p>好了，原理搞完了，我们来正式研究一下</p><p>现在列举一下我知道的响应式失去的几个情况：</p><ul><li>1、解构 <code>props</code> 对象，因为它会失去响应式</li><li>2、 直接赋值<code>reactive</code>响应式对象</li><li>3、 <code>vuex</code>中组合API赋值</li></ul><h2 id="解构-props-对象，因为它会失去响应式"><a href="#解构-props-对象，因为它会失去响应式" class="headerlink" title="解构 props 对象，因为它会失去响应式"></a>解构 <code>props</code> 对象，因为它会失去响应式</h2><pre><code class="js">       const obj = &#123;            a: &#123;                count: 1            &#125;,            b: 1        &#125;;                        //reactive 是上文中的reactive           const proxy = reactive(obj);        const &#123;            a,            b        &#125; = proxy;        console.log(a)        console.log(b)        console.log(a.count)        复制代码</code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e9fe55addfa411983362cd620e21069~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>上述代码中，我们发现，  解构赋值，<code>b 不会触发响应式</code>，<code>a如果你访问的时候</code>，会触发响应式</p><p>这是为什么呢？</p><p>别急我们一个个解释？</p><p>先来讨论为什么解构赋值，会丢失响应式呢？</p><p>我们知道解构赋值，区分原始类型的赋值，和引用类型的赋值，</p><pre><code>原始类型的赋值相当于按值传递`， `引用类型的值就相当于按引用传递</code></pre><p>就相当于</p><pre><code class="js">   // 假设a是个响应式对象  const a=&#123; b:1&#125;  // c 此时就是一个值跟当前的a 已经不沾边了  const c=a.b// 你直接访问c就相当于直接访问这个值 也就绕过了 a 对象的get ，也就像原文中说的失去响应式复制代码</code></pre><p>那为啥<code>a</code> 具备响应式呢?</p><p>因为<code>a</code> 是引用类型，我们还记得上述代码中的一个判断吗。如果他是个<code>object</code> 那么就重新包装为响应式</p><p>正式由于当前特性，导致，如果是引用类型， 你再去访问其中的内容的时候并不会失去响应式</p><pre><code class="js">  // 假设a是个响应式对象 const a=&#123; b:&#123;c:3&#125;&#125; // 当你访问a.b的时候就已经重新初始化响应式了，此时的c就已经是个代理的对象 const c=a.b// 你直接访问c就相当于访问一个响应式对象，所以并不会失去响应式复制代码</code></pre><p>以上就大致解释了为什么解构赋值，可能会失去响应式，我猜的文档中懒得解释其中缘由，索性就定了个规矩，您啊！</p><p>就别用了，省的以为是<code>vue</code>的bug，提前改变用户的使用习惯！不惯着</p><h2 id="直接赋值reactive响应式对象"><a href="#直接赋值reactive响应式对象" class="headerlink" title="直接赋值reactive响应式对象"></a>直接赋值<code>reactive</code>响应式对象</h2><p>我们最初使用vue3的时候,指定会写出以下代码</p><pre><code class="js"> const vue = reactive(&#123; a: 1 &#125;) vue = &#123; b: 2 &#125;复制代码</code></pre><p>然后就发出疑问<code>reactive</code>不是响应式的吗？ 为啥我赋值了以后，他的响应式就没了 ，接着破口大骂，垃圾vue</p><p>其实啊，这就是您对于js 原生的概念不清除，其实<code>尤大</code> 已经做了最大的努力，来防止你进行错误操作了</p><p>比如，由于解构赋值的问题， 他直接禁止了reactive的解构赋值</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a22c36f0c6b844e7bd8de2527a8cc360~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>当你用解构赋值操作的时候，他直接禁用了</p><p>那有人又问了， <code>为啥props 不给禁用了呢</code>?</p><p><code>因为你的props 的数据可能不是响应式的啊，不是响应式的，我得能啊</code>，尤大他也不能干涉用户使用新语法啊</p><p>所以还是那句话：<code>框架现在的呈现，其实充满了取舍</code>,有时候真是两瓶毒药，挑一瓶！</p><p>回归正题，我们再来说说 原生js 语法</p><p>首先需要确认的是，原生js  的引用类型的赋值，其实是 按照引用地址赋值！</p><pre><code class="js"> // 当reactive 之后返回一个代理对象的地址被vue 存起来， // 用一个不恰当的比喻来说，就是这个地址具备响应式的能力 const vue = reactive(&#123; a: 1 &#125;)  //  而当你对于vue重新赋值的时候不是将新的对象赋值给那个地址，而是将vue 换了个新地址 // 而此时新地址不具备响应式，可不就失去响应式了吗 vue = &#123; b: 2 &#125;复制代码</code></pre><p>以上就是<code>reactive</code>失去响应式的解释，所以这个也是很多用户骂骂咧咧的原因。<code>不符合他的使用习惯了，这都是被vue2 培养起来的一代</code></p><p>在这里我要替，尤大说句公道话，<code>人家又没收你钱，还因为他，你有口饭吃</code>，</p><p>您自己不能与时俱进，拥抱新事物，那是您没<code>能耐</code>，</p><p>这是典型的<code>端起碗吃肉，放下筷子骂娘</code></p><h2 id="vuex中组合API赋值"><a href="#vuex中组合API赋值" class="headerlink" title="vuex中组合API赋值"></a><code>vuex</code>中组合API赋值</h2><p>在vuex 用赋值也可能会失去响应式</p><pre><code class="js">import &#123; computed &#125; from &#39;vue&#39;import &#123; useStore &#125; from &#39;vuex&#39;export default &#123;  setup () &#123;    const store = useStore()    return &#123;      // 在 computed 函数中访问 state      count: computed(() =&gt; store.state.count),      // 在 computed 函数中访问 getter      double: computed(() =&gt; store.getters.double)    &#125;  &#125;&#125;复制代码</code></pre><p>以上代码中我们发现<code>store.getters.double</code> 必须用<code>computed</code> 包裹起来，其实道理是一样的，也是变量赋值的原因，在这里我们就不再赘述！</p><p>作者：老骥farmer<br>链接：<a href="https://juejin.cn/post/7114596904926740493">https://juejin.cn/post/7114596904926740493</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VX-微信支付</title>
      <link href="/2022/11/01/2022-11-1%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
      <url>/2022/11/01/2022-11-1%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="微信支付地址官方"><a href="#微信支付地址官方" class="headerlink" title="微信支付地址官方"></a>微信支付地址官方</h2><p>地址：</p><blockquote><pre><code class="js">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#58</code></pre></blockquote><p>&lt;——点击进入微信公众号官方文档</p><h3 id="微信支付【-WeChatPay-】"><a href="#微信支付【-WeChatPay-】" class="headerlink" title="微信支付【 WeChatPay 】"></a>微信支付【 WeChatPay 】</h3><h4 id="WeixinJSBridge-invoke、wx-chooseWXPay"><a href="#WeixinJSBridge-invoke、wx-chooseWXPay" class="headerlink" title="WeixinJSBridge.invoke、wx.chooseWXPay"></a>WeixinJSBridge.invoke、wx.chooseWXPay</h4><p>业务需求：<br>现在涉及到微信相关的项目有很多，主要涉及到的功能有【微信自定义分享、微信支付等】。开发微信公众号H5页面时，需要使用微信支付进行金融支付。当微信支付完成【支付成功 点击“完成”】时，需要出发相应的业务逻辑；比如：支付成功时跳转到订单页面；支付失败时跳转到下订单页面；支付取消时保持当前订单页面不变等。<br>前期开发微信H5页面时，大多考虑的就是【支付成功】之后如何处理，因为是刚接触微信支付，大多都是采用刷新页面获取新数据的方式来更新支付状态。这种方式可以解决当时面临的问题，但是从业务逻辑来看，处理的方式不是很合理。<br>支付场景越来越多，对微信支付流程有了进一步的了解和认识，现在回过头来对过去项目中使用【微信支付】的业务场景进行梳理和完善，进一步优化支付流程以及对支付后的不同状态做相应的处理和优化，并结合实际情况做相应的业务逻辑分析。</p><h3 id="支付方式："><a href="#支付方式：" class="headerlink" title="支付方式："></a>支付方式：</h3><h5 id="方式一：微信支付【微信公众号】"><a href="#方式一：微信支付【微信公众号】" class="headerlink" title="方式一：微信支付【微信公众号】"></a>方式一：微信支付【微信公众号】</h5><p>此支付方式需要在HTML页面中引入JS文件，即【 jweixin-1.6.0.js 】；<br>此JS文件链接支持http和https两种形式，引用时需要匹配当前项目的请求-响应协议（即http、https）；<br>该JS文件支持使用AMD/CMD标准模块加载方式加载。</p><pre><code>let WeChatPay = function() &#123;    // 2、引入js后、获取公众号校验信息    let timestamp = &#39;&#39;,        nonceStr = &#39;&#39;,        signature = &#39;&#39;;    let v = &#123;        // 用于换取微信校验信息的参数：要求不可以包含 “#” 号        url: location.split(&#39;#&#39;)[0]    &#125;;    // 3、通过config接口注入权限验证配置（需要同步进行，在获取到校验信息后方可注入config，否则校验失败！）    wx.config(&#123;        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。        appId: &#39;&#39;, // 必填，公众号的唯一标识        timestamp: , // 必填，生成签名的时间戳        nonceStr: &#39;&#39;, // 必填，生成签名的随机串        signature: &#39;&#39;, // 必填，签名        jsApiList: [&quot;checkJsApi&quot;, &quot;chooseWXPay&quot;, &quot;updateAppMessageShareData&quot;, &quot;updateTimelineShareData&quot;] // 必填，需要使用的JS接口列表    &#125;);        axios.post(&#39;/wx/pay/orderPay_XXXX&#39;, data).then(res =&gt; &#123;        // 支付成功状态        if (res.code == 200) &#123;            // 获取支付必备的参数            let &#123;                nonceStr,                package,                signType,                paySign            &#125; = res.data;            // 4、通过ready接口处理成功验证            wx.ready(function() &#123;                /* 微信支付 */                wx.chooseWXPay(&#123;                    timestamp: 0, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符                    nonceStr: nonceStr, // 支付签名随机串，不长于 32 位                    package: package, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）                    signType: signType, // 签名方式，默认为&#39;SHA1&#39;，使用新版支付需传入&#39;MD5&#39;                    paySign: paySign, // 支付签名                    success: function(res) &#123;                        // 前端判断返回方式，微信团队郑重提示：不保证绝对可靠，切记！                        if (res.errMsg == &#39;chooseWXPay:ok&#39;) &#123;                            // 【支付成功】                         &#125; else if (res.errMsg == &#39;chooseWXPay:cancel&#39;) &#123;                            // 【支付取消】：用户取消支付不会进入这个判断，而是进入complate和cancel函数                        &#125; else &#123;                            &#125;                    &#125;,                    complete: function(res) &#123;                        // 接口调用完成时执行的回调函数，无论成功或失败都会执行                        if (res.errMsg == &#39;chooseWXPay:ok&#39;) &#123;                            // 【支付成功】：支付成功提示页面，点击完成按钮之后                            wx.closeWindow(); /* 关闭微信窗口，调用时需要在config中进行校验 */                        &#125; else if (res.errMsg == &#39;chooseWXPay:cancel&#39;) &#123;                            // 【支付取消】                        &#125; else &#123;                            &#125;                        /**                         * iOS和Android支付成功点击“完成”后都会进入success和complete函数，都返回&#39;chooseWXPay:ok&#39;                         * （也有人说Android支付成功不进入success函数，）                         * 原因是【iOS和Android返回数据不同。支付成功后Android返回 &#123;&quot;errMsg&quot;:&quot;getBrandWCPayRequest:ok&quot;&#125;，iOS返回&#123;&quot;err_Info&quot;:&quot;success&quot;,&quot;errMsg&quot;:&quot;chooseWXPay:ok&quot;&#125;，故Android找不到success方法，导致失败】                         * */                    &#125;,                    fail: function(err) &#123;                        // 接口调用失败                    &#125;,                    cancel: function(err) &#123;                        // 用户点击取消时的回调函数：用户取消支付后实际上进入cancel 和 complate函数                    &#125;                &#125;);            &#125;);        &#125;    &#125;).catch(err =&gt; &#123;        console.log(&#39;支付失败：&#39;, err);    &#125;);&#125;</code></pre><p>接口说明：【不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。】</p><p>success：接口调用成功时执行的回调函数。<br>fail：接口调用失败时执行的回调函数。<br>complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。<br>cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。<br>trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。</p><h5 id="方式二：微信支付【-JSAPI-支付】（常用支付方式）"><a href="#方式二：微信支付【-JSAPI-支付】（常用支付方式）" class="headerlink" title="方式二：微信支付【 JSAPI 支付】（常用支付方式）"></a>方式二：微信支付【 JSAPI 支付】（常用支付方式）</h5><p>地址：<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6</a></p><pre><code>function onBridgeReady() &#123;    WeixinJSBridge.invoke(        &#39;getBrandWCPayRequest&#39;, &#123;            &quot;appId&quot;: &quot;appId&quot;, //公众号名称，由商户传入                 &quot;timeStamp&quot;: &quot;timeStamp&quot;, //时间戳，自1970年以来的秒数                 &quot;nonceStr&quot;: &quot;nonceStr&quot;, //随机串                 &quot;package&quot;: &quot;package&quot;,            &quot;signType&quot;: &quot;MD5&quot;, //微信签名方式：                 &quot;paySign&quot;: &quot;paySign&quot; //微信签名         &#125;,        function(res) &#123;            // 支付成功            if (res.err_msg == &quot;get_brand_wcpay_request:ok&quot;) &#123;                // 使用以上方式判断前端返回,微信团队郑重提示：                //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。            &#125;            // 支付过程中用户取消            if (res.err_msg == &quot;get_brand_wcpay_request:cancel&quot;) &#123;​        &#125;​        // 支付失败​        if (res.err_msg == &quot;get_brand_wcpay_request:fail&quot;) &#123;​        &#125;​        /**</code></pre><pre><code>     * 其它     * 1、请检查预支付会话标识prepay_id是否已失效     * 2、请求的appid与下单接口的appid是否一致     * */    if (res.err_msg == &quot;调用支付JSAPI缺少参数：total_fee&quot;) &#123;    &#125;     &#125;);</code></pre><p>}<br>// 检测支付环境中的 WeixinJSBridge</p><pre><code>if (typeof WeixinJSBridge == &quot;undefined&quot;) &#123;    if (document.addEventListener) &#123;        document.addEventListener(&#39;WeixinJSBridgeReady&#39;, onBridgeReady, false);    &#125; else if (document.attachEvent) &#123;        document.attachEvent(&#39;WeixinJSBridgeReady&#39;, onBridgeReady);        document.attachEvent(&#39;onWeixinJSBridgeReady&#39;, onBridgeReady);    &#125;&#125; else &#123;    onBridgeReady();&#125;</code></pre><h5 id="JSAPI调起支付注意事项："><a href="#JSAPI调起支付注意事项：" class="headerlink" title="JSAPI调起支付注意事项："></a>JSAPI调起支付注意事项：</h5><p>在微信浏览器里打开H5网页中执行JS调起支付；<br>WeixinJSBridge是微信浏览器内置对象，在其他浏览器中无效；<br>调用支付传递的参数注意区分大小写。</p><h5 id="WeixinJSBridge-invoke-、-wx-chooseWXPay-的区别"><a href="#WeixinJSBridge-invoke-、-wx-chooseWXPay-的区别" class="headerlink" title="WeixinJSBridge.invoke 、 wx.chooseWXPay 的区别"></a>WeixinJSBridge.invoke 、 wx.chooseWXPay 的区别</h5><p>WeixinJSBridge.invoke()出现的版本更早 无需引用jssdk 无需wx.config方法注入 需要参数appId 使用回调 有详细的说明<br>而wx.choosewxpay()出现的版本比较晚 需要jssdk注入 不需要参数appId 使用回调 只有SUCCESS 和 FAIL没有具体的说明<br>WeixinJSBridge.invoke()是微信浏览器的内置方法 其实wx.choosewxpay()在引用的微信jssdk文件中 也调用了WeixinJSBridge.invoke() 是对WeixinJSBridge.invoke()的再次封装<br>综上所诉 这是微信前后设计的不同方法的支付 还是weixinjsbridge更方便一些 有具体的失败回调</p><p>代码演示：</p><p>  // 支付按钮。</p><p> 在vue里面</p><pre><code class="vue">npm install weixin-js-sdk --saveimport wx from &quot;weixin-js-sdk&quot;;</code></pre><pre><code class="vue">payBtn() &#123;​      new Promise((resolve, reject) =&gt; &#123;​        Api_insured.isWaitPay(this.orderNo)​          .then(res =&gt; &#123;​            // this.payDisabled = true​            if (this.selectedIndex == 1) &#123;​              console.log(&quot;微信内&quot;);​              if (​                navigator.userAgent.toLowerCase().indexOf(&quot;micromessenger&quot;) !==​                -1​              ) &#123;​                var that = this;​                new Promise((resolve, reject) =&gt; &#123;​                  Api_insured.payEnable()​                    .then(res =&gt; &#123;​                      if(res.result) &#123;​                        console.log(&quot;微信端&quot;);​                        that.$vux.loading.show();​                        ​                        new Promise((resolve, reject) =&gt; &#123;​                          Api_insured.wxPay(that.orderNo, that.isSign)​                            .then(res =&gt; &#123;​                              // that.payDisabled = false​                              that.appId = res.result.appId;​                              that.timeStamp = res.result.timeStamp;​                              that.nonceStr = res.result.nonceStr;​                              that.package = res.result.package;​                              that.signType = res.result.signType;​                              that.paySign = res.result.paySign;​                              wx.config(&#123;​                                debug: false,​                                appId: res.result.appId,​                                timeStamp: res.result.timeStamp,​                                nonceStr: res.result.nonceStr,​                                signType: res.result.signType,​                                paySign: res.result.paySign,​                                jsApiList: [&quot;chooseWXPay&quot;]​                              &#125;);​                              that.$vux.loading.hide();​                              that.onBridgeReady();​                            &#125;)​                            .catch(error =&gt; &#123;​                              that.$vux.toast.text(error.message);​                              that.$vux.loading.hide();​                              // that.payDisabled = false​                              reject(error);​                            &#125;);​                        &#125;);​                      &#125; else &#123;​                        that.h5DialogShow = true​                        // location.href =​                        //   location.href.split(&quot;#&quot;)[0] +​                        //   &quot;pi-hz/api/wxpay/wapPay?orderNo=&quot; +​                        //   that.orderNo;​                        &#125;​                      &#125;)​                    .catch(error =&gt; &#123;​                      that.$vux.toast.text(error.message);​                      reject(error);​                    &#125;);​                &#125;);​                ​              &#125; else &#123;​                // that.payDisabled = false​                console.log(&quot;H5&quot;);​                var that = this;​                location.href =​                  location.href.split(&quot;#&quot;)[0] +​                  &quot;pi-hz/api/wxpay/wapPay?orderNo=&quot; +​                  that.orderNo;​              &#125;​            &#125; else &#123;​              console.log(&quot;支付宝&quot;);​              if (​                navigator.userAgent.toLowerCase().indexOf(&quot;micromessenger&quot;) !==​                -1​              ) &#123;​                // 弹窗​                // this.payDisabled = false​                this.$refs.aliPayDialog.style.display = &quot;&quot;;​              &#125; else &#123;​                // this.payDisabled = false​                location.href =​                  location.href.split(&quot;#&quot;)[0] +​                  &quot;pi-hz/api/alipay/wapPay?orderNo=&quot; +​                  this.orderNo;​              &#125;​            &#125;​          &#125;)​          .catch(error =&gt; &#123;​            this.$vux.toast.text(error.message);​            reject(error);​          &#125;);​      &#125;);​    &#125;,</code></pre><pre><code class="vue"> // 公众号支付​    onBridgeReady() &#123;​      let that = this;​      WeixinJSBridge.invoke(​        &quot;getBrandWCPayRequest&quot;,​        &#123;​          appId: that.appId, //公众号名称，由商户传入​          timeStamp: that.timeStamp, //时间戳，自1970年以来的秒数​          nonceStr: that.nonceStr, //随机串​          package: that.package,​          signType: that.signType, //微信签名方式​          paySign: that.paySign //微信签名​        &#125;,​        function(res) &#123;​          if (res.err_msg == &quot;get_brand_wcpay_request:ok&quot;) &#123;​            // 支付成功​            that.$router.push(&#123;​              path: &quot;/paySuccess&quot;,​              query: &#123;​                orderNo: that.orderNo​              &#125;​            &#125;);​            // that.payDisabled = false​          &#125; else if (res.err_msg == &quot;get_brand_wcpay_request:cancel&quot;) &#123;​            that.$vux.toast.text(&quot;支付取消&quot;);​            // that.payDisabled = false​          &#125; else &#123;​            that.$vux.toast.text(&quot;支付失败&quot;);​            // that.payDisabled = false​          &#125;​        &#125;​      );​    &#125;,</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mac安装nvm-自动切换node版本</title>
      <link href="/2022/10/13/nvm%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2022/10/13/nvm%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>nvm介绍</strong><br>node的版本管理器，可以方便地安装&amp;切换不同版本的node。<br>随着大前端的快速发展，node版本更新很快，我们在工作中，可能会有老版本的node的项目需要维护，也有新版本的node的项目需要开发，如果我们只有一个node版本的话将会很麻烦，nvm可以解决我们的难点。</p><p>1、打开终端输入 cd ~/<br>紧接着输入 git clone <a href="https://links.jianshu.com/go?to=https://github.com/nvm-sh/nvm.git">https://github.com/nvm-sh/nvm.git</a> （这里从github下载nvm）</p><p>2、进入 nvm目录中执行install.sh 等待执行完成<br>cd nvm （进入nvm目录）</p><pre><code>./install.sh </code></pre><p>（等待执行成功）</p><p>3、配置nvm环境变量将下述代码复制到 ~/.bash_profile</p><blockquote><pre><code>vi ~/.bash_profile</code></pre></blockquote><p>shift+:键盘，i键，qw保存文件并且退出</p><p>在~/.bash_profile添加</p><blockquote><pre><code>&gt; export NVM_DIR=&quot;$HOME/.nvm&quot;&gt;&gt; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm&gt;&gt; [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion&gt; source ~/.bash_profile</code></pre></blockquote><p>在终端运行<br><strong>zsh报错</strong><br>但是再zsh中使用nvm依旧提示<br><strong>解决方法</strong><br>编辑~/.zshrc<br>添加</p><blockquote><pre><code>source ~/.bash_profile</code></pre></blockquote><p>source ~/.zshrc</p><p>4、重新打开终端，执行</p><pre><code class="js">nvm --version</code></pre><p>检测是否安装成功</p><h6 id="5、nvm的使用"><a href="#5、nvm的使用" class="headerlink" title="5、nvm的使用"></a>5、nvm的使用</h6><pre><code>1.nvm ls # 列出当前安装的所有node版本2.nvm ls-remote # 列出所有node版本3.nvm install 版本号 # 安装指定版本的node 版本号取nvm ls-remote列出的 例如：nvm install 16.1.04.nvm uninstall 版本号  # 卸载指定版本号 例如：nvm uninstall 16.1.05.nvm use 版本号 # 切换到指定node版本 例如：nvm use 16.1.0</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-闭包</title>
      <link href="/2022/09/15/28%20%E9%97%AD%E5%8C%85/"/>
      <url>/2022/09/15/28%20%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>利用作用域的嵌套，实现了将局部变量进化成<strong>私有（自由）变量</strong>，然后可以被原本不能获取到的作用域获取到的环境，叫闭包</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JavaScript 闭包的本质源自两点，词法作用域和函数当作值传递。</p><p>词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。</p><p>函数当作值传递，即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>内存的：删除就删除，没了</p><p>硬盘的：暂存到回收站，还在，可以找到继续使用</p><h3 id="闭包特点"><a href="#闭包特点" class="headerlink" title="闭包特点"></a>闭包特点</h3><ol><li>可以在全局修改局部</li><li>连接函数内外部的桥梁</li><li>IE9~浏览器会造成内存泄漏</li><li>占内存</li><li>避免全局变量命名空间的污染</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="事件委托的封装"><a href="#事件委托的封装" class="headerlink" title="事件委托的封装"></a>事件委托的封装</h4><pre><code class="js">obox.onclick = eveEnt(achild, function () &#123;&#125;);function eveEnt(arr, cb) &#123;    return function () &#123;        arr        cb    &#125;&#125;</code></pre><h4 id="循环中的事件需要获取循环中的变量"><a href="#循环中的事件需要获取循环中的变量" class="headerlink" title="循环中的事件需要获取循环中的变量"></a>循环中的事件需要获取循环中的变量</h4><pre><code class="js">for(var i in arr)&#123;    arr[i].onclick = function(i)&#123;        return funtion()&#123;            console.log(i);        &#125;    &#125;&#125;baidufor(var i = 0;i &lt; oLis.length;i ++)&#123;    ;(function(i)&#123;        oLis[i].onclick = function()&#123;            alert(i); //0123        &#125;    &#125;)(i);</code></pre><h4 id="计时器的回调函数，想传参"><a href="#计时器的回调函数，想传参" class="headerlink" title="计时器的回调函数，想传参"></a>计时器的回调函数，想传参</h4><pre><code class="js">setTimeout(fn(&quot;world&quot;), 1000);function fn(data)&#123;    return function()&#123;        console.log(data);    &#125;&#125;</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-箭头函数</title>
      <link href="/2022/09/15/17%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/15/17%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p><strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p></blockquote><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><pre><code class="js">(param1, param2, …, paramN) =&gt; &#123; statements &#125; (param1, param2, …, paramN) =&gt; expression//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;// 当只有一个参数时，圆括号是可选的：(singleParam) =&gt; &#123; statements &#125;singleParam =&gt; &#123; statements &#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123; statements &#125;</code></pre><h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><pre><code class="js">//加括号的函数体返回对象字面量表达式：params =&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(param1, param2, ...rest) =&gt; &#123; statements &#125;(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f();  // 6</code></pre><h3 id="没有单独的this"><a href="#没有单独的this" class="headerlink" title="没有单独的this"></a>没有单独的this</h3><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：</p><ul><li>如果是该函数是一个构造函数，this指针指向一个新的对象</li><li>在严格模式下的函数调用下，this指向undefined</li><li>如果是该函数是一个对象的方法，则它的this指针指向这个对象</li><li>等等</li></ul><p><code>This</code>被证明是令人厌烦的面向对象风格的编程。</p><p>箭头函数不会创建自己的<code>this,它只会从自己的作用域链的上一层继承this</code>。因此，在下面的代码中，传递给<code>setInterval</code>的函数内的<code>this</code>与封闭函数中的<code>this</code>值相同：</p><pre><code class="js">function Person()&#123;  this.age = 0;  setInterval(() =&gt; &#123;    this.age++; // |this| 正确地指向 p 实例  &#125;, 1000);&#125;var p = new Person();</code></pre><h3 id="通过call或apply调用"><a href="#通过call或apply调用" class="headerlink" title="通过call或apply调用"></a>通过call或apply调用</h3><p>由于 箭头函数没有自己的this指针，通过 <code>call()</code> <em>或</em> <code>apply()</code> 方法调用一个函数时，只能传递参数（不能绑定this—译者注），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立—译者注）</p><pre><code class="js">var adder = &#123;  base : 1,      add : function(a) &#123;    var f = v =&gt; v + this.base;    return f(a);  &#125;,  addThruCall: function(a) &#123;    var f = v =&gt; v + this.base;    var b = &#123;      base : 2    &#125;;                return f.call(b, a);  &#125;&#125;;console.log(adder.add(1));         // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-关键字</title>
      <link href="/2022/09/15/16%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/09/15/16%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p><strong>let</strong> 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];</code></pre><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p><code>    let</code>声明的变量只在其声明的块或子块中可用，这一点，与<code>var</code>相似。二者之间最主要的区别在于<code>var</code>声明的变量的作用域是整个封闭函数。</p><pre><code class="js">function varTest() &#123;  var x = 1;  &#123;    var x = 2;  // 同样的变量!    console.log(x);  // 2  &#125;  console.log(x);  // 2&#125;function letTest() &#123;  let x = 1;  &#123;    let x = 2;  // 不同的变量    console.log(x);  // 2  &#125;  console.log(x);  // 1&#125;</code></pre><h5 id="不给全局增加属性"><a href="#不给全局增加属性" class="headerlink" title="不给全局增加属性"></a>不给全局增加属性</h5><p>​    位于函数或代码顶部的**<code>var</code><strong>声明会给全局对象新增属性, 而</strong><code>let</code>**不会。</p><pre><code class="js">var x = &#39;global&#39;;let name = &#39;global&#39;;console.log(this.x); // &quot;global&quot;console.log(this.name); // undefined</code></pre><h5 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h5><pre><code class="js">console.log(a);//报错：Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization    at &lt;anonymous&gt;:1:13let a = 10;console.log(a);</code></pre><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><blockquote><p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><pre><code class="js">let a = 10;function fn()&#123;    console.log(a);    let a = 20;&#125;fn();</code></pre><h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><pre><code class="javascript">// 报错function func() &#123;  let a = 10;  var a = 1;&#125;// 报错function func() &#123;  let a = 10;  let a = 1;&#125;</code></pre><p>因此，不能在函数内部重新声明参数。</p><pre><code class="javascript">function func(arg) &#123;  let arg;&#125;func() // 报错function func(arg) &#123;  &#123;    let arg;  &#125;&#125;func() // 不报错</code></pre><p>在程序和方法的最顶端，**<code>let</code><strong>不像 <strong><code>var</code></strong> 一样，</strong><code>let</code>**不会在全局对象里新建一个属性。比如：</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p></blockquote><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];</code></pre><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><h5 id="只声明不赋值，就会报错"><a href="#只声明不赋值，就会报错" class="headerlink" title="只声明不赋值，就会报错"></a>只声明不赋值，就会报错</h5><pre><code class="js">const foo;// SyntaxError: Missing initializer in const declaration</code></pre><h5 id="块级作用域-1"><a href="#块级作用域-1" class="headerlink" title="块级作用域"></a>块级作用域</h5><pre><code class="js">if (true) &#123;  const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined</code></pre><h5 id="不存在提升-1"><a href="#不存在提升-1" class="headerlink" title="不存在提升"></a>不存在提升</h5><pre><code class="js">if (true) &#123;  console.log(MAX); // ReferenceError  const MAX = 5;&#125;</code></pre><h5 id="暂时性死区-1"><a href="#暂时性死区-1" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><pre><code class="js">if (true) &#123;  console.log(MAX); // ReferenceError  const MAX = 5;&#125;</code></pre><h5 id="不可重复声明"><a href="#不可重复声明" class="headerlink" title="不可重复声明"></a>不可重复声明</h5><pre><code class="js">var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30;</code></pre><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><h5 id="只能保证变量的地址不变"><a href="#只能保证变量的地址不变" class="headerlink" title="只能保证变量的地址不变"></a>只能保证变量的地址不变</h5><p><code>const</code>实际上保证的，并<strong>不是变量的值不得改动</strong>，而是变量指向的那个<strong>内存地址</strong>所保存的数据<strong>不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，**<code>const</code>只能保证这个指针是固定的**（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><pre><code class="javascript">const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</code></pre><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><pre><code class="javascript">const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;</code></pre><p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><pre><code class="javascript">var constantize = (obj) =&gt; &#123;  Object.freeze(obj);  Object.keys(obj).forEach( (key, i) =&gt; &#123;    if ( typeof obj[key] === &#39;object&#39; ) &#123;      constantize( obj[key] );    &#125;  &#125;);&#125;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-面向对象编程</title>
      <link href="/2022/09/15/18%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/15/18%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="面向对象分析OOA"><a href="#面向对象分析OOA" class="headerlink" title="面向对象分析OOA"></a>面向对象分析OOA</h3><blockquote><p>分析问题，需求：</p><ol><li>将任务不断的拆分，拆分成更具体的小任务，使用分工协作的形式，解决所有的小任务</li><li>更具体的小任务：能直接解决的小任务</li></ol></blockquote><h3 id="面向对象设计OOD"><a href="#面向对象设计OOD" class="headerlink" title="面向对象设计OOD"></a>面向对象设计OOD</h3><blockquote><p>高内聚（忠诚度），低耦合（依赖）</p></blockquote><h3 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程OOP</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote><p>工厂模式抽象了具体对象的过程。也就是说，发明了一种函数，把对象放到函数里，用函数封装创建对象的细节。</p></blockquote><pre><code class="js">function createPerson (name,age) &#123;    var o = &#123;        name : name,        age : age,            sayName : function () &#123;            alert(this.name)        &#125;    &#125;    return o;&#125;var person1 = createPerson(&quot;Tom&quot;,14);var person2 = createPerson(&quot;Jerry&quot;,18)console.log(person1 instanceof Object)  //trueconsole.log(person1 instanceof createPerson)  //falseinstanceof 用于检测数据类型var aa = []console.log(aa instanceof Array)  //true</code></pre><p>工厂模式解决了代码复用的问题，但是却没有解决对象识别的问题。即创建的所有实例都是Object类型。<br>为了解决这一问题，就有了构造函数模式</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><blockquote><p>可以被构造的函数和正常函数的区别：首字母大写（大驼峰）</p></blockquote><pre><code class="js">function Person (name,age) &#123;    this.name = name;    this.age = age;    this.sayName = function () &#123;        alert(this.name)    &#125;&#125;    var person1 = new Person(&#39;Tom&#39;,14);    var Person2 = new Person(&#39;Jerry&#39;,18);</code></pre><ol><li>构造函数 Person 有一个prototype(原型)属性，这个属性是一个指针，指向一个对象即：Person.prototype(原型对象)；</li><li>实例person1 person2也有一个[[prototype]]属性或者叫_proto_,这个属性 也指向Person.prototype；</li><li>构造函数和实例都共享Person.prototype里的属性和方法；</li><li>Person.prototype里有一个 constructor属性，这个属性也是一个指针，指向构造函数Person。这样以来，实例也指向了Person,那么实例也共享了构造函数的属性和方法。</li><li>构造函数、实例、原型对象里所有的属性和方法都是共享的。</li></ol><p>构造函数解决了对象识别问题，我们在这个例子中创建的对所有对象既是Object的实例，同时，也是Person的实例。这一点通过instanceof操作符可以得到验证。</p><h4 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h4><ol><li>自动创建一个新对象</li><li>将这个构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li><li>执行构造函数中的代码(为这个新对象添加属性)</li><li>检测函数是否主动返回对象，没有，就返回第一步创建的新对象</li></ol><h4 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h4><blockquote><p>构造函数和普通函数的唯一区别，在于调用它们的方式不同。</p></blockquote><h5 id="当作构造函数使用"><a href="#当作构造函数使用" class="headerlink" title="当作构造函数使用"></a>当作构造函数使用</h5><pre><code class="js">function Person (name,age) &#123;    console.log(this);    this.name = name;    this.age = age;&#125;var person = new Person(&quot;andy&quot;,21);</code></pre><p>需要注意的是，this指向构造函数Person</p><h5 id="当作普通函数使用"><a href="#当作普通函数使用" class="headerlink" title="当作普通函数使用"></a>当作普通函数使用</h5><pre><code class="js"> function Person (name,age) &#123;    console.log(this) &#125; Person()</code></pre><p>this指向widow.</p><h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>构造函数虽然好用，但也有缺点。既每个new出来的实例里的方法都要重新创建一遍。在前面的例子中person1 person2 都有一个sayName方法，但这两个方法不是同一个Function实例！每个实例的方法 都是不同的，不相等的。这是不合理的！</p><pre><code class="js">function Person (name) &#123;    this.name = name;    this.sayName = new Function (&quot;alert(this.name)&quot;)&#125;function Person (name) &#123;    this.name = name;    this.sayName = function () &#123;        alert(this.name)    &#125;&#125;alert( person1.sayName == person2.sayName ) //false</code></pre><p>由此可见，完成同样任务的函数确实没必要每个实例，就实例一次。<br>于是，有需求，就有解决方案：原型模式。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p> TBD</p><h3 id="组合构造函数原型模式"><a href="#组合构造函数原型模式" class="headerlink" title="组合构造函数原型模式"></a>组合构造函数原型模式</h3><blockquote><p>构造函数与原型混合的模式是目前使用最广泛、认同度最高的一种创建定义类型的方法。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><p>每个实例都会有自己的一份实例属性的副本，同时共享着对方法的引用，最大限度节省内存。同时，这种混杂模式还支持向构造函数传递参数，可谓是集两种模式之长。</p></blockquote><pre><code class="js">function Person(name,age,job)&#123;　　this.name=name;　　this.age=age;　　this.job=job;　　this.friends=[&quot;Machiel&quot;,&quot;Dophe&quot;];&#125;;Person.prototype=&#123;　　constructor:&quot;Person&quot;,　　sayName:function()&#123;　　　　alert(this.name)　　&#125;&#125;;var person=new Person(&quot;Niche&quot;,12,&quot;Software&quot;)console.log(person.friends);person.sayName();//构造函数实现实例属性的副本，原型实现方法的共享function Peason(name, age, sex) &#123;    this.name = name;    this.age = age;    this.sex = sex;&#125;Peason.prototype.show = function () &#123;    console.log(this.name, this.age, this.sex);&#125;let andy = new Peason(&quot;andy&quot;,25,1);let yuehui = new Peason(&quot;yuehui&quot;,23,1);andy.show();//&quot;andy&quot;,25,1andy.name = &quot;xiaoandy&quot;;andy.show();//&quot;xiaoandy&quot;,25,1yuehui.show = function () &#123;     console.log(this.name,this.age)&#125;yuehui.show();//&quot;yuehui&quot;,23 只会在yuehui对象中新增一个方法，不会修改到原型里的方法，如果使用yuehui.prototype.show去修改，就会修改共享方法andy.show()//&quot;xiaoandy&quot;,25,1</code></pre><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p> TBD</p><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p> TBD</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p> TBD</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么是工厂模式-？"><a href="#什么是工厂模式-？" class="headerlink" title="什么是工厂模式 ？"></a>什么是工厂模式 ？</h3><blockquote><p>工厂模式就是抽象了具体对象细节过程的方法。这个方法以函数的形式封装实现的细节。实现了重复调用的功能。</p></blockquote><h3 id="什么是构造函数模式-？"><a href="#什么是构造函数模式-？" class="headerlink" title="什么是构造函数模式 ？"></a>什么是构造函数模式 ？</h3><blockquote><p>构造函数模式就是创建一个对象，new 这个对象就是对象的实例。实现重复调用的同时，它的实例 也有了QQVIP的尊贵特权 ，即实例可以标识为特定的类型。有了这个标识 可以更好的识别出，谁是数组类型，谁是函数类型，然后你 typeof arr 或 typeof fun<br>一看，真的是Array类型，functiong类型。你也可以自定义自己想要的类型，这样大大的增加了JS的拓展性。</p></blockquote><h3 id="什么是原型模式-？"><a href="#什么是原型模式-？" class="headerlink" title="什么是原型模式 ？"></a>什么是原型模式 ？</h3><blockquote><p>首先我们要知道，我们创建的每一个函数都有一个隐藏属性，也就是原型属性。这个原型属性指向一个原型对象。且所有实例和构造函数 都指向这个原型对象，共享原型对象的所有方法和属性。<br>我们通过操作原型对象达到 实例共享属性方法的目的，就是原型模式。<br>同时，因为实例都是引用原型对象的属性和方法，也避免了构造函数模式下所有实例都有各自的方法的弊端。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-数组常用方法</title>
      <link href="/2022/09/15/33js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/33js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>1.join() （数组转字符串）<br>数组转字符串，方法只接收一个参数：即默认为逗号分隔符（）。</p><script>    var arr=[1,2,3,4];    console.log(arr.join()); //1,2,3,4    console.log(arr.join(":")); //1:2:3:4    console.log(arr); //[1,2,3,4],原数组不变</script><p>join()实现重复字符串</p><script>    function repeatStr(str, n) {        return new Array(n + 1).join(str);    }    console.log(repeatStr("嗨",3)); //嗨嗨嗨    console.log(repeatStr("Hi",3)); //HiHiHi    console.log(repeatStr(1,3));    //111</script><p>2.push()和pop()（数组尾操作）<br>push()：方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p>pop()：方法用于删除并返回数组的最后一个元素。</p><script>    var arr=[1,2,3,4];    //push    var push_arr=arr.push("Tom","Sun");    console.log(arr); //[1,2,3,4,"Tom","Sun"];    console.log(push_arr); // 6    //pop    var pop_arr=arr.pop();    console.log(arr); //[1,2,3,4,"Tom"];    console.log(pop_arr); // Sun    </script><p>3.shift() 和 unshift()（数组首操作）<br>shift()：方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</p><p>unshift()：方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><script>    var arr=[1,2,3,4];    //shift    var shift_arr=arr.shift();    console.log(arr); // [2, 3, 4]    console.log(shift_arr); // 1    //unshift    var unshift_arr=arr.unshift("Tom");    console.log(arr); // ["Tom", 2, 3, 4]    console.log(unshift_arr); // 4</script><p>4.sort()（排序）<br>方法用于对数组的元素进行排序。</p><script>    var arr=[1,100,5,20];    console.log(arr.sort()); // [1, 100, 20, 5]    console.log(arr); // [1, 100, 20, 5] (原数组改变)    </script><p>请注意，上面的代码没有按照数值的大小对数字进行排序，是按照字符编码的顺序进行排序，要实现这一点，就必须使用一个排序函数：</p><p>升序：</p><script>    var arr=[1,100,5,20];    function sortNumber(a,b){return a - b};    console.log(arr.sort(sortNumber)); //[1, 5, 20, 100]    console.log(arr); //[1, 5, 20, 100] (原数组改变)</script><p>降序：</p><script>    var arr=[1,100,5,20];    function sortNumber(a,b){return b - a};    console.log(arr.sort(sortNumber)); // [100, 20, 5, 1]    console.log(arr); // [100, 20, 5, 1] (原数组改变)</script><p>5.reverse() （反转数组）<br>方法用于颠倒数组中元素的顺序。</p><script>    var arr=[12,25,5,20];    console.log(arr.reverse()); // [20, 5, 25, 12]    console.log(arr); // [20, 5, 25, 12] (原数组改变)</script><p>6.concat() （连接两个或多个数组）<br>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p><script>    var arr=[1,2,3,4];    var arr2=[11,12,13]     var arrCopy = arr.concat(arr2);    console.log(arr.concat()); // [1, 2, 3, 4] (复制数组)    console.log(arrCopy); // [1, 2, 3, 4, 11, 12, 13]    console.log(arr); // [1, 2, 3, 4] (原数组未改变)</script><p>如果传入的参数是一个二维数组呢？</p><script>    var arr=[1,2,3,4];    var arr2=[11,[12,13]]     var arrCopy = arr.concat(arr2);        console.log(arrCopy); // [1, 2, 3, 4, 11, Array(2)]    console.log(arr); // [1, 2, 3, 4] (原数组未改变)</script><p>从上面代码中可以看出concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy中。</p><p>7.slice()（数组截取）<br>arr.slice(start , end);</p><p>start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p><p>end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p><p>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arr 中的元素。</p><script>    var arr = [1,4,6,8,12];    var arrCopy1 = arr.slice(1);        var arrCopy2 = arr.slice(0,4);        var arrCopy3 = arr.slice(1,-2);    var arrCopy4 = arr.slice(-5,4);    var arrCopy5 = arr.slice(-4,-1)    console.log(arrCopy1);  // [4, 6, 8, 12]    console.log(arrCopy2);  // [1, 4, 6, 8]     console.log(arrCopy3);  // [4, 6]     console.log(arrCopy4);  // [1, 4, 6, 8]    console.log(arrCopy5);  // [4, 6, 8]    console.log(arr);  // [1, 4, 6, 8, 12] (原数组未改变) </script><p>8.splice() （数组更新）<br>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。（该方法会改变原始数组）</p><p>arr.splice(index , howmany , item1,…..,itemX)</p><p>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</p><p>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</p><p>item1, …, itemX：可选。向数组添加的新项目。</p><p>返回值：含有被删除的元素的数组，若没有删除元素则返回一个空数组。</p><script>    var arr = ["张三","李四","王五","小明","小红"];    /**************删除"王五"****************/    var arrReplace1 = arr.splice(2,1);        console.log(arrReplace1);  // ["王五"]     console.log(arr);  // ["张三", "李四", "小明", "小红"] (原数组改变)    //删除多个    var arrReplace2 = arr.splice(1,2);        console.log(arrReplace2);  //  ["李四", "小明"]     console.log(arr);  // ["张三", "小红"]    /**************添加"小刚"****************/    var arrReplace3 = arr.splice(1,0,"小刚");    console.log(arrReplace3);  // [] (没有删除元素，所以返回的是空数组)    console.log(arr);  // ["张三", "小刚", "小红"]    //添加多个    var arrReplace4 = arr.splice(3,0,"刘一","陈二","赵六");    console.log(arrReplace4);  // []    console.log(arr);  // ["张三", "小刚", "小红", "刘一", "陈二", "赵六"]    /**************"王五"替换"小刚"****************/    var arrReplace5 = arr.splice(1,1,"王五");    console.log(arrReplace5);  // ["小刚"]    console.log(arr);  // ["张三", "王五", "小红", "刘一", "陈二", "赵六"]    //替换多个    var arrReplace6 = arr.splice(1,4,"李四");    console.log(arrReplace6);  // ["王五", "小红", "刘一", "陈二"]    console.log(arr);  // ["张三", "李四", "赵六"]</script><p>ES5数组新增方法：<br>2个索引方法：indexOf()和 lastIndexOf()<br>两个方法都返回要查找的项在数组中首次出现的位置，在没找到的情况下返回-1</p><p>indexOf()——–array.indexOf(item,start) （从数组的开头（位置 0）开始向后查找）</p><p>item： 必须。查找的元素。</p><p>start：可选的整数参数。规定在数组中开始检索的位置。如省略该参数，则将从array[0]开始检索。</p><p>lastIndexOf()——–array.lastIndexOf(item,start) （从数组的末尾开始向前查找）</p><p>item： 必须。查找的元素。</p><p>start：可选的整数参数。规定在数组中开始检索的位置。如省略该参数，则将从 array[array.length-1]开始检索。</p><script>    var arr = [1,4,7,10,7,18,7,26];    console.log(arr.indexOf(7));        // 2    console.log(arr.lastIndexOf(7));    // 6    console.log(arr.indexOf(7,4));      // 4    console.log(arr.lastIndexOf(7,2));  // 2    console.log(arr.indexOf(5));        // -1        </script><p>5个迭代方法：forEach()、map()、filter()、some()、every()<br>这几个方法语法都一样，都不会改变原数组。</p><p>forEach()：对数组进行遍历循环，这个方法没有返回值。jquery()也提供了相应的方法each()方法。</p><p>语法：array.forEach(function(currentValue , index , arr){//do something}, thisValue)</p><p>currentValue : 必需。当前元素</p><p>index： 可选。当前元素的索引值。</p><p>arr :  可选。当前元素所属的数组对象。</p><p>thisValue： 可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值</p><script>    var Arr = [1,4,7,10];    Arr.forEach(function(currentValue, index, arr){        console.log(index+"--"+currentValue+"--"+(arr === Arr));            })    // 输出：    // 0--1--true    // 1--4--true    // 2--7--true    // 3--10--true    </script><p>map()：指“映射”，方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p>语法：array.map(function(currentValue , index , arr){//do something}, thisValue)  </p><p>map方法实现数组中每个数求平方：</p><script>    var arr = [1,4,8,10];    var arr2 = arr.map(function(currentValue){        return currentValue*currentValue;    });    console.log(arr2);  // [1, 16, 64, 100]</script><p>filter()： “过滤”功能，方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。和filter() 方法类似，jquery中有个 grep()方法也用于数组元素过滤筛选。</p><p>语法： array.filter(function(currentValue , index , arr){//do something}, thisValue) </p><p>filter方法实现筛选排除掉所有小于5的元素：</p><script>    var arr = [1,4,6,8,10];    var result1 = arr.filter(function(currentValue){        return currentValue>5;    });    console.log(result1);  // [6, 8, 10]    var result2 = arr.filter(function(currentValue){        return currentValue>"5";    });    console.log(result2);  // [6, 8, 10]</script><p>当我们分别设置item &gt; 5和item &gt; “5”时, 返回的结果是一样的，由此我们可以看出函数支持弱等于（==），不是必须全（===）。</p><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p><p>语法： array.every(function(currentValue , index , arr){//do something}, thisValue) </p><script>    var arr = [1,4,6,8,10];    var result1 = arr.every(function(currentValue){        return currentValue< 12;    });    console.log(result1);  // true    var result2 = arr.every(function(currentValue){        return currentValue> 1;    });    console.log(result2);  // false</script><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p><p>语法： array.some(function(currentValue , index , arr){//do something}, thisValue)</p><script>    var arr = [1,4,6,8,10];    var result1 = arr.some(function(currentValue){        return currentValue> 10;    });    console.log(result1);  // false    var result2 = arr.some(function(currentValue){        return currentValue> 5;    });    console.log(result2);  // true</script><p>2个归并方法：reduce()、reduceRight()<br>这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。他们都接收两个参数，第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组，函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。</p><p>reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p><p>reduce()语法：arr.reduce(function(total , cur , index , arr){//do something}, initialValue)</p><p>reduceRight()语法：arr.reduceRight(function(total , cur , index , arr){//do something}, initialValue)</p><p>total ：必需。初始值, 或者计算结束后的返回值。</p><p>cur ：必需。当前元素。</p><p>index ：可选。当前元素的索引。</p><p>arr：可选。当前元素所属的数组对象。</p><p>initialValue：可选。传递给函数的初始值。</p><p>下面代码实现数组求和：</p><script>    var arr = [1,2,3,4,5];    var result1 = arr.reduce(function(total,cur,index,arr){            console.log("total:"+total+",cur:"+cur+",index:"+index);        return total+cur;    });    console.log("结果："+result1);    // 输出    // total:1,cur:2,index:1    // total:3,cur:3,index:2    // total:6,cur:4,index:3    // total:10,cur:5,index:4    // 结果：15    var result2 = arr.reduce(function(total,cur,index,arr){            console.log("total:"+total+",cur:"+cur+",index:"+index);        return total+cur;    },10);    console.log("结果："+result2);    // 输出    // total:10,cur:1,index:0    // total:11,cur:2,index:1    // total:13,cur:3,index:2    // total:16,cur:4,index:3    // total:20,cur:5,index:4    // 结果：25</script><p>从上面代码我们可以看出，当我们不给函数传递迭代初始值时初始值 total 为数组第一项，函数从数组第二项开始迭代；若我们给函数传递迭代初始值，则函数从数组第一项开始迭代。</p><p>ES6数组新增方法（注意浏览器兼容）<br>1.Array.from()<br>方法是用于类似数组的对象（即有length属性的对象）和可遍历对象转为真正的数组。</p><script>    let json ={        '0':'卢',        '1':'本',        '2':'伟',        length:3    }    let arr = Array.from(json);    console.log(arr); // ["卢", "本", "伟"]    </script><p>2.Array.of()<br>方法是将一组值转变为数组，参数不分类型，只分数量，数量为0返回空数组。</p><script>    let arr1 = Array.of(1,2,3);        let arr2 = Array.of([1,2,3]);    let arr3 = Array.of(undefined);    let arr4 = Array.of();    console.log(arr1); // [1, 2, 3]    console.log(arr2); // [[1, 2, 3]]    console.log(arr3); // [undefined]    console.log(arr4); // []</script><p>3.find()<br>方法返回通过测试（函数内判断）的数组的第一个元素的值。方法为数组中的每个元素都调用一次函数执行。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p><p>回调函数可以接收3个参数，依次为当前的值（currentValue）、当前的位置（index）、原数组（arr）</p><p>注意：find() 对于空数组，函数是不会执行的。find() 并没有改变数组的原始值。</p><script>    let Arr = [1,2,5,7,5,9];    let result1 = Arr.find(function(currentValue,index,arr){                    return currentValue>5;    });    let result2 = Arr.find(function(currentValue,index,arr){                    return currentValue>9;    });    console.log(result1); // 7    console.log(result2); // undefined</script><p>find()实现根据id取出数组中的对象</p><script>    let Arr = [        {            id:1,            name:"张三"        },        {            id:2,            name:"李四"        }            ];    let obj = Arr.find(function(currentValue,index,arr){                    return currentValue.id===1;    });    console.log(obj.name); // 张三</script><p>4.findIndex ()<br>findIndex和find差不多，不过默认返回的是索引，如果没有符合条件的元素返回 -1</p><script>    let Arr = [1,2,5,7,5,9];    let result1 = Arr.findIndex(function(currentValue,index,arr){                    return currentValue>5;    });    let result2 = Arr.findIndex(function(currentValue,index,arr){                    return currentValue>9;    });    console.log(result1); // 3    console.log(result2); // -1</script><p>5.fill()<br>fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><p>语法：array.fill(value,  start,  end)</p><p>value：必需。填充的值。</p><p>start：可选。开始填充位置。如果这个参数是负数，那么它规定的是从数组尾部开始算起。</p><p>end：可选。停止填充位置 (默认为 array.length)。如果这个参数是负数，那么它规定的是从数组尾部开始算起。</p><script>    let arr = [1,2,3,4,5,6];    arr.fill(0);  // [0, 0, 0, 0, 0, 0]    arr.fill(0,1);  // [1, 0, 0, 0, 0, 0]     arr.fill(0,1,2);  // [1, 0, 3, 4, 5, 6]    arr.fill(0,-1);  // [1, 2, 3, 4, 5, 0]    arr.fill(0,1,-1);  // [1, 0, 0, 0, 0, 6]</script><p>6.遍历数组方法 keys()、values()、entries()<br>这三个方法都是返回一个遍历器对象，可用for…of循环遍历，唯一区别：keys()是对键名的遍历、values()对键值的遍历、entries()是对键值对的遍历。</p><p>keys()</p><script>    let arr = ["a","b","c","d"];    for(let i of arr.keys()){        console.log(i);    }    //打印：    // 0    // 1    // 2    // 3</script><p>values()</p><script>    let arr = ["a","b","c","d"];    for(let i of arr.values()){        console.log(i);    }    //打印：    // a    // b    // c    // d</script><p>entries()</p><script>    let arr = ["a","b","c","d"];    for(let i of arr.entries()){        console.log(i);    }    //打印：    // [0, "a"]    // [1, "b"]    // [2, "c"]    // [3, "d"]    for(let [idx,item] of arr.entries()){        console.log(idx+":"+item);    }    //打印：    // 0:a    // 1:b    // 2:c    // 3:d</script><p>7.includes()<br>方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p><p>语法：arr.includes(searchElement ,  fromIndex)</p><p>searchElement ： 必须。需要查找的元素值。</p><p>fromIndex：可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</p><script>    let arr = ["a","b","c","d"];    let result1 = arr.includes("b");    let result2 = arr.includes("b",2);    let result3 = arr.includes("b",-1);    let result4 = arr.includes("b",-3);    console.log(result1);  // true    console.log(result2);  // false    console.log(result3);  // flase    console.log(result4);  // true</script><p>8.copyWithin()<br>方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中，会覆盖原有成员</p><p>语法：array.copyWithin(target ,  start ,  end)</p><p>target ：必需。从该位置开始替换数据。</p><p>start ：可选。从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。</p><p>end： 可选。到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p><script>    let arr = [1,2,3,4,5,6];    let result1 = [1,2,3,4,5,6].copyWithin(0);    let result2 = [1,2,3,4,5,6].copyWithin(0,1);    let result3 = [1,2,3,4,5,6].copyWithin(1,3,5);    let result4 = [1,2,3,4,5,6].copyWithin(1,2,-1);    let result5 = [1,2,3,4,5,6].copyWithin(1,-4,6);    console.log(result1);  // [1, 2, 3, 4, 5, 6]    console.log(result2);  // [2, 3, 4, 5, 6, 6]    console.log(result3);  // [1, 4, 5, 4, 5, 6]    console.log(result4);  // [1, 3, 4, 5, 5, 6]    console.log(result5);  // [1, 3, 4, 5, 6, 6]</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-Promise</title>
      <link href="/2022/09/15/31%20Promise%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/31%20Promise%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p><code>ES6</code>新增的<code>构造函数Promise</code>，用来处理异步的程序(为了解决回调地狱)</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li><p>开启承诺：三天之后放假，然后呢：成功了，去哪玩，失败了，扫码</p><pre><code> 如同：开启ajax请求，请求资源，成功了，渲染页面，失败了，报错</code></pre></li><li><p>承诺正在进行时</p></li><li><p>承诺失败OR承诺成功</p></li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><pre><code class="js">new Promise( function(resolve, reject) &#123;...&#125; /* executor */  );</code></pre></blockquote><pre><code class="js">var p = new Promise(function(a,b)&#123;    // 正在进行时....    setTimeout(() =&gt; &#123;        a();    &#125;, Math.random()*1000);    setTimeout(() =&gt; &#123;        b();    &#125;, Math.random()*1000);&#125;);p.then(function()&#123;    // 成功时，要做的事情    // .....    console.log(1)&#125;,function()&#123;    // 失败时，要做的事情    // .....    console.log(2)&#125;)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>executor</p><p>executor是带有 <code>resolve</code> 和 <code>reject</code> 两个参数的函数 。Promise构造函数执行时立即调用<code>executor</code> 函数， <code>resolve</code> 和 <code>reject</code> 两个函数作为参数传递给<code>executor</code>（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。<code>resolve</code> 和 <code>reject</code> 函数被调用时，分别将promise的状态改为<em>fulfilled（</em>完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成<em>fulfilled</em>，要么调用<code>reject</code> 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p></li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>**Promise**</code> 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p><p>一个 <code>Promise</code>有以下几种状态:</p><ul><li><em>pending</em>: 初始状态，既不是成功，也不是失败状态。</li><li><em>fulfilled</em>: 意味着操作成功完成。</li><li><em>rejected</em>: 意味着操作失败。</li></ul><p>pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 <code>then</code> 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为<em>fulfilled</em>时，调用 then 的 onfulfilled 方法，当Promise状态为<em>rejected</em>时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p><p>因为 <code>Promise.prototype.then</code> 和  <code>Promise.prototype.catch</code> 方法返回promise 对象， 所以它们可以被链式调用。</p><p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="img"></p><p><strong>不要和惰性求值混淆：</strong> 有一些语言中有惰性求值和延时计算的特性，它们也被称为“promises”，例如Scheme. Javascript中的promise代表一种已经发生的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头方法</a>“:  <code>f = () =&gt;</code><em>表达式</em> 创建惰性求值的表达式<em>，</em>使用 <code>f()</code> 求值。</p><p><strong>注意：</strong> 如果一个promise对象处在fulfilled或rejected状态而不是pending状态，那么它也可以被称为<em>settled</em>状态。你可能也会听到一个术语<em>resolved</em> ，它表示promise对象处于settled状态。关于promise的术语， Domenic Denicola 的 <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and fates</a> 有更多详情可供参考。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h4><p>​    这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法—译者注）</p><h4 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h4><p>​    当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p><h4 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h4><p>​    返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p><h4 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h4><p>​    返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p><h2 id="Promise-原型"><a href="#Promise-原型" class="headerlink" title="Promise 原型"></a>Promise 原型</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><code>Promise.prototype.constructor</code></p><p>返回被创建的实例函数.  默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 函数.</p></li></ul><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch(onRejected)</code></a></p><p>添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果.</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then(onFulfilled, onRejected)</code></a></p><p>添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code>Promise.prototype.finally(onFinally)</code></a></p><p>添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)</p></li></ul><h2 id="promise改造ajax-amp-jsonp"><a href="#promise改造ajax-amp-jsonp" class="headerlink" title="promise改造ajax&amp;jsonp"></a>promise改造ajax&amp;jsonp</h2><h3 id="ajaxget封装"><a href="#ajaxget封装" class="headerlink" title="ajaxget封装"></a>ajaxget封装</h3><pre><code class="JS">url1 = &quot;http://127.0.0.1/myown/promise/php/data1.php&quot;url2 = &quot;http://127.0.0.1/myown/promise/php/data2.php&quot;url3 = &quot;http://127.0.0.1/myown/promise/php/data3.php&quot;function getAjax(url, data) &#123;    var p = new Promise(function (success, error) &#123;        var str = &quot;&quot;;        data = data || &#123;&#125;;        var xhr = new XMLHttpRequest();        for (var i in data) &#123;            str += `$&#123;i&#125;=$&#123;data[i]&#125;&amp;`;        &#125;        str = str.slice(0, str.length - 1);        url = url + &quot;?&quot; + str + &quot;__retr0__=&quot; + new Date().getDate();        xhr.open(&quot;get&quot;, url, true);        xhr.onreadystatechange = function () &#123;            if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;                success(xhr.responseText);            &#125; else if (xhr.readyState === 4 &amp;&amp; xhr.status != 200) &#123;                error(xhr.status);            &#125;        &#125;        xhr.send();    &#125;)    return p;&#125;var p1 = getAjax(url1)var p2 = getAjax(url2)var p3 = getAjax(url3)Promise.all([p1, p2, p3]).then(function (res) &#123;    console.log(res);&#125;, function (res) &#123;    console.log(res)&#125;)</code></pre><h3 id="ajaxpost封装"><a href="#ajaxpost封装" class="headerlink" title="ajaxpost封装"></a>ajaxpost封装</h3><pre><code class="JS">url1 = &quot;http://127.0.0.1/myown/promise/php/data1.php&quot;;url2 = &quot;http://127.0.0.1/myown/promise/php/data2.php&quot;;url3 = &quot;http://127.0.0.1/myown/promise/php/data3.php&quot;;function postAjax(url, data) &#123;    var p = new Promise(function (success, error) &#123;        data = data || &#123;&#125;;        var str = &quot;&quot;;        var xhr = new XMLHttpRequest();        for (var i in data) &#123;            str += `$&#123;i&#125;=$&#123;data[i]&#125;&amp;`;        &#125;        xhr.open(&quot;post&quot;, url, true);        xhr.onreadystatechange = function () &#123;            if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;                success(xhr.responseText);            &#125; else if (xhr.readyState === 4 &amp;&amp; xhr.status != 200) &#123;                error(xhr.status);            &#125;        &#125;        console.log(1)        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);        xhr.send(str);    &#125;)    return p;&#125;var p1 = postAjax(url1);var p2 = postAjax(url2);var p3 = postAjax(url3);Promise.all([p1, p2, p3]).then(function (res) &#123;    console.log(res);&#125;, function (res) &#123;    console.log(res);&#125;)</code></pre><h3 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h3><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><pre><code class="js">url1 = &quot;http://127.0.0.1/myown/promise/php/jsonp1.php&quot;;url2 = &quot;http://127.0.0.1/myown/promise/php/jsonp2.php&quot;;url3 = &quot;http://127.0.0.1/myown/promise/php/jsonp3.php&quot;;function jsonp(url, data) &#123;    var p = new Promise(function (success) &#123;        var str = &quot;&quot;;        var script = document.createElement(&quot;script&quot;);        for (var i in data) &#123;            str += `$&#123;i&#125;=$&#123;data[i]&#125;&amp;`;        &#125;        url = url + &quot;?&quot; + str + &quot;__retr0__=&quot; + new Date().getTime();        script.src = url;        window[data[data.cbName]] = function (res) &#123;            success(res);        &#125;        document.body.appendChild(script);    &#125;)    return p;&#125;var p1 = jsonp(url1, &#123;    user: &quot;admin&quot;,    pass: &quot;admi&quot;,    cbName: &quot;callback&quot;,    callback: &quot;qqq&quot;&#125;);var p2 = jsonp(url2, &#123;    user: &quot;root&quot;,    pass: &quot;root&quot;,    cbName: &quot;callback&quot;,    callback: &quot;bbb&quot;&#125;);var p3 = jsonp(url3, &#123;    user: &quot;retr0&quot;,    pass: &quot;retr&quot;,    cbName: &quot;callback&quot;,    callback: &quot;ccc&quot;&#125;);Promise.all([p1, p2, p3]).then(function (res) &#123;    console.log(res)&#125;)</code></pre><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><pre><code class="php">&lt;?php$u = $_GET[&quot;user&quot;];$p = $_GET[&quot;pass&quot;];$cb = $_GET[&quot;callback&quot;];$data = &quot;这是JSONP接受到的数据&quot; . $u . &quot;------&quot; . $p;echo &quot;$cb(&#39;&quot; . $data . &quot;&#39;)&quot;;?&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-storage</title>
      <link href="/2022/09/15/27%20Storage%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/27%20Storage%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><blockquote><p>只读的<code>localStorage</code> 属性允许你访问一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> 源（origin）的对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a>；存储的数据将保存在浏览器会话中。<code>localStorage</code> 类似 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除 。</p><p>应注意，无论数据存储在 <code>localStorage</code> 还是 <code>sessionStorage</code> ，<strong>它们都特定于页面的协议。</strong></p><p>另外，<code>localStorage</code> 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">myStorage = localStorage;</code></pre><h4 id="值"><a href="#值" class="headerlink" title="值"></a>值</h4><p>一个可被用于访问当前源（ origin ）的本地存储空间的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul><li><p><code>SecurityError</code></p><p>请求违反了一个策略声明，或者源（ origin ）不是 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Definition_of_an_origin">一个有效的 scheme/host/port tuple</a> （例如如果origin使用 <code>file:</code> 或者 <code>data:</code> 形式将可能发生）。比如，用户可以有禁用允许对指定的origin存留数据的浏览器配置。</p></li></ul><p>下面的代码片段访问了当前域名下的本地 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象，并通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/setItem"><code>Storage.setItem()</code></a> 增加了一个数据项目。</p><h4 id="setItem"><a href="#setItem" class="headerlink" title=".setItem()"></a>.setItem()</h4><pre><code>localStorage.setItem(&#39;myCat&#39;, &#39;Tom&#39;);</code></pre><h4 id="getItem"><a href="#getItem" class="headerlink" title=".getItem()"></a>.getItem()</h4><p>该语法用于读取 <code>localStorage</code> 项，如下:</p><pre><code>let cat = localStorage.getItem(&#39;myCat&#39;);</code></pre><h4 id="removeItem"><a href="#removeItem" class="headerlink" title=".removeItem()"></a>.removeItem()</h4><p>该语法用于移除 <code>localStorage</code> 项，如下:</p><pre><code>localStorage.removeItem(&#39;myCat&#39;);</code></pre><h4 id="clear"><a href="#clear" class="headerlink" title=".clear()"></a>.clear()</h4><p>该语法用于移除所有的 <code>localStorage</code> 项，如下:</p><pre><code>// 移除所有localStorage.clear();</code></pre><h4 id="localStorage是对象，有自己的属性或值"><a href="#localStorage是对象，有自己的属性或值" class="headerlink" title="localStorage是对象，有自己的属性或值"></a>localStorage是对象，有自己的属性或值</h4><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>localStorage.user = “admin”;</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>localStorage.user = “root”;</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>console.log(localStorage.user)</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>delete localStorage.user</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><blockquote><p><code>sessionStorage</code> 属性允许你访问一个 session <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象。它与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>localStorage</code></a> 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。<strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，</strong>这点和 session cookies 的运行方式不同。</p><p>应该注意，存储在sessionStorage或localStorage中的数据<strong>特定于该页面的协议</strong>。</p></blockquote><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">// 保存数据到 sessionStoragesessionStorage.setItem(&#39;key&#39;, &#39;value&#39;);// 从 sessionStorage 获取数据let data = sessionStorage.getItem(&#39;key&#39;);// 从 sessionStorage 删除保存的数据sessionStorage.removeItem(&#39;key&#39;);// 从 sessionStorage 删除所有保存的数据sessionStorage.clear();</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a> 对象。</p><h3 id="window-onStorage事件"><a href="#window-onStorage事件" class="headerlink" title="window.onStorage事件"></a>window.onStorage事件</h3><blockquote><p><strong>WindowEventHandlers.onstorage</strong> 属性包含一个在<code>storage</code>事件触发时的事件句柄。 当存储域发生改变时会触发事件。(例如： 有新的项被存储)</p><p>专门用来检测storage的变化</p><p><strong>不能直接使用，只能检测<code>非当前页面</code>的storage的变化</strong>，而且只能检测同一个服务器环境下的页面</p></blockquote><h4 id="event-key"><a href="#event-key" class="headerlink" title="event.key"></a>event.key</h4><blockquote><p>值发生变化的key</p></blockquote><h4 id="event-oldValue"><a href="#event-oldValue" class="headerlink" title="event.oldValue"></a>event.oldValue</h4><blockquote><p>改变前的值</p></blockquote><h4 id="event-newValue"><a href="#event-newValue" class="headerlink" title="event.newValue"></a>event.newValue</h4><blockquote><p>改变后的值</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code class="js">window.onstorage = function(e) &#123;  console.log( e.key + &#39; 键已经从 &#39; + e.oldValue + &#39; 改变为 &#39; + e.newValue + &#39;.&#39;);&#125;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-cookie</title>
      <link href="/2022/09/15/26%20COOKIES%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/26%20COOKIES%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="计算机通信协议"><a href="#计算机通信协议" class="headerlink" title="计算机通信协议"></a>计算机通信协议</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><blockquote><p>ip地址，标记，接入互联网的每台设备的唯一身份</p></blockquote><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><blockquote><p>数据：面向连接的协议，可靠，三次握手协议</p></blockquote><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote><p>数据：面向数据的协议，不可靠，容易造成数据丢失</p></blockquote><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><blockquote><p>网页，超文本传输协议，html，无状态协议，为了安全，节约，http每次建立连接，传输数据之后，会自动断开</p></blockquote><h4 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h4><blockquote><p>会话跟踪技术，帮助http记住状态</p></blockquote><h3 id="cookie的介绍"><a href="#cookie的介绍" class="headerlink" title="cookie的介绍"></a>cookie的介绍</h3><blockquote><p>用来记录客户端到服务器的一次连接过程中产生的各种状态</p><p>前后端数据交互的格式：字符</p></blockquote><h3 id="cookie记录状态"><a href="#cookie记录状态" class="headerlink" title="cookie记录状态"></a>cookie记录状态</h3><ul><li>怎么给服务器？跟随http协议，发往服务器</li><li>记录在哪？本地浏览器的缓存中，在硬盘上，不是内存</li><li>以什么形式记录？字符</li><li>大小限制：4K左右，1K=1024字节，1个中文，找2个字节</li><li>条数限制：50条左右</li><li>时间限制：默认是会话级，关闭浏览器自动删除；随意设置，没有永久，必须指定时间</li><li>使用限制：不允许跨域，不允许跨浏览器，不允许跨路径（父文件夹不能拿子文件夹中的cookie）</li></ul><h3 id="cookie的属性"><a href="#cookie的属性" class="headerlink" title="cookie的属性"></a>cookie的属性</h3><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>​    path表示cookie所在的目录，asp.net默认为/，就是根目录。</p><p>​    在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。</p><h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4><p>​    指定了cookie的生存期，默认情况下cookie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户退出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个用毫秒数表示的过期日期或时间点，expires默认为设置的expires的当前时间。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。</p><p>​    如果max-age属性为正数，则表示该cookie会在max-age秒之后自动失效。浏览器会将max-age为正数的cookie持久化，即写到对应的cookie文件中。无论客户关闭了浏览器还是电脑，只要还在max-age秒之前，登录网站时该cookie仍然有效。</p><p>​    如果max-age为负数，则表示该cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该cookie即失效。max-age为负数的Cookie，为临时性cookie，不会被持久化，不会被写到cookie文件中。cookie信息保存在浏览器内存中，因此关闭浏览器该cookie就消失了。cookie默认的max-age值为-1。</p><p>​    如果max-age为0，则表示删除该cookie。cookie机制没有提供删除cookie的方法，因此通过设置该cookie即时失效实现删除cookie的效果。失效的Cookie会被浏览器从cookie文件或者内存中删除。</p><p>如果不设置expires或者max-age这个cookie默认是Session的，也就是关闭浏览器该cookie就消失了。</p><p>​    这里要说明一下：Session的cookie在ie6下，如果用户实在网页上跳转打开页面或新开窗口（包括target=”_blank”，鼠标右键新开窗口），都是在同一个Session内。如果用户新开浏览器程序或者说是进程再打开当前的页面就不是同一个Session。其他浏览器只要你Session存在，还是同一个Session，cookie还能共享。在前段时间的项目中ie6下吃了很大一个亏。</p><h3 id="封装cookie"><a href="#封装cookie" class="headerlink" title="封装cookie"></a>封装cookie</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><pre><code class="js">function setCookie(key, val, options) &#123;    options = options || &#123;&#125;;    var time = &quot;&quot;;    if (options.Expires) &#123;        var d = new Date();        d.setDate(d.getDate() + options.Expires);        time = &quot;;expires=&quot; + d;    &#125;    var path = &quot;&quot;;    path = options.path ? &quot;;path=&quot; + options.path : &quot;&quot;;    document.cookie = key + &quot;=&quot; + val + time + path;&#125;setCookie(&quot;user&quot;,&quot;admin&quot;,&#123;    Expires:7,    path：&quot;/cookie&quot;&#125;)</code></pre><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><pre><code class="js">function setCookie(key, val, options) &#123;    options = options || &#123;&#125;;    var time = &quot;&quot;;    if (options.Expires) &#123;        var d = new Date();        d.setDate(d.getDate() + options.Expires);        time = &quot;;expires=&quot; + d;    &#125;    var path = &quot;&quot;;    path = options.path ? &quot;;path=&quot; + options.path : &quot;&quot;;    document.cookie = key + &quot;=&quot; + val + time + path;&#125;setCookie(&quot;user&quot;,&quot;admin&quot;,&#123;    Expires:7&#125;)setCookie(&quot;user&quot;,&quot;admin&quot;,&#123;    Expires:-1&#125;)//利用cookie有效期，将有效期调整为当前日期的前一天即可销毁</code></pre><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><pre><code class="js">function setCookie(key, val, options) &#123;    options = options || &#123;&#125;;    var time = &quot;&quot;;    if (options.Expires) &#123;        var d = new Date();        d.setDate(d.getDate() + options.Expires);        time = &quot;;expires=&quot; + d;    &#125;    var path = &quot;&quot;;    path = options.path ? &quot;;path=&quot; + options.path : &quot;&quot;;    document.cookie = key + &quot;=&quot; + val + time + path;&#125;setCookie(&quot;user&quot;,&quot;admin&quot;,&#123;    Expires:7&#125;)setCookie(&quot;user&quot;,&quot;123456&quot;,&#123;    Expires:6&#125;)</code></pre><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><pre><code class="js">function getCookie(key) &#123;    var arr = document.cookie.split(&quot;; &quot;);    var v = &quot;&quot;;    arr.forEach((val) =&gt; &#123;        if (val.split(&quot;=&quot;)[0] === key) &#123;            v = val.split(&quot;=&quot;)[1];        &#125;    &#125;)    return v;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-JSONP</title>
      <link href="/2022/09/15/25%20JSONP%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/25%20JSONP%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><blockquote><p>利用<script>标签可以跨域，让服务器端返回可执行的Javascript函数，参数为要回发的数据。</p></blockquote><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote><p><strong>同源策略</strong>限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的<strong>源</strong>。我们也可以把它称为“协议/主机/端口 tuple”，或简单地叫做“tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)</p><p>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><code>http://store.company.com/dir2/other.html</code></td><td>成功</td><td>只有路径不同</td></tr><tr><td><code>http://store.company.com/dir/inner/another.html</code></td><td>成功</td><td>只有路径不同</td></tr><tr><td><code>https://store.company.com/secure.html</code></td><td>失败</td><td>不同协议 ( https和http )</td></tr><tr><td><code>http://store.company.com:81/dir/etc.html</code></td><td>失败</td><td>不同端口 ( http:// 80是默认的)</td></tr><tr><td><code>http://news.company.com/dir/other.html</code></td><td>失败</td><td>不同域名 ( news和store )</td></tr></tbody></table><h3 id="JSON和JSONP"><a href="#JSON和JSONP" class="headerlink" title="JSON和JSONP"></a>JSON和JSONP</h3><p>JSONP和JSON好像啊，他们之间有什么联系吗？</p><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。对于JSON大家应该是很了解了吧，不是很清楚的朋友可以去<a href="https://link.zhihu.com/?target=http://www.json.org/json-zh.html">json.org</a>上了解下，简单易懂。</p><p><strong>JSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。</strong>–来源百度</p><p>　　JSONP就像是JSON+Padding一样(Padding这里我们理解为填充)， 我们先看下面的小例子然后再详细介绍。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><pre><code class="js">var url = &quot;http://localhost/myown/jsonp/jsonp2.php&quot;;document.onclick = function () &#123;    jsonp(url, (res) =&gt; &#123;        console.log(res);    &#125;, &#123;        cb: &quot;qwe&quot;,        cbname: &quot;cb&quot;,        user: &quot;root&quot;,        pass: &quot;root&quot;    &#125;)&#125;function jsonp(url, callback, obj) &#123;    var str = &quot;&quot;;    var script = document.createElement(&quot;script&quot;);    for (var i in obj) &#123;        str += `$&#123;i&#125;=$&#123;obj[i]&#125;&amp;`;    &#125;    url = url + &quot;?&quot; + str + &quot;__retr0__=&quot; + new Date().getTime();    script.src = url;    document.body.appendChild(script);    window[obj[obj.cbname]] = function (res) &#123;            callback(res);    &#125;    script.remove();&#125;</code></pre><h4 id="php代码"><a href="#php代码" class="headerlink" title="php代码"></a>php代码</h4><pre><code class="php">&lt;?php$u = $_GET[&quot;user&quot;];$p = $_GET[&quot;pass&quot;];$cb = $_GET[&quot;cb&quot;];$data = &quot;这是JSONP接受到的数据&quot; . $u . &quot;------&quot; . $p;echo &quot;$cb(&#39;&quot; . $data . &quot;&#39;)&quot;;?&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-Event-Loop</title>
      <link href="/2022/09/15/21%20Event-Loop%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/21%20Event-Loop%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event-Loop"></a>Event-Loop</h2><h3 id="JavaScript的运行机制"><a href="#JavaScript的运行机制" class="headerlink" title="JavaScript的运行机制"></a>JavaScript的运行机制</h3><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p><p>（2）主线程之外，还存在”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p><p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p><p>（4）主线程不断重复上面的第三步</p><p>概括即是: 调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作</p><blockquote><p>一个事件循环中有一个或者是多个任务队列</p></blockquote><h3 id="异步任务分类"><a href="#异步任务分类" class="headerlink" title="异步任务分类"></a>异步任务分类</h3><ol><li>宏任务: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering</li><li>微任务: process.nextTick（Nodejs）, Promises, Object.observe, MutationObserver</li></ol><h3 id="Event-Loop定义"><a href="#Event-Loop定义" class="headerlink" title="Event-Loop定义"></a>Event-Loop定义</h3><p>主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行。</p><blockquote><h4 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明:"></a>详细说明:</h4></blockquote><ol><li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会跳转至microtask的执行步骤。</li><li>将事件循环的当前运行宏任务设置为已选择的宏任务。</li><li>运行宏任务。</li><li>将事件循环的当前运行任务设置为null。</li><li>将运行完的宏任务从宏任务队列中移除。</li><li>microtasks步骤：进入microtask检查点。</li><li>更新界面渲染。</li><li>返回第一步。</li></ol><p><strong>执行进入microtask检查的的具体步骤如下:</strong></p><ol><li>设置进入microtask检查点的标志为true。</li><li>当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束的microtask从microtask队列中移除。</li><li>对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为rejected。</li><li>清理indexedDB的事务。</li><li>设置进入microtask检查点的标志为false。</li></ol><p><strong>需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个事件。同一次事件循环中, 微任务永远在宏任务之前执行。</strong></p><p>图示:</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a4038c4e156f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="event-loop2"></p><p>先看一个简单的示例：</p><pre><code class="js">setTimeout(()=&gt;&#123;    console.log(&quot;setTimeout1&quot;);    Promise.resolve().then(data =&gt; &#123;        console.log(222);    &#125;);&#125;);setTimeout(()=&gt;&#123;    console.log(&quot;setTimeout2&quot;);&#125;);Promise.resolve().then(data=&gt;&#123;    console.log(111);&#125;);</code></pre><p>思考一下, 运行结果是什么？</p><p>运行结果为:</p><pre><code class="js">111setTimeout1222setTimeout2</code></pre><p>我们来看一下为什么？</p><p>我们来详细说明一下, JS引擎是如何执行这段代码的:</p><ol><li>主线程上没有需要执行的代码</li><li>接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)。</li><li>接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在再下一次的事件循环中执行)。</li><li>首先检查微任务队列, 即 microtask队列，发现此队列不为空，执行第一个promise的then回调，输出 ‘111’。</li><li>此时microtask队列为空，进入下一个事件循环, 检查宏任务队列，发现有 setTimeout的回调函数，立即执行回调函数输出 ‘setTimeout1’,检查microtask 队列，发现队列不为空，执行promise的then回调，输出’222’，microtask队列为空，进入下一个事件循环。</li><li>检查宏任务队列，发现有 setTimeout的回调函数, 立即执行回调函数输出’setTimeout2’。</li></ol><p>再思考一下下面代码的执行顺序:</p><pre><code class="js">console.log(&#39;script start&#39;);setTimeout(function () &#123;    console.log(&#39;setTimeout---0&#39;);&#125;, 0);setTimeout(function () &#123;    console.log(&#39;setTimeout---200&#39;);    setTimeout(function () &#123;        console.log(&#39;inner-setTimeout---0&#39;);    &#125;);    Promise.resolve().then(function () &#123;        console.log(&#39;promise5&#39;);    &#125;);&#125;, 200);Promise.resolve().then(function () &#123;    console.log(&#39;promise1&#39;);&#125;).then(function () &#123;    console.log(&#39;promise2&#39;);&#125;);Promise.resolve().then(function () &#123;    console.log(&#39;promise3&#39;);&#125;);console.log(&#39;script end&#39;);</code></pre><p>思考一下, 运行结果是什么？</p><p>运行结果为:</p><pre><code class="js">script startscript endpromise1promise3promise2setTimeout---0setTimeout---200promise5inner-setTimeout---0</code></pre><p>那么为什么？</p><p>我们来详细说明一下, JS引擎是如何执行这段代码的:</p><ol><li>首先顺序执行完主进程上的同步任务，第一句和最后一句的console.log</li><li>接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)。</li><li>接着遇到setTimeout 200，它的作用是在 200ms 后将回调函数放到宏任务队列中(这个任务在再下一次的事件循环中执行)。</li><li>同步任务执行完之后，首先检查微任务队列, 即 microtask队列，发现此队列不为空，执行第一个promise的then回调，输出 ‘promise1’，然后执行第二个promise的then回调，输出’promise3’，由于第一个promise的.then()的返回依然是promise，所以第二个.then()会放到microtask队列继续执行，输出 ‘promise2’;</li><li>此时microtask队列为空，进入下一个事件循环, 检查宏任务队列，发现有 setTimeout的回调函数，立即执行回调函数输出 ‘setTimeout—0’,检查microtask 队列，队列为空，进入下一次事件循环.</li><li>检查宏任务队列，发现有 setTimeout的回调函数, 立即执行回调函数输出’setTimeout—200’.</li><li>接着遇到setTimeout 0，它的作用是在 0ms 后将回调函数放到宏任务队列中，检查微任务队列，即 microtask 队列，发现此队列不为空，执行promise的then回调，输出’promise5’。</li><li>此时microtask队列为空，进入下一个事件循环，检查宏任务队列，发现有 setTimeout 的回调函数，立即执行回调函数输出，输出’inner-setTimeout—0’。代码执行结束.</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-异步编程原理</title>
      <link href="/2022/09/15/20%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/20%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="异步编程原理"><a href="#异步编程原理" class="headerlink" title="异步编程原理"></a>异步编程原理</h2><p>JavaScript 引擎负责解析，执行 JavaScript 代码，但它并不能单独运行，通常都得有一个宿主环境，一般如浏览器或 Node 服务器，前文说到的单线程是指在这些宿主环境创建单一线程，提供一种机制，调用 JavaScript 引擎完成多个 JavaScript 代码块的调度，这种机制就称为事件循环（ Event Loop ）。</p><p>关于事件循环流程分解如下：</p><p>宿主环境为 JavaScript 创建线程时，会创建堆 (heap) 和栈 (stack) ，堆内存储 JavaScript 对象，栈内存储执行上下文；栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息；当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）；当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈；当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick ，事件循环流转一次称为一次 tick ）。</p><p><img src="https://pics0.baidu.com/feed/0b46f21fbe096b63bd7dd5dd79c34f40e9f8acc8.jpeg?token=4eca9533d590b3ed5e2e6922f0b2f7f2&s=25B06D335D38DE011A4534CB02008033" alt="img"></p><p>很多的队列先后按顺序执行任务就形成了 Event</p><h3 id="异步编程实现"><a href="#异步编程实现" class="headerlink" title="异步编程实现"></a>异步编程实现</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>优点：简单、容易理解和部署。</p><p>缺点：不利于代码的阅读和维护，各个部分之间高度耦合（ Coupling ），流程会很混乱。</p><h4 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h4><p>一个 promise 可能有三种状态：等待（ pending ）、已完成（ fulfilled ）、已拒绝（ rejected ） ;</p><p><img src="https://pics4.baidu.com/feed/72f082025aafa40ffd6105ccde94cb4b79f01975.jpeg?token=ca08273304b97bbb1f079bc3c4fd60d2&s=0C98ED1209D86CC80EDDC5DE0000D0B1" alt="img"></p><p>resolve，接受一个成功值，传递给绑定的 fulfilled 回调函数中。主要工作是将当前状态变为 fulfilled 状态，同时调用绑定的 fulfilled 回调函数。</p><p>reject，接受一个失败信息，传递给绑定的 rejected 回调函数中。主要工作是将当前状态变为 rejected 状态，同时调用绑定的 rejected 回调函数。</p><p>then 方法返回一个 Promise。它有两个参数，分别为 Promise 在成功和失败情况下的回调函数。</p><p>语法：</p><p><img src="https://pics1.baidu.com/feed/e850352ac65c1038cfb273fcc7e15b17b17e8931.jpeg?token=0b84ad8e7ccb941b4adf70720dd0d877&s=6D9AEC121F406D430CFCE5DA0000D0B2" alt="img"></p><p><img src="https://pics3.baidu.com/feed/dc54564e9258d10962760abda7a804bb6d814d19.jpeg?token=3d55d771aa3792b50b2603d9662fe9f7&s=59A83C72953044231C75E8DE0000C0B3" alt="img"></p><p>概括来说 promise 是对异步的执行结果的描述对象。</p><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案 ，允许函数的暂停和恢复。</p><p>异步任务的封装：</p><p><img src="https://pics1.baidu.com/feed/a044ad345982b2b751bdbddb445d03eb77099b80.jpeg?token=528b67eb6f61d06dcbf8d5787c676dc2&s=4D00ED1201D84DC8187C01DA000050B2" alt="img"></p><p>整个过程类似于，浏览器遇到标识符 * 之后，就明白这个函数是生成器函数，一旦遇到 yield 标识符，就会将以后的函数放入此异步函数之内，待异步返回结果后再进行执行。</p><p>更深一步，从内存上来讲：</p><p>普通函数在被调用时，JS 引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。</p><p>当执行到 yield 语句时， Generator 的栈帧同样会被弹出栈外，但 Generator 在这里耍了个花招 —— 它在堆里保存了栈帧的引用（或拷贝）！这样当 it.next 方法被调用时， JS 引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当这一切都被恢复如初之时，就好像程序从原本暂停的地方继续向前执行了。</p><p>而因为每次 yield 和 it.next 都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-类</title>
      <link href="/2022/09/15/19%20%E7%B1%BB%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/19%20%E7%B1%BB%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法<strong>不会</strong>为JavaScript引入新的面向对象的继承模型。</p></blockquote><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>类实际上是个“特殊的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions">函数</a>”，就像你能够定义的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">函数声明</a>一样，类语法有两个组成部分：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/class">类表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class">类声明</a>。</p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>定义一个类的一种方法是使用一个<strong>类声明</strong>。要声明一个类，你可以使用带有<code>class</code>关键字的类名（这里是“Rectangle”）。</p><pre><code class="js">class Rectangle &#123;  constructor(height, width) &#123;    this.height = height;    this.width = width;  &#125;&#125;</code></pre><h3 id="不会提升"><a href="#不会提升" class="headerlink" title="不会提升"></a>不会提升</h3><p><strong>函数声明</strong>和<strong>类声明</strong>之间的一个重要区别是函数声明会<a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">提升</a>，类声明不会。你首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"><code>ReferenceError</code></a>：</p><pre><code class="js">let p = new Rectangle(); // ReferenceErrorclass Rectangle &#123;&#125;</code></pre><h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>一个<strong>类表达式</strong>是定义一个类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。</p><pre><code class="js">/* 匿名类 */ let Rectangle = class &#123;  constructor(height, width) &#123;    this.height = height;    this.width = width;  &#125;&#125;;/* 命名的类 */ let Rectangle = class Rectangle &#123;  constructor(height, width) &#123;    this.height = height;    this.width = width;  &#125;&#125;;</code></pre><p><strong>注意:</strong> 类<strong>表达式</strong>也同样受到类<strong>声明</strong>中提到的提升问题的限制。</p><h3 id="使用-extends-创建子类"><a href="#使用-extends-创建子类" class="headerlink" title="使用 extends 创建子类"></a>使用 extends 创建子类</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-正则表达式</title>
      <link href="/2022/09/15/15%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/15%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。本章介绍 JavaScript 正则表达式。</p></blockquote><h3 id="创建正则"><a href="#创建正则" class="headerlink" title="创建正则"></a>创建正则</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><pre><code class="js">var reg = /a/; var r1 = /test/g;</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="js">var reg = new RegExp(&quot;a&quot;);var r2 = new RegExp(&#39;test&#39;, &#39;g&#39;);</code></pre><h3 id="使用正则"><a href="#使用正则" class="headerlink" title="使用正则"></a>使用正则</h3><h4 id="reg-test-str"><a href="#reg-test-str" class="headerlink" title="reg.test(str)"></a>reg.test(str)</h4><blockquote><p><code>test()</code> 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p></blockquote><ul><li><p>语法</p><pre><code class="js">regexObj.test(str)</code></pre></li><li><p>返回值</p><p>如果正则表达式与指定的字符串匹配 ，返回<code>true</code>；否则<code>false</code>。</p></li><li><p>实例</p><pre><code class="js">let str = &#39;hello world!&#39;;let result = /^hello/.test(str);console.log(result); // true</code></pre></li></ul><h4 id="reg-exec-str"><a href="#reg-exec-str" class="headerlink" title="reg.exec(str)"></a>reg.exec(str)</h4><blockquote><p><code>exec() </code>方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p><p>如果你只是为了判断是否匹配（true或 false），可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>RegExp.test()</code></a> 方法，或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>String.search()</code></a> 方法。</p></blockquote><ul><li><p>语法</p><pre><code class="js">regexObj.exec(str)</code></pre></li><li><p>返回值</p><p>如果匹配成功，<code>exec</code>() 方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。</p><p>如果匹配失败，exec() 方法返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p></li><li><p>实例</p><pre><code class="js">var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:([0-5][0-9])\:([0-5][0-9])$/;console.log(re.exec(&#39;19:05:30&#39;)); // [&#39;19:05:30&#39;, &#39;19&#39;, &#39;05&#39;, &#39;30&#39;]</code></pre></li></ul><h4 id="str-match-reg"><a href="#str-match-reg" class="headerlink" title="str.match(reg)"></a>str.match(reg)</h4><blockquote><p><strong><code>match()</code></strong> 方法检索返回一个字符串匹配正则表达式的的结果。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.match(regexp)</code></pre></li><li><p>返回值</p><ul><li>如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</li><li>如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（<code>Array</code>）。 在这种情况下，返回的项目将具有如下所述的其他属性。</li></ul></li><li><p>实例</p><pre><code class="js">var str = &#39;For more information, see Chapter 3.4.5.1&#39;;var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// logs [ &#39;see Chapter 3.4.5.1&#39;,//        &#39;Chapter 3.4.5.1&#39;,//        &#39;.1&#39;,//        index: 22,//        input: &#39;For more information, see Chapter 3.4.5.1&#39; ]// &#39;see Chapter 3.4.5.1&#39; 是整个匹配。// &#39;Chapter 3.4.5.1&#39; 被&#39;(chapter \d+(\.\d)*)&#39;捕获。// &#39;.1&#39; 是被&#39;(\.\d)&#39;捕获的最后一个值。// &#39;index&#39; 属性(22) 是整个匹配从零开始的索引。// &#39;input&#39; 属性是被解析的原始字符串。</code></pre></li></ul><h4 id="str-replace-reg-newstr"><a href="#str-replace-reg-newstr" class="headerlink" title="str.replace(reg,newstr)"></a>str.replace(reg,newstr)</h4><blockquote><p><strong><code>replace()</code></strong> 方法返回一个由替换值（<code>replacement</code>）替换一些或所有匹配的模式（<code>pattern</code>）后的新字符串。模式可以是一个字符串或者一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp">正则表达式</a>，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。</p><p>原字符串不会改变。</p></blockquote><ul><li><p>语法</p><pre><code class="js">一个部分或全部匹配由替代模式所取代的新的字符串。</code></pre></li><li><p>返回值</p><p>如果正则表达式与指定的字符串匹配 ，返回<code>true</code>；否则<code>false</code>。</p></li><li><p>实例</p><pre><code class="js">var str2 = &quot; andy Wu &quot;;var reg2 = /(^\s*)|(\s*$)/g;console.log(str2.replace(reg2,&quot;&quot;))//&quot;andy Wu&quot;</code></pre></li></ul><h4 id="str-search-reg"><a href="#str-search-reg" class="headerlink" title="str.search(reg)"></a>str.search(reg)</h4><blockquote><p><strong><code>search()</code></strong> 方法执行正则表达式和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 对象之间的一个搜索匹配。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.search(regexp)</code></pre></li><li><p>返回值</p><p>如果匹配成功，则 <code>search()</code> 返回正则表达式在字符串中首次匹配项的索引;否则，返回 <strong>-1</strong>。</p></li><li><p>实例</p><pre><code class="js">var str = &quot;hey JudE&quot;;var re = /[A-Z]/g;var re2 = /[.]/g;console.log(str.search(re)); // returns 4, which is the index of the first capital letter &quot;J&quot;console.log(str.search(re2)); // returns -1 cannot find &#39;.&#39; dot punctuation</code></pre></li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h4 id="g：全局"><a href="#g：全局" class="headerlink" title="g：全局"></a>g：全局</h4><h4 id="i-忽略大小写"><a href="#i-忽略大小写" class="headerlink" title="i:忽略大小写"></a>i:忽略大小写</h4><h4 id="：或"><a href="#：或" class="headerlink" title="|：或"></a>|：或</h4><blockquote><p>匹配‘x’或者‘y’。</p><p>例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</p></blockquote><h4 id="：至少一个"><a href="#：至少一个" class="headerlink" title="+：至少一个"></a>+：至少一个</h4><blockquote><p>匹配前面一个表达式 1 次或者多次。等价于 <code>&#123;1,&#125;</code>。</p><p>例如，<code>/a+/</code> 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。</p></blockquote><h4 id="：0到1个"><a href="#：0到1个" class="headerlink" title="?：0到1个"></a>?：0到1个</h4><blockquote><p>匹配前面一个表达式 0 次或者 1 次。等价于 <code>&#123;0,1&#125;</code>。</p><p>例如，<code>/e?le?/</code> 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。</p><p>如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 <code>/\d+/</code> 将会匹配 “123”，而使用 <code>/\d+?/</code> 则只会匹配到 “1”。</p><p>还用于先行断言中，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目所述。</p></blockquote><h4 id="：0到多个"><a href="#：0到多个" class="headerlink" title="*：0到多个"></a>*：0到多个</h4><blockquote><p> 匹配前一个表达式 0 次或多次。等价于 <code>&#123;0,&#125;</code>。例如，<code>/bo*/</code> 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。</p></blockquote><h4 id=""><a href="#" class="headerlink" title="."></a>.</h4><blockquote><p>（小数点）默认匹配除换行符之外的任何单个字符。</p><p>例如，<code>/.n/</code> 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</p><p>如果 <code>s</code> (“dotAll”) 标志位被设为 true，它也会匹配换行符。</p></blockquote><h4 id="-1"><a href="#-1" class="headerlink" title="{}"></a>{}</h4><table><thead><tr><th><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier"><code>&#123;n&#125;</code></a></th><th>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如， /a{2}/ 不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个’a’。</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier"><code>&#123;n,&#125;</code></a></td><td>n是一个正整数，匹配前一个字符至少出现了n次。例如, /a{2,}/ 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-quantifier-range"><code>&#123;n,m&#125;</code></a></td><td>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</td></tr></tbody></table><blockquote></blockquote><h4 id="-2"><a href="#-2" class="headerlink" title="()"></a>()</h4><blockquote><p>一个整体，按照小括号的而出现顺序，分为第一部分，第二部分,..</p></blockquote><table><thead><tr><th><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-capturing-parentheses"><code>(x)</code></a></th><th>像下面的例子展示的那样，它会匹配 ‘x’ 并且记住匹配项。其中括号被称为<em>捕获括号</em>。模式 <code>/(foo) (bar) \1 \2/</code> 中的 ‘<code>(foo)</code>‘ 和 ‘<code>(bar)</code>‘ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 <code>\1</code> 和 <code>\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\1</code>、<code>\2</code>、…、<code>\n</code> 是用在正则表达式的匹配环节，详情可以参阅后文的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions$edit#special-backreference">\n</a> 条目。而在正则表达式的替换环节，则要使用像 <code>$1</code>、<code>$2</code>、…、<code>$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-capturing-parentheses"><code>(?:x)</code></a></td><td>匹配 ‘x’ 但是不记住匹配项。这种括号叫作<em>非捕获括号</em>，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 <code>/(?:foo)&#123;1,2&#125;/</code>。如果表达式是 <code>/foo&#123;1,2&#125;/</code>，<code>&#123;1,2&#125;</code> 将只应用于 ‘foo’ 的最后一个字符 ‘o’。如果使用非捕获括号，则 <code>&#123;1,2&#125;</code> 会应用于整个 ‘foo’ 单词。更多信息，可以参阅下文的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses">Using parentheses</a> 条目.</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead"><code>x(?=y)</code></a></td><td>匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-lookahead"><code>(?&lt;=y)</code></a>x</td><td>匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。例如，/(?&lt;=Jack)Sprat/会匹配到’ Sprat ‘仅仅当它前面是’ Jack ‘。/(?&lt;=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是’Jack’或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-look-ahead"><code>x(?!y)</code></a></td><td>仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!.)/ 匹配一个数字。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</td></tr><tr><td>`(?</td><td>仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。例如, 仅仅当这个数字前面没有负号的时候，<code>/(? 匹配一个数字。 </code>/(? 匹配到 “3”. `/(? 因为这个数字前有负号，所以没有匹配到。</td></tr></tbody></table><h4 id="-3"><a href="#-3" class="headerlink" title="[]"></a>[]</h4><blockquote><p>中元符，中括号中的内容会依次取或</p></blockquote><table><thead><tr><th><code>[xyz\]</code></th><th>一个字符集合。匹配方括号中的任意字符，包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types">转义序列</a>。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</th></tr></thead><tbody><tr><td><code>[^xyz\]</code></td><td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。</td></tr><tr><td><code>[\b\]</code></td><td>匹配一个退格(U+0008)。（不要和\b混淆了。）</td></tr></tbody></table><h4 id="-4"><a href="#-4" class="headerlink" title="\"></a>\</h4><blockquote><p>依照下列规则匹配：</p><p>在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 “&quot; 的 “b” 通常匹配小写字母 “b”，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 “&quot;，它将不再匹配任何字符，而是表示一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note">字符边界</a>。</p><p>在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 “转义（Escaping）” 部分。</p><p>如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。<code>/[a-z]\s/i</code> 和 <code>new RegExp(&quot;[a-z]\\s&quot;, &quot;i&quot;)</code> 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（<code>\s</code> 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和表达式级别都对它进行转义。例如 <code>/[a-z]:\\/i</code> 和 <code>new RegExp(&quot;[a-z]:\\\\&quot;,&quot;i&quot;)</code> 会创建相同的表达式，即匹配类似 “C:&quot; 字符串。</p></blockquote><table><thead><tr><th><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word-boundary"><code>\b</code></a></th><th>匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）使用”moon”举例： /\bm/匹配“moon”中的‘m’； /oo\b/并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。 /oon\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。<strong>注意:</strong> JavaScript的正则表达式引擎将<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6">特定的字符集</a>定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word-boundary"><code>\B</code></a></td><td>匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，/\B../匹配”noonday”中的’oo’, 而/y\B../匹配”possibly yesterday”中的’yes‘</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-control"><code>\c*X*</code></a></td><td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，<code>/\cM/</code> 匹配字符串中的 control-M (U+000D)。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-digit"><code>\d</code></a></td><td>匹配一个数字<code>。``等价于[0-9]</code>。例如， <code>/\d/</code> 或者 <code>/[0-9]/</code> 匹配”B2 is the suite number.”中的’2’。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-digit"><code>\D</code></a></td><td>匹配一个非数字字符<code>。``等价于[^0-9]</code>。例如， <code>/\D/</code> 或者 <code>/[^0-9]/</code> 匹配”B2 is the suite number.”中的’B’ 。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-form-feed"><code>\f</code></a></td><td>匹配一个换页符 (U+000C)。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-line-feed"><code>\n</code></a></td><td>匹配一个换行符 (U+000A)。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-carriage-return"><code>\r</code></a></td><td>匹配一个回车符 (U+000D)。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space"><code>\s</code></a></td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如, <code>/\s\w*/</code> 匹配”foo bar.”中的’ bar’。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-white-space"><code>\S</code></a></td><td>匹配一个非空白字符。等价于 <code>[^ </code>\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code>。例如，<code>/\S\w*/</code> 匹配”foo bar.”中的’foo’。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-tab"><code>\t</code></a></td><td>匹配一个水平制表符 (U+0009)。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-vertical-tab"><code>\v</code></a></td><td>匹配一个垂直制表符 (U+000B)。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-word"><code>\w</code></a></td><td>匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。例如, <code>/\w/</code> 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-word"><code>\W</code></a></td><td>匹配一个非单字字符。等价于 <code>[^A-Za-z0-9_]</code>。例如, <code>/\W/</code> 或者 <code>/[^A-Za-z0-9_]/</code> 匹配 “50%.” 中的 ‘%’。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-backreference"><code>\*n*</code></a></td><td>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 <code>/apple(,)\sorange\1/</code> 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-null"><code>\0</code></a></td><td>匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 <code>\0</code> 是一个八进制转义序列。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-hex-escape"><code>\xhh</code></a></td><td>与代码 hh 匹配字符（两个十六进制数字）</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-unicode-escape"><code>\uhhhh</code></a></td><td>与代码 hhhh 匹配字符（四个十六进制数字）。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-unicode-escape-es6"><code>\u&#123;hhhh&#125;</code></a></td><td>（仅当设置了u标志时）使用 Unicode 值 hhhh 匹配字符（十六进制数字）。</td></tr></tbody></table><h4 id="d"><a href="#d" class="headerlink" title="\d"></a>\d</h4><blockquote><p>0-9的数组</p></blockquote><h4 id="w"><a href="#w" class="headerlink" title="\w"></a>\w</h4><blockquote><p>数字字母下划线，[0-9a-zA-Z_]</p></blockquote><h4 id="D"><a href="#D" class="headerlink" title="\D"></a>\D</h4><blockquote><p>除了数字</p></blockquote><h4 id="W"><a href="#W" class="headerlink" title="\W"></a>\W</h4><blockquote><p>除了数字字母下划线</p></blockquote><h4 id="-5"><a href="#-5" class="headerlink" title="^"></a>^</h4><blockquote><p>除了，非，但是仅限在[]中使用时，才是这个意思</p><p>开头，在[]外使用才是这个意思</p><p>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</p><p>例如，<code>/^A/</code> 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。</p><p>当 ‘<code>^</code>‘ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set">反向字符集合</a> 一节有详细介绍和示例。</p></blockquote><h4 id="-6"><a href="#-6" class="headerlink" title="$"></a>$</h4><blockquote><p>匹配输入的结束。如果多行标示被设置为 true，那么也匹配换行符前的位置。</p><p>例如，<code>/t$/</code> 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</p></blockquote><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p><pre><code class="js">var re = /^(\d+)(0*)$/;re.exec(&#39;102300&#39;); // [&#39;102300&#39;, &#39;102300&#39;, &#39;&#39;]</code></pre><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><pre><code class="js">var re = /^(\d+?)(0*)$/;re.exec(&#39;102300&#39;); // [&#39;102300&#39;, &#39;1023&#39;, &#39;00&#39;]</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-Event 对象</title>
      <link href="/2022/09/15/14%20Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/14%20Event%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h3><blockquote><p>​    Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p><p>​    事件通常与函数结合使用，函数不会在事件发生前被执行！</p><p>​    注意，所有事件的语法都是一样的，行为的触发方式有区别</p></blockquote><p><strong>只有在事件发生的时候，才会产生事件对象，无法手动创建，并且事件对象只能在处理函数内部访问，处理函数允许结束后该对象自动销毁</strong></p><p>绑定方式：赋值式</p><pre><code class="js">元素.事件名 = function()&#123;&#125;;</code></pre><ul><li>事件源：元素，绑定事件的元素</li><li>事件类型：onclick：触发事件的行为</li><li>事件处理函数：function：触发这个事件时要做的事情</li></ul><h4 id="获取事件对象"><a href="#获取事件对象" class="headerlink" title="获取事件对象"></a>获取事件对象</h4><p>事件处理函数的第一个参数：正常浏览器</p><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    console.log(eve);&#125;</code></pre><p>通过window找event属性：IE浏览器</p><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    console.log(window.event);&#125;</code></pre><h5 id="兼容性写法"><a href="#兼容性写法" class="headerlink" title="兼容性写法"></a>兼容性写法</h5><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    var e = eve || window.event;&#125;</code></pre><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>事件类型</p><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    var e = eve || window.event;    console.log(e.type)//click，这里显示触发事件的类型&#125;</code></pre><h5 id="target"><a href="#target" class="headerlink" title="target"></a>target</h5><blockquote><p>触发事件的对象 (某个DOM元素) 的引用。当事件处理程序在事件的冒泡或捕获阶段被调用时，它与<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/currentTarget"><code>event.currentTarget</code></a>不同。</p></blockquote><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    var e = eve || window.event;    console.log(e.target)//&lt;div class=&quot;box&gt;&lt;/div&gt;&quot;，这里显示触发事件的对象&#125;</code></pre><h5 id="button"><a href="#button" class="headerlink" title="button"></a>button</h5><blockquote><p>**<code>mouseEvent.button</code>**是只读属性，它返回一个值，代表用户按下并触发了事件的鼠标按键。</p><p>这个属性只能够表明在触发事件的单个或多个按键按下或释放过程中哪些按键被按下了。因此，它对判断<code>mouseenter</code>, <code>mouseleave</code>, <code>mouseover</code>, <code>mouseout</code> or <code>mousemove</code>这些事件并不可靠。</p><p>用户可能会改变鼠标按键的配置，因此当一个事件的**<code>MouseEvent.button</code>**值为0时，它可能不是由物理上设备最左边的按键触发的。但是对于标准按键布局的鼠标设备来说，这个值应该是能正确使用的。</p></blockquote><ul><li><p>语法</p><pre><code class="js">var buttonPressed = instanceOfMouseEvent.button</code></pre></li><li><p>返回值</p><p>一个数值，代表按下的鼠标按键：</p><p>0：主按键被按下，通常指鼠标左键 or the un-initialized state<br>1：辅助按键被按下，通常指鼠标滚轮 or the middle button (if present)<br>2：次按键被按下，通常指鼠标右键<br>3：第四个按钮被按下，通常指浏览器后退按钮<br>4：第五个按钮被按下，通常指浏览器的前进按钮<br>对于配置为左手使用的鼠标，按键操作将正好相反。此种情况下，从右至左读取值。</p></li><li><p>实例</p><pre><code class="js">var whichButton = function (e) &#123;    // Handle different event models    var e = e || window.event;    var btnCode;    if (&#39;object&#39; === typeof e) &#123;        btnCode = e.button;        switch (btnCode) &#123;            case 0:                console.log(&#39;Left button clicked.&#39;);            break;            case 1:                console.log(&#39;Middle button clicked.&#39;);            break;            case 2:                console.log(&#39;Right button clicked.&#39;);            break;            default:                console.log(&#39;Unexpected code: &#39; + btnCode);        &#125;    &#125;&#125;</code></pre></li></ul><h5 id="buttons"><a href="#buttons" class="headerlink" title="buttons"></a>buttons</h5><p>返回对应的鼠标按键</p><h4 id="MouseEvent"><a href="#MouseEvent" class="headerlink" title="MouseEvent."></a>MouseEvent.</h4><p><img src="file:///D:/APP/feiq/Recv%20Files/JavaScript/%E8%AF%BE%E4%BB%B6/day11/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-%E4%B8%8A_files/Image%20[3].png" alt="img"></p><p>鼠标相对于事件源的坐标</p><h5 id="offsetX"><a href="#offsetX" class="headerlink" title="offsetX"></a>offsetX</h5><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>MouseEvent</code></a> 接口的只读属性 <strong>offsetX</strong> 规定了事件对象与目标节点的内填充边（padding edge）在 X 轴方向上的偏移量。</p><p>鼠标相对于事件源的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var xOffset = instanceOfMouseEvent.offsetX;</code></pre></li><li><p>返回值</p><pre><code class="js">一个双精度浮点值。早期的规范将其规定为整数值。详见浏览器兼容性部分。</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><h5 id="offsetY"><a href="#offsetY" class="headerlink" title="offsetY"></a>offsetY</h5><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>MouseEvent</code></a> 接口的只读属性 <strong>offsetX</strong> 规定了事件对象与目标节点的内填充边（padding edge）在 X 轴方向上的偏移量。</p><p>鼠标相对于事件源的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var xOffset = instanceOfMouseEvent.offsetX;</code></pre></li><li><p>返回值</p><pre><code class="js">一个双精度浮点值。早期的规范将其规定为整数值。详见浏览器兼容性部分。</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><p>鼠标相对于页面可视区域的坐标</p><h5 id="clientX"><a href="#clientX" class="headerlink" title="clientX"></a>clientX</h5><blockquote><p><strong><code>MouseEvent.clientX</code></strong> 是只读属性， 它提供事件发生时的应用客户端区域的水平坐标 (与页面坐标不同)。例如，不论页面是否有水平滚动，当你点击客户端区域的左上角时，鼠标事件的 <code>clientX</code> 值都将为 0 。最初这个属性被定义为长整型（long integer），如今 <strong>CSSOM</strong> 视图模块将其重新定义为双精度浮点数（double float）。</p><p>鼠标相对于页面可视区域的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var x = instanceOfMouseEvent.clientX</code></pre></li><li><p>返回值</p><pre><code class="js">被 CSSOM View Module 重新定义为一个 double 类型的浮点值. 原来这个属性是被定义为一个 long 整数. 可以在 &quot;浏览器兼容性&quot; 那里查看详细内容.</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><h5 id="clientY"><a href="#clientY" class="headerlink" title="clientY"></a>clientY</h5><blockquote><p><strong><code>MouseEvent.clientX</code></strong> 是只读属性， 它提供事件发生时的应用客户端区域的Y坐标 (与页面坐标不同)。例如，不论页面是否有水平滚动，当你点击客户端区域的左上角时，鼠标事件的 <code>clientX</code> 值都将为 0 。最初这个属性被定义为长整型（long integer），如今 <strong>CSSOM</strong> 视图模块将其重新定义为双精度浮点数（double float）。</p><p>鼠标相对于页面可视区域的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var x = instanceOfMouseEvent.clientY</code></pre></li><li><p>返回值</p><pre><code class="js">被 CSSOM View Module 重新定义为一个 double 类型的浮点值. 原来这个属性是被定义为一个 long 整数. 可以在 &quot;浏览器兼容性&quot; 那里查看详细内容.</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><p>鼠标相对于页面的坐标</p><h5 id="pageX"><a href="#pageX" class="headerlink" title="pageX"></a>pageX</h5><blockquote><p><code>pageX</code> 是一个由<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>MouseEvent</code></a>接口返回的相对于整个文档的x（水平）坐标以像素为单位的只读属性。</p><p>这个属性将基于文档的边缘，考虑任何页面的水平方向上的滚动。举个例子，如果页面向右滚动 200px 并出现了滚动条，这部分在窗口之外，然后鼠标点击距离窗口左边 100px 的位置，pageX 所返回的值将是 300。</p><p>起初这个属性被定义为长整型。 CSSOM 视图模块将它重新定位为双浮点数类型。请参阅浏览器兼容性部分了解详情。</p><p>鼠标相对于页面的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var pos = event.pageX</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><h5 id="pageY"><a href="#pageY" class="headerlink" title="pageY"></a>pageY</h5><blockquote><p>pageY<code> 是一个由[</code>MouseEvent`](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent)%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%95%B4%E4%B8%AA%E6%96%87%E6%A1%A3%E7%9A%84Y%EF%BC%88%E6%B0%B4%E5%B9%B3%EF%BC%89%E5%9D%90%E6%A0%87%E4%BB%A5%E5%83%8F%E7%B4%A0%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent)接口返回的相对于整个文档的Y（水平）坐标以像素为单位的只读属性。</a></p><p>鼠标相对于页面的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var pos = event.pageY</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><p>鼠标相对于屏幕的坐标</p><h5 id="screenX"><a href="#screenX" class="headerlink" title="screenX"></a>screenX</h5><blockquote><p><strong><code>screenX</code></strong> 是只读属性，他提供了鼠标相对于屏幕坐标系的水平偏移量。</p><p>鼠标相对于屏幕的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var pixelNumber = instanceOfMouseEvent.screenX</code></pre></li><li><p>返回值</p><pre><code class="js">一个双浮点值。早期版本的规格定义这是一个 整数指的像素数。有关详细信息，请参见浏览器兼容性部分。</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;    var e = eve || window.event;    console.log(e.offsetX,e.offsetY)    console.log(e.clientX,e.clientY)    console.log(e.pageX,e.pageY)    console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><h5 id="screenY"><a href="#screenY" class="headerlink" title="screenY"></a>screenY</h5><blockquote><p><strong><code>screenY</code></strong> 是只读属性，他提供了鼠标相对于屏幕坐标系的垂直偏移量。</p><p>鼠标相对于屏幕的坐标</p></blockquote><ul><li><p>语法</p><pre><code class="js">var pixelNumber = instanceOfMouseEvent.screenY</code></pre></li><li><p>返回值</p><pre><code class="js">一个双浮点值。早期版本的规格定义这是一个 整数指的像素数。有关详细信息，请参见浏览器兼容性部分。</code></pre></li><li><p>实例</p><pre><code class="js">var box = document.querySelector(&quot;.box&quot;);box.onclick = (eve)=&gt;&#123;var e = eve || window.event;console.log(e.offsetX,e.offsetY)console.log(e.clientX,e.clientY)console.log(e.pageX,e.pageY)console.log(e.screenX,e.screenY)&#125;</code></pre></li></ul><h4 id="KeyboardEvent"><a href="#KeyboardEvent" class="headerlink" title="KeyboardEvent."></a>KeyboardEvent.</h4><blockquote><p><code>KeyboardEvent </code>对象描述了键盘的交互方式。 每个事件都描述了一个按键（Each event describes a key）；事件类型<code>keydown</code>， <code>keypress</code> 与 <code>keyup</code> 可以确定是哪种事件在活动。</p></blockquote><h5 id="keyCode"><a href="#keyCode" class="headerlink" title="keyCode"></a>keyCode</h5><blockquote><p>返回当前按键的ASCII码</p></blockquote><table><thead><tr><th></th><th>ASCII码</th></tr></thead><tbody><tr><td>空格</td><td>32</td></tr><tr><td>回车</td><td>13</td></tr><tr><td>左</td><td>37</td></tr><tr><td>上</td><td>38</td></tr><tr><td>右</td><td>39</td></tr><tr><td>下</td><td>40</td></tr></tbody></table><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><h5 id="兼容性写法-1"><a href="#兼容性写法-1" class="headerlink" title="兼容性写法"></a>兼容性写法</h5><pre><code class="js">document.onkeydown = function(eve)&#123;        var e = eve || window.event;        var code = e.keyCode || e.which;    &#125;</code></pre><h5 id="ctrlKey"><a href="#ctrlKey" class="headerlink" title="ctrlKey"></a>ctrlKey</h5><blockquote><p>鼠标事件<strong>ctrlKey是只读属性，可返回一个布尔值，当ctrl键被按下，返回true，否则返回false</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">var ctrlKeyPressed = instanceOfMouseEvent.ctrlKey</code></pre></li><li><p>返回值</p><pre><code class="js">A boolean</code></pre></li><li><p>实例</p><pre><code>document.onkeypress = ()=&gt;&#123;    console.log(e.ctrlKey);/如果按下了ctrl就为true,没按下ctrl就为false&#125;</code></pre></li></ul><h5 id="altKey"><a href="#altKey" class="headerlink" title="altKey"></a>altKey</h5><blockquote><p>鼠标事件<strong>altKey是只读属性，可返回一个布尔值，当alt键被按下，返回true，否则返回false</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">var altKeyPressed = instanceOfMouseEvent.altKey</code></pre></li><li><p>返回值</p><pre><code class="js">A boolean</code></pre></li><li><p>实例</p><pre><code class="js">document.onkeypress = ()=&gt;&#123;    console.log(e.altKey);/如果按下了alt就为true,没按下alt就为false&#125;</code></pre></li></ul><h5 id="shiftKey"><a href="#shiftKey" class="headerlink" title="shiftKey"></a>shiftKey</h5><blockquote><p>鼠标事件<strong>shiftKey是只读属性，可返回一个布尔值，当shift键被按下，返回true，否则返回false</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">var shiftKeyPressed = instanceOfMouseEvent.shiftKey</code></pre></li><li><p>返回值</p><pre><code class="js">A boolean</code></pre></li><li><p>实例</p><pre><code>document.onkeypress = ()=&gt;&#123;    console.log(e.shiftKey);/如果按下了shift就为true,没按下shift就为false&#125;</code></pre></li></ul><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>当内层元素的事件被触发时，会依次向上触发所有父级的相同事件，即便父级没有事件处理函数，但父级有事件，因此依然会往上冒泡</p></blockquote><h5 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation"></a>event.stopPropagation</h5><blockquote><p>阻止捕获和冒泡阶段中当前事件的进一步传播。</p></blockquote><ul><li><p>语法</p><pre><code class="js">event.stopPropagation(); </code></pre></li><li><p>实例</p><pre><code class="js">function stopBubble(e) &#123;    if (e.stopPropagation) &#123;        e.stopPropagation();    &#125; else &#123;        e.cancelBubble = true;    &#125;&#125;</code></pre></li></ul><h5 id="event-cancelBubble"><a href="#event-cancelBubble" class="headerlink" title="event.cancelBubble"></a>event.cancelBubble</h5><blockquote><p>获取或设置一个布尔值,表明当前事件是否要取消冒泡.</p></blockquote><ul><li><p>语法</p><pre><code class="js">event.cancelBubble = bool;var bool = event.cancelBubble;</code></pre><p>如果一个事件是可冒泡的,则它的cancelBubble<code>属性的默认值为 </code>false<code>,代表允许该事件向上冒泡. 将</code>cancelBubble<code>属性设置为</code>true以后,可以阻止该事件的进一步冒泡行为.</p></li><li><p>实例</p><pre><code class="js">function stopBubble(e) &#123;    if (e.stopPropagation) &#123;        e.stopPropagation();    &#125; else &#123;        e.cancelBubble = true;    &#125;&#125;</code></pre></li></ul><h4 id="阻止浏览器默认行为"><a href="#阻止浏览器默认行为" class="headerlink" title="阻止浏览器默认行为"></a>阻止浏览器默认行为</h4><h5 id="Event-returnValue"><a href="#Event-returnValue" class="headerlink" title="Event.returnValue"></a>Event.returnValue</h5><blockquote><p> <code>Event.returnValue</code> 属性表示该事件的默认操作是否已被阻止。默认情况下，它被设置为true，允许发生默认操作。将该属性设置为false，可以防止默认操作。</p></blockquote><ul><li><p>语法</p><pre><code class="js">event.returnValue = bool;var bool = event.returnValue;</code></pre></li><li><p>实例</p><pre><code class="js">e.returnValue = false;</code></pre></li></ul><h5 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault"></a>Event.preventDefault</h5><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 接口的 <code>preventDefault()</code>方法，告诉<a href="https://developer.mozilla.org/en-US/docs/Glossary/user_agent">user agent</a>：如果此事件没有被显式处理，那么它默认的动作也不要做（因为默认是要做的）。此事件还是继续传播，除非碰到事件侦听器调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation"><code>stopImmediatePropagation()</code></a>，才停止传播。</p></blockquote><ul><li><p>语法</p><pre><code class="js">event.preventDefault();</code></pre></li><li><p>返回值</p><p><strong>undefined</strong></p></li><li><p>实例</p><pre><code class="js">e.preventDefault()</code></pre></li></ul><h5 id="兼容性写法-2"><a href="#兼容性写法-2" class="headerlink" title="兼容性写法"></a>兼容性写法</h5><pre><code class="js">function stopDefault(e)&#123;    if(e.preventDefault)    e.preventDefault();//兼容其他浏览器    else    e.returnValue = false;//兼容IE&#125;</code></pre><h5 id="return-false"><a href="#return-false" class="headerlink" title="return false"></a>return false</h5><p>在某一事件类型的事件处理函数结尾加上<code>return false</code>会阻止该事件类型的默认行为</p><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><blockquote><p> 事件触发阶段主要由于事件流：DOM0级事件处理阶段和DOM2级事件处理</p></blockquote><h5 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h5><p>​        通过一种赋值方式，是被所有浏览器所支持的，简单易懂容易操作：元素.onclick = function(){}</p><h5 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h5><p>​        通过所有DOM节点中的方法，可以重复绑定，但是浏览器兼容存在问题</p><h5 id="触发顺序"><a href="#触发顺序" class="headerlink" title="触发顺序"></a>触发顺序</h5><ul><li>事件冒泡：从里向外</li><li>事件捕获：从外向内</li><li>目标阶段：当前元素的当前事件</li></ul><p><img src="file:///D:/APP/feiq/Recv%20Files/JavaScript/%E8%AF%BE%E4%BB%B6/day12/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-%E4%B8%8B_files/Image.jpg" alt="img"></p><h4 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h4><h5 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><blockquote><p><strong>EventTarget.addEventListener()</strong> 方法将指定的监听器注册到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget"><code>EventTarget</code></a> 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element"><code>Element</code></a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>Window</code></a>或者任何其他支持事件的对象 (比如 <code>XMLHttpRequest</code>)<code>。</code></p><p><code>addEventListener()</code>的工作原理是将实现<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventListener"><code>EventListener</code></a>的函数或对象添加到调用它的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget"><code>EventTarget</code></a>上的指定事件类型的事件侦听器列表中。</p></blockquote><ul><li><p>语法</p><pre><code class="js">target.addEventListener(type, listener[, options]);target.addEventListener(type, listener[, useCapture]);target.addEventListener(type, listener[, useCapture, wantsUntrusted  ]);  // Gecko/Mozilla only</code></pre></li><li><p>返回值</p><p><strong>undefined</strong></p></li><li><p>实例</p><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.addEventListener(&quot;click&quot;,function()&#123;    console.log(1);&#125;)</code></pre></li></ul><h5 id="add兼容性写法"><a href="#add兼容性写法" class="headerlink" title="add兼容性写法"></a>add兼容性写法</h5><pre><code class="js">function addEvent(ele,type,callback)&#123;    if(ele.attachEvent)    ele.attachEvent(&quot;on&quot;+type,callback);//兼容IE    else    ele.addEventListener(type,callback);&#125;</code></pre><h5 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h5><blockquote><p>删除使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>EventTarget.addEventListener()</code></a> 方法添加的事件。使用事件类型，事件侦听器函数本身，以及可能影响匹配过程的各种可选择的选项的组合来标识要删除的事件侦听器。</p></blockquote><ul><li><p>语法</p><pre><code class="js">target.removeEventListener(type, listener[, options]);target.removeEventListener(type, listener[, useCapture]);</code></pre></li><li><p>实例</p><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);function fn1()&#123;    console.log(1);&#125;obox.addEventListener(&quot;click&quot;,fn1)obox.removeEventListener(&quot;click&quot;,fn1)</code></pre></li></ul><h5 id="remove兼容性写法"><a href="#remove兼容性写法" class="headerlink" title="remove兼容性写法"></a>remove兼容性写法</h5><pre><code class="js">function removeEvent(ele,type,callback)&#123;    if(ele.detachEvent)    ele.detachEvent(&quot;on&quot;+type,callback);//兼容IE    else    ele.removeEventListener(type,callback);&#125;</code></pre><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><blockquote><p>将多个子元素的相同事件，加给共同的现有的父元素，实现节省事件的目的</p></blockquote><h5 id="事件委托的好处4"><a href="#事件委托的好处4" class="headerlink" title="事件委托的好处4"></a>事件委托的好处4</h5><ul><li>节省性能</li><li>可以给页面上暂时不存在的元素绑定事件</li></ul><h5 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h5><blockquote><p>触发事件的对象 (某个DOM元素) 的引用。当事件处理程序在事件的冒泡或捕获阶段被调用时，它与<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/currentTarget"><code>event.currentTarget</code></a>不同。</p></blockquote><ul><li><p>语法</p><pre><code class="js">let theTarget = event.target</code></pre></li><li><p>实例</p><pre><code class="js">// Make a listvar ul = document.createElement(&#39;ul&#39;);document.body.appendChild(ul);var li1 = document.createElement(&#39;li&#39;);var li2 = document.createElement(&#39;li&#39;);ul.appendChild(li1);ul.appendChild(li2);function hide(e)&#123;  // e.target 引用着 &lt;li&gt; 元素  // 不像 e.currentTarget 引用着其父级的 &lt;ul&gt; 元素.  e.target.style.visibility = &#39;hidden&#39;;&#125;// 添加监听事件到列表，当每个 &lt;li&gt; 被点击的时候都会触发。ul.addEventListener(&#39;click&#39;, hide, false);</code></pre></li></ul><h5 id="兼容写法"><a href="#兼容写法" class="headerlink" title="兼容写法"></a>兼容写法</h5><pre><code class="js"> otable.onclick = function(eve)&#123;        var e = eve || window.event;        var target = e.target || e.srcElement;//只看这行        if(target.nodeName === &quot;TD&quot;)&#123;            var ipt = document.createElement(&quot;input&quot;);            ipt.value = target.innerHTML;            target.innerHTML = &quot;&quot;;            target.appendChild(ipt);            ipt.focus();            var that = target;            ipt.onblur = function()&#123;                that.innerHTML = this.value;            &#125;            ipt.onclick = function(eve)&#123;                var e = eve || window.event;                e.stopPropagation();            &#125;        &#125;    &#125;</code></pre><h5 id="闭包封装写法"><a href="#闭包封装写法" class="headerlink" title="闭包封装写法"></a>闭包封装写法</h5><p>HTML：</p><pre><code class="html">&lt;div class=&quot;box&quot;&gt;    &lt;p class=&quot;red&quot;&gt;段落1&lt;/p&gt;    &lt;span&gt;文本1&lt;/span&gt;    &lt;p&gt;段落2&lt;/p&gt;    &lt;span&gt;文本2&lt;/span&gt;    &lt;p class=&quot;red&quot;&gt;段落3&lt;/p&gt;    &lt;span&gt;文本3&lt;/span&gt;    &lt;h2&gt;二级标题1&lt;/h2&gt;&lt;/div&gt;&lt;div class=&quot;box1&quot;&gt;    &lt;p&gt;段落1&lt;/p&gt;    &lt;span class=&quot;red&quot;&gt;文本1&lt;/span&gt;    &lt;p&gt;段落2&lt;/p&gt;    &lt;span&gt;文本2&lt;/span&gt;    &lt;p class=&quot;red&quot;&gt;段落3&lt;/p&gt;    &lt;span&gt;文本3&lt;/span&gt;    &lt;h2 class=&quot;red&quot;&gt;二级标题2&lt;/h2&gt;&lt;/div&gt;</code></pre><p>JS：</p><pre><code class="js">let obox = document.querySelector(&quot;.box&quot;);    let obox1 = document.querySelector(&quot;.box1&quot;);    let aspan = document.querySelectorAll(&quot;.box span&quot;)    let ap = document.querySelectorAll(&quot;.box1 p&quot;)    let ared = document.querySelectorAll(&quot;.box1 .red&quot;)    obox.onclick = fn(aspan,function()&#123;        console.log(this);        this.style.color = &quot;red&quot;;    &#125;);    obox1.onclick = fn(ared,function () &#123;         console.log(this);     &#125;)    function fn(achild,callback)&#123;        return function(eve)&#123;            let e = eve ||window.event;            let target = e.target || e.srcElement;            for(let i=0;i&lt;achild.length;i++)            &#123;                if(target == achild[i])                &#123;                    callback.call(target);                &#125;            &#125;        &#125;    &#125;</code></pre><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><table><thead><tr><th>定义</th><th>事件名</th></tr></thead><tbody><tr><td>左键单击</td><td>click</td></tr><tr><td>双击</td><td>dblclick</td></tr><tr><td>右键单击</td><td>contextmenu</td></tr><tr><td>按下</td><td>mousedown</td></tr><tr><td>移动</td><td>mousemove</td></tr><tr><td>抬起</td><td>mouseup</td></tr><tr><td>进入</td><td>mouseover</td></tr><tr><td>离开</td><td>mouseout</td></tr></tbody></table><h5 id="鼠标拖拽效果"><a href="#鼠标拖拽效果" class="headerlink" title="鼠标拖拽效果"></a>鼠标拖拽效果</h5><blockquote><ol><li>按下鼠标</li><li>移动鼠标 </li><li>松开鼠标</li></ol></blockquote><ol><li><p>给目标元素添加onmousedown事件，拖拽的前提是在目标元素按下鼠标左键</p></li><li><p>当onmousedown发生以后，此刻给document添加onmousemove事件，意味着此刻鼠标在网页的移动都将改变目标元素的位置</p></li><li><p>在onmousemove事件中，设定目标元素的left和top</p><p>公式：</p><p>目标元素的left = 鼠标的clientX – （鼠标和元素的横坐标差，即offsetX）</p><p>目标元素的top = 鼠标的clientY– （鼠标和元素的纵坐标差，即offsetY）</p></li><li><p>当onmousedown发生以后，此刻给document添加onmouseup事件，意味着此刻鼠标在网页的任意位置松开鼠标，都会放弃拖拽的效果   在onmouseup事件中，取消document的onmousemove事件即可。</p></li></ol><p> <a href="..%5C%E4%BD%9C%E4%B8%9A%5Cday12%5C%E5%BC%B9%E5%87%BA%E7%AA%97%E5%8F%A3%E6%8B%96%E6%8B%BD.html">弹出窗口拖拽.html</a> </p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><table><thead><tr><th>定义</th><th>事件名</th><th>备注</th></tr></thead><tbody><tr><td>按下</td><td>keydown</td><td>一般作用于能加焦点的元素</td></tr><tr><td>抬起</td><td>keyup</td><td>一般作用于能加焦点的元素</td></tr><tr><td>敲击</td><td>keypress</td><td>一般作用于能加焦点的元素</td></tr></tbody></table><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><table><thead><tr><th>定义</th><th>事件名</th><th>备注</th></tr></thead><tbody><tr><td>获取焦点</td><td>focus</td><td></td></tr><tr><td>失去焦点</td><td>blur</td><td></td></tr><tr><td>内容改变</td><td>change</td><td>失去焦点后触发</td></tr><tr><td>提交</td><td>submit</td><td>作用于form元素</td></tr><tr><td>重置</td><td>reset</td><td>作用于form元素</td></tr><tr><td>输入</td><td>input</td><td>立即触发</td></tr></tbody></table><h4 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h4><table><thead><tr><th>浏览器事件</th><th>window</th></tr></thead><tbody><tr><td>加载完成</td><td>load</td></tr><tr><td>滚动</td><td>scroll</td></tr><tr><td>改变大小</td><td>resize</td></tr></tbody></table><h5 id="onscroll"><a href="#onscroll" class="headerlink" title="onscroll"></a>onscroll</h5><blockquote><p>事件在元素滚动条在滚动时触发。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">window.onscroll = ()=&gt;&#123;    console.log(1);&#125;</code></pre></li><li><p>实例</p><pre><code class="js">&lt;body style=&quot;height: 5000px;&quot;&gt;//有滚动条时才可以触发滚动事件&lt;/body&gt;&lt;script&gt;       window.onscroll = () =&gt; &#123;        console.log(1);    &#125;&lt;/script&gt;</code></pre></li><li><p>相关变量</p><ol><li><p><strong>document.documentElement.scrollTop</strong></p><p>获取右滚动条的位置，可以赋值给该变量，赋值后配合事件触发会改变滚动条的位置</p><pre><code class="js">    document.onclick = function()&#123;        document.documentElement.scrollTop += 100;    &#125;</code></pre></li><li><p><strong>document.documentElement.scrollLeft</strong></p><p>获取下滚动条的位置，可以赋值给该变量，赋值后配合事件触发会改变滚动条的位置</p><pre><code class="js">    document.onclick = function()&#123;        document.documentElement.scrollLeft += 100;    &#125;</code></pre></li></ol></li></ul><h5 id="onresize"><a href="#onresize" class="headerlink" title="onresize()"></a>onresize()</h5><blockquote><p> onresize 事件会在窗口或框架被调整大小时发生。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">onresize=&quot;SomeJavaScriptCode&quot;</code></pre></li><li><p>实例</p><pre><code class="js">window.onresize = ()=&gt;&#123;    console.log(document.documentElement.clientWidth);    console.log(document.documentElement.clientHeight);&#125;</code></pre></li><li><p>相关变量</p><ol><li><p><strong>document.documentElement.clientWidth</strong></p><p>浏览器窗口宽度</p></li><li><p><strong>document.documentElement.clientHeight</strong></p><p>浏览器窗口高度</p></li></ol></li></ul><h5 id="onload"><a href="#onload" class="headerlink" title="onload()"></a>onload()</h5><blockquote><p> onload 事件会在页面或图像加载完成后立即发生。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">onload=&quot;SomeJavaScriptCode&quot;</code></pre></li><li><p>实例</p><pre><code class="js">&lt;head&gt;    &lt;script&gt;        // onload：页面和资源加载完成触发        onload = function()&#123;            // console.log(1)            var box = document.getElementById(&quot;box&quot;);            console.log(box);        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;height: 3000px;&quot;&gt;    &lt;div id=&quot;box&quot;&gt;123&lt;/div&gt;&lt;/body&gt;</code></pre><p>按照<strong>浏览器的渲染规则</strong>，该实例的<strong>JS代码</strong>放在了body<strong>前面</strong>去执行，会造成先渲染到JS的时候找不到div元素，因此无法正常工作。</p><p>因此，当JS代码放在body前面执行时，需要配合onload事件才能触发JS</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-13 JS的执行和编译过程的副本</title>
      <link href="/2022/09/15/13%20JS%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/13%20JS%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><blockquote><p>基于事件驱动并独立于平台的脚本/客户端语言</p></blockquote><h3 id="JS的执行和编译过程"><a href="#JS的执行和编译过程" class="headerlink" title="JS的执行和编译过程"></a>JS的执行和编译过程</h3><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><blockquote><ol><li><p>没有执行，检查：提升，语法</p></li><li><p>提升：提升到一个临时空间内，</p></li><li><p>语法：语法不对，抛出错误，直接终止一切</p></li></ol></blockquote><p>提升：提升到一个临时空间内，</p><p>语法：语法不对，抛出错误，直接终止一切</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><blockquote><ol><li><p>执行</p></li><li><p>如果解析器没有遇到报错，并且把所有的提升都做好了，才会执行编译器</p></li><li><p>当编译器执行时，会先去临时空间中读取要操作的变量，直接使用</p></li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-JSON</title>
      <link href="/2022/09/15/09%20JSON%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/09%20JSON%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote><p> JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 </p></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ol><li>必须是字符</li><li>这个字符的格式与js中的数组和对象大体一致</li><li>但是如果与对象一致，对象的key必须加双引号</li><li>不允许出现没有意义的,号</li><li>不允许出现undefined，function，NaN</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>number：和JavaScript的<code>number</code>完全一致；</li><li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li><li>string：就是JavaScript的<code>string</code>；</li><li>null：就是JavaScript的<code>null</code>；</li><li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li><li>object：就是JavaScript的<code>&#123; ... &#125;</code>表示方式。</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code class="js">var xiaoming = &#123;    name: &#39;小明&#39;,    age: 14,    gender: true,    height: 1.65,    grade: null,    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;]&#125;;var s = JSON.stringify(xiaoming);console.log(s);</code></pre><pre><code class="js">JSON.stringify(xiaoming, null, &#39;  &#39;);//要输出得好看一些，可以加上参数，按缩进输出：</code></pre><ul><li><code>JSON.stringify()</code> 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>:</li></ul><pre><code class="js">JSON.stringify(xiaoming, [&#39;name&#39;, &#39;skills&#39;], &#39;  &#39;);</code></pre><ul><li>还可以传入一个函数，这样对象的每个键值对都会被函数先处理。</li></ul><pre><code class="js">function convert(key, value) &#123;    if (typeof value === &#39;string&#39;) &#123;        return value.toUpperCase();    &#125;    return value;&#125;JSON.stringify(xiaoming, convert, &#39;  &#39;);</code></pre><ul><li> 给<code>对象</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据： </li></ul><pre><code class="js">var xiaoming = &#123;    name: &#39;小明&#39;,    age: 14,    gender: true,    height: 1.65,    grade: null,    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;],    toJSON: function () &#123;        return &#123; // 只输出name和age，并且改变了key：            &#39;Name&#39;: this.name,            &#39;Age&#39;: this.age        &#125;;    &#125;&#125;;JSON.stringify(xiaoming); // &#39;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#39;</code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p> 拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象 。</p><pre><code class="js">JSON.parse(&#39;[1,2,3,true]&#39;); // [1, 2, 3, true]JSON.parse(&#39;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#39;); // Object &#123;name: &#39;小明&#39;, age: 14&#125;JSON.parse(&#39;true&#39;); // trueJSON.parse(&#39;123.45&#39;); // 123.45</code></pre><p> <code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性： </p><pre><code class="js">var obj = JSON.parse(&#39;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#39;, function (key, value) &#123;    if (key === &#39;name&#39;) &#123;        return value + &#39;同学&#39;;    &#125;    return value;&#125;);console.log(JSON.stringify(obj)); // &#123;name: &#39;小明同学&#39;, age: 14&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-BOM</title>
      <link href="/2022/09/15/08%20BOM%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/08%20BOM%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><blockquote><p>浏览器对象模型</p></blockquote><h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><blockquote><p> <code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。 </p></blockquote><p> <code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于<code>显示网页的净宽高</code>。 </p><pre><code class="js">console.log(&#39;window inner size: &#39; + window.innerWidth + &#39; x &#39; + window.innerHeight);</code></pre><p> //<strong>window inner size: 1280 x 613</strong> </p><p> 对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以<code>获取浏览器窗口的整个宽高</code>。</p><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><blockquote><p><code>navigator</code>对象表示浏览器的信息</p></blockquote><p>最常用的属性包括：</p><h5 id="navigator-appName"><a href="#navigator-appName" class="headerlink" title="navigator.appName"></a>navigator.appName</h5><p>​    浏览器名称</p><h5 id="navigator-appVersion"><a href="#navigator-appVersion" class="headerlink" title="navigator.appVersion"></a>navigator.appVersion</h5><p>​    浏览器版本</p><h5 id="navigator-language"><a href="#navigator-language" class="headerlink" title="navigator.language"></a>navigator.language</h5><p>​    浏览器设置的语言</p><h5 id="navigator-platform"><a href="#navigator-platform" class="headerlink" title="navigator.platform"></a>navigator.platform</h5><p>​    操作系统类型</p><h5 id="navigator-userAgent"><a href="#navigator-userAgent" class="headerlink" title="navigator.userAgent"></a>navigator.userAgent</h5><p>​    浏览器设定的<code>User-Agent</code>字符串</p><p>请注意，以上属性返回的均为<strong>字符串</strong>`</p><p><em>请注意</em>，<code>navigator</code>的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用<code>if</code>判断浏览器版本，例如：</p><pre><code class="js">var width;if (getIEVersion(navigator.userAgent) &lt; 9) &#123;    width = document.body.clientWidth;&#125; else &#123;    width = window.innerWidth;&#125;</code></pre><p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回<code>undefined</code>的特性，直接用短路运算符<code>||</code>计算：</p><pre><code class="js">var width = window.innerWidth || document.body.clientWidth;</code></pre><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><blockquote><p><code>screen</code>对象表示屏幕的信息</p></blockquote><p>常用的属性有：</p><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><pre><code class="js">console.log(&#39;Screen size = &#39; + screen.width + &#39; x &#39; + screen.height);</code></pre><p>// <strong>Screen size = 1920 x 1080</strong> </p><h4 id="history-不推荐使用"><a href="#history-不推荐使用" class="headerlink" title="history//不推荐使用"></a>history//不推荐使用</h4><blockquote><p><code>history</code>对象保存了浏览器的历史记录</p></blockquote><p>JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p><p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用<code>history.back()</code>可能会让用户感到非常愤怒。</p><p>新手开始设计Web页面时喜欢在登录页登录成功时调用<code>history.back()</code>，试图回到登录前的页面。这是一种错误的方法。</p><p>任何情况，你都不应该使用<code>history</code>这个对象了。</p><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><blockquote><p>历史记录的个数</p></blockquote><h5 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h5><blockquote><p>back() 方法可加载历史列表中的前一个 URL（如果存在）。</p><p>调用该方法的效果等价于点击后退按钮或调用 history.go(-1)。</p></blockquote><ul><li><p>语法</p><pre><code class="js">history.back()</code></pre></li><li><p>实例</p><pre><code class="js">history.back();//回退上一个页面</code></pre></li></ul><h5 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h5><blockquote><p>forward() 方法可加载历史列表中的下一个 URL。</p><p>调用该方法的效果等价于点击前进按钮或调用 history.go(1)。</p></blockquote><ul><li><p>语法</p><pre><code class="js">history.forward();</code></pre></li><li><p>实例</p><pre><code class="js">history.forward();//前进一个页面</code></pre></li></ul><h5 id="go"><a href="#go" class="headerlink" title="go()"></a>go()</h5><blockquote><p> go() 方法可加载历史列表中的某个具体的页面。 跳转指定的步数，负为退，正为进，0为刷新</p></blockquote><ul><li><p>语法</p><pre><code class="js">history.go(number|URL)</code></pre></li><li><p>实例</p><pre><code class="js">window.history.go(-1);//回退上一个页面window.history.go(5);//前进5个页面</code></pre></li></ul><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><blockquote><p> <code>location</code>对象表示当前页面的URL信息 </p></blockquote><p>例如一个完整的URL：<a href="http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</a></p><p>可以用<code>location.href</code>获取。要获得URL各个部分的值，可以这么写：</p><pre><code class="js">location.protocol; // &#39;http&#39;location.host; // &#39;www.example.com&#39;location.port; // &#39;8080&#39;location.pathname; // &#39;/path/index.html&#39;location.search; // &#39;?a=1&amp;b=2&#39;location.hash; // &#39;TOP&#39;</code></pre><p>要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用<code>location.reload()</code>方法非常方便。</p><pre><code class="js">if (confirm(&#39;重新加载当前页&#39; + location.href + &#39;?&#39;)) &#123;    location.reload();&#125; else &#123;    location.assign(&#39;/&#39;); // 设置一个新的URL地址&#125;</code></pre><h5 id="href"><a href="#href" class="headerlink" title="href"></a>href</h5><blockquote><p> href 属性是一个可读可写的字符串，可设置或返回当前显示的文档的完整 URL。</p><p> 因此，我们可以通过为该属性设置新的 URL，使浏览器读取并显示新的 URL 的内容。</p></blockquote><ul><li><p>语法</p><pre><code class="js">location.href = URL</code></pre></li><li><p>实例</p><pre><code class="js">console.log(location.href);//当前页面完整的URL</code></pre></li></ul><h5 id="search"><a href="#search" class="headerlink" title="search"></a>search</h5><blockquote><p>  search 属性是一个可读可写的字符串，可设置或返回当前 URL 的查询部分（问号 ? 之后的部分）。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">location.search = path_from_questionmark</code></pre></li><li><p>实例</p><pre><code class="js">console.log(location.href);//返回当前 URL 的查询部分（问号 ? 之后的部分）</code></pre></li></ul><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><blockquote><p>  hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分） </p></blockquote><ul><li><p>语法</p><pre><code class="js">location.hash = anchorname</code></pre></li><li><p>实例</p><pre><code class="js">console.log(location.hash);// URL 的锚部分（从 # 号开始的部分）location.hash = &quot;#3_2&quot;//改变锚点#ID,可以到达指定位置</code></pre></li></ul><h5 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h5><blockquote><p>  reload() 方法用于重新加载当前文档。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">location.reload(force)</code></pre></li><li><p>实例</p><pre><code class="js">window.location.reload()//刷新页面</code></pre></li></ul><h5 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h5><blockquote><p>  assign() 方法可加载一个新的文档。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">location.assign(URL)</code></pre></li><li><p>实例</p><pre><code class="js"> window.location.assign(&quot;http://www.w3school.com.cn&quot;)//重新加载新的网页 window.location.assign(&quot;&quot;)//刷新页面</code></pre></li></ul><h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><blockquote><p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p></blockquote><p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>xxx</code>读取的，但是可以动态改变：</p><pre><code class="js">document.title = &#39;努力学习JavaScript!&#39;;</code></pre><h5 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h5><blockquote><p> 按ID获得一个DOM节点 </p></blockquote><h5 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h5><blockquote><p> 按Tag名称获得一组DOM节点 </p></blockquote><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><blockquote><p> 可以获取当前页面的Cookie</p></blockquote><p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p><p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p><p>JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p><pre><code class="js">document.cookie; // &#39;v=123; remember=true; prefer=zh&#39;</code></pre><p>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p><pre><code class="js">&lt;!-- 当前页面在wwwexample.com --&gt;&lt;html&gt;    &lt;head&gt;        &lt;script src=&quot;http://www.foo.com/jquery.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    ...&lt;/html&gt;</code></pre><p>如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<code>www.example.com</code>网站的用户登录信息。</p><p>为了解决这个问题，服务器在设置Cookie时可以使用<code>httpOnly</code>，设定了<code>httpOnly</code>的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持<code>httpOnly</code>选项，IE从IE6 SP1开始支持。</p><p>为了确保安全，服务器端在设置Cookie时，应该始终坚持使用<code>httpOnly</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-DOM</title>
      <link href="/2022/09/15/07%20DOM%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/07%20DOM%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h4><blockquote><p> getElementById() 方法可返回对拥有指定 ID 的第一个对象的引用。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">document.getElementById(id)</code></pre></li><li><p>实例</p><pre><code class="js">var c = document.body.children;</code></pre></li></ul><h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h4><blockquote><p> getElementsByClassName() 方法可返回带有指定标签名的对象的<strong>集合</strong>。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">document.getElementsByTagName(classname)</code></pre></li><li><p>实例</p><pre><code class="js">var aCont = document.getElementsByClassName(&quot;cont&quot;);//返回的是一个集合</code></pre></li></ul><h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h4><blockquote><p> getElementsByTagName() 方法可返回带有指定标签名的对象的<strong>集合</strong>。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">document.getElementsByTagName(tagname)</code></pre></li><li><p>实例</p><pre><code class="js">var aSpan = document.getElementsByTagName(&quot;span&quot;);//返回的是一个集合</code></pre></li></ul><h4 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h4><blockquote><p> getElementsByName() 方法可返回带有指定名称的对象的<strong>集合</strong>。  </p></blockquote><ul><li><p>语法</p><pre><code class="js">document.getElementsByName(name)</code></pre></li><li><p>实例</p><pre><code class="js">var x=document.getElementsByName(&quot;myInput&quot;);//返回的是一个集合</code></pre></li></ul><h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h4><blockquote><p> querySelector() 方法返回文档中匹配指定 CSS 选择器的<strong>一个元素</strong>。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">elementList = document.querySelectorAll(selector);</code></pre></li><li><p>实例</p><pre><code class="js">var ele = document.querySelector(&quot;#box&quot;);var ele = document.querySelector(&quot;.cont&quot;);var ele = document.querySelector(&quot;span&quot;);var ele = document.querySelector(&quot;.msg h2&quot;);var ele = document.querySelector(&quot;.msg&gt;h2&quot;);var ele = document.querySelector(&quot;input[name=pass]&quot;);</code></pre></li></ul><h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h4><blockquote><p> querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的<strong>所有元素</strong>，返回NodeList对象。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">elementList = document.querySelectorAll(selectors);</code></pre></li><li><p>实例</p><pre><code class="js">var ele = document.querySelectorAll(&quot;#box&quot;);var ele = document.querySelectorAll(&quot;.cont&quot;);var ele = document.querySelectorAll(&quot;span&quot;);var ele = document.querySelectorAll(&quot;.msg h2&quot;);var ele = document.querySelectorAll(&quot;.msg&gt;h2&quot;);var ele = document.querySelectorAll(&quot;input[name=pass]&quot;);var ele = document.querySelectorAll(&quot;span,p,input,div,#box,.cont&quot;)</code></pre></li></ul><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><h4 id="children"><a href="#children" class="headerlink" title=".children"></a>.children</h4><blockquote><p>children 属性返回元素的子元素的集合，是一个 HTMLCollection 对象。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">element.children</code></pre></li><li><p>实例</p><pre><code class="js">var c = document.body.children;</code></pre></li></ul><h4 id="parentNode"><a href="#parentNode" class="headerlink" title=".parentNode"></a>.parentNode</h4><blockquote><p>parentNode 属性以 Node 对象的形式返回指定节点的父节点。</p><p>如果指定节点没有父节点，则返回 null。</p></blockquote><ul><li><p>语法</p><pre><code class="js">node.parentNode</code></pre></li><li><p>实例</p><pre><code class="js">document.getElementById(&quot;item1&quot;).parentNode;</code></pre></li></ul><h4 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title=".firstElementChild"></a>.firstElementChild</h4><blockquote><p>firstElementChild 返回指定节点的第一个子元素节点</p></blockquote><ul><li><p>语法</p><pre><code class="js">var last = oXbox.lastElementChild;</code></pre></li><li><p>实例</p><pre><code class="js">var last = oXbox.lastElementChild;</code></pre></li></ul><h4 id="lastElementChild"><a href="#lastElementChild" class="headerlink" title=".lastElementChild"></a>.lastElementChild</h4><blockquote><p>lastElementChild 返回指定节点的最后一个子元素节点</p></blockquote><ul><li><p>语法</p><pre><code class="js">var last = oXbox.lastElementChild;</code></pre></li><li><p>实例</p><pre><code class="js">var last = oXbox.lastElementChild;</code></pre></li></ul><h4 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title=".previousElementSibling"></a>.previousElementSibling</h4><blockquote><p> previousElementSibling 属性返回指定元素的前一个兄弟元素（相同节点树层中的前一个元素节点）。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">node.previousElementSibling</code></pre></li><li><p>实例</p><pre><code class="js">var x = document.getElementById(&quot;item2&quot;).previousElementSibling.innerHTML;</code></pre></li></ul><h4 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title=".nextElementSibling"></a>.nextElementSibling</h4><blockquote><p> nextElementSibling 属性返回指定元素之后的下一个兄弟元素（相同节点树层中的下一个元素节点）</p></blockquote><ul><li><p>语法</p><pre><code class="js">node.nextElementSibling</code></pre></li><li><p>实例</p><pre><code class="js">var x = document.getElementById(&quot;item1&quot;).nextElementSibling.innerHTML;</code></pre></li></ul><h3 id="其他节点选择器"><a href="#其他节点选择器" class="headerlink" title="其他节点选择器"></a>其他节点选择器</h3><h4 id="childNodes"><a href="#childNodes" class="headerlink" title=".childNodes"></a>.childNodes</h4><blockquote><p>  <strong>Node.childNodes</strong> 返回包含指定节点的子节点的集合，该集合为即时更新的集合（live collection）</p></blockquote><ul><li><p>语法</p><pre><code class="js">var ndList = elementNodeReference.childNodes; </code></pre></li><li><p>实例</p><pre><code class="js">var child = oxbox.childNodes;console.log(child);console.log(child[0]);console.log(child[1]);console.log(child[2]);console.log(child[3]);</code></pre></li></ul><h4 id="firstChild"><a href="#firstChild" class="headerlink" title=".firstChild"></a>.firstChild</h4><blockquote><p> firstChild 属性返回指定节点的首个子节点，以 Node 对象。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">var childNode = node.firstChild;</code></pre></li><li><p>实例</p><pre><code class="js">document.firstChild;//&lt;!DOCTYPE html&gt;(是一个对象)</code></pre></li></ul><h4 id="lastChild"><a href="#lastChild" class="headerlink" title=".lastChild"></a>.lastChild</h4><blockquote><p> lastChild 属性返回指定节点的最后一个子节点，以 Node 对象。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">node.lastChild;</code></pre></li><li><p>实例</p><pre><code class="js">document.firstChild;//&lt;html&gt;&lt;/html&gt;</code></pre></li></ul><h4 id="previousSibling"><a href="#previousSibling" class="headerlink" title=".previousSibling"></a>.previousSibling</h4><blockquote><p>  返回当前节点的前一个兄弟节点,没有则返回<code>null.</code> </p></blockquote><ul><li><p>语法</p><pre><code class="js">previousNode = node.previousSibling</code></pre></li><li><p>实例</p><pre><code class="js">// &lt;a&gt;&lt;b1 id=&quot;b1&quot;/&gt;&lt;b2 id=&quot;b2&quot;/&gt;&lt;/a&gt;alert(document.getElementById(&quot;b1&quot;).previousSibling); // nullalert(document.getElementById(&quot;b2&quot;).previousSibling.id); // &quot;b1&quot;</code></pre></li></ul><h4 id="nextSibling"><a href="#nextSibling" class="headerlink" title=".nextSibling"></a>.nextSibling</h4><blockquote><p>  Node.nextSibling 是一个只读属性，返回其父节点的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/childNodes"><code>childNodes</code></a> 列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回 <code>null</code>。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">nextNode = node.nextSibling</code></pre></li><li><p>实例</p><pre><code class="js">// &lt;a&gt;&lt;b1 id=&quot;b1&quot;/&gt;&lt;b2 id=&quot;b2&quot;/&gt;&lt;/a&gt;alert(document.getElementById(&quot;b1&quot;).nextSibling.id); // &quot;b2&quot;alert(document.getElementById(&quot;b2&quot;).nextSibling); // null</code></pre></li></ul><h4 id="attributes"><a href="#attributes" class="headerlink" title=".attributes"></a>.attributes</h4><blockquote><p> <code>Element.attributes</code> 属性返回该元素所有属性节点的一个实时集合。该集合是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/NamedNodeMap"><code>NamedNodeMap</code></a> 对象，不是一个数组，所以它没有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>数组</code></a> 的方法，其包含的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Attr"><code>属性</code></a> 节点的索引顺序随浏览器不同而不同。更确切地说，<code>attributes</code> 是字符串形式的名/值对，每一对名/值对对应一个属性节点。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">var attr = element.attributes;</code></pre></li><li><p>实例</p><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);console.log(obox.attributes);console.log(obox.attributes[0]);console.log(obox.attributes[1]);console.log(obox.attributes[2]);console.log(obox.attributes[3]);console.log(obox.attributes[3].abc);console.log(obox.attributes[4]);</code></pre></li></ul><h3 id="元素的操作"><a href="#元素的操作" class="headerlink" title="元素的操作"></a>元素的操作</h3><h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h4><blockquote><p><strong><code>Document.createElement() </code><strong>方法创建由</strong>tagName</strong> 指定的HTML元素，或一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLUnknownElement"><code>HTMLUnknownElement</code></a>，如果tagName不被识别。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">let element = document.createElement(tagName[, options]);</code></pre></li><li><p>返回值</p><pre><code class="js">新的元素[Element]</code></pre><ul><li>element 是创建的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element"><code>Element</code></a>对象。</li><li>tagName 指定将要创建的元素类型的字符串。创建的element的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName"><code>nodeName</code></a>会被初始化为tagName的值。该方法不接受带条件的元素名字(例如: html:a)。</li><li>options 是一个可选的 ElementCreationOptions 对象. 如果这个对象被定义并赋予了一个 is 特性，则创建的element的 is 属性会被初始化为这个特性的值. 如果这个对象没有 is 特性，则值为空.</li></ul></li><li><p>实例</p><pre><code class="js">var mydiv = document.createElement(&quot;div&quot;);//创建了一个div元素节点</code></pre></li></ul><h4 id="childNode-remove"><a href="#childNode-remove" class="headerlink" title="childNode.remove()"></a>childNode.remove()</h4><blockquote><p><code>ChildNode.remove()</code> 方法，把对象从它所属的 DOM 树中删除。</p></blockquote><ul><li><p>语法</p><pre><code class="js">node.remove();</code></pre></li><li><p>实例</p><pre><code class="js">var el = document.getElementById(&#39;div-02&#39;);el.remove();//&quot;id为&#39;div-02&quot;的元素被删掉了</code></pre><p>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新。删除多个节点时，要注意<code>children</code>属性时刻都在变化。</p></li></ul><h4 id="node-removeChild"><a href="#node-removeChild" class="headerlink" title="node.removeChild()"></a>node.removeChild()</h4><blockquote><p><strong>Node.removeChild()</strong> 方法从DOM中删除一个子节点。返回删除的节点。</p></blockquote><ul><li><p>语法</p><pre><code class="js">let oldChild = node.removeChild(child);//ORelement.removeChild(child);</code></pre></li><li><p>返回值</p><p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。<br>因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量取得它的返回值。</p></li><li><p>实例</p><pre><code class="js">// 拿到待删除节点:var self = document.getElementById(&#39;to-be-removed&#39;);// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);console.log(removed === self )// true</code></pre></li></ul><h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute()"></a>setAttribute()</h4><blockquote><p>  setAttribute() 方法添加指定的属性，并为其赋指定的值。</p><p>  如果这个指定的属性已存在，则仅设置/更改值。</p></blockquote><ul><li><p>语法</p><pre><code class="js">element.setAttribute(attributename,attributevalue)</code></pre></li><li><p>实例</p><pre><code class="js">document.getElementsByTagName(&quot;INPUT&quot;)[0].setAttribute(&quot;type&quot;,&quot;button&quot;);</code></pre></li></ul><h4 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute()"></a>getAttribute()</h4><blockquote><p>   getAttribute() 方法返回指定属性名的属性值。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">element.getAttribute(attributename)</code></pre></li><li><p>实例</p><pre><code class="js">document.getElementsByTagName(&quot;a&quot;)[0].getAttribute(&quot;target&quot;);//_blank</code></pre></li></ul><h4 id="removeAttribute"><a href="#removeAttribute" class="headerlink" title="removeAttribute()"></a>removeAttribute()</h4><blockquote><p>  removeAttribute() 方法删除指定的属性。</p><p>  此方法与 removeAttributeNode() 方法的差异是：removeAttributeNode() 方法删除指定的 Attr 对象，而此方法删除具有指定名称的属性。结果是相同的。同时此方法不返回值，而 removeAttributeNode() 方法返回被删除的属性，以 Attr 对象的形式</p></blockquote><ul><li><p>语法</p><pre><code class="js">element.getAttribute(attributename)</code></pre></li><li><p>实例</p><pre><code class="js">document.getElementsByTagName(&quot;H1&quot;)[0].removeAttribute(&quot;style&quot;);</code></pre></li></ul><h4 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h4><p>可见</p><ul><li><p>作为对象操作（点语法,中括号语法）</p><pre><code class="js">var obox = document.getElementsByClassName(&quot;box&quot;)[0];var a = document.getElementsByTagName(&quot;a&quot;)[0];var img = document.getElementsByTagName(&quot;img&quot;)[0];obox.className;obox[&quot;title&quot;];obox.id;a.href;img.src;img[&quot;alt&quot;];</code></pre></li><li><p>Attribute系列：set，get，remove</p><pre><code class="js">console.log(obox.getAttribute(&quot;title&quot;))//可获得内置可见属性obox.setAttribute(&quot;title&quot;,&quot;123123132&quot;)//可设置内置可见属性obox.removeAttribute(&quot;title&quot;)//可删除内置可见属性</code></pre></li></ul><p>不可见</p><ul><li><p>作为对象操作（点语法,中括号语法）</p><pre><code class="js">innerHTML,innerText,tagNameconsole.log(obox.innerHTML)console.log(obox.innerText)console.log(obox.tagName)obox.tagName = &quot;SPAN&quot;;//不可更改</code></pre></li></ul><h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p>可见</p><ul><li><p>Attribute系列：set，get，remove</p><pre><code class="js">console.log(obox.abc)console.log(obox.href)console.log(obox.getAttribute(&quot;abc&quot;))//可以获得自定义可见属性的值console.log(obox.getAttribute(&quot;href&quot;))obox.setAttribute(&quot;qwe&quot;,&quot;hahahahah&quot;)//可以设置或修改自定义可见属性的值obox.setAttribute(&quot;abc&quot;,&quot;world&quot;)obox.removeAttribute(&quot;abc&quot;)//可以删除自定义可见属性的值obox.removeAttribute(&quot;href&quot;)</code></pre></li></ul><p>不可见</p><ul><li><p>作为对象操作（点语法,中括号语法）</p><pre><code class="js">obox.aaa = &quot;bbb&quot;console.log(obox.aaa);//bbb</code></pre></li></ul><h3 id="样式的操作"><a href="#样式的操作" class="headerlink" title="样式的操作"></a>样式的操作</h3><h4 id="element-style"><a href="#element-style" class="headerlink" title="element.style"></a>element.style</h4><blockquote><p>由.style设置的所有样式都会以行内样式的形式体现</p><p><strong>获取的也是行内样式</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">element.style.attribute =  &quot;&quot;</code></pre></li><li><p>实例</p><pre><code class="js">obox.style.width = 20 + &quot;px&quot;;</code></pre></li></ul><h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h4><blockquote><p> <code>Window.getComputedStyle()</code>方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。 </p><p><strong>注意：该属性只能获取属性不能设置属性</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">let style = window.getComputedStyle(element, [pseudoElt]);//第二个参数是fasle,为true的情况下查看的是元素的伪类或者伪元素</code></pre></li><li><p>返回值</p><pre><code class="js">返回的style是一个实时的CSSStyleDeclaration对象，当元素的样式更改时，它会自动更新本身。</code></pre></li><li><p>实例</p></li></ul><h4 id="element-currentStyle"><a href="#element-currentStyle" class="headerlink" title="element.currentStyle"></a>element.currentStyle</h4><blockquote><p> <strong><code>Element.currentStyle</code></strong> 是一个与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a>方法功能相同的属性。这个属性实现在旧版本的IE浏览器（IE8及以下）中。</p><p><strong>注意：该属性只能获取属性不能设置属性</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">element.currentStyle.attribute</code></pre></li><li><p>实例</p><pre><code class="js">obox.currentStyle.width;</code></pre></li></ul><h4 id="兼容性获取样式方法"><a href="#兼容性获取样式方法" class="headerlink" title="兼容性获取样式方法"></a>兼容性获取样式方法</h4><pre><code class="js">function getStyle(ele,attr)&#123;    if(ele.currentStyle)&#123;//判断获取到的是不是true，那么就执行IE的currentStyle，如果是undefined那么就是false，那就执行getComputedStyle()        return ele.currentStyle[attr];//IE8及以下支持    &#125;else&#123;        return getComputedStyle(ele,false)[attr];//其他正常浏览器支持    &#125;&#125;</code></pre><h3 id="尺寸类样式的获取"><a href="#尺寸类样式的获取" class="headerlink" title="尺寸类样式的获取"></a>尺寸类样式的获取</h3><h4 id="offsetWidth"><a href="#offsetWidth" class="headerlink" title="offsetWidth"></a>offsetWidth</h4><blockquote><p> <strong>HTMLElement.offsetWidth</strong> 是一个只读属性，返回一个元素的布局宽度。一个典型的（译者注：各浏览器的offsetWidth可能有所不同）offsetWidth是测量包含元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值。 </p><p> <strong>content+padding+border</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">var offsetWidth =element.offsetWidth;</code></pre><p>这个属性将会 round(四舍五入)为一个整数。如果你想要一个fractional(小数)值,请使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>element.getBoundingClientRect()</code></a></p></li><li><p>分类</p><ol><li><p>假如元素无padding无滚动无border </p><pre><code>offsetWidth = clientWidth = style.width</code></pre></li><li><p>假如元素有padding无滚动有border</p><pre><code>offsetWidth = style.width + style.padding*2 + border宽度*2offsetWidth = clientWidth + border宽度*2</code></pre></li><li><p>假如元素有padding有滚动，有border，且滚动是显示的 </p><pre><code>offsetWidth = style.width + style.padding*2 + (border-width)*2offsetWidth = clientWidth + 滚轴宽度 + border宽度*2</code></pre><p> <strong>offsetHeight同理</strong> </p></li></ol></li><li><p>实例</p><pre><code class="js">var wid = obox.offsetWidth;//返回一个整数数值</code></pre><p> <img src="https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png" alt="Image:Dimensions-offset.png"> </p></li></ul><h4 id="offsetHeight"><a href="#offsetHeight" class="headerlink" title="offsetHeight"></a>offsetHeight</h4><blockquote><p> <strong><code>HTMLElement.offsetHeight</code></strong> 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。**(content+padding+border)**</p><p>通常，元素的offsetHeight是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。</p><p>对于文档的body对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。 </p><p>如果元素被隐藏（例如 元素或者元素的祖先之一的元素的style.display被设置为none），则返回0</p></blockquote><ul><li><p>语法</p><pre><code class="js">var intElemOffsetHeight = document.getElementById(id_attribute_value).offsetHeight;</code></pre></li><li><p>实例</p><pre><code class="js">var hei = obox.offsetHeight;//返回一个整数数值</code></pre><p> <img src="https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png" alt="Image:Dimensions-offset.png"></p><p> 上面的图片中显示了scollbar和窗口高度的offsetHeight.但是不能滚动的元素可能会有一个很大的高度值，大于可以看见的内容。这些元素原则上是被包含在滚动元素之中的。所以，这些不能滚动的元素可能会因为scrollTop的值会被完全隐藏或者部分隐藏； </p></li></ul><h4 id="clientWidth"><a href="#clientWidth" class="headerlink" title="clientWidth"></a>clientWidth</h4><blockquote><p>clientWeight是一个只读属性。尺寸范围为：<strong>padding+content</strong></p><p>内联元素以及没有 CSS 样式的元素的 <code>**clientWidth**</code> 属性值为 0。<code>**Element.clientWidth**</code> 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。</p></blockquote><ul><li><p>语法</p><pre><code class="js">var intElemClientWidth = element.clientWidth;//intElemClientWidth 是一个整数，表示元素的 clientWidth。</code></pre></li><li><p>分类</p><ol><li><p>假如元素无padding无滚动</p><pre><code>clientWidth = style.width</code></pre></li><li><p>假如元素有padding无滚动</p><pre><code>clientWidth = style.width + style.padding*2</code></pre></li><li><p>假如元素有padding有滚动，且滚动是显示的</p><pre><code>clientWidth = style.width + style.padding*2 - 滚动轴宽度</code></pre><p><strong>clientHeight同理</strong></p></li></ol></li><li><p>实例</p><pre><code class="js">var cw = obox.clientWidth;//返回一个整数数值</code></pre><p> <img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="Image:Dimensions-client.png"> </p></li></ul><h4 id="clientHeight"><a href="#clientHeight" class="headerlink" title="clientHeight"></a>clientHeight</h4><blockquote><p>clientHeight是一个只读属性。尺寸范围为：<strong>padding+content</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">var intElemClientHeight = element.clientHeight;//intElemClientHeight 是一个整数，表示元素的 clientHeight。</code></pre></li><li><p>实例</p><pre><code class="js">var ch = obox.clientHeight;//返回一个整数数值</code></pre><p> <img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="Image:Dimensions-client.png"> </p></li></ul><h4 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h4><blockquote><p> <strong>HTMLElement.offsetTop</strong> 为只读属性，它返回当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的顶部内边距的距离。 </p><p>相对于页面或包含块偏移的位置</p></blockquote><ul><li><p>语法</p><pre><code class="js">topPos = element.offsetTop;</code></pre></li><li><p>实例</p><pre><code class="js">var d = document.getElementById(&quot;div1&quot;);var topPos = d.offsetTop; if (topPos &gt; 10) &#123;  // div1 距离它的 offsetParent 元素的顶部的距离大于 10 px&#125;</code></pre></li></ul><h4 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h4><blockquote><p> <strong>HTMLElement.offsetLeft</strong> 为只读属性，它返回当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的左边内边距的距离。 </p><p>相对于页面或包含块偏移的位置</p></blockquote><ul><li><p>语法</p><pre><code class="js">leftPos = element.offsetLeft;</code></pre></li><li><p>实例</p><pre><code class="js">var d = document.getElementById(&quot;div1&quot;);var topLeft = d.offsetLeft; if (topLeft &gt; 10) &#123;  // div1 距离它的 offsetParent 元素的顶部的距离大于 10 px&#125;</code></pre></li></ul><h4 id="以上属性只能获取不能设置"><a href="#以上属性只能获取不能设置" class="headerlink" title="以上属性只能获取不能设置"></a>以上属性只能获取不能设置</h4><h4 id="scrollTop"><a href="#scrollTop" class="headerlink" title="scrollTop"></a>scrollTop</h4><blockquote><p><code>Element.scrollTop</code> 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p><p>一个元素的 <code>scrollTop</code> 值是这个元素的顶部到视口可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 <code>scrollTop 值为0。</code></p></blockquote><ul><li><p>语法</p><pre><code class="js">// 获得滚动的像素数var  intElemScrollTop = someElement.scrollTop;// 设置滚动的距离element.scrollTop = intValue;</code></pre></li><li><p>实例</p><pre><code class="js">document.onclick = function()&#123;    // console.log(obox.scrollTop);    obox.scrollTop = 666;&#125;</code></pre><p>​                                 <img src="https://developer.mozilla.org/@api/deki/files/842/=ScrollTop.png" alt="Image:scrollTop.png"></p></li></ul><h4 id="scrolLeft"><a href="#scrolLeft" class="headerlink" title="scrolLeft"></a>scrolLeft</h4><blockquote><p><strong><code>Element.scrollLeft</code></strong> 属性可以读取或设置元素滚动条到元素左边的距离。</p><p>注意如果这个元素的内容排列方向（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>） 是<code>rtl</code> (right-to-left) ，那么滚动条会位于最右侧（内容开始处），并且scrollLeft值为0。此时，当你从右到左拖动滚动条时，scrollLeft会从0变为负数（这个特性在chrome浏览器中不存在）。</p></blockquote><ul><li><p>语法</p><pre><code class="js">//获取滚动条到元素左边的距离var sLeft = element.scrollLeft;//设置滚动条滚动了多少像素element.scrollLeft = 10;</code></pre><p><code>scrollLeft</code> 可以是任意整数，然而：</p><ul><li>如果元素不能滚动（比如：元素没有溢出），那么<code>scrollLeft</code> 的值是0。</li><li>如果给<code>scrollLeft</code> 设置的值小于0，那么<code>scrollLeft</code> 的值将变为0。</li><li>如果给<code>scrollLeft</code> 设置的值大于元素内容最大宽度，那么<code>scrollLeft</code> 的值将被设为元素最大宽度。</li></ul></li><li><p>实例</p><pre><code class="js">document.onclick = function()&#123;    // console.log(obox.scrollLeft);    obox.scrollLeft = 666;&#125;</code></pre><p> <img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="Image:Dimensions-client.png"> </p></li></ul><h3 id="Node类型的操作"><a href="#Node类型的操作" class="headerlink" title="Node类型的操作"></a>Node类型的操作</h3><blockquote><p> DOM将任何HTML和XML文档描绘成一个由多层节点构成的结构。有几个不同类型的节点，节点又有各自的特点、数据和方法，同时节点之间存在着某种关系，这些关系构成层次。 </p></blockquote><p>DOM内的节点分为四种：元素，文本，注释和属性</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>除 IE 之外，在其他所有浏览器中都可以访问到Node类型。<br>JavaScript 中的所有节点类型都继承 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。</p><h4 id="12种节点类型"><a href="#12种节点类型" class="headerlink" title="12种节点类型"></a>12种节点类型</h4><blockquote><p><strong>Node.ELEMENT_NODE(1);（常用）            //元素节点</strong><br><strong>Node.ATTRIBUTE_NODE(2);                        //属性节点</strong><br><strong>Node.TEXT_NODE(3);（常用）                    //文本节点</strong><br>Node.CDATA_SECTION_NODE(4);<br>Node.ENTITY_REFERENCE_NODE(5)<br>Node.ENTITY_NODE(6) ;<br>Node.PROCESSING_INSTRUCTION_NODE(7);<br><strong>Node.COMMENT_NODE(8)                            //注释节点</strong><br>Node.DOCUMENT_NODE(9);<br>Node.DOCUMENT_TYPE_NODE(10);<br>Node.DOCUMEN_FRAGME_NODE(11);<br>Node.NOTATION_NODE(12)</p></blockquote><h4 id="nodeType-属性"><a href="#nodeType-属性" class="headerlink" title="nodeType 属性"></a>nodeType 属性</h4><blockquote><p>nodeType 属性返回以数字值返回指定节点的节点类型。</p><p>如果节点是元素节点，则 nodeType 属性将返回 1。</p><p>如果节点是属性节点，则 nodeType 属性将返回 2。</p></blockquote><ul><li><p>语法</p><pre><code class="js">node.nodeName</code></pre></li><li><p>实例</p><pre><code class="js">document.body.nodeType;//1</code></pre></li></ul><h4 id="nodeName属性"><a href="#nodeName属性" class="headerlink" title="nodeName属性"></a>nodeName属性</h4><blockquote><p>nodeName 属性指定节点的节点名称。</p><p>如果节点是元素节点，则 nodeName 属性返回标签名。</p><p>如果节点是属性节点，则 nodeName 属性返回属性的名称。</p><p>对于其他节点类型，nodeName 属性返回不同节点类型的不同名称。</p></blockquote><ul><li><p>语法</p><pre><code class="js">node.nodeName</code></pre></li><li><p>实例</p><pre><code class="js">document.body.nodeName;//BODY</code></pre></li></ul><h4 id="nodeValue属性"><a href="#nodeValue属性" class="headerlink" title="nodeValue属性"></a>nodeValue属性</h4><blockquote><p>nodeValue 属性设置或返回指定节点的节点值。</p><p><strong>注释：</strong>如果您希望返回元素的文本，<strong>请记住文本始终位于文本节点中</strong>，并且您必须返回文本节点的值（element.childNodes[0].nodeValue）。</p><p><strong>提示：</strong>nodeValue 属性的替代选择是 textContent 属性。</p><p><strong>更改文本节点的nodeValue属性值即可改变文本节点的内容</strong></p></blockquote><ul><li><p>语法</p><pre><code class="js">node.nodeValue = value;</code></pre></li><li><p>实例</p><pre><code class="js">var txt = document.createTextNode(&quot;123&quot;);txt.nodeValue = &quot;456&quot;;console.log(txt)//内容变成了456；</code></pre><p>```</p></li></ul><h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p><p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p><ul><li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li><li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li><li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li><li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li></ul><p>在操作一个DOM节点前，我们需要通过各种方式<code>先拿到这个DOM节点</code>。</p><p><strong>第一种方法</strong>或者<strong>最常用的方法</strong>是：</p><ul><li><p><strong>document.getElementById()</strong></p></li><li><p><strong>document.getElementsByTagName()</strong></p></li><li><p><strong>CSS选择器document.getElementsByClassName()</strong></p></li></ul><p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p><p>​```js<br>// 返回ID为’test’的节点：<br>var test = document.getElementById(‘test’);</p><p>// 先定位ID为’test-table’的节点，再返回其内部所有tr节点：<br>var trs = document.getElementById(‘test-table’).getElementsByTagName(‘tr’);</p><p>// 先定位ID为’test-div’的节点，再返回其内部所有class包含red的节点：<br>var reds = document.getElementById(‘test-div’).getElementsByClassName(‘red’);</p><p>// 获取节点test下的所有直属子节点:<br>var cs = test.children;</p><p>// 获取节点test下第一个、最后一个子节点：<br>var first = test.firstElementChild;<br>var last = test.lastElementChild;</p><pre><code>**第二种方法**是使用`querySelector()`和`querySelectorAll()`，需要了解selector语法，然后使用条件来获取节点，更加方便：</code></pre><p>// 通过querySelector获取ID为q1的节点：<br>var q1 = document.querySelector(‘#q1’);</p><p>// 通过querySelectorAll获取q1节点内的符合条件的所有节点：<br>var ps = q1.querySelectorAll(‘div.highlighted &gt; p’);</p><pre><code>注意：低版本的IE&lt;8不支持`querySelector`和`querySelectorAll`。IE8仅有限支持。严格地讲，我们这里的DOM节点是指`Element`，但是DOM节点实际上是`Node`，在HTML中，`Node`包括`Element`、`Comment`、`CDATA_SECTION`等很多种，以及根节点`Document`类型，但是，绝大多数时候我们只关心`Element`，也就是实际控制页面结构的`Node`，其他类型的`Node`忽略即可。根节点`Document`已经自动绑定为全局变量`document`。#### 更新DOM#####  innerHTML &gt;  可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树 ```js// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;var p = document.getElementById(&#39;p-id&#39;);// 设置文本为abc:p.innerHTML = &#39;ABC&#39;; // &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;// 设置HTML:p.innerHTML = &#39;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#39;;// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</code></pre><p> 用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 </p><p>通过<strong>innerHTML</strong>和<strong>数组遍历</strong>实现多行多列的商品列表： <a href="..%5C%E4%BD%9C%E4%B8%9A%5Cday08%5C%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8.html">商品列表.html</a> </p><h5 id="innerText-textContent"><a href="#innerText-textContent" class="headerlink" title="innerText || textContent"></a>innerText || textContent</h5><blockquote><p> 可以自动对字符串进行HTML编码，保证无法设置任何HTML标签 </p></blockquote><pre><code class="js">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;var p = document.getElementById(&#39;p-id&#39;);// 设置文本:p.innerText = &#39;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#39;;// HTML被自动编码，无法设置一个&lt;script&gt;节点:// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</code></pre><p> 两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意IE&lt;9不支持<code>textContent</code>。 </p><h5 id="修改CSS"><a href="#修改CSS" class="headerlink" title="修改CSS"></a>修改CSS</h5><blockquote><p> DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置 </p></blockquote><p> 因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为<strong>驼峰式命名</strong><code>fontSize</code> ：</p><pre><code class="js">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;var p = document.getElementById(&#39;p-id&#39;);// 设置CSS:p.style.color = &#39;#ff0000&#39;;p.style.fontSize = &#39;20px&#39;;p.style.paddingTop = &#39;2em&#39;;</code></pre><h4 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h4><h5 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h5><blockquote><p> 把一个子节点添加到父节点的最后一个子节点 </p></blockquote><pre><code class="js">&lt;!-- HTML结构 --&gt;&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="js">var    js = document.getElementById(&#39;js&#39;),    list = document.getElementById(&#39;list&#39;);list.appendChild(js);</code></pre><p>现在，HTML结构变成了这样：</p><pre><code class="js">&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;/div&gt;</code></pre><p> 因为我们插入的<code>js</code>节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。 </p><h5 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h5><blockquote><p> 把子节点插入到指定的位置 </p></blockquote><ul><li><p>语法</p><pre><code class="js">document.getElementById(&quot;myList&quot;).insertBefore(newItem,existingItem);</code></pre></li><li><p>实例</p><pre><code class="js">var    list = document.getElementById(&#39;list&#39;),    ref = document.getElementById(&#39;python&#39;),    haskell = document.createElement(&#39;p&#39;);haskell.id = &#39;haskell&#39;;haskell.innerText = &#39;Haskell&#39;;list.insertBefore(haskell, ref);//把haskell节点 放在ref节点之前</code></pre></li></ul><ul><li>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-JavaScript对象Math</title>
      <link href="/2022/09/15/03%20JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/03%20JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="aJavaScript对象"><a href="#aJavaScript对象" class="headerlink" title="aJavaScript对象"></a>aJavaScript对象</h2><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h5 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h5><h6 id="Math-round-3-6"><a href="#Math-round-3-6" class="headerlink" title="Math.round(3.6);"></a>Math.round(3.6);</h6><blockquote><p>四舍五入  </p></blockquote><h6 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random();"></a>Math.random();</h6><blockquote><p>​     //返回一个大于等于0到小于1的随机数  </p></blockquote><h6 id="Math-max-a-b"><a href="#Math-max-a-b" class="headerlink" title="Math.max(a,b)"></a>Math.max(a,b)</h6><blockquote><p>返回较大的值  </p></blockquote><h6 id="Math-min-a-b"><a href="#Math-min-a-b" class="headerlink" title="Math.min(a,b);"></a>Math.min(a,b);</h6><blockquote><p>返回较小的值  </p></blockquote><h6 id="Math-abs-num"><a href="#Math-abs-num" class="headerlink" title="Math.abs(num)"></a>Math.abs(num)</h6><blockquote><p>返回绝对值  </p></blockquote><h6 id="Math-ceil-3-6"><a href="#Math-ceil-3-6" class="headerlink" title="Math.ceil(3.6)"></a>Math.ceil(3.6)</h6><blockquote><p>向上取整  </p></blockquote><h6 id="Math-floor-3-6"><a href="#Math-floor-3-6" class="headerlink" title="Math.floor(3.6)"></a>Math.floor(3.6)</h6><blockquote><p>向下取整  </p></blockquote><h6 id="Math-pow-x-y"><a href="#Math-pow-x-y" class="headerlink" title="Math.pow(x,y)"></a>Math.pow(x,y)</h6><blockquote><p>x的y次方  </p></blockquote><h6 id="Math-sqrt-num"><a href="#Math-sqrt-num" class="headerlink" title="Math.sqrt(num)"></a>Math.sqrt(num)</h6><blockquote><p>开平方  </p></blockquote><h6 id="Math-sin-x"><a href="#Math-sin-x" class="headerlink" title="Math.sin(x)"></a>Math.sin(x)</h6><blockquote><p>x的正弦值，返回值在-1到1之间  </p></blockquote><h6 id="Math-cos-x"><a href="#Math-cos-x" class="headerlink" title="Math.cos(x)"></a>Math.cos(x)</h6><blockquote><p>x的余弦值，返回值在-1到1之间</p></blockquote><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_abs.asp">abs(x)</a></td><td align="left">返回数的绝对值。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_acos.asp">acos(x)</a></td><td align="left">返回数的反余弦值。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_asin.asp">asin(x)</a></td><td align="left">返回数的反正弦值。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_atan.asp">atan(x)</a></td><td align="left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_atan2.asp">atan2(y,x)</a></td><td align="left">返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_ceil.asp">ceil(x)</a></td><td align="left">对数进行上舍入。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_cos.asp">cos(x)</a></td><td align="left">返回数的余弦。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_exp.asp">exp(x)</a></td><td align="left">返回 e 的指数。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_floor.asp">floor(x)</a></td><td align="left">对数进行下舍入。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_log.asp">log(x)</a></td><td align="left">返回数的自然对数（底为e）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_max.asp">max(x,y)</a></td><td align="left">返回 x 和 y 中的最高值。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_min.asp">min(x,y)</a></td><td align="left">返回 x 和 y 中的最低值。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_pow.asp">pow(x,y)</a></td><td align="left">返回 x 的 y 次幂。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_random.asp">random()</a></td><td align="left">返回 0 ~ 1 之间的随机数。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_round.asp">round(x)</a></td><td align="left">把数四舍五入为最接近的整数。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sin.asp">sin(x)</a></td><td align="left">返回数的正弦。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sqrt.asp">sqrt(x)</a></td><td align="left">返回数的平方根。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tan.asp">tan(x)</a></td><td align="left">返回角的正切。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tosource_math.asp">toSource()</a></td><td align="left">返回该对象的源代码。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_valueof_math.asp">valueOf()</a></td><td align="left">返回 Math 对象的原始值。</td></tr></tbody></table><h5 id="Math属性"><a href="#Math属性" class="headerlink" title="Math属性"></a>Math属性</h5><h6 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h6><blockquote><p> PI 属性就是 π，即圆的周长和它的直径之比。这个值近似为 3.141592653589793。 </p></blockquote><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_e.asp">E</a></td><td align="left">返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_ln2.asp">LN2</a></td><td align="left">返回 2 的自然对数（约等于0.693）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_ln10.asp">LN10</a></td><td align="left">返回 10 的自然对数（约等于2.302）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_log2e.asp">LOG2E</a></td><td align="left">返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_log10e.asp">LOG10E</a></td><td align="left">返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_pi.asp">PI</a></td><td align="left">返回圆周率（约等于3.14159）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sqrt1_2.asp">SQRT1_2</a></td><td align="left">返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_sqrt2.asp">SQRT2</a></td><td align="left">返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><blockquote><p> Date 对象用于处理日期和时间。 </p></blockquote><h5 id="创建-Date-对象的语法"><a href="#创建-Date-对象的语法" class="headerlink" title="创建 Date 对象的语法"></a>创建 Date 对象的语法</h5><pre><code class="js">var myDate = new Date();</code></pre><p><strong>注释：</strong>Date 对象会自动把当前日期和时间保存为其初始值。</p><h5 id="设置Date对象的语法"><a href="#设置Date对象的语法" class="headerlink" title="设置Date对象的语法"></a>设置Date对象的语法</h5><ul><li><p>创建日期对象时设置</p><ul><li><p>单个参数：<strong>参数为字符</strong>,没有设置的部分为0，超出上限就：Invalid Date</p><pre><code class="js">var d = new Date(&quot;2008.08.08 8:8:8&quot;);var d = new Date(&quot;2008.08.08&quot;);var d = new Date(&quot;2008.13.08&quot;);var d = new Date(&quot;2008/08/08&quot;);var d = new Date(&quot;2008-08-08&quot;);var d = new Date(&quot;2008,08,08&quot;);var d = new Date(&quot;2008 08 08&quot;);console.log(d);</code></pre></li><li><p>多个参数：<strong>参数为数值</strong>，月的范围是0~11，没有设置的部分为0，超出上限，向前进1</p><pre><code class="js">var d = new Date(2008,8,8,8,8,8);var d = new Date(2008,8,8);var d = new Date(2008,12,33);//2009-2-02，33号自动进1个月，12（超过了0-11反胃）自动进1个年，相当于进了2个月console.log(d);</code></pre></li></ul></li><li><p>创建日期对象后</p><ul><li><p>使用set系列方法单独设置：没有设置的部分，以当前日期为准,超出上限，向前进1</p><pre><code class="js">var d = new Date();d.setFullYear(2008);d.setMonth(12);     //0~11d.setDate(56);//不能设置星期几，因为星期几是自动计算得出的d.setHours(35);d.setMinutes(78);d.setSeconds(86);d.setMilliseconds(666);console.log(d)console.log(d.getMilliseconds());</code></pre></li><li><p>使用设置时间戳</p><pre><code class="js">var d = new Date();d.setTime(1000000000000);console.log(d);</code></pre></li></ul></li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_constructor_date.asp">constructor</a></td><td align="left">返回对创建此对象的 Date 函数的引用。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_prototype_date.asp">prototype</a></td><td align="left">使您有能力向对象添加属性和方法。</td></tr></tbody></table><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_Date.asp">Date()</a></td><td align="left">返回当日的日期和时间。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getDate.asp">getDate()</a></td><td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getDay.asp">getDay()</a></td><td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getMonth.asp">getMonth()</a></td><td align="left">从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getFullYear.asp">getFullYear()</a></td><td align="left">从 Date 对象以四位数字返回年份。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getYear.asp">getYear()</a></td><td align="left">请使用 getFullYear() 方法代替。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getHours.asp">getHours()</a></td><td align="left">返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getMinutes.asp">getMinutes()</a></td><td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getSeconds.asp">getSeconds()</a></td><td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getMilliseconds.asp">getMilliseconds()</a></td><td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getTime.asp">getTime()</a></td><td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getTimezoneOffset.asp">getTimezoneOffset()</a></td><td align="left">返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCDate.asp">getUTCDate()</a></td><td align="left">根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCDay.asp">getUTCDay()</a></td><td align="left">根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCMonth.asp">getUTCMonth()</a></td><td align="left">根据世界时从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCFullYear.asp">getUTCFullYear()</a></td><td align="left">根据世界时从 Date 对象返回四位数的年份。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCHours.asp">getUTCHours()</a></td><td align="left">根据世界时返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCMinutes.asp">getUTCMinutes()</a></td><td align="left">根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCSeconds.asp">getUTCSeconds()</a></td><td align="left">根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCMilliseconds.asp">getUTCMilliseconds()</a></td><td align="left">根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_parse.asp">parse()</a></td><td align="left">返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setDate.asp">setDate()</a></td><td align="left">设置 Date 对象中月的某一天 (1 ~ 31)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setMonth.asp">setMonth()</a></td><td align="left">设置 Date 对象中月份 (0 ~ 11)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setFullYear.asp">setFullYear()</a></td><td align="left">设置 Date 对象中的年份（四位数字）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setYear.asp">setYear()</a></td><td align="left">请使用 setFullYear() 方法代替。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setHours.asp">setHours()</a></td><td align="left">设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setMinutes.asp">setMinutes()</a></td><td align="left">设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setSeconds.asp">setSeconds()</a></td><td align="left">设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setMilliseconds.asp">setMilliseconds()</a></td><td align="left">设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setTime.asp">setTime()</a></td><td align="left">以毫秒设置 Date 对象。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCDate.asp">setUTCDate()</a></td><td align="left">根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCMonth.asp">setUTCMonth()</a></td><td align="left">根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCFullYear.asp">setUTCFullYear()</a></td><td align="left">根据世界时设置 Date 对象中的年份（四位数字）。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setutchours.asp">setUTCHours()</a></td><td align="left">根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCMinutes.asp">setUTCMinutes()</a></td><td align="left">根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCSeconds.asp">setUTCSeconds()</a></td><td align="left">根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCMilliseconds.asp">setUTCMilliseconds()</a></td><td align="left">根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_tosource_boolean.asp">toSource()</a></td><td align="left">返回该对象的源代码。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toString_date.asp">toString()</a></td><td align="left">把 Date 对象转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toTimeString.asp">toTimeString()</a></td><td align="left">把 Date 对象的时间部分转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toDateString.asp">toDateString()</a></td><td align="left">把 Date 对象的日期部分转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toGMTString.asp">toGMTString()</a></td><td align="left">请使用 toUTCString() 方法代替。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toUTCString.asp">toUTCString()</a></td><td align="left">根据世界时，把 Date 对象转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toLocaleString.asp">toLocaleString()</a></td><td align="left">根据本地时间格式，把 Date 对象转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toLocaleTimeString.asp">toLocaleTimeString()</a></td><td align="left">根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_toLocaleDateString.asp">toLocaleDateString()</a></td><td align="left">根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_utc.asp">UTC()</a></td><td align="left">根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/jsref/jsref_valueOf_date.asp">valueOf()</a></td><td align="left">返回 Date 对象的原始值。</td></tr></tbody></table><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><blockquote><p>值 <code>null</code> 特指对象的值未设置。它是 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">基本类型</a> 之一。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">null</code></pre><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>值 <code>null</code> 是一个字面量，不像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>，它不是全局对象的一个属性。<code>null</code> 是表示缺少的标识，指示变量未指向任何对象。把 <code>null</code> 作为尚未创建的对象，也许更好理解。在 API 中，<code>null</code> 常在返回类型应是一个对象，但没有关联的值的地方使用。</p><pre><code class="js">// foo 不存在，它从来没有被定义过或者是初始化过：foo;&quot;ReferenceError: foo is not defined&quot;// foo 现在已经是知存在的，但是它没有类型或者是值：var foo = null; foo;null</code></pre><h4 id="null-与-undefined-的不同点："><a href="#null-与-undefined-的不同点：" class="headerlink" title="null 与 undefined 的不同点："></a><code>null</code> 与 <code>undefined</code> 的不同点：</h4><p>当检测 <code>null</code> 或 <code>undefined</code> 时，注意<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">相等（==）与全等（===）两个操作符的区别</a> ，前者会执行类型转换：</p><pre><code class="js">typeof null        // &quot;object&quot; (因为一些以前的原因而不是&#39;null&#39;)typeof undefined   // &quot;undefined&quot;null === undefined // falsenull  == undefined // truenull === null // truenull == null // true!null //trueisNaN(1 + null) // falseisNaN(1 + undefined) // true</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-引用数据类型</title>
      <link href="/2022/09/15/02%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/02%20%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h3><ul><li>对象的概念：对象事物的描述</li><li>对象的语法（组成，本质）：属性名和属性值，<strong>键值对</strong></li></ul><pre><code class="JS">var people = &#123;    name:&quot;admin&quot;,    age:18,    sex:&quot;男&quot;,    like:&quot;ball&quot;,    sayhello:function()&#123;        console.log(&quot;我叫&quot;+people.name+&quot;今年&quot;+people.age+&quot;性别&quot;+people.sex+&quot;爱好&quot;+people.like)    &#125;&#125;people.sayhello();</code></pre><ul><li>对象的作用（意义）:储存数据，编程</li><li>对象中的值的叫法和操作：对象里的变量叫<strong>属性</strong>，对象里的函数叫<strong>方法</strong></li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li><strong>.语法</strong>：对象.属性（方法名），当属性名和方法名确定</li></ul><pre><code class="js">obj1.name = &quot;hello&quot;;console.log(obj1.name);</code></pre><ul><li> <strong>[ ]语法</strong>，当属性名和方法名不确定</li></ul><pre><code class="js">var obj1 = &#123;&#125;;var str = &quot;age&quot;;console.log(obj1[str]);obj1[str] = &quot;男&quot;;console.log(obj1[&quot;name&quot;]);console.log(obj1);</code></pre><h3 id="函数Function"><a href="#函数Function" class="headerlink" title="函数Function"></a>函数Function</h3><blockquote><p>函数是由事件驱动的或者当他被调用时可执行的可重复使用的代码块。</p></blockquote><h4 id="函数的好处"><a href="#函数的好处" class="headerlink" title="函数的好处"></a>函数的好处</h4><ol><li>重复使用－－－－空调不可能是一次性的，可以重复使用</li><li>忽略细节－－－－会用空调不一定会生产空调</li><li>选择执行－－－－夏冬使用，春秋不用</li></ol><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><ol><li><p><strong>声明式</strong></p><table><thead><tr><th>function</th><th>为声明函数的关键字，指出这是一个函数</th></tr></thead><tbody><tr><td>fn</td><td>是函数名，类似于永来存储函数的变量</td></tr><tr><td>()</td><td>为函数的参数，多个参数用 , 隔开</td></tr><tr><td>{}</td><td>放置函数体，用于执行时，所要编译的代码段</td></tr></tbody></table></li><li><p><strong>赋值式</strong></p><pre><code class="js">var fn = function()&#123;&#125;;</code></pre><p>​    这种方式下，虽然这个函数没有名字，但是这个函数赋值给了fn，因此通过变量fn也能调用到这个函数，以上两种声明方式等价都可以使用，函数名/变量名＋()  调用执行。</p></li></ol><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><ol><li><p>自身执行</p><ul><li>函数名(),任何情况下，只要函数名()了，函数立即执行</li></ul></li><li><p>事件调用</p><ul><li><p>元素.事件 = 函数名</p><pre><code class="js">box.onclick = fn;</code></pre></li><li><p>元素.事件 = 函数的内容</p><pre><code class="js">box.onclick = function()&#123;...&#125;</code></pre></li></ul></li></ol><h4 id="函数写法的分类"><a href="#函数写法的分类" class="headerlink" title="函数写法的分类"></a>函数写法的分类</h4><ol><li><p>有名函数</p><ul><li>声明式创建的函数：function fn(){}</li></ul></li><li><p>无名函数</p><p>注意：无名函数不允许直接存在，必须作为值使用，是一种表达式，或值</p><pre><code class="js">function()&#123;  console.log(1)&#125;</code></pre><p>使用:</p><ol><li><strong>作为赋值式创建函数的值</strong>：<strong>var fn = function(){}</strong></li><li><strong>事件处理函数</strong>，直接作为事件执行函数存在：<strong>元素.事件 = function(){}</strong></li><li><strong>回调函数</strong>：作为函数的参数存在，也是一个值：</li></ol><pre><code class="js">function fn(a)&#123;a(1)&#125;; fn(function(b)&#123;...&#125;)；</code></pre><ol start="4"><li><strong>作为匿名函数的函数体存在</strong>：**(function(){})()**  </li></ol></li><li><p>匿名函数</p><pre><code class="js">(function()&#123;&#125;)()</code></pre><p>特点：自动执行</p></li></ol><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><ol><li><p><strong>形参</strong></p><ol><li>定义时的参数叫形参，</li><li>形参保存了实参</li><li>形参是变量</li><li>形参相当于赋值元素运算符=号，左边的内容</li></ol></li><li><p><strong>实参</strong></p><ol><li>执行时的参数叫实参</li><li>实参被形参接收</li><li>实参是值</li><li>实参相当于赋值元素运算符=号，右边的内容</li></ol></li><li><p><strong>参数的个数</strong></p><ul><li><p>可以传无限个</p></li><li><p>关系：实参和形参，数量一致，按照顺序一一对应</p></li><li><p>形参多，多出来的形参是undefined</p></li><li><p>实参多，多出来的实参，被传到arguments（实参全部都会比传到arguments)</p></li></ul></li><li><p><strong>参数的类型</strong></p><ul><li>任何类型</li></ul></li></ol><h4 id="函数的回调"><a href="#函数的回调" class="headerlink" title="函数的回调"></a>函数的回调</h4><blockquote><p>​    回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。</p><p>​    在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数</p></blockquote><pre><code class="js">   function sum(x,y,callback)&#123;                var sum = x+y;                callback(sum);        &#125;        sum(1,3,function(sum)&#123;                console.log(sum)        &#125;)</code></pre><h4 id="函数的return"><a href="#函数的return" class="headerlink" title="函数的return"></a>函数的return</h4><blockquote><p>将函数的执行或处理结果，返回到执行语句上，方便二次使用</p></blockquote><ol start="3"><li><p><strong>默认情况下，函数返回undefined</strong></p></li><li><p>如果需要有返回值，要在函数中使用关键字：return</p></li><li><p>return 值</p></li></ol><ul><li>为什么要有返回值，如果是处理数据的函数，处理之后的数据，有可能需要二次使用，需要有返回值，返回处理好的数据</li></ul><ol start="6"><li><p>通过return来返回无名函数</p><pre><code class="js">    function fn(a)&#123;            return function(b)&#123;                    return function (c)&#123;                            return function (d)&#123;                                    return a+b+c+d;                            &#125;                    &#125;            &#125;    &#125;    fn(3)(4)(5)(6)=3+4+5+6;</code></pre></li><li><p>return 可以返回几次数据:<strong>1次</strong></p><ul><li>函数中，可以写多个return，但是函数只能执行一次return，执行之后，函数会立即结束，后面代码不再执行</li></ul></li></ol><h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>arguments是函数中专有的一个对象，只有在函数中能拿到，用来保存函数所有的实参。</p><ol><li>arguments其实是一个伪数组，可以使用数组的所有方法和属性（length)。</li><li>arguments.length实际上就是实参的个数。</li><li>借助arguments找到所有的实参：console.log(arguments);</li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote><p>变量生效的区域</p><p>能不能跨作用域访问：</p><ol><li>同级局部不能跨</li><li>不能拿子，子能拿父</li><li>多个父子级作用域内都有，找最近的作用域</li></ol></blockquote><h5 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h5><blockquote><p>区域：每个函数都是一个局部</p></blockquote><ol><li><p>生命周期：朝生暮死，作用域声明时被创建，作用域结束时被释放</p></li><li><p>缺点：更麻烦，每个局部都需要定义某个变量，甚至是几个局部都相同的变量</p></li></ol><h5 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h5><blockquote><p>整个代码文件，不属于任何一个函数，就是全局</p></blockquote><ol><li>生命周期：一直存在，在任何位置都可以拿到</li><li>缺点：更浪费性能</li></ol><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><blockquote><p>递归算法：在函数内部，执行自己</p></blockquote><pre><code class="js">    function fn(n)&#123;        if(n == 1 || n == 2)&#123;            return 1        &#125;else&#123;            return fn(n-1) + fn(n-2);        &#125;    &#125;    console.log(fn(8));</code></pre><p><strong>递归最重要的就是停止条件</strong></p><h4 id="Function-prototype方法"><a href="#Function-prototype方法" class="headerlink" title="Function.prototype方法"></a>Function.prototype方法</h4><h5 id="blind"><a href="#blind" class="headerlink" title="blind()"></a>blind()</h5><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p></blockquote><ul><li><p>语法</p><pre><code class="js">function.bind(thisArg[, arg1[, arg2[, ...]]])</code></pre></li><li><p>返回值</p><p>​    返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。</p></li><li><p>实例</p><pre><code class="js">this.x = 9;    // 在浏览器中，this 指向全局的 &quot;window&quot; 对象var module = &#123;  x: 81,  getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 81var retrieveX = module.getX;retrieveX();   // 返回 9 - 因为函数是在全局作用域中调用的// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象// 新手可能会将全局变量 x 与 module 的属性 x 混淆var boundGetX = retrieveX.bind(module);boundGetX(); // 81</code></pre></li></ul><h5 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h5><blockquote><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p></blockquote><ul><li><p>语法</p><pre><code class="js">function.call(thisArg, arg1, arg2, ...)</code></pre></li><li><p>返回值</p><p>​    使用调用者提供的 <code>this</code> 值和参数调用该函数的返回值。若该方法没有返回值，则返回 <code>undefined</code>。</p></li><li><p>实例</p><pre><code class="js">//使用call 方法调用父构造函数function Product(name, price) &#123;  this.name = name;  this.price = price;&#125;function Food(name, price) &#123;  Product.call(this, name, price);  this.category = &#39;food&#39;;&#125;function Toy(name, price) &#123;  Product.call(this, name, price);  this.category = &#39;toy&#39;;&#125;var cheese = new Food(&#39;feta&#39;, 5);var fun = new Toy(&#39;robot&#39;, 40);//使用call方法调用匿名函数var animals = [  &#123; species: &#39;Lion&#39;, name: &#39;King&#39; &#125;,  &#123; species: &#39;Whale&#39;, name: &#39;Fail&#39; &#125;];for (var i = 0; i &lt; animals.length; i++) &#123;  (function(i) &#123;    this.print = function() &#123;      console.log(&#39;#&#39; + i + &#39; &#39; + this.species                  + &#39;: &#39; + this.name);    &#125;    this.print();  &#125;).call(animals[i], i);&#125;</code></pre></li></ul><h5 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h5><blockquote><p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数。</p></blockquote><ul><li><p>语法</p><pre><code class="js">func.apply(thisArg, [argsArray])</code></pre></li><li><p>返回值</p><p>​    调用有指定<code>this</code>值和参数的函数的结果。</p></li><li><p>实例</p><pre><code class="js">//用 apply 将数组添加到另一个数组var array = [&#39;a&#39;, &#39;b&#39;];var elements = [0, 1, 2];array.push.apply(array, elements);console.info(array); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</code></pre></li></ul><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><blockquote><p>概念：一组数据，数据的组合</p><p>意义：可以操作多个数据</p></blockquote><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><ul><li><p>字面量</p><pre><code class="js">var arr = [];</code></pre></li><li><p>构造函数：</p><pre><code class="js">var arr = new Array();</code></pre></li><li><p>二者的唯一区别：</p><p>字面量：当只有一个数据，还是数值时，字面量会在数组中保存这个数值</p><p>构造函数：会将这个数值作为长度</p><pre><code class="js"> var arr = [6];    var arr2 = new Array(6);    console.log(arr);//[6]    console.log(arr2);//(6) [empty × 6]    console.log(arr.length)//1    console.log(arr2.length)//6</code></pre></li></ul><h4 id="Array-prototype方法"><a href="#Array-prototype方法" class="headerlink" title="Array.prototype方法"></a>Array.prototype方法</h4><p>索引操作</p><ul><li><p>增：给不存在的索引赋值</p><pre><code class="js">var arr = [1,2,3];arr[5] = 5;console.log(arr);//(6) [1, 2, 3, empty × 2, 5]console.log(arr.length);//6</code></pre></li><li><p>删</p><pre><code class="js">var arr = [1,2,3];arr.length = 2;console.log(arr);//(2) [1, 2]</code></pre></li><li><p>改</p><pre><code class="js">var arr = [1,2,3];arr[1] = 4;console.log(arr);//(3) [1,4,3]</code></pre></li><li><p>查：数组的遍历</p><pre><code class="js">var arr = [1,2,3];for(var i=0;i&lt;3;i++)    &#123;        console.log(arr[i]);    &#125;</code></pre></li></ul><p><strong>方法操作(方法：对象中的函数属性)</strong></p><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p><strong>功能：</strong>用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br> <strong>参数：</strong>concat(data1,data2,…);所有参数可选，要合并的数据；data为数组时，将data合并到原数组；data为具体数据时直接添加到原数组尾部；省略时创建原数组的副本。</p><pre><code class="js">var arr1 = [1,2,3]var arr2 = arr1.concat();console.log(arr1);           //[1,2,3]---原数组console.log(arr1 === arr2);  //falseconsole.log(arr2);           //[1,2,3]---原数组的副本console.log(arr1.concat(&quot;hello&quot;,&quot;world&quot;));           //[1,2,3,&quot;hello&quot;,&quot;world&quot;]console.log(arr1.concat([&quot;a&quot;,&quot;b&quot;],[[3,4],&#123;&quot;name&quot;:&quot;admin&quot;&#125;]));   //[1,2,3,&quot;a&quot;,&quot;b&quot;,[3,4],&#123;&quot;name&quot;:&quot;admin&quot;&#125;]console.log(arr1);           //[1,2,3]---原数组未改变1,2,3,4].concat(1,2,3,[1,[1,2,3,4,5],3]);//(10) [1, 2, 3, 4, 1, 2, 3, 1, Array(5), 3]</code></pre><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p><strong>功能：</strong>根据指定分隔符将数组中的所有元素放入一个字符串，并返回这个字符串。<br> <strong>参数：</strong>join(str);参数可选，默认为”,”号，以传入的字符作为分隔符。</p><pre><code class="jsx">    var arr = [1,2,3];    console.log(arr.join());         //1,2,3    console.log(arr.join(&quot;-&quot;));      //1-2-3    console.log(arr);                //[1,2,3]---原数组未改变</code></pre><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p><strong>功能：</strong>方法用于删除并返回数组的最后一个元素。<br> <strong>参数：</strong>无</p><pre><code class="jsx">    var arr = [1,2,3];    console.log(arr.pop());     //3    console.log(arr);           //[1,2]---原数组改变</code></pre><h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p><strong>功能：</strong>方法用于删除并返回数组的第一个元素。<br> <strong>参数：</strong>无</p><pre><code class="jsx">    var arr = [1,2,3]    console.log(arr.shift());       //1    console.log(arr);               //[2,3]---原数组改变</code></pre><h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p><strong>功能：</strong>向数组的开头添加一个或更多元素，并返回新的长度。<br> <strong>参数：</strong>unshift(newData1, newData2, ……)</p><pre><code class="jsx">    var arr = [1,2,3];    console.log(arr.unshift(&quot;hello&quot;));  //4    console.log(arr);                   //[&quot;hello&quot;,1,2,3]---原数组改变    console.log(arr.unshift(&quot;a&quot;,&quot;b&quot;));  //6    console.log(arr);                   //[&quot;a&quot;,&quot;b&quot;,&quot;hello&quot;,1,2,3]---原数组改变</code></pre><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p><strong>功能：</strong>向数组的末尾添加一个或更多元素，并返回新的长度。<br> <strong>参数：</strong>push(newData1, newData2, ……)</p><pre><code class="jsx">    var arr = [1,2,3];    console.log(arr.push(&quot;hello&quot;));  //4    console.log(arr);                //[1,2,3,&quot;hello&quot;]---原数组改变    console.log(arr.push(&quot;a&quot;,&quot;b&quot;));  //6    console.log(arr);                //[1,2,3,&quot;hello&quot;,&quot;a&quot;,&quot;b&quot;]---原数组改变</code></pre><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p><strong>功能：</strong>颠倒数组中元素的顺序。<br> <strong>参数：</strong>无</p><pre><code class="jsx">    var arr = [1,2,3];    console.log(arr.reverse());     //[3,2,1]    console.log(arr);               //[3,2,1]---原数组改变</code></pre><h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p><strong>功能：</strong>可从已有的数组中返回选定的元素。该方法接收两个参数slice(start,end)，strat为必选，表示从第几位开始；end为可选，表示到第几位结束(不包含end位)，省略表示到最后一位；start和end都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。<br> <strong>参数：</strong>slice(startIndex, endIndex)</p><pre><code class="ruby">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    console.log(arr.slice(1,3));        //[&quot;Jack&quot;,&quot;Lucy&quot;]    console.log(arr.slice(1));          //[&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;]    console.log(arr.slice(-4,-1));      //[&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;]    console.log(arr.slice(-2));         //[&quot;Lily&quot;,&quot;May&quot;]    console.log(arr.slice(1,-2));       //[&quot;Jack&quot;,&quot;Lucy&quot;]    console.log(arr);                   //[&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;]---原数组未改变</code></pre><h6 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h6><p><strong>功能：</strong>对数组中的元素进行排序，默认是升序。</p><pre><code class="jsx">    var arr = [6,1,5,2,3];    console.log(arr.sort());    //[1, 2, 3, 5, 6]    console.log(arr);           //[1, 2, 3, 5, 6]---原数组改变</code></pre><p>但是在排序前，会先调用数组的toString方法，将每个元素都转成字符之后，再进行排序，此时会按照字符串的排序，逐位比较，进行排序。</p><pre><code class="jsx">    var arr = [6,1024,52,256,369];    console.log(arr.sort());    //[1024, 256, 369, 52, 6]    console.log(arr);           //[1024, 256, 369, 52, 6]---原数组改变</code></pre><p><strong>参数：</strong>sort(callback)<br> 如果需要按照数值排序，需要传参。sort(callback)，callback为回调函数，该函数应该具有两个参数，比较这两个参数，然后返回一个用于说明这两个值的相对顺序的数字（a-b）。其返回值如下：<br> 若 a 小于 b，返回一个小于 0 的值。<br> 若 a 等于 b，则返回 0。<br> 若 a 大于 b，则返回一个大于 0 的值。</p><pre><code class="jsx">    var arr = [6,1024,52,256,369];    console.log(arr.sort(fn));  //[6, 52, 256, 369, 1024]    console.log(arr);           //[6, 52, 256, 369, 1024]---原数组改变    function fn(a,b)&#123;        return a-b;    &#125;</code></pre><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p><strong>功能：</strong>向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。<br> <strong>参数：</strong>splice(start,num,data1,data2,…); 所有参数全部可选。</p><ol><li>不传参时：无操作</li></ol><pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    console.log(arr.splice());      //[]    console.log(arr);               //[&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;]---无操作</code></pre><ol start="2"><li>只传入start：表示从索引为start的数据开始删除，直到数组结束</li></ol><pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];        console.log(arr.splice(2));     //[&quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]    console.log(arr);               //[&quot;Tom&quot;, &quot;Jack&quot;]---原数组改变</code></pre><ol start="3"><li>传入start和num：表示从索引为start的数据开始删除，删除num个</li></ol><pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];        console.log(arr.splice(2,2));   //[&quot;Lucy&quot;, &quot;Lily&quot;]    console.log(arr);               //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;May&quot;]---原数组改变</code></pre><ol start="4"><li>删除和替换更多：表示从索引为start的数据开始删除，删除num个，并将第三个参数及后面所有参数，插入到start的位置</li></ol><pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];        console.log(arr.splice(2,2,&quot;a&quot;,&quot;b&quot;));  //[&quot;Lucy&quot;, &quot;Lily&quot;]    console.log(arr);                      //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;a&quot;, &quot;b&quot;, &quot;May&quot;]---原数组改变</code></pre><ol start="5"><li>增加更多：表示从索引为start的数据开始删除，删除num个，并将第三个参数及后面所有参数，插入到start的位置</li></ol><pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];        console.log(arr.splice(2,0,&quot;a&quot;,&quot;b&quot;));  //[]    console.log(arr);    //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;a&quot;, &quot;b&quot;, &quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]---原数组改变</code></pre><h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h6><p><strong>功能：</strong>转换成字符串，类似于没有参数的join()。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。<br> <strong>参数：</strong>无</p><pre><code class="js">    var arr = [1,2,3];    console.log(arr.toString());     //1,2,3    console.log(arr);                //[1,2,3]---原数组未改变</code></pre><h6 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h6><p><strong>功能：</strong>返回数组的原始值（一般情况下其实就是数组自身），一般由js在后台调用，并不显式的出现在代码中<br> <strong>参数：</strong>无</p><pre><code class="jsx">    var arr = [1,2,3];    console.log(arr.valueOf());         //[1,2,3]    console.log(arr);                   //[1,2,3]    //为了证明返回的是数组自身    console.log(arr.valueOf() == arr);  //true</code></pre><h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><p><strong>功能：</strong>根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1。该方法是查询方法，不会对数组产生改变。<br> <strong>参数：</strong>indexOf(value, start);value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1</p><pre><code class="jsx">    var arr = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];    console.log(arr.indexOf(&quot;l&quot;));        //2    console.log(arr.indexOf(&quot;l&quot;,3));      //3    console.log(arr.indexOf(&quot;l&quot;,4));      //-1    console.log(arr.indexOf(&quot;l&quot;,-1));     //-1    console.log(arr.indexOf(&quot;l&quot;,-3));     //2</code></pre><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h6><p><strong>功能：</strong>根据指定的数据，从右向左，查询在数组中出现的位置，如果不存在指定的数据，返回-1。该方法是查询方法，不会对数组产生改变。<br> <strong>参数：</strong>lastIndexOf(value, start);value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1</p><pre><code class="jsx">    var arr = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;];    console.log(arr.lastIndexOf(&quot;l&quot;));        //3    console.log(arr.lastIndexOf(&quot;l&quot;,3));      //3    console.log(arr.lastIndexOf(&quot;l&quot;,1));      //-1    console.log(arr.lastIndexOf(&quot;l&quot;,-3));     //2    console.log(arr.lastIndexOf(&quot;l&quot;,-4));     //-1</code></pre><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h6><p><strong>功能：</strong>ES5新增方法，用来遍历数组，该方法没有返回值。forEach接收的回调函数会根据数组的每一项执行，该回调函数默认有三个参数，分别为：遍历到的数组的数据，对应的索引，数组自身。<br> <strong>参数：</strong>forEach(callback);callback默认有三个参数，分别为value，index，self。</p><pre><code class="js">    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.forEach(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self));    &#125;)    // 打印结果为：    // Tom--0--true    // Jack--1--true    // Lucy--2--true    // Lily--3--true    // May--4--true    console.log(a);     //undefined---forEach没有返回值    //该方法为遍历方法，不会修改原数组</code></pre><h6 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h6><p><strong>功能：</strong>1.同forEach功能；2.map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。<br> <strong>参数：</strong>map(callback);callback默认有三个参数，分别为value，index，self。</p><pre><code class="js">    //功能1：同forEach    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.map(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self))    &#125;)    // 打印结果为：    // Tom--0--true    // Jack--1--true    // Lucy--2--true    // Lily--3--true    // May--4--true    //功能2：每次回调函数的返回值被map组成新数组返回    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.map(function(value,index,self)&#123;        return &quot;hi:&quot;+value;    &#125;)    console.log(a);     //[&quot;hi:Tom&quot;, &quot;hi:Jack&quot;, &quot;hi:Lucy&quot;, &quot;hi:Lily&quot;, &quot;hi:May&quot;]    console.log(arr);   //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]---原数组未改变</code></pre><h6 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h6><p><strong>功能：</strong>1.同forEach功能；2.filter的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）。<br> <strong>参数：</strong>filter(callback);callback默认有三个参数，分别为value，index，self。</p><pre><code class="js">    //功能1：同forEach    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.filter(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr === self))    &#125;)    // 打印结果为：    // Tom--0--true    // Jack--1--true    // Lucy--2--true    // Lily--3--true    // May--4--true    //功能2：当回调函数的返回值为true时，本次的数组值返回给filter，被filter组成新数组返回    var arr = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.filter(function(value,index,self)&#123;        return value.length &gt; 3;    &#125;)    console.log(a);         //[&quot;Jack&quot;, &quot;Lucy&quot;, &quot;Lily&quot;]    console.log(arr);       //[&quot;Tom&quot;, &quot;Jack&quot;, &quot;Lucy&quot;, &quot;Lily&quot;, &quot;May&quot;]---原数组未改变</code></pre><h6 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h6><blockquote><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p></blockquote><ul><li><p>语法</p><pre><code class="js">arr.includes(valueToFind[, fromIndex])</code></pre></li><li><p>返回值</p><pre><code class="js">返回一个布尔值 Boolean ，如果在数组中找到了（如果传入了 fromIndex ，表示在 fromIndex 指定的索引范围中找到了）则返回 true 。</code></pre></li><li><p>实例</p><pre><code class="js">var arr = [1,2,2,4,5,6,7];console.log(arr.includes(8));//falseconsole.log(arr.includes(1));//trueconsole.log(arr.includes(2));//true</code></pre></li></ul><h6 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h6><p><strong>功能：</strong>判断数组中每一项是否都满足条件，只有所有项都满足条件，才会返回true。<br> <strong>参数：</strong>every()接收一个回调函数作为参数，这个回调函数需要有返回值，every(callback);callback默认有三个参数，分别为value，index，self。</p><p><strong>功能1：</strong>当回调函数的返回值为true时，类似于forEach的功能，遍历所有；如果为false，那么停止执行，后面的数据不再遍历，停在第一个返回false的位置。</p><pre><code class="jsx">    //demo1:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.every(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))    &#125;)    // 打印结果为：    // Tom--0--true    //因为回调函数中没有return true，默认返回undefined，等同于返回false    //demo2:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.every(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))        return value.length &lt; 4;    &#125;)    // 打印结果为：    // Tom--0--true    // abc--1--true    // Jack--2--true    //因为当遍历到Jack时，回调函数到return返回false，此时Jack已经遍历，但是后面数据就不再被遍历了    //demo3:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.every(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))        return true;    &#125;)    // 打印结果为：    // Tom--0--true    // abc--1--true    // Jack--2--true    // Lucy--3--true    // Lily--4--true    // May--5--true    //因为每个回调函数的返回值都是true，那么会遍历数组所有数据，等同于forEach功能</code></pre><p><strong>功能2：</strong>当每个回调函数的返回值都为true时，every的返回值为true，只要有一个回调函数的返回值为false，every的返回值都为false</p><pre><code class="jsx">    //demo1:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.every(function(value,index,self)&#123;        return value.length &gt; 3;    &#125;)    console.log(a);           //false    //demo2:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.every(function(value,index,self)&#123;        return value.length &gt; 2;    &#125;)    console.log(a);           //true</code></pre><h6 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h6><p><strong>功能：</strong>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。<br> <strong>参数：</strong>some()接收一个回调函数作为参数，这个回调函数需要有返回值，some(callback);callback默认有三个参数，分别为value，index，self。</p><p><strong>功能1：</strong>因为要判断数组中的每一项，只要有一个回调函数返回true，some都会返回true，所以与every正好相反，当遇到一个回调函数的返回值为true时，可以确定结果，那么停止执行，后面都数据不再遍历，停在第一个返回true的位置；当回调函数的返回值为false时，需要继续向后执行，到最后才能确定结果，所以会遍历所有数据，实现类似于forEach的功能，遍历所有。</p><pre><code class="jsx">    //demo1:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.some(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))        return value.length &gt; 3;    &#125;)    // 打印结果为：    // Tom--0--true    // abc--1--true    // Jack--2--true    //demo2:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.some(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))        return true;    &#125;)    // 打印结果为：    // Tom--0--true    //demo3:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.some(function(value,index,self)&#123;        console.log(value + &quot;--&quot; + index + &quot;--&quot; + (arr == self))        return false;    &#125;)    // 打印结果为：    // Tom--0--true    // abc--1--true    // Jack--2--true    // Lucy--3--true    // Lily--4--true    // May--5--true</code></pre><p><strong>功能2：</strong>与every相反，只要有一个回调函数的返回值都为true，some的返回值为true，所有回调函数的返回值为false，some的返回值才为false</p><pre><code class="jsx">    //demo1:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.some(function(value,index,self)&#123;        return value.length &gt; 3;    &#125;)    console.log(a);             //true    //demo2:    var arr = [&quot;Tom&quot;,&quot;abc&quot;,&quot;Jack&quot;,&quot;Lucy&quot;,&quot;Lily&quot;,&quot;May&quot;];    var a = arr.some(function(value,index,self)&#123;        return value.length &gt; 4;    &#125;)    console.log(a);             //false</code></pre><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h6><p><strong>功能：</strong>从数组的第一项开始，逐个遍历到最后，迭代数组的所有项，然后构建一个最终返回的值。</p><p><strong>参数：</strong>reduce()接收一个或两个参数：第一个是回调函数，表示在数组的每一项上调用的函数；第二个参数（可选的）作为归并的初始值，被回调函数第一次执行时的第一个参数接收。<br> reduce(callback,initial);callback默认有四个参数，分别为prev，now，index，self。<br> callback返回的任何值都会作为下一次执行的第一个参数。<br> 如果initial参数被省略，那么第一次迭代发生在数组的第二项上，因此callback的第一个参数是数组的第一项，第二个参数就是数组的第二项。</p><pre><code class="jsx">    //demo1:不省略initial参数，回调函数没有返回值    var arr = [10,20,30,40,50];    arr.reduce(function(prev,now,index,self)&#123;        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self))    &#125;, 2019)    // 打印结果为：    // 2019--10--0--true    // undefined--20--1--true    // undefined--30--2--true    // undefined--40--3--true    // undefined--50--4--true    // 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined    //demo2:省略initial参数，回调函数没有返回值    var arr = [10,20,30,40,50];    arr.reduce(function(prev,now,index,self)&#123;        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self))    &#125;)    // 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项    // 10--20--1--true    // undefined--30--2--true    // undefined--40--3--true    // undefined--50--4--true    // 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined    //demo3:不省略initial参数，回调函数有返回值    var arr = [10,20,30,40,50];    arr.reduce(function(prev,now,index,self)&#123;        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self));        return &quot;hello&quot;;    &#125;, 2019)    // 打印结果为：    // 2019--10--0--true    // hello--20--1--true    // hello--30--2--true    // hello--40--3--true    // hello--50--4--true    // 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值    //demo4:省略initial参数，回调函数有返回值    var arr = [10,20,30,40,50];    arr.reduce(function(prev,now,index,self)&#123;        console.log(prev + &quot;--&quot; + now + &quot;--&quot; + index + &quot;--&quot; + (arr == self));        return &quot;hello&quot;;    &#125;)    // 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项    // 10--20--1--true    // hello--30--2--true    // hello--40--3--true    // hello--50--4--true    // 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值    //demo5：使用reduce计算数组中所有数据的和    var arr = [10,20,30,40,50];    var sum = arr.reduce(function(prev,now,index,self)&#123;        return prev + now;    &#125;)    console.log(sum);      //150    // 回调函数的最后一次return的结果被返回到reduce方法的身上    //demo6：使用reduce计算数组中所有数据的和    var arr = [10,20,30,40,50];    var sum = arr.reduce(function(prev,now,index,self)&#123;        return prev + now;    &#125;, 8)    console.log(sum);      //158    // 回调函数的最后一次return的结果被返回到reduce方法的身上    // 因为reduce有第二个参数initial，在第一次执行时被计算，所以最终结果被加上8</code></pre><h6 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h6><p><strong>功能：</strong>（与reduce类似）从数组的最后一项开始，向前逐个遍历到第一位，迭代数组的所有项，然后构建一个最终返回的值。<br> <strong>参数：</strong>同reduce。<br> <strong>demo：</strong>同reduce</p><h5 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h5><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h6><pre><code class="js">var arr = [5,99,2,9,1,5,67,7,10,23]      //定义一个杂乱的数组    for(var i=0;i&lt;arr.length-1;i++)&#123;         //大循环，用于遍历数组每个元素        for(var j=0;j&lt;arr.length-i-1;j++)&#123;   //小循环，用于将数组中的某个元素与其它所有元素相比较            var temp;                         //声明一个局部变量，当作第三个空瓶子            if(arr[j]&gt;arr[j+1])&#123;           //判断当前元素和后一个元素的大小，如果当前元素比后一个元素大                temp = arr[j+1];           //将后一个元素（小元素）放在空瓶子里                arr[j+1] = arr[j];         //将当前元素（大元素）放在后一个元素的位置                arr[j] = temp;             //将小元素从空瓶子中拿出来，放在当前元素的位置            &#125;        &#125;     &#125;    console.log(arr);                      //完成循环之后，初始数组的顺序已经发生改变</code></pre><h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h6><pre><code class="js">    var arr = [5,99,2,9,1,5,67,7,10,23]    for(var i=0;i&lt;arr.length-1;i++)&#123;       //大循环，需要比对的次数        var min = arr[i];                  //假定一个最小值        var minIndex = i;                  //假定最小值的索引        for(var j=i+1;j&lt;arr.length;j++)&#123;   //小循环，每次需要比对的次数            if(min&gt;arr[j])&#123;                //判断最小值是否为真的最小值                min = arr[j];              //获取真正的最小值                minIndex = j;              //获取真正最小值的索引            &#125;        &#125;        arr[minIndex] = arr[i];            //将当前元素放在最小值的位置        arr[i] = min;                      //将最小值放在当前元素的位置    &#125;    console.log(arr);                      //输入排序好的数组 </code></pre><h1 id="数组的方法some和includes"><a href="#数组的方法some和includes" class="headerlink" title="数组的方法some和includes"></a><a href="https://www.cnblogs.com/wwwxxjsyy/p/12558954.html">数组的方法some和includes</a></h1><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p><p>some() 方法会依次执行数组的每个元素：</p><ul><li>如果有一个元素满足条件，则表达式返回<em>true</em> , 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回false。</li><li></li></ul><p><strong>注意：</strong> some() 不会对空数组进行检测。</p><p>​      some() 不会改变原始数组。</p><p>includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false</p><p>两者经常会搭配使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-基本数据类型</title>
      <link href="/2022/09/15/01%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/09/15/01%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote><p>字符串的标志：引号</p></blockquote><ul><li><p>字符串的拼接过程中：引号要配对，变量不能放在引号中</p><pre><code class="js">var a = &quot;很好&quot;;console.log(&quot;今天天气&quot;+ a +&quot;适合出去玩&quot;);</code></pre></li><li><p>创建字符</p><ul><li>字面量创建</li><li>构造函数创建</li></ul><pre><code class="js">var str = &quot;&quot;;var str2 = new String(&quot;&quot;);console.log(str);console.log(str2);</code></pre></li></ul><h4 id="String-prototype方法"><a href="#String-prototype方法" class="headerlink" title="String.prototype方法"></a>String.prototype方法</h4><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h5><blockquote><p> indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.indexOf(searchvalue,fromindex)</code></pre></li><li><p>实例</p><pre><code class="js">var str = &quot;hello world&quot;;str.indexOf(&quot;o&quot;);//4，存在即返回索引str.indexOf(&quot;o&quot;,5);//7,从索引为5的数据开始往后找str.indexOf(&quot;a&quot;);//-1,不存在即返回-1</code></pre></li></ul><h5 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h5><blockquote><p>charAt() 方法可返回指定位置的字符。</p><p>请注意，JavaScript 并没有一种有别于字符串类型的字符数据类型，所以返回的字符是长度为 1 的字符串。</p></blockquote><ul><li><p>语法</p><pre><code class="js"> stringObject.charAt(index)</code></pre></li><li><p>实例</p><pre><code class="js">var str = &quot;hello world&quot;;str.charAt(2);//&quot;l&quot;str.charAt(-1);//&quot;&quot;</code></pre></li></ul><h5 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h5><blockquote><p> slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.slice(start,end)</code></pre></li><li><p>实例</p><pre><code class="js">var str=&quot;Hello happy world!&quot;;document.write(str.slice(6));//&quot;happy world!&quot;document.write(str.slice(2,4));//&quot;ll&quot;</code></pre></li></ul><h5 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h5><blockquote><p> substr() 方法可在字符串中抽取从 <em>start</em> 下标开始的指定数目的字符。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.substr(start,length)</code></pre></li><li><p>实例</p><pre><code class="js">var str=&quot;Hello happy world!&quot;;document.write(str.substr(6));//&quot;happy world!&quot;document.write(str.substr(2,4));//&quot;lo h&quot;</code></pre></li></ul><h5 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h5><blockquote><p> substring() 方法用于提取字符串中介于两个指定下标之间的字符。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.substring(start,stop)，取start到（stop-1）范围内的字符</code></pre></li><li><p>实例</p><pre><code class="js">var str=&quot;Hello world!&quot;document.write(str.substring(3));//&quot;lo world!&quot;document.write(str.substring(3,7))//&quot;lo w&quot;</code></pre></li></ul><h5 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h5><blockquote><p> split() 方法用于把一个字符串分割成字符串数组。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.split(separator,howmany)</code></pre></li><li><p>实例</p><pre><code class="js">var str=&quot;How are you doing today?&quot;console.log(str.split(&quot; &quot;) + &quot;&lt;br /&gt;&quot;)//&quot;How,are,you,doing,today?&lt;br /&gt;&quot;console.log(str.split(&quot;&quot;) + &quot;&lt;br /&gt;&quot;)//&quot;H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?&lt;br /&gt;&quot;console.log(str.split(&quot; &quot;,3))//(3) [&quot;How&quot;, &quot;are&quot;, &quot;you&quot;]&quot;2:3:4:5&quot;.split(&quot;:&quot;)    //将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]&quot;|a|b|c&quot;.split(&quot;|&quot;)    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&quot;hello&quot;.split(&quot;&quot;, 3)    //可返回 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;]</code></pre></li></ul><h5 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h5><blockquote><p> toLowerCase() 方法用于把字符串转换为小写。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.toLowerCase()</code></pre></li><li><p>返回值</p><p>​    一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了小写字符。</p></li><li><p>实例</p><pre><code class="js">var str=&quot;Hello World!&quot;console.log(str.toLowerCase());//&quot;hello world!&quot;</code></pre></li></ul><h5 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h5><blockquote><p> toUpperCase() 方法用于把字符串转换为大写。 </p></blockquote><ul><li><p>语法</p><pre><code class="JS">stringObject.toUpperCase()</code></pre></li><li><p>返回值</p><p>​    一个新的字符串，在其中 stringObject 的所有小写字符全部被转换为了大写字符。 </p></li><li><p>实例</p><pre><code class="js">var str=&quot;Hello World!&quot;console.log(str.toUpperCase());//&quot;HELLO WORLD!&quot;</code></pre></li></ul><h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><blockquote><p> concat() 方法用于连接两个或多个字符串。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.concat(stringX,stringX,...,stringX)</code></pre></li><li><p>实例</p><pre><code class="js">var str1=&quot;Hello &quot;var str2=&quot;world!&quot;document.write(str1.concat(str2));//&quot;Hello world!&quot;</code></pre></li></ul><h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><blockquote><p><strong><code>includes()</code></strong> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.includes(searchString[, position])</code></pre></li><li><p>返回值</p><pre><code class="js">如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。</code></pre></li><li><p>实例</p><pre><code class="js">var str = &#39;To be, or not to be, that is the question.&#39;;console.log(str.includes(&#39;To be&#39;)); // trueconsole.log(str.includes(&#39;question&#39;)); // trueconsole.log(str.includes(&#39;not tobe&#39;)); // falseconsole.log(str.includes(&#39;To be&#39;, 1)); // falseconsole.log(str.includes(&#39;o be&#39;, 1)); // trueconsole.log(str.includes(&#39;TO BE&#39;)); // false</code></pre></li></ul><h5 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h5><blockquote><p> replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 </p></blockquote><ul><li><p>语法</p><pre><code class="js">stringObject.replace(regexp/substr,replacement)</code></pre></li><li><p>返回值</p><p>​     一个新的字符串，是用 <em>replacement</em> 替换了 regexp 的第一次匹配或所有匹配之后得到的。 </p></li><li><p>实例</p><pre><code class="js">var str=&quot;Visit Microsoft!,Microsoft&quot;console.log(str.replace(/Microsoft/, &quot;W3School&quot;));//&quot;Visit Microsoft&quot;</code></pre></li></ul><h4 id="字符编码的介绍和转换"><a href="#字符编码的介绍和转换" class="headerlink" title="字符编码的介绍和转换"></a>字符编码的介绍和转换</h4><h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><ul><li> American Standard Code for Information Interchange，美国信息交换标准代码。 </li></ul><h5 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h5><ul><li>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。</li><li>Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 Unicode目前普遍采用的是UCS-2,它用两个字节来编码一个字符。 </li></ul><h5 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h5><ul><li>GBK全称《汉字内码扩展规范》（GBK即“国标”、“扩展”汉语拼音的第一个字母，英文名称：Chinese Internal Code Specification）</li><li>GBK 向下与GB2312编码兼容，向上支持 ISO 10646.1国际标准，是前者向后者过渡过程中的一个承上启下的产物。 </li></ul><h6 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h6><ul><li> UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码。</li><li> UTF-8用1到4个字节编码UNICODE字符。用在网页上可以同一页面显示中文简体繁体及其它语言（如英文，日文，韩文） </li></ul><h4 id="字符串常见API"><a href="#字符串常见API" class="headerlink" title="字符串常见API"></a>字符串常见API</h4><h5 id="myStr-charCodeAt-num"><a href="#myStr-charCodeAt-num" class="headerlink" title="myStr.charCodeAt(num)"></a>myStr.charCodeAt(num)</h5><p>返回指定位置的字符的Unicode（是字符编码的一种模式）编码。</p><pre><code class="js">var str=&quot;Hello world!&quot;console.log(str.charCodeAt(1));//&quot;101&quot;</code></pre><h5 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h5><p>String的意思就是不能用自己定义的字符串名字来调用，只能用String来定义调用。可以识别十进制和十六进制的编码，但是不识别u编码然后返回一个或多个字符串。(把unicode编码转换为字符串)。</p><pre><code class="js">var n = String.fromCharCode(65);//A</code></pre><h4 id="ES6新增"><a href="#ES6新增" class="headerlink" title="ES6新增"></a>ES6新增</h4><h5 id="str-codePointAt"><a href="#str-codePointAt" class="headerlink" title="str.codePointAt()"></a>str.codePointAt()</h5><blockquote><p> <strong><code>codePointAt()</code></strong> 方法返回 一个 Unicode 编码点值的非负整数。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.codePointAt(pos)//支持5位unicode编码</code></pre></li><li><p>实例</p><pre><code class="js">&#39;ABC&#39;.codePointAt(1);          // 66&#39;\uD800\uDC00&#39;.codePointAt(0); // 65536&#39;XYZ&#39;.codePointAt(42); // undefined`𠮶`.codePointAt();//134070</code></pre></li></ul><h5 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h5><blockquote><p> <code>String.fromCodePoint()</code> 静态方法返回使用指定的代码点序列创建的字符串。**</p></blockquote><ul><li><p>语法</p><pre><code class="js">String.fromCodePoint(num1[, ...[, numN]])</code></pre></li><li><p>返回值</p><p><strong>使用指定的 Unicode 编码位置创建的字符串。</strong></p></li><li><p>实例</p><pre><code class="js">String.fromCodePoint(42);       // &quot;*&quot;String.fromCodePoint(65, 90);   // &quot;AZ&quot;String.fromCodePoint(0x404);    // &quot;\u0404&quot;String.fromCodePoint(0x2F804);  // &quot;\uD87E\uDC04&quot;String.fromCodePoint(194564);   // &quot;\uD87E\uDC04&quot;String.fromCodePoint(0x1D306, 0x61, 0x1D307) // &quot;\uD834\uDF06a\uD834\uDF07&quot;</code></pre></li></ul><h5 id="str-includes"><a href="#str-includes" class="headerlink" title="str.includes()"></a>str.includes()</h5><blockquote><p><strong><code>includes()</code></strong> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.includes(searchString[, position])</code></pre></li><li><p>返回值</p><pre><code class="js">如果当前字符串包含被搜寻的字符串，就返回 true；否则返回 false。</code></pre></li><li><p>实例</p><pre><code class="js">var str = &#39;To be, or not to be, that is the question.&#39;;console.log(str.includes(&#39;To be&#39;)); // trueconsole.log(str.includes(&#39;question&#39;)); // trueconsole.log(str.includes(&#39;not tobe&#39;)); // falseconsole.log(str.includes(&#39;To be&#39;, 1)); // falseconsole.log(str.includes(&#39;o be&#39;, 1)); // trueconsole.log(str.includes(&#39;TO BE&#39;)); // false</code></pre></li></ul><h5 id="str-startsWith"><a href="#str-startsWith" class="headerlink" title="str.startsWith()"></a>str.startsWith()</h5><blockquote><p><code>startsWith()</code> 方法用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 <code>true</code> 或 <code>false</code>。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.startsWith(searchString[, position])</code></pre></li><li><p>返回值</p><pre><code class="js">如果在字符串的开头找到了给定的字符则返回true;否则, 返回false.</code></pre></li><li><p>实例</p><pre><code class="js">var str = &quot;To be, or not to be, that is the question.&quot;;alert(str.startsWith(&quot;To be&quot;));         // truealert(str.startsWith(&quot;not to be&quot;));     // falsealert(str.startsWith(&quot;not to be&quot;, 10)); // true</code></pre></li></ul><h5 id="str-endsWith"><a href="#str-endsWith" class="headerlink" title="str.endsWith()"></a>str.endsWith()</h5><blockquote><p><code>endsWith()</code>方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 <code>true</code> 或 <code>false</code>。</p></blockquote><ul><li><p>语法</p><pre><code class="js">str.endsWith(searchString[, length])</code></pre></li><li><p>返回值</p><pre><code class="js">如果传入的子字符串在搜索字符串的末尾则返回true；否则将返回 false。</code></pre></li><li><p>实例</p><pre><code class="js">var str = &quot;To be, or not to be, that is the question.&quot;;alert( str.endsWith(&quot;question.&quot;) );  // truealert( str.endsWith(&quot;to be&quot;) );      // falsealert( str.endsWith(&quot;to be&quot;, 19) );  // true</code></pre></li></ul><h5 id="str-repeat"><a href="#str-repeat" class="headerlink" title="str.repeat()"></a>str.repeat()</h5><blockquote><p><strong><code>repeat()</code></strong> 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</p></blockquote><ul><li><p>语法</p><pre><code class="js">/**  * str: String * count: Number */let resultString = str.repeat(count);</code></pre></li><li><p>返回值</p><p><strong>包含指定字符串的指定数量副本的新字符串</strong></p></li><li><p>实例</p><pre><code class="js">&quot;abc&quot;.repeat(-1)     // RangeError: repeat count must be positive and less than inifinity&quot;abc&quot;.repeat(0)      // &quot;&quot;&quot;abc&quot;.repeat(1)      // &quot;abc&quot;&quot;abc&quot;.repeat(2)      // &quot;abcabc&quot;&quot;abc&quot;.repeat(3.5)    // &quot;abcabcabc&quot; 参数count将会被自动转换成整数.&quot;abc&quot;.repeat(1/0)    // RangeError: repeat count must be positive and less than inifinity</code></pre></li></ul><h5 id="反引号语法"><a href="#反引号语法" class="headerlink" title="反引号语法"></a>反引号语法</h5><ul><li><p>支持换行</p><pre><code class="js">var name = &quot;root&quot;;var str = `helloworld`;console.log(str);</code></pre></li><li><p>配合<code>$&#123;&#125;</code>支持变量拼接</p><pre><code class="js">var name = &quot;root&quot;;var str = `hello&quot;&quot;&#39;&#39;&#39;&quot;&quot;$&#123;name&#125;&quot;world`;console.log(str)</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js原生-Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</title>
      <link href="/2022/09/15/Object-assign/"/>
      <url>/2022/09/15/Object-assign/</url>
      
        <content type="html"><![CDATA[<pre><code class="jsx">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】举个栗子：const object1 = &#123;  a: 1,  b: 2,  c: 3&#125;;const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d);console.log(object1)  // &#123; a: 1, b: 2, c: 3 &#125;console.log(object2)  // &#123; c: 3, d: 5, a: 1, b: 2 &#125;注意：1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</code></pre><h4 id="二、Object-assign-对象的深拷贝"><a href="#二、Object-assign-对象的深拷贝" class="headerlink" title="二、Object.assign()对象的深拷贝"></a>二、Object.assign()对象的深拷贝</h4><pre><code class="jsx">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; 最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响// Deep Clone （深拷贝）obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</code></pre><h4 id="3、对象的合并"><a href="#3、对象的合并" class="headerlink" title="3、对象的合并"></a>3、对象的合并</h4><pre><code class="jsx">const o1 = &#123; a: 1 &#125;;const o2 = &#123; b: 2 &#125;;const o3 = &#123; c: 3 &#125;;const obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1);  // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。其实就是对象的拷贝，o1就是目标对象，后面的是源对象，后面的属性等会拷贝到目标对象</code></pre><h4 id="4、合并具有相同属性的对象"><a href="#4、合并具有相同属性的对象" class="headerlink" title="4、合并具有相同属性的对象"></a>4、合并具有相同属性的对象</h4><pre><code class="jsx">const o1 = &#123; a: 1, b: 1, c: 1 &#125;;const o2 = &#123; b: 2, c: 2 &#125;;const o3 = &#123; c: 3 &#125;;const obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;1.属性被后续参数中具有相同属性的其他对象覆盖。2.目标对象的属性与源对象的属性相同，源的会覆盖目标的属性</code></pre><h4 id="5-继承属性和不可枚举属性是不能拷贝"><a href="#5-继承属性和不可枚举属性是不能拷贝" class="headerlink" title="5.继承属性和不可枚举属性是不能拷贝"></a>5.继承属性和不可枚举属性是不能拷贝</h4><pre><code class="jsx">const obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。    bar: &#123;        value: 2  // bar 是个不可枚举属性。    &#125;,    baz: &#123;        value: 3,        enumerable: true  // baz 是个自身可枚举属性。    &#125;&#125;);创建对象时，如果没有设置enumerable的值，默认为false（不可枚举属性），设置为true，则为可枚举属性const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125;</code></pre><h4 id="6-原始类型会被包装为对象"><a href="#6-原始类型会被包装为对象" class="headerlink" title="6.原始类型会被包装为对象"></a>6.原始类型会被包装为对象</h4><pre><code class="jsx">const v1 = &quot;abc&quot;;const v2 = true;const v3 = 10;const v4 = Symbol(&quot;foo&quot;)const obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); // 原始类型会被包装，null 和 undefined 会被忽略。// 注意，只有字符串的包装对象才可能有自身可枚举属性。console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</code></pre><h4 id="7-异常会打断后续拷贝任务"><a href="#7-异常会打断后续拷贝任务" class="headerlink" title="7.异常会打断后续拷贝任务"></a>7.异常会打断后续拷贝任务</h4><pre><code class="jsx">const target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;    value: 1,    writable: false&#125;); // target 的 foo 属性是个只读属性。Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);// TypeError: &quot;foo&quot; is read-only// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-ie8 浏览器 js兼容问题</title>
      <link href="/2022/09/15/ie8%20%E6%B5%8F%E8%A7%88%E5%99%A8%20js%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/15/ie8%20%E6%B5%8F%E8%A7%88%E5%99%A8%20js%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>因为项目需要，客户设备上都是IE8，总结了一些IE8上容易出现的兼容性错误</p><p>\1. jQuery使用2.0以下版本</p><p>2.document.getElementsByClassName 不能使用</p><p>3.console.log()不支持</p><p>4.iframe 的 onload 事件，需要通过 attachEvent 来注册</p><p>5.因为jq使用版本低，所以注意on ,是在1.7版本才出现的</p><p>6.IE8(Q) 中的 getElementById 方法能以 name 属性为参数获取某些元素</p><p>7.使用apped动态加载元素时候，注意标记元素必须是规范的html标记,不能是自创元素或者标记未关闭</p><p>8.remove()不能再IE8中正常使用,使用removeNode(true);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js原生-判断数组的几种方式</title>
      <link href="/2022/09/15/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/09/15/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>1./通过原型链做判断<br>obj.<strong>proto</strong> === Array.prototype;<br>2./通过 ES6 的 Array.isArray()做判断<br>Array.isArrray(obj);<br>3./通过 instanceof 做判断<br>obj instanceof Array;<br>4.通过 Array.prototype.isPrototypeOf<br>Array.prototype.isPrototypeOf(obj);<br>5./通过 Object.prototype.toString.call()做判断<br>Object.prototype.toString.call(obj).slice(8, -1) === “Array”;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js原生-事件，获取dom兼容写法</title>
      <link href="/2022/09/15/%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/"/>
      <url>/2022/09/15/%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="获取事件对象的兼容性写法"><a href="#获取事件对象的兼容性写法" class="headerlink" title="获取事件对象的兼容性写法"></a>获取事件对象的兼容性写法</h3><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    var e = eve || window.event;&#125;</code></pre><blockquote><p>IE支持：window.event</p></blockquote><h3 id="获取键盘按键值的兼容性写法"><a href="#获取键盘按键值的兼容性写法" class="headerlink" title="获取键盘按键值的兼容性写法"></a>获取键盘按键值的兼容性写法</h3><pre><code class="js">var obox = document.querySelector(&quot;.box&quot;);obox.onclick = function(eve)&#123;    var e = eve || window.event;    var code = e.keyCode || e.which;&#125;</code></pre><h3 id="“阻止浏览器默认行为的”兼容性写法"><a href="#“阻止浏览器默认行为的”兼容性写法" class="headerlink" title="“阻止浏览器默认行为的”兼容性写法"></a>“阻止浏览器默认行为的”兼容性写法</h3><pre><code class="js">function stopDefault(e)&#123;    if(e.preventDefault)    e.preventDefault();//兼容其他浏览器    else    e.returnValue = false;//兼容IE&#125;</code></pre><h3 id="“事件冒泡”的兼容写法"><a href="#“事件冒泡”的兼容写法" class="headerlink" title="“事件冒泡”的兼容写法"></a>“事件冒泡”的兼容写法</h3><pre><code class="js">function stopBubble(e)&#123;    if(e.stopPropagation)    e.stopPropagation();    else    e.cancelBubble = true;&#125;</code></pre><h3 id="“添加事件监听器”兼容性写法"><a href="#“添加事件监听器”兼容性写法" class="headerlink" title="“添加事件监听器”兼容性写法"></a>“添加事件监听器”兼容性写法</h3><pre><code class="js">function addEvent(ele,type,callback)&#123;    if(ele.attachEvent) ele.attachEvent(&quot;on&quot;+type,callback);    else    ele.addEventListener(type,callback);&#125;</code></pre><h3 id="“删除事件监听器”兼容性写法"><a href="#“删除事件监听器”兼容性写法" class="headerlink" title="“删除事件监听器”兼容性写法"></a>“删除事件监听器”兼容性写法</h3><pre><code class="js">function removeEvent(ele,type,callback)&#123;    if(ele.detachEvent) ele.detachEvent(&quot;on&quot;+type,callback);    else    ele.removeEventListener(type,callback);&#125;</code></pre><h3 id="event-target的兼容问题"><a href="#event-target的兼容问题" class="headerlink" title="event.target的兼容问题"></a>event.target的兼容问题</h3><pre><code class="js"> otable.onclick = function(eve)&#123;        var e = eve || window.event;        var target = e.target || e.srcElement;//只看这行        if(target.nodeName === &quot;TD&quot;)&#123;            var ipt = document.createElement(&quot;input&quot;);            ipt.value = target.innerHTML;            target.innerHTML = &quot;&quot;;            target.appendChild(ipt);            ipt.focus();            var that = target;            ipt.onblur = function()&#123;                that.innerHTML = this.value;            &#125;            ipt.onclick = function(eve)&#123;                var e = eve || window.event;                e.stopPropagation();            &#125;        &#125;    &#125;</code></pre><h3 id="“获取样式”的兼容写法"><a href="#“获取样式”的兼容写法" class="headerlink" title="“获取样式”的兼容写法"></a>“获取样式”的兼容写法</h3><pre><code class="js">function getStyle(ele,attr)&#123;    if(ele.currentStyle)&#123;//判断获取到的是不是true，那么就执行IE的currentStyle，如果是undefined那么就是false，那就执行getComputedStyle()        return ele.currentStyle[attr];//IE8及以下支持    &#125;else&#123;        return getComputedStyle(ele,false)[attr];//其他正常浏览器支持    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js原生-节流与防抖</title>
      <link href="/2022/09/15/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2022/09/15/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p> <strong>防抖——触发高频事件后 n 秒后函数只会执行一次，如果 n 秒内高频事件再 次被触发，则重新计算时间；</strong></p><pre><code class="javascript"> function debounce(fn) &#123;    let timeout = null // 创建一个标记用来存放定时器的返回值 return function() &#123; clearTimeout(timeout) // 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments) &#125;, 500) &#125;&#125;function sayHi() &#123; console.log(&#39;防抖成功&#39;)&#125;var inp = document.getElementById(&#39;inp&#39;)inp.addEventListener(&#39;input&#39;, debounce(sayHi))</code></pre><p> // <strong>防抖 节流——高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执 行频率</strong>。 </p><pre><code class="javascript">function throttle(fn) &#123; let canRun = true // 通过闭包保存一个标记 return function() &#123; if (!canRun) return // 在函数开头判断标记是否为 true，不为 true 则 return canRun = false // 立即设置为 false setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在 setTimeout 中 fn.apply(this, arguments) // 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表 示可以执行下一次循环了。当定时器没有执行的时候标记永远是 false，在开头 被 return 掉 canRun = true &#125;, 500) &#125;&#125;function sayHi(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight)&#125;window.addEventListener(&#39;resize&#39;, throttle(sayHi)) ![1624604032862](C:\Users\94549\AppData\Roaming\Typora\typora-user-images\1624604032862.png)![1624604059057](C:\Users\94549\AppData\Roaming\Typora\typora-user-images\1624604059057.png)</code></pre><p>// 防抖</p><pre><code class="javascript">export function _debounce(fn, delay) &#123;  var delay = delay || 200;  var timer;  return function () &#123;​    var th = this;​    var args = arguments;​    if (timer) &#123;​      clearTimeout(timer);​    &#125;​    timer = setTimeout(function () &#123;​      timer = null;​      fn.apply(th, args);​    &#125;, delay);  &#125;;&#125;</code></pre><p>// 节流</p><pre><code class="javascript">export function _throttle(fn, interval) &#123;  var last;  var timer;  var interval = interval || 200;  return function () &#123;​    var th = this;​    var args = arguments;​    var now = +new Date();​    if (last &amp;&amp; now - last &lt; interval) &#123;​      clearTimeout(timer);​      timer = setTimeout(function () &#123;​        last = now;​        fn.apply(th, args);​      &#125;, interval);​    &#125; else &#123;​      last = now;​      fn.apply(th, args);​    &#125;  &#125;&#125;</code></pre><p><strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p><p><strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js原生-js数据类型，堆和栈</title>
      <link href="/2022/09/15/%E5%A0%86%E6%A0%88/"/>
      <url>/2022/09/15/%E5%A0%86%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实一开始对栈、堆的概念特别模糊，只知道好像跟内存有关，又好像事件循环也沾一点边。面试薄荷的时候，面试官正好也问到了这个问题，当时只能大方的承认不会。痛定思痛，回去好好的研究一番。 我们将从<code>JS的内存机制</code>以及<code>事件机制</code>和<code>大量的🌰（例子）</code>来了解栈、堆究竟是个什么玩意。概念比较多，不用死读，所有的🌰心里想一遍，浏览器console看一遍就很清楚了。 let’s go</p><h2 id="JS内存机制"><a href="#JS内存机制" class="headerlink" title="JS内存机制"></a>JS内存机制</h2><p>因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不专业的朋友在进入到前端之后，会对内存空间的认知比较模糊。</p><p>在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，**栈内存(stack)**与**堆内存(heap)**。</p><h3 id="栈内存一般储存基础数据类型"><a href="#栈内存一般储存基础数据类型" class="headerlink" title="栈内存一般储存基础数据类型"></a>栈内存一般储存基础数据类型</h3><pre><code class="js"> Number String Null Undefined Boolean  (es6新引入了一种数据类型，Symbol)</code></pre><h4 id="最简单的🌰"><a href="#最简单的🌰" class="headerlink" title="最简单的🌰"></a>最简单的🌰</h4><pre><code class="js">var a = 1 </code></pre><p>我们定义一个变量a，系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。</p><p>数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循<strong>后进先出</strong>的原则。</p><h3 id="堆内存一般储存引用数据类型"><a href="#堆内存一般储存引用数据类型" class="headerlink" title="堆内存一般储存引用数据类型"></a>堆内存一般储存引用数据类型</h3><h4 id="堆内存的🌰"><a href="#堆内存的🌰" class="headerlink" title="堆内存的🌰"></a>堆内存的🌰</h4><pre><code class="js">var b = &#123; xi : 20 &#125;</code></pre><p>与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript<strong>不允许直接访问堆内存中的位置</strong>，因此我们不能直接操作对象的堆内存空间。看一下下面的图，加深理解。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>￼ </p><p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b03478ae38a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg104"></p><pre><code class="js">var a1 = 0;   // 栈 var a2 = &#39;this is string&#39;; // 栈var a3 = null; // 栈var b = &#123; m: 20 &#125;; // 变量b存在于栈中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中</code></pre><p>因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是<strong>从栈中获取了该对象的地址引用（或者地址指针）</strong>，然后再从堆内存中取得我们需要的数据。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="js">var a = 20;var b = a;b = 30;console.log(a)var m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;console.log(m.a)</code></pre><p>同学们自己在console里打一遍，再结合下面的图例，就很好理解了</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b0347adb343?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg106"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ecdcf3a44f381?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="15282536739797"></p><p>内存机制我们了解了，又引出一个新的问题，栈里只能存基础数据类型吗，我们经常用的function存在哪里呢？</p><h2 id="浏览器的事件机制"><a href="#浏览器的事件机制" class="headerlink" title="浏览器的事件机制"></a>浏览器的事件机制</h2><h4 id="一个经常被搬上面试题的🌰"><a href="#一个经常被搬上面试题的🌰" class="headerlink" title="一个经常被搬上面试题的🌰"></a>一个经常被搬上面试题的🌰</h4><pre><code class="js">console.log(1)let promise = new Promise(function(resolve,reject)&#123;    console.log(3)    resolve(100)&#125;).then(function(data)&#123;    console.log(100)&#125;)setTimeout(function()&#123;    console.log(4);&#125;)console.log(2)</code></pre><blockquote><p>上面这个demo的结果值是 1 3 2 100 4</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b033cff7849?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg105"></p><p><strong>对象</strong>放在<strong>heap（堆）**里，**常见的基础类型和函数**放在**stack（栈）**里，函数执行的时候在**栈<strong>里执行。栈里函数执行的时候可能会调一些</strong>Dom操作，ajax操作和setTimeout定时器</strong>，这时候要等stack（栈）里面的所有程序先走<strong>（注意：栈里的代码是先进后出）</strong>，走完后再走WebAPIs，WebAPIs执行后的结果放在callback queue（回调的队列里，注意：队列里的代码先放进去的先执行），也就是当栈里面的程序走完之后，再从任务队列中读取事件，将队列中的事件放到执行栈中依次执行，这个过程是循环不断的。</p><ul><li>1.所有同步任务都在主线程上执行，形成一个执行栈</li><li>2.主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>3.一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行</li><li>4.主线程从任务队列中读取事件，这个过程是循环不断的</li></ul><p>概念又臭又长，没关系，我们先粗略的扫一眼，接着往下看。</p><h4 id="举一个🌰说明栈的执行方式"><a href="#举一个🌰说明栈的执行方式" class="headerlink" title="举一个🌰说明栈的执行方式"></a>举一个🌰说明栈的执行方式</h4><pre><code class="js">var a = &quot;aa&quot;;function one()&#123;    let a = 1;    two();    function two()&#123;        let b = 2;        three();        function three()&#123;            console.log(b)        &#125;    &#125;&#125;console.log(a);one();</code></pre><blockquote><p>demo的结果是 aa 2</p></blockquote><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://user-gold-cdn.xitu.io/2018/6/13/163f6b03477d89cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="wechatimg107"></p><p>执行栈里面最先放的是全局作用域（代码执行有一个全局文本的环境），然后再放one， one执行再把two放进来，two执行再把three放进来，一层叠一层。</p><p>最先走的肯定是three，因为two要是先销毁了，那three的代码b就拿不到了，所以是<strong>先进后出</strong>（先进的后出），所以，three最先出，然后是two出，再是one出。</p><h3 id="那队列又是怎么一回事呢？"><a href="#那队列又是怎么一回事呢？" class="headerlink" title="那队列又是怎么一回事呢？"></a>那队列又是怎么一回事呢？</h3><h4 id="再举一个🌰"><a href="#再举一个🌰" class="headerlink" title="再举一个🌰"></a>再举一个🌰</h4><pre><code class="js">console.log(1);console.log(2);setTimeout(function()&#123;    console.log(3);&#125;)setTimeout(function()&#123;    console.log(4);&#125;)console.log(5);</code></pre><blockquote><p>首先执行了栈里的代码，1 2 5。 前面说到的<strong>settimeout</strong>会被放在队列里，当栈执行完了之后，从队列里添加到栈里执行（此时是依次执行），得到 3 4</p></blockquote><h4 id="再再举一个🌰"><a href="#再再举一个🌰" class="headerlink" title="再再举一个🌰"></a>再再举一个🌰</h4><pre><code class="js">console.log(1);console.log(2);setTimeout(function()&#123;    console.log(3);    setTimeout(function()&#123;        console.log(6);    &#125;)&#125;)setTimeout(function()&#123;    console.log(4);    setTimeout(function()&#123;        console.log(7);    &#125;)&#125;)console.log(5)</code></pre><blockquote><p>同样，先执行栈里的同步代码 1 2 5. 再同样，最外层的settimeout会放在队列里，当栈里面执行完成以后，放在栈中执行，3 4。 而嵌套的2个settimeout，会放在一个新的队列中，去执行 6 7.</p></blockquote><h4 id="再再再看一个🌰"><a href="#再再再看一个🌰" class="headerlink" title="再再再看一个🌰"></a>再再再看一个🌰</h4><pre><code class="js">console.log(1);console.log(2);setTimeout(function()&#123;    console.log(3);    setTimeout(function()&#123;        console.log(6);    &#125;)&#125;,400)setTimeout(function()&#123;    console.log(4);    setTimeout(function()&#123;        console.log(7);    &#125;)&#125;,100)console.log(5)</code></pre><blockquote><p>如上：这里的顺序是1，2，5，4，7，3，6。也就是只要两个set时间不一样的时候 ，就set时间短的先走完，包括set里面的回调函数，再走set时间慢的。（因为只有当时间到了的时候，才会把set放到队列里面去）</p></blockquote><pre><code class="js">setTimeout(function()&#123;    console.log(&#39;setTimeout&#39;)&#125;,0)for(var i = 0;i&lt;10;i++)&#123;    console.log(i)&#125;</code></pre><blockquote><p>这个demo的结果是 0 1 2 3 4 5 6 7 8 9 setTimeout</p></blockquote><p>所以，得出结论，永远都是<strong>栈里的代码先行执行</strong>，再从队列中依次读事件，加入栈中执行</p><p>stack（栈）里面都走完之后，就会依次读取任务队列,将队列中的事件放到执行栈中依次执行，这个时候栈中又出现了事件，这个事件又去调用了WebAPIs里的异步方法，那这些异步方法会在再被调用的时候放在队列里，然后这个主线程（也就是stack）执行完后又将从任务队列中依次读取事件，这个过程是循环不断的。</p><h4 id="再回到我们的第一个🌰"><a href="#再回到我们的第一个🌰" class="headerlink" title="再回到我们的第一个🌰"></a>再回到我们的第一个🌰</h4><pre><code class="js">console.log(1)let promise = new Promise(function(resolve,reject)&#123;    console.log(3)    resolve(100)&#125;).then(function(data)&#123;    console.log(100)&#125;)setTimeout(function()&#123;    console.log(4);&#125;)console.log(2)</code></pre><blockquote><p>上面这个demo的结果值是 1 3 2 100 4</p></blockquote><ul><li>为什么setTimeout要在Promise.then之后执行呢？</li><li>为什么new Promise又在console.log(2)之前执行呢？</li></ul><p>setTimeout是宏任务,而Promise.then是微任务 这里的new Promise()是同步的,所以是立即执行的。</p><h4 id="这就要引入一个新的话题宏任务和微任务（面试也会经常提及到）"><a href="#这就要引入一个新的话题宏任务和微任务（面试也会经常提及到）" class="headerlink" title="这就要引入一个新的话题宏任务和微任务（面试也会经常提及到）"></a>这就要引入一个新的话题<em>宏任务</em>和<em>微任务</em>（面试也会经常提及到）</h4><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><h5 id="参考-Tasks-microtasks-queues-and-schedules（https-jakearchibald-com-2015-tasks-microtasks-queues-and-schedules-utm-source-html5weekly）"><a href="#参考-Tasks-microtasks-queues-and-schedules（https-jakearchibald-com-2015-tasks-microtasks-queues-and-schedules-utm-source-html5weekly）" class="headerlink" title="参考  Tasks, microtasks, queues and schedules（https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly）"></a>参考  Tasks, microtasks, queues and schedules（<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly%EF%BC%89">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly）</a></h5><p><strong>概念：微任务和宏任务都是属于队列，而不是放在栈中</strong></p><h4 id="一个新的🌰"><a href="#一个新的🌰" class="headerlink" title="一个新的🌰"></a>一个新的🌰</h4><pre><code class="js">console.log(&#39;1&#39;);setTimeout(function() &#123;  console.log(&#39;setTimeout&#39;);&#125;, 0);Promise.resolve().then(function() &#123;  console.log(&#39;promise1&#39;);&#125;).then(function() &#123;  console.log(&#39;promise2&#39;);&#125;);console.log(&#39;2&#39;);</code></pre><blockquote><p>1 2 promise1 promise2 setTimeout</p></blockquote><h3 id="宏任务（task）"><a href="#宏任务（task）" class="headerlink" title="宏任务（task）"></a>宏任务（task）</h3><p>浏览器为了能够使得JS内部宏任务与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;…） 鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTMl。但是，<strong>setTimeout不一样</strong>，<strong>setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务</strong>。这就是为什么打印‘<strong>setTimeout</strong>’在‘<strong>promise1</strong> , <strong>promise2</strong>’之后。因为打印‘<strong>promise1</strong> , <strong>promise2</strong>’是第一个宏任务里面的事情，而‘<strong>setTimeout</strong>’是<strong>另一个新的独立的</strong>任务里面打印的。</p><h3 id="微任务-Microtasks"><a href="#微任务-Microtasks" class="headerlink" title="微任务 (Microtasks)"></a>微任务 (Microtasks)</h3><p>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务 比如对一系列动作做出反馈，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以<strong>减小一点性能的开销</strong>。只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。微任务包括了mutation observe的回调还有接下来的例子<strong>promise的回调</strong>。</p><p>一旦一个pormise有了结果，或者早已有了结果（有了结果是指这个promise到了fulfilled或rejected状态），他就会为它的回调产生一个微任务，这就保证了回调异步的执行即使这个promise早已有了结果。所以对一个已经有了结果的**promise调用.then()**会立即产生一个微任务。这就是为什么‘promise1’,’promise2’会打印在‘script end’之后，因为所有微任务执行的时候，当前执行栈的代码必须已经执行完毕。‘promise1’,’promise2’会打印在‘setTimeout’之前是因为所有微任务总会在下一个宏任务之前全部执行完毕。</p><h4 id="还是🌰"><a href="#还是🌰" class="headerlink" title="还是🌰"></a>还是🌰</h4><pre><code class="js">&lt;div class=&quot;outer&quot;&gt;  &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;//  elementsvar outer = document.querySelector(&#39;.outer&#39;);var inner = document.querySelector(&#39;.inner&#39;);//监听element属性变化new MutationObserver(function() &#123;  console.log(&#39;mutate&#39;);&#125;).observe(outer, &#123;  attributes: true&#125;);// click listener…function onClick() &#123;  console.log(&#39;click&#39;);  setTimeout(function() &#123;    console.log(&#39;timeout&#39;);  &#125;, 0);  Promise.resolve().then(function() &#123;    console.log(&#39;promise&#39;);  &#125;);  outer.setAttribute(&#39;data-random&#39;, Math.random());&#125;// inner.addEventListener(&#39;click&#39;, onClick);outer.addEventListener(&#39;click&#39;, onClick);</code></pre><blockquote><p>click promise mutate click promise mutate (2) timeout</p></blockquote><p>很好的解释了，setTimeout会在微任务（Promise.then、MutationObserver.observe）执行完成之后，加入一个新的宏任务中</p><h4 id="多看一些🌰"><a href="#多看一些🌰" class="headerlink" title="多看一些🌰"></a>多看一些🌰</h4><pre><code class="js">console.log(1);setTimeout(function()&#123;    console.log(2);    Promise.resolve(1).then(function()&#123;        console.log(&#39;promise1&#39;)    &#125;)&#125;)setTimeout(function()&#123;    console.log(3)    Promise.resolve(1).then(function()&#123;        console.log(&#39;promise2&#39;)    &#125;)&#125;)setTimeout(function()&#123;    console.log(4)    Promise.resolve(1).then(function()&#123;        console.log(&#39;promise3&#39;)    &#125;)&#125;)</code></pre><blockquote><p>1 2 promise1 3 promise2 4 promise3</p></blockquote><pre><code class="js">console.log(1);setTimeout(function()&#123;    console.log(2);    Promise.resolve(1).then(function()&#123;        console.log(&#39;promise1&#39;)        setTimeout(function()&#123;            console.log(3)            Promise.resolve(1).then(function()&#123;                console.log(&#39;promise2&#39;)            &#125;)        &#125;)    &#125;)&#125;)</code></pre><blockquote><p>1 2 promise1 3 promise2</p></blockquote><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><ul><li>栈：<ul><li>存储基础数据类型</li><li>按值访问</li><li>存储的值大小固定</li><li>由系统自动分配内存空间</li><li>空间小，运行效率高</li><li>先进后出，后进先出</li><li>栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。</li><li>微任务和宏任务</li></ul></li><li>堆:<ul><li>存储引用数据类型</li><li>按引用访问</li><li>存储的值大小不定，可动态调整</li><li>主要用来存放对象</li><li>空间大，但是运行效率相对较低</li><li>无序存储，可根据引用直接获取</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React- react基础</title>
      <link href="/2022/09/14/01%20react%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/14/01%20react%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="react基础"><a href="#react基础" class="headerlink" title="react基础"></a>react基础</h1><blockquote><p>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。</p></blockquote><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200310185038214.png" alt="image-20200310185038214"></p><h2 id="视图层的开发模式与函数式编程"><a href="#视图层的开发模式与函数式编程" class="headerlink" title="视图层的开发模式与函数式编程"></a>视图层的开发模式与函数式编程</h2><p>React 并不是完整的 MVC/MVVM 框架，它专注于提供清晰、简洁的 View（视图）层解决方案。</p><h3 id="函数式编程的好处"><a href="#函数式编程的好处" class="headerlink" title="函数式编程的好处"></a>函数式编程的好处</h3><ol><li>代码简洁，开发快速</li><li>接近自然语音，易于理解</li><li>更方便的代码管理</li><li>易于“并发编程”</li><li>代码的热更新</li></ol><h2 id="jsx语法与组件"><a href="#jsx语法与组件" class="headerlink" title="jsx语法与组件"></a>jsx语法与组件</h2><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由Babel 的 JSX 编译器实现。</p><p><a href="https://reactjs.org/docs/hello-world.html">https://reactjs.org/docs/hello-world.html</a></p><h2 id="如何创建react项目"><a href="#如何创建react项目" class="headerlink" title="如何创建react项目"></a>如何创建react项目</h2><pre><code class="javascript">1.npx create-react-app my-app</code></pre><pre><code class="javascript"> （my-app：项目名称）cd my-app  进入项目npm run start 或者yarn start</code></pre><h4 id="创建react-TypeScript的项目"><a href="#创建react-TypeScript的项目" class="headerlink" title="创建react+TypeScript的项目"></a>创建react+TypeScript的项目</h4><pre><code class="javascript">2.npx create-react-app my-app --template typescript</code></pre><pre><code class="javascript">（my-app：项目名称）cd my-app  进入项目npm run start 或者yarn start</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode -开发Vue必备插件</title>
      <link href="/2022/09/07/001VSCode%20%E5%BC%80%E5%8F%91Vue%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
      <url>/2022/09/07/001VSCode%20%E5%BC%80%E5%8F%91Vue%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="VSCode-开发Vue必备插件"><a href="#VSCode-开发Vue必备插件" class="headerlink" title="VSCode 开发Vue必备插件"></a>VSCode 开发Vue必备插件</h3><p>1.Vetur —— 语法高亮、智能感知、Emmet等<br>包含格式化功能， Alt+Shift+F （格式化全文），Ctrl+K Ctrl+F（格式化选中代码，两个Ctrl需要同时按着）</p><p>2.EsLint ——  检查代码是否符合规范</p><p>3.Debugger for Chrome —— 映射vscode上的断点到chrome上，方便调试（配置有点麻烦，其实我没用这个）</p><p>4.Auto Close Tag —— 自动闭合HTML/XML标签</p><p>5.Auto Rename Tag —— 自动完成另一侧标签的同步修改</p><p>6.JavaScript(ES6) code snippets —— ES6语法智能提示以及快速输入，除js外还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间</p><p>7.Path Intellisense —— 自动路径补全</p><p>8.HTML CSS Support —— 让 html 标签上写class 智能提示当前项目所支持的样式</p><p>9.Beautify—— 美化 javascript, JSON, CSS, Sass, 以及 HTML 。一般需要配合.jsbeautifyrc使用</p><p>10.Bracket Pair Colorizer——给括号加上不同的颜色，便于区分不同的区块，使用者可以定义不同括号类型和不同颜色</p><p>11.open in browser——直接右键项目单击启动<br>12.Material Icon Theme ———多样化的文件图标<br>13.One Dark Pro—— 一款深黑色的主题<br>14.Vue VSCode Snippets —— Vue 语法片段扩展<br>15.npm Intellisense—— import、require npm模块是自动补全</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-移动端项目的搭建过程</title>
      <link href="/2022/09/06/vue-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/06/vue-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>1.新建项目文件夹</p><p>2.执行vue-cli命令：vue init webpack 项目名</p><p>适配：vw,vh 永远获取屏幕宽高</p><p>100vw=屏幕的宽度      100除以设计图的百分之1例如：100/(375x0.01)</p><p>1vw=1%屏幕尺寸（设计图的百分比）</p><p>这样更直观的获取百分比 但是少部分手机不支持 所以需要自己把控</p><p>vw,vh是未来的趋势</p><p>l要移动端尺寸显示正常需要加上以下meta</p><meta name="viewport“ content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/><pre><code>width - viewport的宽度 height - viewport的高度initial-scale - 初始的缩放比例minimum-scale - 允许用户缩放到的最小比例maximum-scale - 允许用户缩放到的最大比例user-scalable - 用户是否可以手动缩放</code></pre><p>html&lt;font-size=:vw;&gt;{}100除以设计图总宽度的百分之1.例如width:800px时，100除以(800乘以1%)等于12.5vw.所以总html{font-size:12.5vw}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-36vue 前端代码风格</title>
      <link href="/2022/09/06/36vue%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
      <url>/2022/09/06/36vue%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h2><p>市面上常用的命名规范：</p><ul><li><code>camelCase</code>（小驼峰式命名法 —— 首字母小写）</li><li><code>PascalCase</code>（大驼峰式命名法 —— 首字母大写）</li><li><code>kebab-case</code>（短横线连接式）</li><li><code>Snake</code>（下划线连接式）</li></ul><h3 id="1-1-项目文件命名"><a href="#1-1-项目文件命名" class="headerlink" title="1.1 项目文件命名"></a>1.1 项目文件命名</h3><h4 id="1-1-1-项目名"><a href="#1-1-1-项目名" class="headerlink" title="1.1.1 项目名"></a>1.1.1 项目名</h4><p>全部采用小写方式， 以<strong>短横线</strong>分隔。 例：<code>my-project-name</code>。</p><h4 id="1-1-2-目录名"><a href="#1-1-2-目录名" class="headerlink" title="1.1.2 目录名"></a>1.1.2 目录名</h4><p><strong>参照项目命名规则，有复数结构时，要采用复数命名法</strong>。例：docs、assets、components、directives、mixins、utils、views。</p><pre><code class="js">my-project-name/|- BuildScript    // 流水线部署文件目录|- docs           // 项目的细化文档目录（可选）|- nginx          // 部署在容器上前端项目 nginx 代理文件目录|- node_modules   // 下载的依赖包|- public         // 静态页面目录    |- index.html // 项目入口|- src            // 源码目录    |- api        // http 请求目录    |- assets     // 静态资源目录，这里的资源会被wabpack构建        |- icon   // icon 存放目录        |- img    // 图片存放目录        |- js     // 公共 js 文件目录        |- scss   // 公共样式 scss 存放目录            |- frame.scss   // 入口文件            |- global.scss  // 公共样式            |- reset.scss   // 重置样式    |- components     // 组件    |- plugins        // 插件    |- router         // 路由    |- routes         // 详细的路由拆分目录（可选）        |- index.js    |- store          // 全局状态管理    |- utils          // 工具存放目录        |- request.js // 公共请求工具    |- views          // 页面存放目录    |- App.vue        // 根组件    |- main.js        // 入口文件    |- tests          // 测试用例    |- .browserslistrc// 浏览器兼容配置文件    |- .editorconfig  // 编辑器配置文件    |- .eslintignore  // eslint 忽略规则    |- .eslintrc.js   // eslint 规则    |- .gitignore     // git 忽略规则    |- babel.config.js // babel 规则    |- Dockerfile // Docker 部署文件    |- jest.config.js    |- package-lock.json    |- package.json // 依赖    |- README.md // 项目 README    |- vue.config.js // webpack 配置复制代码</code></pre><h4 id="1-1-3-图像文件名"><a href="#1-1-3-图像文件名" class="headerlink" title="1.1.3 图像文件名"></a>1.1.3 图像文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p><pre><code>banner_sina.gifmenu_aboutus.gifmenutitle_news.giflogo_police.giflogo_national.gifpic_people.jpgpic_TV.jpg复制代码</code></pre><h4 id="1-1-4-HTML-文件名"><a href="#1-1-4-HTML-文件名" class="headerlink" title="1.1.4 HTML 文件名"></a>1.1.4 HTML 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p><pre><code>|- error_report.html|- success_report.html复制代码</code></pre><h4 id="1-1-5-CSS-文件名"><a href="#1-1-5-CSS-文件名" class="headerlink" title="1.1.5 CSS 文件名"></a>1.1.5 CSS 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p><pre><code class="lua">|- normalize.less|- base.less|- date-picker.scss|- input-number.scss复制代码</code></pre><h4 id="1-1-6-JavaScript-文件名"><a href="#1-1-6-JavaScript-文件名" class="headerlink" title="1.1.6 JavaScript 文件名"></a>1.1.6 JavaScript 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p><pre><code class="scss">|- index.js|- plugin.js|- util.js|- date-util.js|- account-model.js|- collapse-transition.js复制代码</code></pre><blockquote><p>上述规则可以快速记忆为“静态文件下划线，编译文件短横线”。</p></blockquote><h3 id="1-2-Vue-组件命名"><a href="#1-2-Vue-组件命名" class="headerlink" title="1.2 Vue 组件命名"></a>1.2 Vue 组件命名</h3><h4 id="1-2-1-单文件组件名"><a href="#1-2-1-单文件组件名" class="headerlink" title="1.2.1 单文件组件名"></a>1.2.1 单文件组件名</h4><p>文件扩展名为 <code>.vue</code> 的 <code>single-file components</code> (单文件组件)。单文件组件名应该始终是<strong>单词大写开头</strong> (PascalCase)。</p><pre><code class="json">components/|- MyComponent.vue复制代码</code></pre><h4 id="1-2-2-单例组件名"><a href="#1-2-2-单例组件名" class="headerlink" title="1.2.2 单例组件名"></a>1.2.2 单例组件名</h4><p><strong>只拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p><p>这不意味着组件只可用于一个单页面，而是<em>每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em>只是目前</em>在每个页面里只使用一次。</p><p>比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。</p><pre><code>components/|- TheHeading.vue|- TheSidebar.vue复制代码</code></pre><h4 id="1-2-3-基础组件名"><a href="#1-2-3-基础组件名" class="headerlink" title="1.2.3 基础组件名"></a>1.2.3 基础组件名</h4><blockquote><p>基础组件：不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。</p></blockquote><p>应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。<strong>基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。</strong></p><pre><code>components/|- BaseButton.vue|- BaseTable.vue|- BaseIcon.vue复制代码</code></pre><h4 id="1-2-4-业务组件"><a href="#1-2-4-业务组件" class="headerlink" title="1.2.4 业务组件"></a>1.2.4 业务组件</h4><blockquote><p>业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p></blockquote><p><strong>掺杂了复杂业务的组件（拥有自身 <code>data</code>、<code>prop</code> 的相关处理）即业务组件</strong>应该以 <code>Custom</code> 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。</p><pre><code>components/|- CustomCard.vue复制代码</code></pre><h4 id="1-2-5-紧密耦合的组件名"><a href="#1-2-5-紧密耦合的组件名" class="headerlink" title="1.2.5 紧密耦合的组件名"></a>1.2.5 紧密耦合的组件名</h4><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong>  因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p><pre><code>components/|- TodoList.vue|- TodoListItem.vue|- TodoListItemButton.vue复制代码</code></pre><h4 id="1-2-6-组件名中单词顺序"><a href="#1-2-6-组件名中单词顺序" class="headerlink" title="1.2.6 组件名中单词顺序"></a>1.2.6 组件名中单词顺序</h4><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong> 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。如下组件主要是用于搜索和设置功能。</p><pre><code>components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputQuery.vue|- SearchInputExcludeGlob.vue|- SettingsCheckboxTerms.vue|- SettingsCheckboxLaunchOnStartup.vue复制代码</code></pre><p>还有另一种多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。</p><h4 id="1-2-7-完整单词的组件名"><a href="#1-2-7-完整单词的组件名" class="headerlink" title="1.2.7 完整单词的组件名"></a>1.2.7 完整单词的组件名</h4><p><strong>组件名应该倾向于而不是缩写。</strong> 编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p><pre><code>components/|- StudentDashboardSettings.vue|- UserProfileOptions.vue复制代码</code></pre><h3 id="1-3-代码参数命名"><a href="#1-3-代码参数命名" class="headerlink" title="1.3 代码参数命名"></a>1.3 代码参数命名</h3><h4 id="1-3-1-name"><a href="#1-3-1-name" class="headerlink" title="1.3.1 name"></a>1.3.1 name</h4><p><strong>组件名应该始终是多个单词，应该始终是 PascalCase 的。</strong> 根组件 App 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt; </code>之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><pre><code class="javascript">export default &#123;  name: &#39;ToDoList&#39;,  // ...&#125;复制代码</code></pre><h4 id="1-3-2-prop"><a href="#1-3-2-prop" class="headerlink" title="1.3.2 prop"></a>1.3.2 prop</h4><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case</strong>。我们单纯的遵循每个语言的约定，在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p><pre><code class="html">&lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt;复制代码export default &#123;  name: &#39;MyComponent&#39;,  // ...  props: &#123;    greetingText: &#123;      type: String,      required: true,      validator: function (value) &#123;        return [&#39;syncing&#39;, &#39;synced&#39;,].indexOf(value) !== -1      &#125;    &#125;  &#125;&#125;复制代码</code></pre><h4 id="1-3-3-router"><a href="#1-3-3-router" class="headerlink" title="1.3.3 router"></a>1.3.3 router</h4><p><strong>Vue Router Path 命名采用 kebab-case 格式。</strong> 用 Snake（如：<code>/user_info</code>）或 camelCase（如：<code>/userInfo</code>)的单词会被当成一个单词，搜索引擎无法区分语义。</p><pre><code class="javascript">// bad&#123;  path: &#39;/user_info&#39;, // user_info 当成一个单词  name: &#39;UserInfo&#39;,  component: UserInfo,  meta: &#123;    title: &#39; - 用户&#39;,    desc: &#39;&#39;  &#125;&#125;,// good&#123;  path: &#39;/user-info&#39;, // 能解析成 user info  name: &#39;UserInfo&#39;,  component: UserInfo,  meta: &#123;    title: &#39; - 用户&#39;,    desc: &#39;&#39;  &#125;&#125;,复制代码</code></pre><h4 id="1-3-4-模板中组件"><a href="#1-3-4-模板中组件" class="headerlink" title="1.3.4 模板中组件"></a>1.3.4 模板中组件</h4><p><strong>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。</strong></p><pre><code class="html">&lt;!-- 在单文件组件和字符串模板中 --&gt; &lt;MyComponent/&gt;&lt;!-- 在 DOM 模板中 --&gt; &lt;my-component&gt;&lt;/my-component&gt;复制代码</code></pre><h4 id="1-3-5-自闭合组件"><a href="#1-3-5-自闭合组件" class="headerlink" title="1.3.5 自闭合组件"></a>1.3.5 自闭合组件</h4><p><strong>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p><pre><code class="html">&lt;!-- 在单文件组件和字符串模板中 --&gt;&lt;MyComponent/&gt;&lt;!-- 在所有地方 --&gt;&lt;my-component&gt;&lt;/my-component&gt;复制代码</code></pre><h4 id="1-3-6-变量"><a href="#1-3-6-变量" class="headerlink" title="1.3.6 变量"></a>1.3.6 变量</h4><ul><li>命名方法：camelCase</li><li>命名规范：类型 + 对象描述或属性的方式</li></ul><pre><code class="javascript">// badvar getTitle = &quot;LoginTable&quot;// goodlet tableTitle = &quot;LoginTable&quot;let mySchool = &quot;我的学校&quot;复制代码</code></pre><h4 id="1-3-7-常量"><a href="#1-3-7-常量" class="headerlink" title="1.3.7 常量"></a>1.3.7 常量</h4><ul><li>命名方法：全部大写下划线分割</li><li>命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词</li></ul><pre><code class="javascript">const MAX_COUNT = 10const URL = &#39;http://test.host.com&#39;复制代码</code></pre><h4 id="1-3-8-方法"><a href="#1-3-8-方法" class="headerlink" title="1.3.8 方法"></a>1.3.8 方法</h4><ul><li>命名方法：camelCase</li><li>命名规范：统一使用动词或者动词 + 名词形式</li></ul><pre><code class="javascript">// 1、普通情况下，使用动词 + 名词形式// badgo、nextPage、show、open、login// goodjumpPage、openCarInfoDialog// 2、请求数据方法，以 data 结尾// badtakeData、confirmData、getList、postForm// goodgetListData、postFormData// 3、单个动词的情况init、refresh复制代码</code></pre><table><thead><tr><th>动词</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作 (权 )</td><td>函数返回一个布尔值。true：可执行；false：不可执行；</td></tr><tr><td>has</td><td>判断是否含有某个值</td><td>函数返回一个布尔值。true：含有此值；false：不含有此值；</td></tr><tr><td>is</td><td>判断是否为某个值</td><td>函数返回一个布尔值。true：为某个值；false：不为某个值；</td></tr><tr><td>get</td><td>获取某个值</td><td>函数返回一个非布尔值</td></tr><tr><td>set</td><td>设置某个值</td><td>无返回值、返回是否设置成功或者返回链式对象</td></tr></tbody></table><h4 id="1-3-9-自定义事件"><a href="#1-3-9-自定义事件" class="headerlink" title="1.3.9 自定义事件"></a>1.3.9 自定义事件</h4><p><strong>自定义事件应始终使用 kebab-case 的事件名。</strong></p><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p><pre><code class="javascript">this.$emit(&#39;my-event&#39;)复制代码&lt;MyComponent @my-event=&quot;handleDoSomething&quot; /&gt;复制代码</code></pre><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Events">原生事件参考列表</a></li></ul><p>由原生事件可以发现其使用方式如下：</p><pre><code class="html">&lt;div  @blur=&quot;toggleHeaderFocus&quot;  @focus=&quot;toggleHeaderFocus&quot;  @click=&quot;toggleMenu&quot;  @keydown.esc=&quot;handleKeydown&quot;  @keydown.enter=&quot;handleKeydown&quot;  @keydown.up.prevent=&quot;handleKeydown&quot;  @keydown.down.prevent=&quot;handleKeydown&quot;  @keydown.tab=&quot;handleKeydown&quot;  @keydown.delete=&quot;handleKeydown&quot;  @mouseenter=&quot;hasMouseHoverHead = true&quot;  @mouseleave=&quot;hasMouseHoverHead = false&quot;&gt;&lt;/div&gt;复制代码</code></pre><p>而为了区分<em>原生事件</em>和<em>自定义事件</em>在 Vue 中的使用，建议除了多单词事件名使用 kebab-case 的情况下，命名还需遵守为 <strong><code>on</code> + 动词</strong> 的形式，如下：</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;div  @on-search=&quot;handleSearch&quot;  @on-clear=&quot;handleClear&quot;  @on-clickoutside=&quot;handleClickOutside&quot;&gt;&lt;/div&gt;复制代码// 子组件export default &#123;  methods: &#123;    handleTriggerItem () &#123;      this.$emit(&#39;on-clear&#39;)    &#125;  &#125;&#125;复制代码</code></pre><h4 id="1-3-10-事件方法"><a href="#1-3-10-事件方法" class="headerlink" title="1.3.10 事件方法"></a>1.3.10 事件方法</h4><ul><li>命名方法：camelCase</li><li>命名规范：handle + 名称（可选）+ 动词</li></ul><pre><code class="javascript">&lt;template&gt;  &lt;div    @click.native.stop=&quot;handleItemClick()&quot;    @mouseenter.native.stop=&quot;handleItemHover()&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  methods: &#123;    handleItemClick () &#123;      //...    &#125;,    handleItemHover () &#123;      //...    &#125;  &#125;&#125;&lt;/script&gt;复制代码</code></pre><h2 id="二、代码规范"><a href="#二、代码规范" class="headerlink" title="二、代码规范"></a>二、代码规范</h2><h3 id="2-1-Vue"><a href="#2-1-Vue" class="headerlink" title="2.1 Vue"></a>2.1 Vue</h3><h4 id="2-1-1-代码结构"><a href="#2-1-1-代码结构" class="headerlink" title="2.1.1 代码结构"></a>2.1.1 代码结构</h4><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;my-component&quot;&gt;    &lt;DemoComponent /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import DemoComponent from &#39;../components/DemoComponent&#39;export default &#123;  name: &#39;MyComponent&#39;,  components: &#123;    DemoComponent  &#125;,  mixins: [],  props: &#123;&#125;,  data () &#123;    return &#123;&#125;  &#125;,  computed: &#123;&#125;,  watch: &#123;&#125;  created () &#123;&#125;,  mounted () &#123;&#125;,  destroyed () &#123;&#125;,  methods: &#123;&#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;#my-component &#123;&#125;&lt;/style&gt;复制代码</code></pre><h4 id="2-1-2-data"><a href="#2-1-2-data" class="headerlink" title="2.1.2 data"></a>2.1.2 data</h4><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p><pre><code class="javascript">// In a .vue fileexport default &#123;  data () &#123;    return &#123;      foo: &#39;bar&#39;    &#125;  &#125;&#125;复制代码</code></pre><h4 id="2-1-3-prop"><a href="#2-1-3-prop" class="headerlink" title="2.1.3 prop"></a>2.1.3 prop</h4><p><strong>Prop 定义应该尽量详细。</strong></p><pre><code class="javascript">export default &#123;  props: &#123;    status: &#123;      type: String,      required: true,      validator: function (value) &#123;        return [          &#39;syncing&#39;,           &#39;synced&#39;,          &#39;version-conflict&#39;,          &#39;error&#39;        ].indexOf(value) !== -1      &#125;    &#125;  &#125;&#125;复制代码</code></pre><h4 id="2-1-4-computed"><a href="#2-1-4-computed" class="headerlink" title="2.1.4 computed"></a>2.1.4 computed</h4><p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性。</strong> 小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p><pre><code class="javascript">// badcomputed: &#123;   price: function () &#123;     var basePrice = this.manufactureCost / (1 - this.profitMargin)     return (       basePrice -       basePrice * (this.discountPercent || 0)     )   &#125; &#125;// goodcomputed: &#123;  basePrice: function () &#123;    return this.manufactureCost / (1 - this.profitMargin)  &#125;,  discount: function () &#123;    return this.basePrice * (this.discountPercent || 0)  &#125;,  finalPrice: function () &#123;    return this.basePrice - this.discount  &#125;&#125;复制代码</code></pre><h4 id="2-1-5-为-v-for-设置键值"><a href="#2-1-5-为-v-for-设置键值" class="headerlink" title="2.1.5 为 v-for 设置键值"></a>2.1.5 为 <code>v-for</code> 设置键值</h4><p>**在组件上必须用 <code>key</code> 搭配 <code>v-for</code>**，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href="https://link.juejin.cn/?target=https://bost.ocks.org/mike/constancy/">对象固化 (object constancy)</a>。</p><pre><code class="html">&lt;ul&gt;  &lt;li    v-for=&quot;todo in todos&quot;    :key=&quot;todo.id&quot;&gt;      &#123;&#123; todo.text &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;复制代码</code></pre><h4 id="2-1-6-v-if-和-v-for-互斥"><a href="#2-1-6-v-if-和-v-for-互斥" class="headerlink" title="2.1.6 v-if 和 v-for 互斥"></a>2.1.6 <code>v-if</code> 和 <code>v-for</code> 互斥</h4><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p><pre><code class="html">&lt;!-- bad：控制台报错 --&gt;&lt;ul&gt;  &lt;li    v-for=&quot;user in users&quot;    v-if=&quot;shouldShowUsers&quot;    :key=&quot;user.id&quot;&gt;      &#123;&#123; user.name &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;复制代码</code></pre><p>一般我们在两种常见的情况下会倾向于这样做：</p><ul><li>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</li></ul><pre><code class="javascript">computed: &#123;  activeUsers: function () &#123;    return this.users.filter((user) =&gt; &#123;      return user.isActive    &#125;)  &#125;&#125;复制代码&lt;ul&gt;  &lt;li    v-for=&quot;user in activeUsers&quot;    :key=&quot;user.id&quot;&gt;      &#123;&#123; user.name &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;复制代码</code></pre><ul><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>, <code>ol</code>)。</li></ul><pre><code class="html">&lt;!-- bad --&gt;&lt;ul&gt;  &lt;li    v-for=&quot;user in users&quot;    v-if=&quot;shouldShowUsers&quot;    :key=&quot;user.id&quot;&gt;      &#123;&#123; user.name &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;&lt;!-- good --&gt;&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;  &lt;li    v-for=&quot;user in users&quot;    :key=&quot;user.id&quot;&gt;      &#123;&#123; user.name &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;复制代码</code></pre><h4 id="2-1-7-多个-attribute-的元素"><a href="#2-1-7-多个-attribute-的元素" class="headerlink" title="2.1.7 多个 attribute 的元素"></a>2.1.7 多个 attribute 的元素</h4><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p><pre><code class="html">&lt;!-- bad --&gt;&lt;img src=&quot;https://vuejs.org/images/logo.png&quot; alt=&quot;Vue Logo&quot;&gt;&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;复制代码&lt;!-- good --&gt;&lt;img  src=&quot;https://vuejs.org/images/logo.png&quot;  alt=&quot;Vue Logo&quot;&gt;&lt;MyComponent  foo=&quot;a&quot;  bar=&quot;b&quot;  baz=&quot;c&quot;/&gt;复制代码</code></pre><h4 id="2-1-8-模板中简单的表达式"><a href="#2-1-8-模板中简单的表达式" class="headerlink" title="2.1.8 模板中简单的表达式"></a>2.1.8 模板中简单的表达式</h4><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p><p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<strong>是什么</strong>，而非<strong>如何</strong>计算那个值。而且计算属性和方法使得代码可以重用。</p><pre><code class="javascript">// bad&#123;&#123;  fullName.split(' ').map((word) => &#123;    return word[0].toUpperCase() + word.slice(1)  &#125;).join(' ')&#125;&#125;复制代码</code></pre><p>更好的做法：</p><pre><code class="html">&lt;!-- 在模板中 --&gt;&#123;&#123; normalizedFullName &#125;&#125;复制代码// 复杂表达式已经移入一个计算属性computed: &#123;  normalizedFullName: function () &#123;    return this.fullName.split(&#39; &#39;).map(function (word) &#123;      return word[0].toUpperCase() + word.slice(1)    &#125;).join(&#39; &#39;)  &#125;&#125;复制代码</code></pre><h4 id="2-1-9-带引号的-attribute-值"><a href="#2-1-9-带引号的-attribute-值" class="headerlink" title="2.1.9 带引号的 attribute 值"></a>2.1.9 带引号的 attribute 值</h4><p><strong>非空 HTML 特性值应该始终带双引号。</strong></p><pre><code class="html">&lt;!-- bad --&gt;&lt;input type=text&gt;&lt;AppSidebar :style=&#123;width:sidebarWidth+&#39;px&#39;&#125;&gt;复制代码&lt;!-- good --&gt;&lt;input type=&quot;text&quot;&gt;&lt;AppSidebar :style=&quot;&#123; width: sidebarWidth + &#39;px&#39; &#125;&quot;&gt;复制代码</code></pre><h4 id="2-1-10-指令缩写"><a href="#2-1-10-指令缩写" class="headerlink" title="2.1.10 指令缩写"></a>2.1.10 指令缩写</h4><ul><li><strong>用 <code>:</code> 表示 <code>v-bind:</code></strong></li><li><strong>用 <code>@</code> 表示 <code>v-on:</code></strong></li><li><strong>用 <code>#</code> 表示 <code>v-slot:</code></strong></li></ul><pre><code class="html">&lt;input  :value=&quot;newTodoText&quot;  :placeholder=&quot;newTodoInstructions&quot;&gt;&lt;input  @input=&quot;onInput&quot;  @focus=&quot;onFocus&quot;&gt;&lt;template #header&gt;  &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt;  &lt;p&gt;Here&#39;s some contact info&lt;/p&gt;&lt;/template&gt;复制代码</code></pre><h3 id="2-2-HTML"><a href="#2-2-HTML" class="headerlink" title="2.2 HTML"></a>2.2 HTML</h3><h4 id="2-2-1-文件模板"><a href="#2-2-1-文件模板" class="headerlink" title="2.2.1 文件模板"></a>2.2.1 文件模板</h4><p>HTML5 文件模板：</p><pre><code class="html">&lt;!DOCTYPE html&gt;  &lt;html lang=&quot;zh-CN&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;HTML5标准模版&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;/body&gt;&lt;/html&gt;复制代码</code></pre><p>移动端：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;        content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no&quot;&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;    &lt;title&gt;移动端HTML模版&lt;/title&gt;    &lt;!-- S DNS预解析 --&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;&quot;&gt;    &lt;!-- E DNS预解析 --&gt;    &lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;    &lt;!-- #include virtual=&quot;&quot; --&gt;    &lt;!-- E 线上样式页面片 --&gt;    &lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;    &lt;!-- /本地调试方式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://srcPath/index.css&quot;&gt;    &lt;!-- /开发机调试方式 --&gt;    &lt;!-- E 本地调试 --&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;复制代码</code></pre><p>PC 端：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;keywords&quot; content=&quot;your keywords&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;your description&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt;    &lt;title&gt;PC端HTML模版&lt;/title&gt;    &lt;!-- S DNS预解析 --&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;&quot;&gt;    &lt;!-- E DNS预解析 --&gt;    &lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;    &lt;!-- #include virtual=&quot;&quot; --&gt;    &lt;!-- E 线上样式页面片 --&gt;    &lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;    &lt;!-- /本地调试方式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://srcPath/index.css&quot;&gt;    &lt;!-- /开发机调试方式 --&gt;    &lt;!-- E 本地调试 --&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;复制代码</code></pre><h4 id="2-2-2-元素及标签闭合"><a href="#2-2-2-元素及标签闭合" class="headerlink" title="2.2.2 元素及标签闭合"></a>2.2.2 元素及标签闭合</h4><p>HTML 元素共有以下5种：</p><ul><li>空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</li><li>原始文本元素：script、style</li><li>RCDATA 元素：textarea、title</li><li>外来元素：来自 MathML 命名空间和 SVG 命名空间的元素</li><li>常规元素：其他 HTML 允许的元素都称为常规元素</li></ul><p>为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定：</p><ul><li>所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。</li><li>空元素标签都不加 “/” 字符。</li></ul><pre><code class="html">&lt;!-- good --&gt;&lt;div&gt;    &lt;h1&gt;我是h1标题&lt;/h1&gt;    &lt;p&gt;我是一段文字，我有始有终，浏览器能正确解析&lt;/p&gt;&lt;/div&gt;    &lt;br data-tomark-pass&gt;&lt;!-- bad --&gt;&lt;div&gt;    &lt;h1&gt;我是h1标题&lt;/h1&gt;    &lt;p&gt;我是一段文字，我有始无终，浏览器亦能正确解析&lt;/div&gt;&lt;br/&gt;复制代码</code></pre><h4 id="2-2-3-代码嵌套"><a href="#2-2-3-代码嵌套" class="headerlink" title="2.2.3 代码嵌套"></a>2.2.3 代码嵌套</h4><p>元素嵌套规范，每个块状元素独立一行，内联元素可选。</p><pre><code class="html">&lt;!-- good --&gt;&lt;div&gt;    &lt;h1&gt;&lt;/h1&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;!-- bad --&gt;&lt;div&gt;    &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;    &lt;p&gt;     &lt;span&gt;&lt;/span&gt;    &lt;span&gt;&lt;/span&gt;&lt;/p&gt;复制代码</code></pre><p>段落元素与标题元素只能嵌套内联元素。</p><pre><code class="html">&lt;!-- good --&gt;&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;!-- bad --&gt;&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;复制代码</code></pre><h3 id="2-3-CSS"><a href="#2-3-CSS" class="headerlink" title="2.3 CSS"></a>2.3 CSS</h3><h4 id="2-3-1-样式文件"><a href="#2-3-1-样式文件" class="headerlink" title="2.3.1 样式文件"></a>2.3.1 样式文件</h4><p>样式文件必须写上 <code>@charset</code> 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 <code>“UTF-8”</code>。</p><ul><li>推荐：</li></ul><pre><code class="css">@charset &quot;UTF-8&quot;;.jdc &#123;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">/* @charset规则不在文件首行首个字符开始 */@charset &quot;UTF-8&quot;;.jdc &#123;&#125;/* @charset规则没有用小写 */@CHARSET &quot;UTF-8&quot;;.jdc &#123;&#125;/* 无@charset规则 */.jdc &#123;&#125;复制代码</code></pre><h4 id="2-3-2-代码格式化"><a href="#2-3-2-代码格式化" class="headerlink" title="2.3.2 代码格式化"></a>2.3.2 代码格式化</h4><p>样式书写一般有两种：一种是紧凑格式 （Compact），一种是展开格式（Expanded）。</p><ul><li>推荐：展开格式（Expanded）</li></ul><pre><code class="css">.jdc &#123;  display: block;  width: 50px;&#125;复制代码</code></pre><ul><li>不推荐：紧凑格式 （Compact）</li></ul><pre><code class="css">.jdc &#123; display: block; width: 50px;&#125;复制代码</code></pre><h4 id="2-3-3-代码大小写"><a href="#2-3-3-代码大小写" class="headerlink" title="2.3.3 代码大小写"></a>2.3.3 代码大小写</h4><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  display: block;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.JDC &#123;  DISPLAY: BLOCK;&#125;复制代码</code></pre><h4 id="2-3-4-代码易读性"><a href="#2-3-4-代码易读性" class="headerlink" title="2.3.4 代码易读性"></a>2.3.4 代码易读性</h4><ol><li>左括号与类名之间一个空格，冒号与属性值之间一个空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  width: 100%;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc&#123;  width:100%;&#125;复制代码</code></pre><ol><li>逗号分隔的取值，逗号之后一个空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc &#123;  box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;&#125;复制代码</code></pre><ol><li>为单个 CSS 选择器或新声明开启新行。</li></ol><ul><li>推荐：</li></ul><pre><code class="css">.jdc, .jdc_logo, .jdc_hd &#123;  color: #ff0;&#125;.nav&#123;  color: #fff;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc, .jdc_logo, .jdc_hd &#123;  color: #ff0;&#125;.nav&#123;  color: #fff;&#125;复制代码</code></pre><ol><li>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0。</li></ol><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  color: rgba(255,255,255,.5);&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc &#123;  color: rgba( 255, 255, 255, 0.5 );&#125;复制代码</code></pre><ol><li>属性值十六进制数值能用简写的尽量用简写。</li></ol><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  color: #fff;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc &#123;  color: #ffffff;&#125;复制代码</code></pre><ol><li>不要为 <code>0</code> 指明单位。</li></ol><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  margin: 0 10px;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc &#123;  margin: 0px 10px;&#125;复制代码</code></pre><h4 id="2-3-5-属性值引号"><a href="#2-3-5-属性值引号" class="headerlink" title="2.3.5 属性值引号"></a>2.3.5 属性值引号</h4><p>CSS 属性值需要用到引号时，统一使用单引号。</p><ul><li>推荐：</li></ul><pre><code class="css">.jdc &#123;  font-family: &#39;Hiragino Sans GB&#39;;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">.jdc &#123;  font-family: &quot;Hiragino Sans GB&quot;;&#125;复制代码</code></pre><h4 id="2-3-6-属性书写建议"><a href="#2-3-6-属性书写建议" class="headerlink" title="2.3.6 属性书写建议"></a>2.3.6 属性书写建议</h4><p>建议遵循以下顺序：</p><ol><li>布局定位属性：display / position / float / clear / visibility / overflow</li><li>自身属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient …</li></ol><pre><code class="css">.jdc &#123;  display: block;  position: relative;  float: left;  width: 100px;  height: 100px;  margin: 0 10px;  padding: 20px 0;  font-family: Arial, &#39;Helvetica Neue&#39;, Helvetica, sans-serif;  color: #333;  background: rgba(0,0,0,.5);  -webkit-border-radius: 10px;  -moz-border-radius: 10px;  -o-border-radius: 10px;  -ms-border-radius: 10px;  border-radius: 10px;&#125;复制代码</code></pre><h4 id="3-3-7-CSS3-浏览器私有前缀"><a href="#3-3-7-CSS3-浏览器私有前缀" class="headerlink" title="3.3.7 CSS3 浏览器私有前缀"></a>3.3.7 CSS3 浏览器私有前缀</h4><p>CSS3 浏览器私有前缀在前，标准前缀在后。</p><pre><code class="css">.jdc &#123;  -webkit-border-radius: 10px;  -moz-border-radius: 10px;  -o-border-radius: 10px;  -ms-border-radius: 10px;  border-radius: 10px;&#125;复制代码</code></pre><h3 id="2-4-JavaScript"><a href="#2-4-JavaScript" class="headerlink" title="2.4 JavaScript"></a>2.4 JavaScript</h3><h4 id="2-4-1-单行代码块"><a href="#2-4-1-单行代码块" class="headerlink" title="2.4.1 单行代码块"></a>2.4.1 单行代码块</h4><p>在单行代码块中使用空格。</p><ul><li>不推荐：</li></ul><pre><code class="JavaScript">function foo () &#123;return true&#125;if (foo) &#123;bar = 0&#125;复制代码</code></pre><ul><li>推荐：</li></ul><pre><code class="javascript">function foo () &#123; return true &#125;if (foo) &#123; bar = 0 &#125;复制代码</code></pre><h4 id="2-4-2-大括号风格"><a href="#2-4-2-大括号风格" class="headerlink" title="2.4.2 大括号风格"></a>2.4.2 大括号风格</h4><p>在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下：</p><ul><li><strong>【推荐】One True Brace Style</strong></li></ul><pre><code class="javascript">if (foo) &#123;  bar()&#125; else &#123;  baz()&#125;复制代码</code></pre><ul><li><strong>Stroustrup</strong></li></ul><pre><code class="javascript">if (foo) &#123;  bar()&#125;else &#123;  baz()&#125;复制代码</code></pre><ul><li><strong>Allman</strong></li></ul><pre><code class="javascript">if (foo)&#123;  bar()&#125;else&#123;  baz()&#125;复制代码</code></pre><h4 id="2-4-3-代码中的空格"><a href="#2-4-3-代码中的空格" class="headerlink" title="2.4.3 代码中的空格"></a>2.4.3 代码中的空格</h4><ol><li>逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="javascript">var foo = 1, bar = 2复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">var foo = 1,bar = 2var foo = 1 , bar = 2var foo = 1 ,bar = 2复制代码</code></pre><ol><li>对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="javascript">var obj = &#123; &#39;foo&#39;: &#39;haha&#39; &#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">var obj = &#123; &#39;foo&#39; : &#39;haha&#39; &#125;复制代码</code></pre><ol><li>代码块前要添加空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="javascript">if (a) &#123;  b()&#125;function a () &#123;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">if (a)&#123;  b()&#125;function a ()&#123;&#125;复制代码</code></pre><ol><li>函数声明括号前要加空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="javascript">function func (x) &#123;  // ...&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">function func(x) &#123;  // ...&#125;复制代码</code></pre><ol><li>在函数调用时，禁止使用空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="javascript">fn()复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">fn ()fn()复制代码</code></pre><ol><li>在操作符前后都需要添加空格。</li></ol><ul><li>推荐：</li></ul><pre><code class="JavaScript">var sum = 1 + 2复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="JavaScript">var sum = 1+2复制代码</code></pre><h2 id="三、注释规范"><a href="#三、注释规范" class="headerlink" title="三、注释规范"></a>三、注释规范</h2><p><strong>注释的目的：</strong></p><ul><li><strong>提高代码的可读性，从而提高代码的可维护性</strong></li></ul><p><strong>注释的原则：</strong></p><ul><li><strong>如无必要，勿增注释 ( As short as possible )</strong></li><li><strong>如有必要，尽量详尽 ( As long as necessary )</strong></li></ul><h3 id="3-1-HTML-文件注释"><a href="#3-1-HTML-文件注释" class="headerlink" title="3.1 HTML 文件注释"></a>3.1 HTML 文件注释</h3><h4 id="3-1-1-单行注释"><a href="#3-1-1-单行注释" class="headerlink" title="3.1.1 单行注释"></a>3.1.1 单行注释</h4><p><strong>一般用于简单的描述，如某些状态描述、属性描述等。</strong></p><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。</p><ul><li>推荐：</li></ul><pre><code class="html">&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt;复制代码</code></pre><ul><li>不推荐</li></ul><pre><code class="html">&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt;&lt;div&gt;&lt;!-- Comment Text --&gt;  ...&lt;/div&gt;复制代码</code></pre><h4 id="3-1-2-模块注释"><a href="#3-1-2-模块注释" class="headerlink" title="3.1.2 模块注释"></a>3.1.2 模块注释</h4><p><strong>一般用于描述模块的名称以及模块开始与结束的位置。</strong></p><p>注释内容前后各一个空格字符， <code>&lt;!-- S Comment Text --&gt;</code>表示模块开始， <code>&lt;!-- E Comment Text --&gt;</code>表示模块结束，模块与模块之间相隔一行。</p><ul><li>推荐：</li></ul><pre><code class="html">&lt;!-- S Comment Text A --&gt;    &lt;div class=&quot;mod_a&quot;&gt;  ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt;    &lt;!-- S Comment Text B --&gt;    &lt;div class=&quot;mod_b&quot;&gt;  ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt;复制代码</code></pre><ul><li>不推荐</li></ul><pre><code class="html">&lt;!-- S Comment Text A --&gt;&lt;div class=&quot;mod_a&quot;&gt;  ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt;&lt;!-- S Comment Text B --&gt;    &lt;div class=&quot;mod_b&quot;&gt;  ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt;复制代码</code></pre><h4 id="3-1-3-嵌套模块注释"><a href="#3-1-3-嵌套模块注释" class="headerlink" title="3.1.3 嵌套模块注释"></a>3.1.3 嵌套模块注释</h4><p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用。</p><pre><code class="html">&lt;!-- S Comment Text --&gt;&lt;!-- E Comment Text --&gt;复制代码</code></pre><p>而改用</p><pre><code class="html">&lt;!-- /Comment Text --&gt;复制代码</code></pre><p>注释写在模块结尾标签底部，单独一行。</p><pre><code class="html">&lt;!-- S Comment Text A --&gt;&lt;div class=&quot;mod_a&quot;&gt;            &lt;div class=&quot;mod_b&quot;&gt;        ...    &lt;/div&gt;    &lt;!-- /mod_b --&gt;            &lt;div class=&quot;mod_c&quot;&gt;        ...    &lt;/div&gt;    &lt;!-- /mod_c --&gt;        &lt;/div&gt;&lt;!-- E Comment Text A --&gt;复制代码</code></pre><h3 id="3-2-CSS-文件注释"><a href="#3-2-CSS-文件注释" class="headerlink" title="3.2 CSS 文件注释"></a>3.2 CSS 文件注释</h3><h4 id="3-2-1-单行注释"><a href="#3-2-1-单行注释" class="headerlink" title="3.2.1 单行注释"></a>3.2.1 单行注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行。</p><ul><li>推荐：</li></ul><pre><code class="css">/* Comment Text */ .jdc &#123;&#125; /* Comment Text */ .jdc &#123;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">/*Comment Text*/.jdc &#123;  display: block;&#125;.jdc &#123;  display: block;/*Comment Text*/&#125;复制代码</code></pre><h4 id="3-2-2-模块注释"><a href="#3-2-2-模块注释" class="headerlink" title="3.2.2 模块注释"></a>3.2.2 模块注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，<code>/*</code> 与 模块信息描述占一行，多个横线分隔符 <code>-</code> 与 <code>*/</code> 占一行，行与行之间相隔两行。</p><ul><li>推荐：</li></ul><pre><code class="css">/* Module A---------------------------------------------------------------- */.mod_a &#123;&#125;/* Module B---------------------------------------------------------------- */.mod_b &#123;&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="css">/* Module A ---------------------------------------------------- */.mod_a &#123;&#125;/* Module B ---------------------------------------------------- */.mod_b &#123;&#125;复制代码</code></pre><h4 id="3-2-3-文件注释"><a href="#3-2-3-文件注释" class="headerlink" title="3.2.3 文件注释"></a>3.2.3 文件注释</h4><p>在样式文件编码声明 <code>@charset</code> 语句下面注明页面名称、作者、创建日期等信息。</p><pre><code class="css">@charset &quot;UTF-8&quot;;/** * @desc File Info * @author Author Name * @date 2015-10-10 */复制代码</code></pre><h3 id="3-3-JavaScript-文件注释"><a href="#3-3-JavaScript-文件注释" class="headerlink" title="3.3 JavaScript 文件注释"></a>3.3 JavaScript 文件注释</h3><h4 id="3-3-1-单行注释"><a href="#3-3-1-单行注释" class="headerlink" title="3.3.1 单行注释"></a>3.3.1 单行注释</h4><p>单行注释使用 <code>//</code>，注释应单独一行写在被注释对象的上方，不要追加在某条语句的后面。</p><ul><li>推荐：</li></ul><pre><code class="javascript">// is current tabconst active = true复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">const active = true // is current tab复制代码</code></pre><p>注释行的上方需要有一个空行（<strong>除非注释行上方是一个块的顶部</strong>），以增加可读性。</p><ul><li>推荐：</li></ul><pre><code class="javascript">function getType () &#123;    console.log(&#39;fetching type...&#39;)    // set the default type to &#39;no type&#39;  const type = this.type || &#39;no type&#39;  return type&#125;复制代码// 注释行上面是一个块的顶部时不需要空行function getType () &#123;    // set the default type to &#39;no type&#39;  const type = this.type || &#39;no type&#39;              return type&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">function getType () &#123;    console.log(&#39;fetching type...&#39;)  // set the default type to &#39;no type&#39;  const type = this.type || &#39;no type&#39;  return type&#125;复制代码</code></pre><h4 id="3-3-2-多行注释"><a href="#3-3-2-多行注释" class="headerlink" title="3.3.2 多行注释"></a>3.3.2 多行注释</h4><p>多行注释使用 <code>/** ... */</code>，而不是多行的 <code>//</code>。</p><ul><li>推荐：</li></ul><pre><code class="javascript">/** * make() returns a new element * based on the passed-in tag name */function make (tag) &#123;  // ...  return element&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">// make() returns a new element// based on the passed in tag namefunction make (tag) &#123;  // ...  return element&#125;复制代码</code></pre><h4 id="3-3-3-注释空格"><a href="#3-3-3-注释空格" class="headerlink" title="3.3.3 注释空格"></a>3.3.3 注释空格</h4><p>注释内容和注释符之间需要有一个空格，以增加可读性。eslint: <code>spaced-comment</code>。</p><ul><li>推荐：</li></ul><pre><code class="javascript">// is current tabconst active = true/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123;    // ...  return element&#125;复制代码</code></pre><ul><li>不推荐：</li></ul><pre><code class="javascript">//is current tabconst active = true/** *make() returns a new element *based on the passed-in tag name */function make(tag) &#123;    // ...  return element&#125;复制代码</code></pre><h4 id="3-3-4-特殊标记"><a href="#3-3-4-特殊标记" class="headerlink" title="3.3.4 特殊标记"></a>3.3.4 特殊标记</h4><p>有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种：</p><ul><li><code>// FIXME</code> : 说明问题是什么</li><li><code>// TODO</code> : 说明还要做什么或者问题的解决方案</li></ul><pre><code class="javascript">class Calculator extends Abacus &#123;  constructor () &#123;    super ()      // FIXME: shouldn’t use a global here      total = 0      // TODO: total should be configurable by an options param      this.total = 0  &#125;&#125;复制代码</code></pre><h4 id="3-3-5-文档类注释"><a href="#3-3-5-文档类注释" class="headerlink" title="3.3.5 文档类注释"></a>3.3.5 文档类注释</h4><p>文档类注释，如函数、类、文件、事件等；都使用 jsdoc 规范。</p><pre><code class="javascript">/** * Book类，代表一个书本. * @constructor * @param &#123;string&#125; title - 书本的标题. * @param &#123;string&#125; author - 书本的作者. */function Book (title, author) &#123;  this.title = title  this.author = author&#125;Book.prototype = &#123;  /**   * 获取书本的标题   * @returns &#123;string|*&#125;   */  getTitle: function () &#123;    return this.title  &#125;,  /**   * 设置书本的页数   * @param pageNum &#123;number&#125; 页数   */  setPageNum: function (pageNum) &#123;    this.pageNum=pageNum  &#125;&#125;复制代码</code></pre><h4 id="3-3-6-注释工具"><a href="#3-3-6-注释工具" class="headerlink" title="3.3.6 注释工具"></a>3.3.6 注释工具</h4><p><code>ESLint</code> 是当下最流行的 JS 代码检查工具，<code>ESLint</code> 中有一些注释相关的规则，用户可选择开启：</p><ul><li><code>valid-jsdoc</code></li><li><code>require-jsdoc</code></li><li><code>no-warning-comments</code></li><li><code>capitalized-comments</code></li><li><code>line-comment-position</code></li><li><code>lines-around-comment</code></li><li><code>multiline-comment-style</code></li><li><code>no-inline-comments</code></li><li><code>spaced-comment</code></li></ul><h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><ul><li>缩进换行请使用两个空格。</li><li>大型团队多人协作项目推荐 JavaScript 代码末尾加分号。</li><li>小型个人创新练手项目可尝试使用 JavaScript 代码末尾不加分号的风格，更加清爽简练。</li></ul><p>作者：鱼酱<br>链接：<a href="https://juejin.cn/post/6987349513836953607">https://juejin.cn/post/6987349513836953607</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Css-重置样式表</title>
      <link href="/2022/09/05/css-%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
      <url>/2022/09/05/css-%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>/* <a href="http://meyerweb.com/eric/tools/css/reset/">http://meyerweb.com/eric/tools/css/reset/</a><br>   v2.0 | 20110126<br>   License: none (public domain)<br>*/</p><pre><code class="css">html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123;    margin: 0;    padding: 0;    border: 0;    font-size: 100%;    font: inherit;    vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123;    display: block;&#125;body &#123;    line-height: 1;&#125;ol, ul &#123;    list-style: none;&#125;blockquote, q &#123;    quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123;    content: &#39;&#39;;    content: none;&#125;table &#123;    border-collapse: collapse;    border-spacing: 0;&#125;</code></pre><p>/图片水平垂直居中/</p><pre><code class="css">.valign&#123;text-align:center;&#125;.valign img&#123;vertical-align:middle;&#125;.valign:after&#123;content:&quot;&quot;;display:inline-block;height:100%;vertical-align:middle;&#125;</code></pre><p>/<em>单行文本出现省略号</em>/</p><pre><code class="css">.over&#123;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;&#125;</code></pre><p>/<em>阻止margin-top向父元素传递</em>/</p><pre><code class="css">.clear:before&#123;content:&quot;&quot;;display:table;&#125;</code></pre><p>/<em>边框圆角属性</em>/</p><pre><code class="css">.border-radius&#123;border-radius:50%;&#125;</code></pre><p>/<em>清除浮动</em>/</p><pre><code class="css">.clear:after&#123;content:&quot;&quot;;clear:both;display:block;&#125;</code></pre><p>/<em>弹性盒子,垂直居中，水平居中；水平两边分开对齐；换行；纵向排列；分开左右边距对齐;怪异盒模型</em>/</p><pre><code class="css">.display&#123;display:flex;align-items:center;justify-content:center;justify-content:space-between;flex-wrap:wrap;flex-direction:column; justify-content:space-around;box-sizing:border-box;&#125;</code></pre><p>/<em>定位;1固定定位不占文档流，绝对定位不占文档流，相对定位占文档流</em>/</p><pre><code class="css">.position&#123;position:fixed;position:absolute;position:relative;&#125;</code></pre><p>/<em>响应式移动端</em>/</p><pre><code class="css">@media screen and (width:640px)&#123;    html&#123;font-size:64px;&#125;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Css-清除浮动</title>
      <link href="/2022/09/05/css-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2022/09/05/css-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<pre><code class="css">.clearfix::after &#123;  content: &quot;&quot;;  clear: both;  display: table;&#125;</code></pre><h4 id="1-上面伪类清除法"><a href="#1-上面伪类清除法" class="headerlink" title="1.上面伪类清除法"></a>1.上面伪类清除法</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-参考链接</title>
      <link href="/2022/09/05/15%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/"/>
      <url>/2022/09/05/15%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E5%AE%98%E6%96%B9%E6%96%87%E4%BB%B6">官方文件</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E7%BB%BC%E5%90%88%E4%BB%8B%E7%BB%8D">综合介绍</a></li><li>[let 和 const](<a href="https://es6.ruanyifeng.com/#docs/reference#let">https://es6.ruanyifeng.com/#docs/reference#let</a> 和 const)</li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E6%AD%A3%E5%88%99">正则</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E6%95%B0%E5%80%BC">数值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E5%AF%B9%E8%B1%A1">对象</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#Symbol">Symbol</a></li><li>[Set 和 Map](<a href="https://es6.ruanyifeng.com/#docs/reference#Set">https://es6.ruanyifeng.com/#docs/reference#Set</a> 和 Map)</li><li>[Proxy 和 Reflect](<a href="https://es6.ruanyifeng.com/#docs/reference#Proxy">https://es6.ruanyifeng.com/#docs/reference#Proxy</a> 和 Reflect)</li><li>[Promise 对象](<a href="https://es6.ruanyifeng.com/#docs/reference#Promise">https://es6.ruanyifeng.com/#docs/reference#Promise</a> 对象)</li><li><a href="https://es6.ruanyifeng.com/#docs/reference#Iterator">Iterator</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#Generator">Generator</a></li><li>[异步操作和 Async 函数](<a href="https://es6.ruanyifeng.com/#docs/reference#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%92%8C">https://es6.ruanyifeng.com/#docs/reference#异步操作和</a> Async 函数)</li><li><a href="https://es6.ruanyifeng.com/#docs/reference#Class">Class</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#Decorator">Decorator</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#Module">Module</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%BB%84">二进制数组</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#SIMD">SIMD</a></li><li><a href="https://es6.ruanyifeng.com/#docs/reference#%E5%B7%A5%E5%85%B7">工具</a></li></ol><h2 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h2><ul><li><a href="https://www.ecma-international.org/ecma-262/6.0/index.html">ECMAScript® 2015 Language Specification</a>: ECMAScript 2015 规格</li><li><a href="https://www.ecma-international.org/ecma-262/7.0/">ECMAScript® 2016 Language Specification</a>: ECMAScript 2016 规格</li><li><a href="https://tc39.github.io/ecma262/">ECMAScript® 2017 Language Specification</a>：ECMAScript 2017 规格（草案）</li><li><a href="https://github.com/tc39/ecma262">ECMAScript Current Proposals</a>: ECMAScript 当前的所有提案</li><li><a href="https://github.com/tc39/proposals">ECMAScript Active Proposals</a>: 已经进入正式流程的提案</li><li><a href="https://github.com/hemanth/es-next">ECMAScript proposals</a>：从阶段 0 到阶段 4 的所有提案列表</li><li><a href="https://github.com/tc39/agendas">TC39 meeting agendas</a>: TC39 委员会历年的会议记录</li><li><a href="https://ecmascript-daily.github.io/">ECMAScript Daily</a>: TC39 委员会的动态</li><li><a href="https://tc39.github.io/process-document/">The TC39 Process</a>: 提案进入正式规格的流程</li><li><a href="https://thefeedbackloop.xyz/tc39-a-process-sketch-stages-0-and-1/">TC39: A Process Sketch, Stages 0 and 1</a>: Stage 0 和 Stage 1 的含义</li><li><a href="https://thefeedbackloop.xyz/tc39-process-sketch-stage-2/">TC39 Process Sketch, Stage 2</a>: Stage 2 的含义</li></ul><h2 id="综合介绍"><a href="#综合介绍" class="headerlink" title="综合介绍"></a>综合介绍</h2><ul><li>Axel Rauschmayer, <a href="http://exploringjs.com/es6/">Exploring ES6: Upgrade to the next version of JavaScript</a>: ES6 的专著，本书的许多代码实例来自该书</li><li>Sayanee Basu, <a href="http://net.tutsplus.com/articles/news/ecmascript-6-today/">Use ECMAScript 6 Today</a></li><li>Ariya Hidayat, <a href="http://www.sencha.com/blog/toward-modern-web-apps-with-ecmascript-6/">Toward Modern Web Apps with ECMAScript 6</a></li><li>Dale Schouten, <a href="http://html5hub.com/10-ecmascript-6-tricks-you-can-perform-right-now/">10 Ecmascript-6 tricks you can perform right now</a></li><li>Colin Toh, <a href="http://colintoh.com/blog/lightweight-es6-features">Lightweight ES6 Features That Pack A Punch</a>: ES6 的一些“轻量级”的特性介绍</li><li>Domenic Denicola, <a href="http://www.slideshare.net/domenicdenicola/es6-the-awesome-parts">ES6: The Awesome Parts</a></li><li>Nicholas C. Zakas, <a href="https://github.com/nzakas/understandinges6">Understanding ECMAScript 6</a></li><li>Justin Drake, <a href="https://github.com/JustinDrake/node-es6-examples">ECMAScript 6 in Node.JS</a></li><li>Ryan Dao, <a href="http://ryandao.net/portal/content/summary-ecmascript-6-major-features">Summary of ECMAScript 6 major features</a></li><li>Luke Hoban, <a href="https://github.com/lukehoban/es6features">ES6 features</a>: ES6 新语法点的罗列</li><li>Traceur-compiler, <a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures">Language Features</a>: Traceur 文档列出的一些 ES6 例子</li><li>Axel Rauschmayer, <a href="https://speakerdeck.com/rauschma/ecmascript-6-whats-next-for-javascript-august-2014">ECMAScript 6: what’s next for JavaScript?</a>: 关于 ES6 新增语法的综合介绍，有很多例子</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/08/getting-started-es6.html">Getting started with ECMAScript 6</a>: ES6 语法点的综合介绍</li><li>Toby Ho, <a href="http://davidwalsh.name/es6-io">ES6 in io.js</a></li><li>Guillermo Rauch, <a href="http://rauchg.com/2015/ecmascript-6/">ECMAScript 6</a></li><li>Benjamin De Cock, <a href="https://github.com/bendc/frontend-guidelines">Frontend Guidelines</a>: ES6 最佳实践</li><li>Jani Hartikainen, <a href="http://codeutopia.net/blog/2015/01/06/es6-what-are-the-benefits-of-the-new-features-in-practice/">ES6: What are the benefits of the new features in practice?</a></li><li>kangax, <a href="http://perfectionkills.com/javascript-quiz-es6/">JavaScript quiz. ES6 edition</a>: ES6 小测试</li><li>Jeremy Fairbank, <a href="https://speakerdeck.com/jfairbank/html5devconf-es7-and-beyond">HTML5DevConf ES7 and Beyond!</a>: ES7 新增语法点介绍</li><li>Timothy Gu, <a href="https://timothygu.me/es-howto/">How to Read the ECMAScript Specification</a>: 如何读懂 ES6 规格</li></ul><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><ul><li>Kyle Simpson, <a href="http://davidwalsh.name/for-and-against-let">For and against let</a>: 讨论 let 命令的作用域</li><li>kangax, <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15">Why typeof is no longer “safe”</a>: 讨论在块级作用域内，let 命令的变量声明和赋值的行为</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/02/es6-scoping.html">Variables and scoping in ECMAScript 6</a>: 讨论块级作用域与 let 和 const 的行为</li><li>Nicolas Bevacqua, <a href="http://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth">ES6 Let, Const and the “Temporal Dead Zone” (TDZ) in Depth</a></li><li>acorn, <a href="https://github.com/ternjs/acorn/issues/118">Function statements in strict mode</a>: 块级作用域对严格模式的函数声明的影响</li><li>Axel Rauschmayer, <a href="https://2ality.com/2016/09/global.html">ES proposal: global</a>: 顶层对象<code>global</code></li><li>Mathias Bynens, <a href="https://mathiasbynens.be/notes/globalthis">A horrifying <code>globalThis</code> polyfill in universal JavaScript</a>：如何写 globalThis 的垫片库</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul><li>Nick Fitzgerald, <a href="http://fitzgeraldnick.com/weblog/50/">Destructuring Assignment in ECMAScript 6</a>: 详细介绍解构赋值的用法</li><li>Nicholas C. Zakas, <a href="https://www.nczonline.net/blog/2015/10/ecmascript-6-destructuring-gotcha/">ECMAScript 6 destructuring gotcha</a></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>Nicholas C. Zakas, <a href="http://www.nczonline.net/blog/2012/08/01/a-critical-review-of-ecmascript-6-quasi-literals/">A critical review of ECMAScript 6 quasi-literals</a></li><li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">Template strings</a></li><li>Addy Osmani, <a href="http://updates.html5rocks.com/2015/01/ES6-Template-Strings">Getting Literal With ES6 Template Strings</a>: 模板字符串的介绍</li><li>Blake Winton, <a href="https://weblog.latte.ca/blake/tech/firefox/templates.html">ES6 Templates</a>: 模板字符串的介绍</li><li>Peter Jaszkowiak, <a href="https://medium.com/@PitaJ/how-to-write-a-template-compiler-in-javascript-f174df6f32f">How to write a template compiler in JavaScript</a>: 使用模板字符串，编写一个模板编译函数</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/11/string-padding.html">ES.stage3: string padding</a></li></ul><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ul><li>Mathias Bynens, <a href="https://mathiasbynens.be/notes/es6-unicode-regex">Unicode-aware regular expressions in ES6</a>: 详细介绍正则表达式的 u 修饰符</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/07/regexp-es6.html">New regular expression features in ECMAScript 6</a>：ES6 正则特性的详细介绍</li><li>Yang Guo, <a href="http://v8project.blogspot.jp/2016/02/regexp-lookbehind-assertions.html">RegExp lookbehind assertions</a>：介绍后行断言</li><li>Axel Rauschmayer, <a href="https://2ality.com/2017/05/regexp-named-capture-groups.html">ES proposal: RegExp named capture groups</a>: 具名组匹配的介绍</li><li>Mathias Bynens, <a href="https://mathiasbynens.be/notes/es-regexp-proposals">ECMAScript regular expressions are getting better!</a>: 介绍 ES2018 添加的多项正则语法</li></ul><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ul><li>Nicolas Bevacqua, <a href="http://ponyfoo.com/articles/es6-number-improvements-in-depth">ES6 Number Improvements in Depth</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2017/03/es-integer.html">ES proposal: arbitrary precision integers</a></li><li>Mathias Bynens, <a href="https://developers.google.com/web/updates/2018/05/bigint">BigInt: arbitrary-precision integers in JavaScript</a></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>Axel Rauschmayer, <a href="https://2ality.com/2014/05/es6-array-methods.html">ECMAScript 6’s new array methods</a>: 对 ES6 新增的数组方法的全面介绍</li><li>TC39, <a href="https://github.com/tc39/Array.prototype.includes/">Array.prototype.includes</a>: 数组的 includes 方法的规格</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/09/holes-arrays-es6.html">ECMAScript 6: holes in Arrays</a>: 数组的空位问题</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>Nicholas C. Zakas, <a href="http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/">Understanding ECMAScript 6 arrow functions</a></li><li>Jack Franklin, <a href="http://javascriptplayground.com/blog/2014/04/real-life-es6-arrow-fn/">Real Life ES6 - Arrow Functions</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2014/04/required-parameters-es6.html">Handling required parameters in ECMAScript 6</a></li><li>Dmitry Soshnikov, <a href="http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/">ES6 Notes: Default values of parameters</a>: 介绍参数的默认值</li><li>Ragan Wald, <a href="http://raganwald.com/2015/02/02/destructuring.html">Destructuring and Recursion in ES6</a>: rest 参数和扩展运算符的详细介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/09/function-names-es6.html">The names of functions in ES6</a>: 函数的 name 属性的详细介绍</li><li>Kyle Simpson, <a href="http://blog.getify.com/arrow-this/">Arrow This</a>: 箭头函数并没有自己的 this</li><li>Derick Bailey, <a href="http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/">Do ES6 Arrow Functions Really Solve “this” In JavaScript?</a>：使用箭头函数处理 this 指向，必须非常小心</li><li>Mark McDonnell, <a href="http://www.integralist.co.uk/posts/js-recursion.html">Understanding recursion in functional JavaScript programming</a>: 如何自己实现尾递归优化</li><li>Nicholas C. Zakas, <a href="https://www.nczonline.net/blog/2016/10/the-ecmascript-2016-change-you-probably-dont-know/">The ECMAScript 2016 change you probably don’t know</a>: 使用参数默认值时，不能在函数内部显式开启严格模式</li><li>Axel Rauschmayer, <a href="https://2ality.com/2017/08/optional-catch-binding.html">ES proposal: optional catch binding</a></li><li>Cynthia Lee, <a href="https://medium.freecodecamp.org/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26">When you should use ES6 arrow functions — and when you shouldn’t</a>: 讨论箭头函数的适用场合</li><li>Eric Elliott, <a href="https://medium.com/javascript-scene/what-is-this-the-inner-workings-of-javascript-objects-d397bfa0708a">What is this?</a>: 箭头函数内部的 this 的解释。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>Addy Osmani, <a href="http://www.html5rocks.com/en/tutorials/es7/observe/">Data-binding Revolutions with Object.observe()</a>: 介绍 Object.observe()的概念</li><li>Sella Rafaeli, <a href="http://www.sellarafaeli.com/blog/native_javascript_data_binding">Native JavaScript Data-Binding</a>: 如何使用 Object.observe 方法，实现数据对象与 DOM 对象的双向绑定</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/09/proto-es6.html"><code>__proto__</code> in ECMAScript 6</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/10/enumerability-es6.html">Enumerability in ECMAScript 6</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2016/02/object-getownpropertydescriptors.html">ES proposal: Object.getOwnPropertyDescriptors()</a></li><li>TC39, <a href="https://github.com/tc39/proposal-object-getownpropertydescriptors">Object.getOwnPropertyDescriptors Proposal</a></li><li>David Titarenco, <a href="https://dvt.name/2018/06/02/spread-syntax-breaks-javascript/">How Spread Syntax Breaks JavaScript</a>: 扩展运算符的一些不合理的地方</li></ul><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul><li>Axel Rauschmayer, <a href="https://2ality.com/2014/12/es6-symbols.html">Symbols in ECMAScript 6</a>: Symbol 简介</li><li>MDN, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>: Symbol 类型的详细介绍</li><li>Jason Orendorff, <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">ES6 In Depth: Symbols</a></li><li>Keith Cirkel, <a href="http://blog.keithcirkel.co.uk/metaprogramming-in-es6-symbols/">Metaprogramming in ES6: Symbols and why they’re awesome</a>: Symbol 的深入介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/09/well-known-symbols-es6.html">Customizing ES6 via well-known symbols</a></li><li>Derick Bailey, <a href="https://derickbailey.com/2016/03/09/creating-a-true-singleton-in-node-js-with-es6-symbols/">Creating A True Singleton In Node.js, With ES6 Symbols</a></li><li>Das Surma, <a href="https://dassur.ma/things/reading-specs-2/">How to read web specs Part IIa – Or: ECMAScript Symbols</a>: 介绍 Symbol 的规格</li></ul><h2 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h2><ul><li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a>：介绍 WeakSet 数据结构</li><li>Dwayne Charrington, <a href="http://ilikekillnerds.com/2015/02/what-are-weakmaps-in-es6/">What Are Weakmaps In ES6?</a>: WeakMap 数据结构介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/01/es6-maps-sets.html">ECMAScript 6: maps and sets</a>: Set 和 Map 结构的详细介绍</li><li>Jason Orendorff, <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-collections/">ES6 In Depth: Collections</a>：Set 和 Map 结构的设计思想</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/08/es6-map-json.html">Converting ES6 Maps to and from JSON</a>: 如何将 Map 与其他数据结构互相转换</li></ul><h2 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h2><ul><li>Nicholas C. Zakas, <a href="http://www.nczonline.net/blog/2014/04/22/creating-defensive-objects-with-es6-proxies/">Creating defensive objects with ES6 proxies</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2014/12/es6-proxies.html">Meta programming with ECMAScript 6 proxies</a>: Proxy 详解</li><li>Daniel Zautner, <a href="http://dzautner.com/meta-programming-javascript-using-proxies/">Meta-programming JavaScript Using Proxies</a>: 使用 Proxy 实现元编程</li><li>Tom Van Cutsem, <a href="https://github.com/tvcutsem/harmony-reflect/wiki">Harmony-reflect</a>: Reflect 对象的设计目的</li><li>Tom Van Cutsem, <a href="https://github.com/tvcutsem/harmony-reflect/blob/master/doc/traps.md">Proxy Traps</a>: Proxy 拦截操作一览</li><li>Tom Van Cutsem, <a href="https://github.com/tvcutsem/harmony-reflect/blob/master/doc/api.md">Reflect API</a></li><li>Tom Van Cutsem, <a href="https://github.com/tvcutsem/harmony-reflect/blob/master/doc/handler_api.md">Proxy Handler API</a></li><li>Nicolas Bevacqua, <a href="http://ponyfoo.com/articles/es6-proxies-in-depth">ES6 Proxies in Depth</a></li><li>Nicolas Bevacqua, <a href="http://ponyfoo.com/articles/es6-proxy-traps-in-depth">ES6 Proxy Traps in Depth</a></li><li>Nicolas Bevacqua, <a href="http://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">More ES6 Proxy Traps in Depth</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2016/11/proxying-builtins.html">Pitfall: not all objects can be wrapped transparently by proxies</a></li><li>Bertalan Miklos, <a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/">Writing a JavaScript Framework - Data Binding with ES6 Proxies</a>: 使用 Proxy 实现观察者模式</li><li>Keith Cirkel, <a href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/">Metaprogramming in ES6: Part 2 - Reflect</a>: Reflect API 的详细介绍</li></ul><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><ul><li>Jake Archibald, <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">JavaScript Promises: There and back again</a></li><li>Jake Archibald, <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li><li>Tilde, <a href="https://github.com/tildeio/rsvp.js">rsvp.js</a></li><li>Sandeep Panda, <a href="http://www.sitepoint.com/overview-javascript-promises/">An Overview of JavaScript Promises</a>: ES6 Promise 入门介绍</li><li>Dave Atchley, <a href="http://www.datchley.name/es6-promises/">ES6 Promises</a>: Promise 的语法介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2014/10/es6-promises-api.html">ECMAScript 6 promises (2/2): the API</a>: 对 ES6 Promise 规格和用法的详细介绍</li><li>Jack Franklin, <a href="http://javascriptplayground.com/blog/2015/02/promises/">Embracing Promises in JavaScript</a>: catch 方法的例子</li><li>Ronald Chen, <a href="https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513#.2an1he6vf">How to escape Promise Hell</a>: 如何使用<code>Promise.all</code>方法的一些很好的例子</li><li>Jordan Harband, <a href="https://github.com/ljharb/proposal-promise-try">proposal-promise-try</a>: Promise.try() 方法的提案</li><li>Sven Slootweg, <a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">What is Promise.try, and why does it matter?</a>: Promise.try() 方法的优点</li><li>Yehuda Katz, <a href="https://thefeedbackloop.xyz/tc39-promises-promises/">TC39: Promises, Promises</a>: Promise.try() 的用处</li></ul><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul><li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">Iterators and generators</a></li><li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">The Iterator protocol</a></li><li>Jason Orendorff, <a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 In Depth: Iterators and the for-of loop</a>: 遍历器与 for…of 循环的介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2013/06/iterators-generators.html">Iterators and generators in ECMAScript 6</a>: 探讨 Iterator 和 Generator 的设计目的</li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a>: Iterator 的详细介绍</li><li>Kyle Simpson, <a href="http://blog.getify.com/iterating-es6-numbers/">Iterating ES6 Numbers</a>: 在数值对象上部署遍历器</li></ul><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ul><li>Matt Baker, <a href="http://flippinawesome.org/2014/02/10/replacing-callbacks-with-es6-generators/">Replacing callbacks with ES6 Generators</a></li><li>Steven Sanderson, <a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">Experiments with Koa and JavaScript Generators</a></li><li>jmar777, <a href="http://devsmash.com/blog/whats-the-big-deal-with-generators">What’s the Big Deal with Generators?</a></li><li>Marc Harter, <a href="http://strongloop.com/strongblog/how-to-generators-node-js-yield-use-cases/">Generators in Node.js: Common Misconceptions and Three Good Use Cases</a>: 讨论 Generator 函数的作用</li><li>StackOverflow, <a href="https://stackoverflow.com/questions/20977379/es6-yield-what-happens-to-the-arguments-of-the-first-call-next">ES6 yield : what happens to the arguments of the first call next()?</a>: 第一次使用 next 方法时不能带有参数</li><li>Kyle Simpson, <a href="http://davidwalsh.name/es6-generators">ES6 Generators: Complete Series</a>: 由浅入深探讨 Generator 的系列文章，共四篇</li><li>Gajus Kuizinas, <a href="http://gajus.com/blog/2/the-definetive-guide-to-the-javascript-generators">The Definitive Guide to the JavaScript Generators</a>: 对 Generator 的综合介绍</li><li>Jan Krems, <a href="https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c">Generators Are Like Arrays</a>: 讨论 Generator 可以被当作数据结构看待</li><li>Harold Cooper, <a href="http://syzygy.st/javascript-coroutines/">Coroutine Event Loops in JavaScript</a>: Generator 用于实现状态机</li><li>Ruslan Ismagilov, <a href="https://github.com/isRuslan/learn-generators">learn-generators</a>: 编程练习，共 6 道题</li><li>Steven Sanderson, <a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">Experiments with Koa and JavaScript Generators</a>: Generator 入门介绍，以 Koa 框架为例</li><li>Mahdi Dibaiee, <a href="http://dibaiee.ir/es7-array-generator-comprehensions/">ES7 Array and Generator comprehensions</a>：ES7 的 Generator 推导</li><li>Nicolas Bevacqua, <a href="http://ponyfoo.com/articles/es6-generators-in-depth">ES6 Generators in Depth</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/03/es6-generators.html">ES6 generators in depth</a>: Generator 规格的详尽讲解</li><li>Derick Bailey, <a href="https://derickbailey.com/2015/10/05/using-es6-generators-to-short-circuit-hierarchical-data-iteration/">Using ES6 Generators To Short-Circuit Hierarchical Data Iteration</a>：使用 for…of 循环完成预定的操作步骤</li></ul><h2 id="异步操作和-Async-函数"><a href="#异步操作和-Async-函数" class="headerlink" title="异步操作和 Async 函数"></a>异步操作和 Async 函数</h2><ul><li>Luke Hoban, <a href="https://github.com/lukehoban/ecmascript-asyncawait">Async Functions for ECMAScript</a>: Async 函数的设计思想，与 Promise、Gernerator 函数的关系</li><li>Jafar Husain, <a href="https://github.com/jhusain/asyncgenerator">Asynchronous Generators for ES7</a>: Async 函数的深入讨论</li><li>Nolan Lawson, <a href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html">Taming the asynchronous beast with ES7</a>: async 函数通俗的实例讲解</li><li>Jafar Husain, <a href="https://docs.google.com/file/d/0B4PVbLpUIdzoMDR5dWstRllXblU/view?sle=true">Async Generators</a>: 对 async 与 Generator 混合使用的一些讨论</li><li>Daniel Brain, <a href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand promises before you start using async/await</a>: 讨论 async/await 与 Promise 的关系</li><li>Jake Archibald, <a href="https://developers.google.com/web/fundamentals/getting-started/primers/async-functions">Async functions - making promises friendly</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2016/10/asynchronous-iteration.html">ES proposal: asynchronous iteration</a>: 异步遍历器的详细介绍</li><li>Dima Grossman, <a href="http://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">How to write async await without try-catch blocks in JavaScript</a>: 除了 try/catch 以外的 async 函数内部捕捉错误的方法</li><li>Mostafa Gaafa, <a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9">6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a>: Async 函数的6个好处</li><li>Mathias Bynens, <a href="https://mathiasbynens.be/notes/async-stack-traces">Asynchronous stack traces: why await beats Promise#then()</a>: async 函数可以保留错误堆栈</li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul><li>Sebastian Porto, <a href="https://reinteractive.net/posts/235-es6-classes-and-javascript-prototypes">ES6 classes and JavaScript prototypes</a>: ES6 Class 的写法与 ES5 Prototype 的写法对比</li><li>Jack Franklin, <a href="http://javascriptplayground.com/blog/2014/07/introduction-to-es6-classes-tutorial/">An introduction to ES6 classes</a>: ES6 class 的入门介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2014/12/es6-oop.html">ECMAScript 6: new OOP features besides classes</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/02/es6-classes-final.html">Classes in ECMAScript 6 (final semantics)</a>: Class 语法的详细介绍和设计思想分析</li><li>Eric Faust, <a href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/">ES6 In Depth: Subclassing</a>: Class 语法的深入介绍</li><li>Nicolás Bevacqua, <a href="https://ponyfoo.com/articles/binding-methods-to-class-instance-objects">Binding Methods to Class Instance Objects</a>: 如何绑定类的实例中的 this</li><li>Jamie Kyle, <a href="https://jamie.build/javascripts-new-private-class-fields.html">JavaScript’s new #private class fields</a>：私有属性的介绍。</li><li>Mathias Bynens, <a href="https://developers.google.com/web/updates/2018/12/class-fields">Public and private class fields</a>：实例属性的新写法的介绍。</li></ul><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><ul><li>Maximiliano Fierro, <a href="https://elmasse.github.io/js/decorators-bindings-es7.html">Declarative vs Imperative</a>: Decorators 和 Mixin 介绍</li><li>Justin Fagnani, <a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">“Real” Mixins with JavaScript Classes</a>: 使用类的继承实现 Mixin</li><li>Addy Osmani, <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841">Exploring ES2016 Decorators</a>: Decorator 的深入介绍</li><li>Sebastian McKenzie, <a href="https://github.com/wycats/javascript-decorators/issues/4">Allow decorators for functions as well</a>: 为什么修饰器不能用于函数</li><li>Maximiliano Fierro, <a href="https://cocktailjs.github.io/blog/traits-with-es7-decorators.html">Traits with ES7 Decorators</a>: Trait 的用法介绍</li><li>Jonathan Creamer: <a href="http://jonathancreamer.com/using-es2016-decorators-to-publish-on-an-event-bus/">Using ES2016 Decorators to Publish on an Event Bus</a>: 使用修饰器实现自动发布事件</li></ul><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul><li>Jack Franklin, <a href="http://24ways.org/2014/javascript-modules-the-es6-way/">JavaScript Modules the ES6 Way</a>: ES6 模块入门</li><li>Axel Rauschmayer, <a href="https://2ality.com/2014/09/es6-modules-final.html">ECMAScript 6 modules: the final syntax</a>: ES6 模块的介绍，以及与 CommonJS 规格的详细比较</li><li>Dave Herman, <a href="http://calculist.org/blog/2012/06/29/static-module-resolution/">Static module resolution</a>: ES6 模块的静态化设计思想</li><li>Jason Orendorff, <a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">ES6 In Depth: Modules</a>: ES6 模块设计思想的介绍</li><li>Ben Newman, <a href="https://benjamn.github.io/empirenode-2015/#/">The Importance of import and export</a>: ES6 模块的设计思想</li><li>ESDiscuss, <a href="https://esdiscuss.org/topic/why-is-export-default-var-a-1-invalid-syntax">Why is “export default var a = 1;” invalid syntax?</a></li><li>Bradley Meck, <a href="https://github.com/nodejs/node-eps/blob/master/002-es6-modules.md">ES6 Module Interoperability</a>: 介绍 Node 如何处理 ES6 语法加载 CommonJS 模块</li><li>Axel Rauschmayer, <a href="https://2ality.com/2017/01/babel-esm-spec-mode.html">Making transpiled ES modules more spec-compliant</a>: ES6 模块编译成 CommonJS 模块的详细介绍</li><li>Axel Rauschmayer, <a href="https://2ality.com/2017/01/import-operator.html">ES proposal: import() – dynamically importing ES modules</a>: import() 的用法</li><li>Node EPS, <a href="https://github.com/nodejs/node-eps/blob/master/002-es-modules.md">ES Module Interoperability</a>: Node 对 ES6 模块的处理规格</li><li>Dan Fabulich, <a href="https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1">Why CommonJS and ES Modules Can’t Get Along</a>: Node.js 对 ES6 模块的处理</li></ul><h2 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h2><ul><li>Ilmari Heikkinen, <a href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/">Typed Arrays: Binary Data in the Browser</a></li><li>Khronos, <a href="http://www.khronos.org/registry/typedarray/specs/latest/">Typed Array Specification</a></li><li>Ian Elliot, <a href="http://www.i-programmer.info/projects/36-web/6234-reading-a-bmp-file-in-javascript.html">Reading A BMP File In JavaScript</a></li><li>Renato Mangini, <a href="http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String">How to convert ArrayBuffer to and from String</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2015/09/typed-arrays.html">Typed Arrays in ECMAScript 6</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2017/01/shared-array-buffer.html">ES proposal: Shared memory and atomics</a></li><li>Lin Clark, <a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/">Avoiding race conditions in SharedArrayBuffers with Atomics</a>: Atomics 对象使用场景的解释</li><li>Lars T Hansen, <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/TUTORIAL.md">Shared memory - a brief tutorial</a></li><li>James Milner, <a href="https://www.sitepen.com/blog/2018/09/19/the-return-of-sharedarraybuffers-and-atomics/">The Return of SharedArrayBuffers and Atomics</a></li></ul><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><ul><li>TC39, <a href="https://docs.google.com/presentation/d/1MY9NHrHmL7ma7C8dyNXvmYNNGgVmmxXk8ZIiQtPlfH4/edit#slide=id.p19">SIMD.js Stage 2</a></li><li>MDN, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SIMD">SIMD</a></li><li>TC39, <a href="https://github.com/tc39/ecmascript_simd">ECMAScript SIMD</a></li><li>Axel Rauschmayer, <a href="https://2ality.com/2013/12/simd-js.html">JavaScript gains support for SIMD</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>Babel, <a href="https://github.com/thejameskyle/babel-handbook/tree/master/translations/en">Babel Handbook</a>: Babel 的用法介绍</p></li><li><p>Google, <a href="https://github.com/google/traceur-compiler">traceur-compiler</a>: Traceur 编译器</p></li><li><p>Casper Beyer, <a href="https://caspervonb.github.io/2014/03/05/ecmascript6-features-and-tools.html">ECMAScript 6 Features and Tools</a></p></li><li><p>Stoyan Stefanov, <a href="http://www.phpied.com/writing-es6-today-with-jstransform/">Writing ES6 today with jstransform</a></p></li><li><p>ES6 Module Loader, <a href="https://github.com/ModuleLoader/es6-module-loader">ES6 Module Loader Polyfill</a>: 在浏览器和 node.js 加载 ES6 模块的一个库，文档里对 ES6 模块有详细解释</p></li><li><p>Paul Miller, <a href="https://github.com/paulmillr/es6-shim">es6-shim</a>: 一个针对老式浏览器，模拟 ES6 部分功能的垫片库（shim）</p></li><li><p>army8735, <a href="https://github.com/army8735/jsdc">JavaScript Downcast</a>: 国产的 ES6 到 ES5 的转码器</p></li><li><p>esnext, <a href="https://github.com/esnext/es6-module-transpiler">ES6 Module Transpiler</a>：基于 node.js 的将 ES6 模块转为 ES5 代码的命令行工具</p></li><li><p>Sebastian McKenzie, <a href="http://babeljs.io/">BabelJS</a>: ES6 转译器</p></li><li><p>SystemJS, <a href="https://github.com/systemjs/systemjs">SystemJS</a>: 在浏览器中加载 AMD、CJS、ES6 模块的一个垫片库</p></li><li><p>Modernizr, <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#ecmascript-6-harmony">HTML5 Cross Browser Polyfills</a>: ES6 垫片库清单</p></li><li><p>Facebook, <a href="https://github.com/facebook/regenerator">regenerator</a>: 将 Generator 函数转为 ES5 的转码器</p><h2 id="Es6-阮一峰"><a href="#Es6-阮一峰" class="headerlink" title="Es6-阮一峰"></a>Es6-<a href="https://www.ruanyifeng.com/">阮一峰</a></h2><ul><li>来源</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Module 的加载实现</title>
      <link href="/2022/09/05/13module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/09/05/13module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/module-loader#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD">浏览器加载</a></li><li>[ES6 模块与 CommonJS 模块的差异](<a href="https://es6.ruanyifeng.com/#docs/module-loader#ES6">https://es6.ruanyifeng.com/#docs/module-loader#ES6</a> 模块与 CommonJS 模块的差异)</li><li>[Node.js 的模块加载方法](<a href="https://es6.ruanyifeng.com/#docs/module-loader#Node.js">https://es6.ruanyifeng.com/#docs/module-loader#Node.js</a> 的模块加载方法)</li><li><a href="https://es6.ruanyifeng.com/#docs/module-loader#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD">循环加载</a></li></ol><p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p><h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><pre><code class="html">&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=&quot;application/javascript&quot;&gt;  // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;</code></pre><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><pre><code class="html">&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></pre><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p><pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;</code></pre><p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></pre><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p><script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。```html<script type="module" src="./foo.js" async></script><pre><code>一旦使用了`async`属性，`&lt;script type=&quot;module&quot;&gt;`就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。```html&lt;script type=&quot;module&quot;&gt;  import utils from &quot;./utils.js&quot;;  // other code&lt;/script&gt;</code></pre><p>举例来说，jQuery 就支持模块加载。</p><pre><code class="html">&lt;script type=&quot;module&quot;&gt;  import $ from &quot;./jquery/src/jquery.js&quot;;  $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);&lt;/script&gt;</code></pre><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>下面是一个示例模块。</p><pre><code class="javascript">import utils from &#39;https://example.com/js/utils.js&#39;;const x = 1;console.log(x === window.x); //falseconsole.log(this === undefined); // true</code></pre><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p><pre><code class="javascript">const isNotModuleScript = this !== undefined;</code></pre><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><p>讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p><p>它们有三个重大差异。</p><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</li></ul><p>第二个差异是因为 CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异。</p><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p><pre><code class="javascript">// lib.jsvar counter = 3;function incCounter() &#123;  counter++;&#125;module.exports = &#123;  counter: counter,  incCounter: incCounter,&#125;;</code></pre><p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p><pre><code class="javascript">// main.jsvar mod = require(&#39;./lib&#39;);console.log(mod.counter);  // 3mod.incCounter();console.log(mod.counter); // 3</code></pre><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><pre><code class="javascript">// lib.jsvar counter = 3;function incCounter() &#123;  counter++;&#125;module.exports = &#123;  get counter() &#123;    return counter  &#125;,  incCounter: incCounter,&#125;;</code></pre><p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p><pre><code class="bash">$ node main.js34</code></pre><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><p>还是举上面的例子。</p><pre><code class="javascript">// lib.jsexport let counter = 3;export function incCounter() &#123;  counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from &#39;./lib&#39;;console.log(counter); // 3incCounter();console.log(counter); // 4</code></pre><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><p>再举一个出现在<code>export</code>一节中的例子。</p><pre><code class="javascript">// m1.jsexport var foo = &#39;bar&#39;;setTimeout(() =&gt; foo = &#39;baz&#39;, 500);// m2.jsimport &#123;foo&#125; from &#39;./m1.js&#39;;console.log(foo);setTimeout(() =&gt; console.log(foo), 500);</code></pre><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。</p><p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p><pre><code class="bash">$ babel-node m2.jsbarbaz</code></pre><p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p><pre><code class="javascript">// lib.jsexport let obj = &#123;&#125;;// main.jsimport &#123; obj &#125; from &#39;./lib&#39;;obj.prop = 123; // OKobj = &#123;&#125;; // TypeError</code></pre><p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p><p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p><pre><code class="javascript">// mod.jsfunction C() &#123;  this.sum = 0;  this.add = function () &#123;    this.sum += 1;  &#125;;  this.show = function () &#123;    console.log(this.sum);  &#125;;&#125;export let c = new C();</code></pre><p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><pre><code class="javascript">// x.jsimport &#123;c&#125; from &#39;./mod&#39;;c.add();// y.jsimport &#123;c&#125; from &#39;./mod&#39;;c.show();// main.jsimport &#39;./x&#39;;import &#39;./y&#39;;</code></pre><p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p><pre><code class="bash">$ babel-node main.js1</code></pre><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p><h2 id="Node-js-的模块加载方法"><a href="#Node-js-的模块加载方法" class="headerlink" title="Node.js 的模块加载方法"></a>Node.js 的模块加载方法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p><p>它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p><p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p><p>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</p><pre><code class="javascript">&#123;   &quot;type&quot;: &quot;module&quot;&#125;</code></pre><p>一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。</p><pre><code class="bash"># 解释成 ES6 模块$ node my-app.js</code></pre><p>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</p><p>总结为一句话：<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</p><p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><h3 id="package-json-的-main-字段"><a href="#package-json-的-main-字段" class="headerlink" title="package.json 的 main 字段"></a>package.json 的 main 字段</h3><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p><pre><code class="javascript">// ./node_modules/es-module-package/package.json&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;main&quot;: &quot;./src/index.js&quot;&#125;</code></pre><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p><p>然后，<code>import</code>命令就可以加载这个模块。</p><pre><code class="javascript">// ./my-app.mjsimport &#123; something &#125; from &#39;es-module-package&#39;;// 实际加载的是 ./node_modules/es-module-package/src/index.js</code></pre><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p><p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p><h3 id="package-json-的-exports-字段"><a href="#package-json-的-exports-字段" class="headerlink" title="package.json 的 exports 字段"></a>package.json 的 exports 字段</h3><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p><p>（1）子目录别名</p><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p><pre><code class="javascript">// ./node_modules/es-module-package/package.json&#123;  &quot;exports&quot;: &#123;    &quot;./submodule&quot;: &quot;./src/submodule.js&quot;  &#125;&#125;</code></pre><p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p><pre><code class="javascript">import submodule from &#39;es-module-package/submodule&#39;;// 加载 ./node_modules/es-module-package/src/submodule.js</code></pre><p>下面是子目录别名的例子。</p><pre><code class="javascript">// ./node_modules/es-module-package/package.json&#123;  &quot;exports&quot;: &#123;    &quot;./features/&quot;: &quot;./src/features/&quot;  &#125;&#125;import feature from &#39;es-module-package/features/x.js&#39;;// 加载 ./node_modules/es-module-package/src/features/x.js</code></pre><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p><pre><code class="javascript">// 报错import submodule from &#39;es-module-package/private-module.js&#39;;// 不报错import submodule from &#39;./node_modules/es-module-package/private-module.js&#39;;</code></pre><p>（2）main 的别名</p><p><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p><pre><code class="javascript">&#123;  &quot;exports&quot;: &#123;    &quot;.&quot;: &quot;./main.js&quot;  &#125;&#125;// 等同于&#123;  &quot;exports&quot;: &quot;./main.js&quot;&#125;</code></pre><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p><pre><code class="javascript">&#123;  &quot;main&quot;: &quot;./main-legacy.cjs&quot;,  &quot;exports&quot;: &#123;    &quot;.&quot;: &quot;./main-modern.cjs&quot;  &#125;&#125;</code></pre><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p><p><strong>（3）条件加载</strong></p><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p><pre><code class="javascript">&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;exports&quot;: &#123;    &quot;.&quot;: &#123;      &quot;require&quot;: &quot;./main.cjs&quot;,      &quot;default&quot;: &quot;./main.js&quot;    &#125;  &#125;&#125;</code></pre><p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p><p>上面的写法可以简写如下。</p><pre><code class="javascript">&#123;  &quot;exports&quot;: &#123;    &quot;require&quot;: &quot;./main.cjs&quot;,    &quot;default&quot;: &quot;./main.js&quot;  &#125;&#125;</code></pre><p>注意，如果同时还有其他别名，就不能采用简写，否则会报错。</p><pre><code class="javascript">&#123;  // 报错  &quot;exports&quot;: &#123;    &quot;./feature&quot;: &quot;./lib/feature.js&quot;,    &quot;require&quot;: &quot;./main.cjs&quot;,    &quot;default&quot;: &quot;./main.js&quot;  &#125;&#125;</code></pre><h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</p><pre><code class="javascript">(async () =&gt; &#123;  await import(&#39;./my-app.mjs&#39;);&#125;)();</code></pre><p>上面代码可以在 CommonJS 模块中运行。</p><p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p><h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</p><pre><code class="javascript">// 正确import packageMain from &#39;commonjs-package&#39;;// 报错import &#123; method &#125; from &#39;commonjs-package&#39;;</code></pre><p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p><p>加载单一的输出项，可以写成下面这样。</p><pre><code class="javascript">import packageMain from &#39;commonjs-package&#39;;const &#123; method &#125; = packageMain;</code></pre><p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p><pre><code class="javascript">// cjs.cjsmodule.exports = &#39;cjs&#39;;// esm.mjsimport &#123; createRequire &#125; from &#39;module&#39;;const require = createRequire(import.meta.url);const cjs = require(&#39;./cjs.cjs&#39;);cjs === &#39;cjs&#39;; // true</code></pre><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p><h3 id="同时支持两种格式的模块"><a href="#同时支持两种格式的模块" class="headerlink" title="同时支持两种格式的模块"></a>同时支持两种格式的模块</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p><p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p><p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p><pre><code class="javascript">import cjsModule from &#39;../index.js&#39;;export const foo = cjsModule.foo;</code></pre><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p><p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p><p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p><pre><code class="javascript">&quot;exports&quot;：&#123;  &quot;require&quot;: &quot;./index.js&quot;，  &quot;import&quot;: &quot;./esm/wrapper.js&quot;&#125;</code></pre><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p><h3 id="Node-js-的内置模块"><a href="#Node-js-的内置模块" class="headerlink" title="Node.js 的内置模块"></a>Node.js 的内置模块</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p><pre><code class="javascript">// 整体加载import EventEmitter from &#39;events&#39;;const e = new EventEmitter();// 加载指定的输出项import &#123; readFile &#125; from &#39;fs&#39;;readFile(&#39;./foo.txt&#39;, (err, source) =&gt; &#123;  if (err) &#123;    console.error(err);  &#125; else &#123;    console.log(source);  &#125;&#125;);</code></pre><h3 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p><pre><code class="javascript">// ES6 模块中将报错import &#123; something &#125; from &#39;./index&#39;;</code></pre><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p><pre><code class="javascript">import &#39;./foo.mjs?query=1&#39;; // 加载 ./foo 传入参数 ?query=1</code></pre><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><pre><code class="javascript">// a.jsvar b = require(&#39;b&#39;);// b.jsvar a = require(&#39;a&#39;);</code></pre><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p><p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><pre><code class="javascript">&#123;  id: &#39;...&#39;,  exports: &#123; ... &#125;,  loaded: true,  ...&#125;</code></pre><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p><h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。脚本文件<code>a.js</code>代码如下。</p><pre><code class="javascript">exports.done = false;var b = require(&#39;./b.js&#39;);console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);exports.done = true;console.log(&#39;a.js 执行完毕&#39;);</code></pre><p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p><p>再看<code>b.js</code>的代码。</p><pre><code class="javascript">exports.done = false;var a = require(&#39;./a.js&#39;);console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);exports.done = true;console.log(&#39;b.js 执行完毕&#39;);</code></pre><p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p><p><code>a.js</code>已经执行的部分，只有一行。</p><pre><code class="javascript">exports.done = false;</code></pre><p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p><p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p><pre><code class="javascript">var a = require(&#39;./a.js&#39;);var b = require(&#39;./b.js&#39;);console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);</code></pre><p>执行<code>main.js</code>，运行结果如下。</p><pre><code class="bash">$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true</code></pre><p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p><pre><code class="javascript">exports.done = true;</code></pre><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p><p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><pre><code class="javascript">var a = require(&#39;a&#39;); // 安全的写法var foo = require(&#39;a&#39;).foo; // 危险的写法exports.good = function (arg) &#123;  return a.foo(&#39;good&#39;, arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123;  return foo(&#39;bad&#39;, arg); // 使用的是一个部分加载时的值&#125;;</code></pre><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><p>请看下面这个例子。</p><pre><code class="javascript">// a.mjsimport &#123;bar&#125; from &#39;./b&#39;;console.log(&#39;a.mjs&#39;);console.log(bar);export let foo = &#39;foo&#39;;// b.mjsimport &#123;foo&#125; from &#39;./a&#39;;console.log(&#39;b.mjs&#39;);console.log(foo);export let bar = &#39;bar&#39;;</code></pre><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><pre><code class="bash">$ node --experimental-modules a.mjsb.mjsReferenceError: foo is not defined</code></pre><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><pre><code class="javascript">// a.mjsimport &#123;bar&#125; from &#39;./b&#39;;console.log(&#39;a.mjs&#39;);console.log(bar());function foo() &#123; return &#39;foo&#39; &#125;export &#123;foo&#125;;// b.mjsimport &#123;foo&#125; from &#39;./a&#39;;console.log(&#39;b.mjs&#39;);console.log(foo());function bar() &#123; return &#39;bar&#39; &#125;export &#123;bar&#125;;</code></pre><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><pre><code class="bash">$ node --experimental-modules a.mjsb.mjsfooa.mjsbar</code></pre><p>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p><pre><code class="javascript">// a.mjsimport &#123;bar&#125; from &#39;./b&#39;;console.log(&#39;a.mjs&#39;);console.log(bar());const foo = () =&gt; &#39;foo&#39;;export &#123;foo&#125;;</code></pre><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p><p>我们再来看 ES6 模块加载器<a href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p><pre><code class="javascript">// even.jsimport &#123; odd &#125; from &#39;./odd&#39;export var counter = 0;export function even(n) &#123;  counter++;  return n === 0 || odd(n - 1);&#125;// odd.jsimport &#123; even &#125; from &#39;./even&#39;;export function odd(n) &#123;  return n !== 0 &amp;&amp; even(n - 1);&#125;</code></pre><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><pre><code class="javascript">$ babel-node&gt; import * as m from &#39;./even.js&#39;;&gt; m.even(10);true&gt; m.counter6&gt; m.even(20)true&gt; m.counter17</code></pre><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p><pre><code class="javascript">// even.jsvar odd = require(&#39;./odd&#39;);var counter = 0;exports.counter = counter;exports.even = function (n) &#123;  counter++;  return n == 0 || odd(n - 1);&#125;// odd.jsvar even = require(&#39;./even&#39;).even;module.exports = function (n) &#123;  return n != 0 &amp;&amp; even(n - 1);&#125;</code></pre><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><pre><code class="bash">$ node&gt; var m = require(&#39;./even&#39;);&gt; m.even(10)TypeError: even is not a function</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Module 的语法</title>
      <link href="/2022/09/05/12Module%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/09/05/12Module%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/module#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="https://es6.ruanyifeng.com/#docs/module#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li><li>[export 命令](<a href="https://es6.ruanyifeng.com/#docs/module#export">https://es6.ruanyifeng.com/#docs/module#export</a> 命令)</li><li>[import 命令](<a href="https://es6.ruanyifeng.com/#docs/module#import">https://es6.ruanyifeng.com/#docs/module#import</a> 命令)</li><li><a href="https://es6.ruanyifeng.com/#docs/module#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD">模块的整体加载</a></li><li>[export default 命令](<a href="https://es6.ruanyifeng.com/#docs/module#export">https://es6.ruanyifeng.com/#docs/module#export</a> default 命令)</li><li>[export 与 import 的复合写法](<a href="https://es6.ruanyifeng.com/#docs/module#export">https://es6.ruanyifeng.com/#docs/module#export</a> 与 import 的复合写法)</li><li><a href="https://es6.ruanyifeng.com/#docs/module#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%A7%E6%89%BF">模块的继承</a></li><li><a href="https://es6.ruanyifeng.com/#docs/module#%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%B8%B8%E9%87%8F">跨模块常量</a></li><li><a href="https://es6.ruanyifeng.com/#docs/module#import()">import()</a></li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><pre><code class="javascript">// CommonJS模块let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);// 等同于let _fs = require(&#39;fs&#39;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;</code></pre><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><pre><code class="javascript">// ES6模块import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;</code></pre><p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li></ul><p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><p>严格模式主要有以下限制。</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul><p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p><p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p><h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><pre><code class="javascript">// profile.jsexport var firstName = &#39;Michael&#39;;export var lastName = &#39;Jackson&#39;;export var year = 1958;</code></pre><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><pre><code class="javascript">// profile.jsvar firstName = &#39;Michael&#39;;var lastName = &#39;Jackson&#39;;var year = 1958;export &#123; firstName, lastName, year &#125;;</code></pre><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><pre><code class="javascript">export function multiply(x, y) &#123;  return x * y;&#125;;</code></pre><p>上面代码对外输出一个函数<code>multiply</code>。</p><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><pre><code class="javascript">function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123;  v1 as streamV1,  v2 as streamV2,  v2 as streamLatestVersion&#125;;</code></pre><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><pre><code class="javascript">// 报错export 1;// 报错var m = 1;export m;</code></pre><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p><pre><code class="javascript">// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;;</code></pre><p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><pre><code class="javascript">// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;;</code></pre><p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><pre><code class="javascript">export var foo = &#39;bar&#39;;setTimeout(() =&gt; foo = &#39;baz&#39;, 500);</code></pre><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。</p><p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><pre><code class="javascript">function foo() &#123;  export default &#39;bar&#39; // SyntaxError&#125;foo()</code></pre><p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><pre><code class="javascript">// main.jsimport &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;function setName(element) &#123;  element.textContent = firstName + &#39; &#39; + lastName;&#125;</code></pre><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;</code></pre><p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</p><pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;</code></pre><p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p><pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;a.foo = &#39;hello&#39;; // 合法操作</code></pre><p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;</code></pre><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><pre><code class="javascript">foo();import &#123; foo &#125; from &#39;my_module&#39;;</code></pre><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><pre><code class="javascript">// 报错import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;// 报错let module = &#39;my_module&#39;;import &#123; foo &#125; from module;// 报错if (x === 1) &#123;  import &#123; foo &#125; from &#39;module1&#39;;&#125; else &#123;  import &#123; foo &#125; from &#39;module2&#39;;&#125;</code></pre><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><pre><code class="javascript">import &#39;lodash&#39;;</code></pre><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><pre><code class="javascript">import &#39;lodash&#39;;import &#39;lodash&#39;;</code></pre><p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p><pre><code class="javascript">import &#123; foo &#125; from &#39;my_module&#39;;import &#123; bar &#125; from &#39;my_module&#39;;// 等同于import &#123; foo, bar &#125; from &#39;my_module&#39;;</code></pre><p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p><p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><pre><code class="javascript">require(&#39;core-js/modules/es6.symbol&#39;);require(&#39;core-js/modules/es6.promise&#39;);import React from &#39;React&#39;;</code></pre><h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p><pre><code class="javascript">// circle.jsexport function area(radius) &#123;  return Math.PI * radius * radius;&#125;export function circumference(radius) &#123;  return 2 * Math.PI * radius;&#125;</code></pre><p>现在，加载这个模块。</p><pre><code class="javascript">// main.jsimport &#123; area, circumference &#125; from &#39;./circle&#39;;console.log(&#39;圆面积：&#39; + area(4));console.log(&#39;圆周长：&#39; + circumference(14));</code></pre><p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p><pre><code class="javascript">import * as circle from &#39;./circle&#39;;console.log(&#39;圆面积：&#39; + circle.area(4));console.log(&#39;圆周长：&#39; + circle.circumference(14));</code></pre><p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p><pre><code class="javascript">import * as circle from &#39;./circle&#39;;// 下面两行都是不允许的circle.foo = &#39;hello&#39;;circle.area = function () &#123;&#125;;</code></pre><h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><pre><code class="javascript">// export-default.jsexport default function () &#123;  console.log(&#39;foo&#39;);&#125;</code></pre><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><pre><code class="javascript">// import-default.jsimport customName from &#39;./export-default&#39;;customName(); // &#39;foo&#39;</code></pre><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用在非匿名函数前，也是可以的。</p><pre><code class="javascript">// export-default.jsexport default function foo() &#123;  console.log(&#39;foo&#39;);&#125;// 或者写成function foo() &#123;  console.log(&#39;foo&#39;);&#125;export default foo;</code></pre><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p>下面比较一下默认输出和正常输出。</p><pre><code class="javascript">// 第一组export default function crc32() &#123; // 输出  // ...&#125;import crc32 from &#39;crc32&#39;; // 输入// 第二组export function crc32() &#123; // 输出  // ...&#125;;import &#123;crc32&#125; from &#39;crc32&#39;; // 输入</code></pre><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><pre><code class="javascript">// modules.jsfunction add(x, y) &#123;  return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as foo &#125; from &#39;modules&#39;;// 等同于// import foo from &#39;modules&#39;;</code></pre><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><pre><code class="javascript">// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1;</code></pre><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><pre><code class="javascript">// 正确export default 42;// 报错export 42;</code></pre><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p><pre><code class="javascript">import _ from &#39;lodash&#39;;</code></pre><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p><pre><code class="javascript">import _, &#123; each, forEach &#125; from &#39;lodash&#39;;</code></pre><p>对应上面代码的<code>export</code>语句如下。</p><pre><code class="javascript">export default function (obj) &#123;  // ···&#125;export function each(obj, iterator, context) &#123;  // ···&#125;export &#123; each as forEach &#125;;</code></pre><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><p><code>export default</code>也可以用来输出类。</p><pre><code class="javascript">// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from &#39;MyClass&#39;;let o = new MyClass();</code></pre><h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p><pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;// 可以简单理解为import &#123; foo, bar &#125; from &#39;my_module&#39;;export &#123; foo, bar &#125;;</code></pre><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p><p>模块的接口改名和整体输出，也可以采用这种写法。</p><pre><code class="javascript">// 接口改名export &#123; foo as myFoo &#125; from &#39;my_module&#39;;// 整体输出export * from &#39;my_module&#39;;</code></pre><p>默认接口的写法如下。</p><pre><code class="javascript">export &#123; default &#125; from &#39;foo&#39;;</code></pre><p>具名接口改为默认接口的写法如下。</p><pre><code class="javascript">export &#123; es6 as default &#125; from &#39;./someModule&#39;;// 等同于import &#123; es6 &#125; from &#39;./someModule&#39;;export default es6;</code></pre><p>同样地，默认接口也可以改名为具名接口。</p><pre><code class="javascript">export &#123; default as es6 &#125; from &#39;./someModule&#39;;</code></pre><p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p><pre><code class="javascript">import * as someIdentifier from &quot;someModule&quot;;</code></pre><p><a href="https://github.com/tc39/proposal-export-ns-from">ES2020</a>补上了这个写法。</p><pre><code class="javascript">export * as ns from &quot;mod&quot;;// 等同于import * as ns from &quot;mod&quot;;export &#123;ns&#125;;</code></pre><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间也可以继承。</p><p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p><pre><code class="javascript">// circleplus.jsexport * from &#39;circle&#39;;export var e = 2.71828182846;export default function(x) &#123;  return Math.exp(x);&#125;</code></pre><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p><p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p><pre><code class="javascript">// circleplus.jsexport &#123; area as circleArea &#125; from &#39;circle&#39;;</code></pre><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p><p>加载上面模块的写法如下。</p><pre><code class="javascript">// main.jsimport * as math from &#39;circleplus&#39;;import exp from &#39;circleplus&#39;;console.log(exp(math.e));</code></pre><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p><h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><pre><code class="javascript">// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from &#39;./constants&#39;;console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from &#39;./constants&#39;;console.log(A); // 1console.log(B); // 3</code></pre><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><pre><code class="javascript">// constants/db.jsexport const db = &#123;  url: &#39;http://my.couchdbserver.local:5984&#39;,  admin_username: &#39;admin&#39;,  admin_password: &#39;admin password&#39;&#125;;// constants/user.jsexport const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;];</code></pre><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><pre><code class="javascript">// constants/index.jsexport &#123;db&#125; from &#39;./db&#39;;export &#123;users&#125; from &#39;./users&#39;;</code></pre><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><pre><code class="javascript">// script.jsimport &#123;db, users&#125; from &#39;./constants/index&#39;;</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p><pre><code class="javascript">// 报错if (x === 2) &#123;  import MyModual from &#39;./myModual&#39;;&#125;</code></pre><p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><pre><code class="javascript">const path = &#39;./&#39; + fileName;const myModual = require(path);</code></pre><p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p><p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p><pre><code class="javascript">import(specifier)</code></pre><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><pre><code class="javascript">const main = document.querySelector(&#39;main&#39;);import(`./section-modules/$&#123;someVariable&#125;.js`)  .then(module =&gt; &#123;    module.loadPageInto(main);  &#125;)  .catch(err =&gt; &#123;    main.textContent = err.message;  &#125;);</code></pre><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node.js 的<code>require()</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><p>由于<code>import()</code>返回 Promise 对象，所以需要使用<code>then()</code>方法指定处理函数。考虑到代码的清晰，更推荐使用<code>await</code>命令。</p><pre><code class="javascript">async function renderWidget() &#123;  const container = document.getElementById(&#39;widget&#39;);  if (container !== null) &#123;    // 等同于    // import(&quot;./widget&quot;).then(widget =&gt; &#123;    //   widget.render(container);    // &#125;);    const widget = await import(&#39;./widget.js&#39;);    widget.render(container);  &#125;&#125;renderWidget();</code></pre><p>上面示例中，<code>await</code>命令后面就是使用<code>import()</code>，对比<code>then()</code>的写法明显更简洁易读。</p><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>下面是<code>import()</code>的一些适用场合。</p><p>（1）按需加载。</p><p><code>import()</code>可以在需要的时候，再加载某个模块。</p><pre><code class="javascript">button.addEventListener(&#39;click&#39;, event =&gt; &#123;  import(&#39;./dialogBox.js&#39;)  .then(dialogBox =&gt; &#123;    dialogBox.open();  &#125;)  .catch(error =&gt; &#123;    /* Error handling */  &#125;)&#125;);</code></pre><p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p><p>（2）条件加载</p><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p><pre><code class="javascript">if (condition) &#123;  import(&#39;moduleA&#39;).then(...);&#125; else &#123;  import(&#39;moduleB&#39;).then(...);&#125;</code></pre><p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p><p>（3）动态的模块路径</p><p><code>import()</code>允许模块路径动态生成。</p><pre><code class="javascript">import(f()).then(...);</code></pre><p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p><pre><code class="javascript">import(&#39;./myModule.js&#39;).then((&#123;export1, export2&#125;) =&gt; &#123;  // ...·&#125;);</code></pre><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p><p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p><pre><code class="javascript">import(&#39;./myModule.js&#39;).then(myModule =&gt; &#123;  console.log(myModule.default);&#125;);</code></pre><p>上面的代码也可以使用具名输入的形式。</p><pre><code class="javascript">import(&#39;./myModule.js&#39;).then((&#123;default: theDefault&#125;) =&gt; &#123;  console.log(theDefault);&#125;);</code></pre><p>如果想同时加载多个模块，可以采用下面的写法。</p><pre><code class="javascript">Promise.all([  import(&#39;./module1.js&#39;),  import(&#39;./module2.js&#39;),  import(&#39;./module3.js&#39;),]).then(([module1, module2, module3]) =&gt; &#123;   ···&#125;);</code></pre><p><code>import()</code>也可以用在 async 函数之中。</p><pre><code class="javascript">async function main() &#123;  const myModule = await import(&#39;./myModule.js&#39;);  const &#123;export1, export2&#125; = await import(&#39;./myModule.js&#39;);  const [module1, module2, module3] =    await Promise.all([      import(&#39;./module1.js&#39;),      import(&#39;./module2.js&#39;),      import(&#39;./module3.js&#39;),    ]);&#125;main();</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-async 函数</title>
      <link href="/2022/09/05/11async%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/05/11async%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/async#%E5%90%AB%E4%B9%89">含义</a></li><li><a href="https://es6.ruanyifeng.com/#docs/async#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li><li><a href="https://es6.ruanyifeng.com/#docs/async#%E8%AF%AD%E6%B3%95">语法</a></li><li>[async 函数的实现原理](<a href="https://es6.ruanyifeng.com/#docs/async#async">https://es6.ruanyifeng.com/#docs/async#async</a> 函数的实现原理)</li><li><a href="https://es6.ruanyifeng.com/#docs/async#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83">与其他异步处理方法的比较</a></li><li><a href="https://es6.ruanyifeng.com/#docs/async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C">实例：按顺序完成异步操作</a></li><li>[顶层 await](<a href="https://es6.ruanyifeng.com/#docs/async#%E9%A1%B6%E5%B1%82">https://es6.ruanyifeng.com/#docs/async#顶层</a> await)</li></ol><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数，依次读取两个文件。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);const readFile = function (fileName) &#123;  return new Promise(function (resolve, reject) &#123;    fs.readFile(fileName, function(error, data) &#123;      if (error) return reject(error);      resolve(data);    &#125;);  &#125;);&#125;;const gen = function* () &#123;  const f1 = yield readFile(&#39;/etc/fstab&#39;);  const f2 = yield readFile(&#39;/etc/shells&#39;);  console.log(f1.toString());  console.log(f2.toString());&#125;;</code></pre><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><pre><code class="javascript">const asyncReadFile = async function () &#123;  const f1 = await readFile(&#39;/etc/fstab&#39;);  const f2 = await readFile(&#39;/etc/shells&#39;);  console.log(f1.toString());  console.log(f2.toString());&#125;;</code></pre><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><pre><code class="javascript">asyncReadFile();</code></pre><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><pre><code class="javascript">async function getStockPriceByName(name) &#123;  const symbol = await getStockSymbol(name);  const stockPrice = await getStockPrice(symbol);  return stockPrice;&#125;getStockPriceByName(&#39;goog&#39;).then(function (result) &#123;  console.log(result);&#125;);</code></pre><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><pre><code class="javascript">function timeout(ms) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(resolve, ms);  &#125;);&#125;async function asyncPrint(value, ms) &#123;  await timeout(ms);  console.log(value);&#125;asyncPrint(&#39;hello world&#39;, 50);</code></pre><p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><pre><code class="javascript">async function timeout(ms) &#123;  await new Promise((resolve) =&gt; &#123;    setTimeout(resolve, ms);  &#125;);&#125;async function asyncPrint(value, ms) &#123;  await timeout(ms);  console.log(value);&#125;asyncPrint(&#39;hello world&#39;, 50);</code></pre><p>async 函数有多种使用形式。</p><pre><code class="javascript">// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123;  constructor() &#123;    this.cachePromise = caches.open(&#39;avatars&#39;);  &#125;  async getAvatar(name) &#123;    const cache = await this.cachePromise;    return cache.match(`/avatars/$&#123;name&#125;.jpg`);  &#125;&#125;const storage = new Storage();storage.getAvatar(&#39;jake&#39;).then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;;</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><pre><code class="javascript">async function f() &#123;  return &#39;hello world&#39;;&#125;f().then(v =&gt; console.log(v))// &quot;hello world&quot;</code></pre><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><pre><code class="javascript">async function f() &#123;  throw new Error(&#39;出错了&#39;);&#125;f().then(  v =&gt; console.log(&#39;resolve&#39;, v),  e =&gt; console.log(&#39;reject&#39;, e))//reject Error: 出错了</code></pre><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>下面是一个例子。</p><pre><code class="javascript">async function getTitle(url) &#123;  let response = await fetch(url);  let html = await response.text();  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log)// &quot;ECMAScript 2017 Language Specification&quot;</code></pre><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><pre><code class="javascript">async function f() &#123;  // 等同于  // return 123;  return await 123;&#125;f().then(v =&gt; console.log(v))// 123</code></pre><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><pre><code class="javascript">class Sleep &#123;  constructor(timeout) &#123;    this.timeout = timeout;  &#125;  then(resolve, reject) &#123;    const startTime = Date.now();    setTimeout(      () =&gt; resolve(Date.now() - startTime),      this.timeout    );  &#125;&#125;(async () =&gt; &#123;  const sleepTime = await new Sleep(1000);  console.log(sleepTime);&#125;)();// 1000</code></pre><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p><p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p><pre><code class="javascript">function sleep(interval) &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(resolve, interval);  &#125;)&#125;// 用法async function one2FiveInAsync() &#123;  for(let i = 1; i &lt;= 5; i++) &#123;    console.log(i);    await sleep(1000);  &#125;&#125;one2FiveInAsync();</code></pre><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><pre><code class="javascript">async function f() &#123;  await Promise.reject(&#39;出错了&#39;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了</code></pre><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><pre><code class="javascript">async function f() &#123;  await Promise.reject(&#39;出错了&#39;);  await Promise.resolve(&#39;hello world&#39;); // 不会执行&#125;</code></pre><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><pre><code class="javascript">async function f() &#123;  try &#123;    await Promise.reject(&#39;出错了&#39;);  &#125; catch(e) &#123;  &#125;  return await Promise.resolve(&#39;hello world&#39;);&#125;f().then(v =&gt; console.log(v))// hello world</code></pre><p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><pre><code class="javascript">async function f() &#123;  await Promise.reject(&#39;出错了&#39;)    .catch(e =&gt; console.log(e));  return await Promise.resolve(&#39;hello world&#39;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world</code></pre><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><pre><code class="javascript">async function f() &#123;  await new Promise(function (resolve, reject) &#123;    throw new Error(&#39;出错了&#39;);  &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了</code></pre><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><pre><code class="javascript">async function f() &#123;  try &#123;    await new Promise(function (resolve, reject) &#123;      throw new Error(&#39;出错了&#39;);    &#125;);  &#125; catch(e) &#123;  &#125;  return await(&#39;hello world&#39;);&#125;</code></pre><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><pre><code class="javascript">async function main() &#123;  try &#123;    const val1 = await firstStep();    const val2 = await secondStep(val1);    const val3 = await thirdStep(val1, val2);    console.log(&#39;Final: &#39;, val3);  &#125;  catch (err) &#123;    console.error(err);  &#125;&#125;</code></pre><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><pre><code class="javascript">const superagent = require(&#39;superagent&#39;);const NUM_RETRIES = 3;async function test() &#123;  let i;  for (i = 0; i &lt; NUM_RETRIES; ++i) &#123;    try &#123;      await superagent.get(&#39;http://google.com/this-throws-an-error&#39;);      break;    &#125; catch(err) &#123;&#125;  &#125;  console.log(i); // 3&#125;test();</code></pre><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><pre><code class="javascript">async function myFunction() &#123;  try &#123;    await somethingThatReturnsAPromise();  &#125; catch (err) &#123;    console.log(err);  &#125;&#125;// 另一种写法async function myFunction() &#123;  await somethingThatReturnsAPromise()  .catch(function (err) &#123;    console.log(err);  &#125;);&#125;</code></pre><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><pre><code class="javascript">let foo = await getFoo();let bar = await getBar();</code></pre><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><pre><code class="javascript">// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;</code></pre><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><pre><code class="javascript">async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  // 报错  docs.forEach(function (doc) &#123;    await db.post(doc);  &#125;);&#125;</code></pre><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><pre><code class="javascript">function dbFuc(db) &#123; //这里不需要 async  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  // 可能得到错误结果  docs.forEach(async function (doc) &#123;    await db.post(doc);  &#125;);&#125;</code></pre><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><pre><code class="javascript">async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  for (let doc of docs) &#123;    await db.post(doc);  &#125;&#125;</code></pre><p>另一种方法是使用数组的<code>reduce()</code>方法。</p><pre><code class="javascript">async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  await docs.reduce(async (_, doc) =&gt; &#123;    await _;    await db.post(doc);  &#125;, undefined);&#125;</code></pre><p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p><p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p><p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p><pre><code class="javascript">async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  let promises = docs.map((doc) =&gt; db.post(doc));  let results = await Promise.all(promises);  console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  let promises = docs.map((doc) =&gt; db.post(doc));  let results = [];  for (let promise of promises) &#123;    results.push(await promise);  &#125;  console.log(results);&#125;</code></pre><p>第四点，async 函数可以保留运行堆栈。</p><pre><code class="javascript">const a = () =&gt; &#123;  b().then(() =&gt; c());&#125;;</code></pre><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><pre><code class="javascript">const a = async () =&gt; &#123;  await b();  c();&#125;;</code></pre><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><pre><code class="javascript">async function fn(args) &#123;  // ...&#125;// 等同于function fn(args) &#123;  return spawn(function* () &#123;    // ...  &#125;);&#125;</code></pre><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><pre><code class="javascript">function spawn(genF) &#123;  return new Promise(function(resolve, reject) &#123;    const gen = genF();    function step(nextF) &#123;      let next;      try &#123;        next = nextF();      &#125; catch(e) &#123;        return reject(e);      &#125;      if(next.done) &#123;        return resolve(next.value);      &#125;      Promise.resolve(next.value).then(function(v) &#123;        step(function() &#123; return gen.next(v); &#125;);      &#125;, function(e) &#123;        step(function() &#123; return gen.throw(e); &#125;);      &#125;);    &#125;    step(function() &#123; return gen.next(undefined); &#125;);  &#125;);&#125;</code></pre><h2 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><pre><code class="javascript">function chainAnimationsPromise(elem, animations) &#123;  // 变量ret用来保存上一个动画的返回值  let ret = null;  // 新建一个空的Promise  let p = Promise.resolve();  // 使用then方法，添加所有动画  for(let anim of animations) &#123;    p = p.then(function(val) &#123;      ret = val;      return anim(elem);    &#125;);  &#125;  // 返回一个部署了错误捕捉机制的Promise  return p.catch(function(e) &#123;    /* 忽略错误，继续执行 */  &#125;).then(function() &#123;    return ret;  &#125;);&#125;</code></pre><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><pre><code class="javascript">function chainAnimationsGenerator(elem, animations) &#123;  return spawn(function*() &#123;    let ret = null;    try &#123;      for(let anim of animations) &#123;        ret = yield anim(elem);      &#125;    &#125; catch(e) &#123;      /* 忽略错误，继续执行 */    &#125;    return ret;  &#125;);&#125;</code></pre><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p><p>最后是 async 函数的写法。</p><pre><code class="javascript">async function chainAnimationsAsync(elem, animations) &#123;  let ret = null;  try &#123;    for(let anim of animations) &#123;      ret = await anim(elem);    &#125;  &#125; catch(e) &#123;    /* 忽略错误，继续执行 */  &#125;  return ret;&#125;</code></pre><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><pre><code class="javascript">function logInOrder(urls) &#123;  // 远程读取所有URL  const textPromises = urls.map(url =&gt; &#123;    return fetch(url).then(response =&gt; response.text());  &#125;);  // 按次序输出  textPromises.reduce((chain, textPromise) =&gt; &#123;    return chain.then(() =&gt; textPromise)      .then(text =&gt; console.log(text));  &#125;, Promise.resolve());&#125;</code></pre><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><pre><code class="javascript">async function logInOrder(urls) &#123;  for (const url of urls) &#123;    const response = await fetch(url);    console.log(await response.text());  &#125;&#125;</code></pre><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><pre><code class="javascript">async function logInOrder(urls) &#123;  // 并发读取远程URL  const textPromises = urls.map(async url =&gt; &#123;    const response = await fetch(url);    return response.text();  &#125;);  // 按次序输出  for (const textPromise of textPromises) &#123;    console.log(await textPromise);  &#125;&#125;</code></pre><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><p>早期的语法规定是，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p><pre><code class="javascript">// 报错const data = await fetch(&#39;https://api.example.com&#39;);</code></pre><p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p><p>从 <a href="https://github.com/tc39/proposal-top-level-await">ES2022</a> 开始，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。它的主要目的是使用<code>await</code>解决模块异步加载的问题。</p><pre><code class="javascript">// awaiting.jslet output;async function main() &#123;  const dynamic = await import(someMission);  const data = await fetch(url);  output = someProcess(dynamic.default, data);&#125;main();export &#123; output &#125;;</code></pre><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p><p>下面是加载这个模块的写法。</p><pre><code class="javascript">// usage.jsimport &#123; output &#125; from &quot;./awaiting.js&quot;;function outputPlusValue(value) &#123; return output + value &#125;console.log(outputPlusValue(100));setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);</code></pre><p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p><p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p><pre><code class="javascript">// awaiting.jslet output;export default (async function main() &#123;  const dynamic = await import(someMission);  const data = await fetch(url);  output = someProcess(dynamic.default, data);&#125;)();export &#123; output &#125;;</code></pre><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p><p>下面是加载这个模块的新的写法。</p><pre><code class="javascript">// usage.jsimport promise, &#123; output &#125; from &quot;./awaiting.js&quot;;function outputPlusValue(value) &#123; return output + value &#125;promise.then(() =&gt; &#123;  console.log(outputPlusValue(100));  setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);&#125;);</code></pre><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p><p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p><p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p><pre><code class="javascript">// awaiting.jsconst dynamic = import(someMission);const data = fetch(url);export const output = someProcess((await dynamic).default, await data);</code></pre><p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p><p>加载这个模块的写法如下。</p><pre><code class="javascript">// usage.jsimport &#123; output &#125; from &quot;./awaiting.js&quot;;function outputPlusValue(value) &#123; return output + value &#125;console.log(outputPlusValue(100));setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);</code></pre><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p><p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p><p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p><p>下面是顶层<code>await</code>的一些使用场景。</p><pre><code class="javascript">// import() 方法加载const strings = await import(`/i18n/$&#123;navigator.language&#125;`);// 数据库操作const connection = await dbConnector();// 依赖回滚let jQuery;try &#123;  jQuery = await import(&#39;https://cdn-a.com/jQuery&#39;);&#125; catch &#123;  jQuery = await import(&#39;https://cdn-b.com/jQuery&#39;);&#125;</code></pre><p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p><pre><code class="javascript">// x.jsconsole.log(&quot;X1&quot;);await new Promise(r =&gt; setTimeout(r, 1000));console.log(&quot;X2&quot;);// y.jsconsole.log(&quot;Y&quot;);// z.jsimport &quot;./x.js&quot;;import &quot;./y.js&quot;;console.log(&quot;Z&quot;);</code></pre><p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p><p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-编程风格</title>
      <link href="/2022/09/05/10%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
      <url>/2022/09/05/10%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/style#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</a></li><li><a href="https://es6.ruanyifeng.com/#docs/style#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="https://es6.ruanyifeng.com/#docs/style#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/style#%E5%AF%B9%E8%B1%A1">对象</a></li><li><a href="https://es6.ruanyifeng.com/#docs/style#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="https://es6.ruanyifeng.com/#docs/style#%E5%87%BD%E6%95%B0">函数</a></li><li>[Map 结构](<a href="https://es6.ruanyifeng.com/#docs/style#Map">https://es6.ruanyifeng.com/#docs/style#Map</a> 结构)</li><li><a href="https://es6.ruanyifeng.com/#docs/style#Class">Class</a></li><li><a href="https://es6.ruanyifeng.com/#docs/style#%E6%A8%A1%E5%9D%97">模块</a></li><li>[ESLint 的使用](<a href="https://es6.ruanyifeng.com/#docs/style#ESLint">https://es6.ruanyifeng.com/#docs/style#ESLint</a> 的使用)</li></ol><p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p><p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href="https://github.com/airbnb/javascript">Airbnb</a> 公司的 JavaScript 风格规范。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p><strong>（1）let 取代 var</strong></p><p>ES6 提出了两个新的声明变量的命令：<code>let</code>和<code>const</code>。其中，<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。</p><pre><code class="javascript">&#39;use strict&#39;;if (true) &#123;  let x = &#39;hello&#39;;&#125;for (let i = 0; i &lt; 10; i++) &#123;  console.log(i);&#125;</code></pre><p>上面代码如果用<code>var</code>替代<code>let</code>，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p><p><code>var</code>命令存在变量提升效用，<code>let</code>命令没有这个问题。</p><pre><code class="javascript">&#39;use strict&#39;;if (true) &#123;  console.log(x); // ReferenceError  let x = &#39;hello&#39;;&#125;</code></pre><p>上面代码如果使用<code>var</code>替代<code>let</code>，<code>console.log</code>那一行就不会报错，而是会输出<code>undefined</code>，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p><p>所以，建议不再使用<code>var</code>命令，而是使用<code>let</code>命令取代。</p><p><strong>（2）全局常量和线程安全</strong></p><p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p><p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</p><pre><code class="javascript">// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3];</code></pre><p><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p><p>所有的函数都应该设置为常量。</p><p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p><pre><code class="javascript">// badconst a = &quot;foobar&quot;;const b = &#39;foo&#39; + a + &#39;bar&#39;;// acceptableconst c = `foobar`;// goodconst a = &#39;foobar&#39;;const b = `foo$&#123;a&#125;bar`;</code></pre><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p><pre><code class="javascript">const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr;</code></pre><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><pre><code class="javascript">// badfunction getFullName(user) &#123;  const firstName = user.firstName;  const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123;  const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125;</code></pre><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><pre><code class="javascript">// badfunction processInput(input) &#123;  return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123;  return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input);</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p><pre><code class="javascript">// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123;  k1: v1,  k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123;  k1: v1,  k2: v2,&#125;;</code></pre><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p><pre><code class="javascript">// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3;</code></pre><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p><pre><code class="javascript">// badconst obj = &#123;  id: 5,  name: &#39;San Francisco&#39;,&#125;;obj[getKey(&#39;enabled&#39;)] = true;// goodconst obj = &#123;  id: 5,  name: &#39;San Francisco&#39;,  [getKey(&#39;enabled&#39;)]: true,&#125;;</code></pre><p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p><p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p><pre><code class="javascript">var ref = &#39;some value&#39;;// badconst atom = &#123;  ref: ref,  value: 1,  addValue: function (value) &#123;    return atom.value + value;  &#125;,&#125;;// goodconst atom = &#123;  ref,  value: 1,  addValue(value) &#123;    return atom.value + value;  &#125;,&#125;;</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用扩展运算符（…）拷贝数组。</p><pre><code class="javascript">// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123;  itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items];</code></pre><p>使用 Array.from 方法，将类似数组的对象转为数组。</p><pre><code class="javascript">const foo = document.querySelectorAll(&#39;.foo&#39;);const nodes = Array.from(foo);</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>立即执行函数可以写成箭头函数的形式。</p><pre><code class="javascript">(() =&gt; &#123;  console.log(&#39;Welcome to the Internet.&#39;);&#125;)();</code></pre><p>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p><pre><code class="javascript">// bad[1, 2, 3].map(function (x) &#123;  return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123;  return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x);</code></pre><p>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</p><pre><code class="javascript">// badconst self = this;const boundMethod = function(...params) &#123;  return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params);</code></pre><p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p><pre><code class="javascript">// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125;</code></pre><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p><pre><code class="javascript">// badfunction concatenateAll() &#123;  const args = Array.prototype.slice.call(arguments);  return args.join(&#39;&#39;);&#125;// goodfunction concatenateAll(...args) &#123;  return args.join(&#39;&#39;);&#125;</code></pre><p>使用默认值语法设置函数参数的默认值。</p><pre><code class="javascript">// badfunction handleThings(opts) &#123;  opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123;  // ...&#125;</code></pre><h2 id="Map-结构"><a href="#Map-结构" class="headerlink" title="Map 结构"></a>Map 结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p><pre><code class="javascript">let map = new Map(arr);for (let key of map.keys()) &#123;  console.log(key);&#125;for (let value of map.values()) &#123;  console.log(value);&#125;for (let item of map.entries()) &#123;  console.log(item[0], item[1]);&#125;</code></pre><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</p><pre><code class="javascript">// badfunction Queue(contents = []) &#123;  this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123;  const value = this._queue[0];  this._queue.splice(0, 1);  return value;&#125;// goodclass Queue &#123;  constructor(contents = []) &#123;    this._queue = [...contents];  &#125;  pop() &#123;    const value = this._queue[0];    this._queue.splice(0, 1);    return value;  &#125;&#125;</code></pre><p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p><pre><code class="javascript">// badconst inherits = require(&#39;inherits&#39;);function PeekableQueue(contents) &#123;  Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123;  return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123;  peek() &#123;    return this._queue[0];  &#125;&#125;</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。</p><p>首先，使用<code>import</code>取代<code>require()</code>。</p><pre><code class="javascript">// CommonJS 的写法const moduleA = require(&#39;moduleA&#39;);const func1 = moduleA.func1;const func2 = moduleA.func2;// ES6 的写法import &#123; func1, func2 &#125; from &#39;moduleA&#39;;</code></pre><p>其次，使用<code>export</code>取代<code>module.exports</code>。</p><pre><code class="javascript">// commonJS 的写法var React = require(&#39;react&#39;);var Breadcrumbs = React.createClass(&#123;  render() &#123;    return &lt;nav /&gt;;  &#125;&#125;);module.exports = Breadcrumbs;// ES6 的写法import React from &#39;react&#39;;class Breadcrumbs extends React.Component &#123;  render() &#123;    return &lt;nav /&gt;;  &#125;&#125;;export default Breadcrumbs;</code></pre><p>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，除非其中某个输出值特别重要，否则建议不要使用<code>export default</code>，即多个输出值如果是平等关系，<code>export default</code>与普通的<code>export</code>就不要同时使用。</p><p>如果模块默认输出一个函数，函数名的首字母应该小写，表示这是一个工具方法。</p><pre><code class="javascript">function makeStyleGuide() &#123;&#125;export default makeStyleGuide;</code></pre><p>如果模块默认输出一个对象，对象名的首字母应该大写，表示这是一个配置值对象。</p><pre><code class="javascript">const StyleGuide = &#123;  es6: &#123;  &#125;&#125;;export default StyleGuide;</code></pre><h2 id="ESLint-的使用"><a href="#ESLint-的使用" class="headerlink" title="ESLint 的使用"></a>ESLint 的使用</h2><p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p><p>首先，在项目的根目录安装 ESLint。</p><pre><code class="bash">$ npm install --save-dev eslint</code></pre><p>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。</p><pre><code class="bash">$ npm install --save-dev eslint-config-airbnb$ npm install --save-dev eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react</code></pre><p>最后，在项目的根目录下新建一个<code>.eslintrc</code>文件，配置 ESLint。</p><pre><code class="javascript">&#123;  &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125;</code></pre><p>现在就可以检查，当前项目的代码是否符合预设的规则。</p><p><code>index.js</code>文件的代码如下。</p><pre><code class="javascript">var unused = &#39;I have no purpose!&#39;;function greet() &#123;    var message = &#39;Hello, World!&#39;;    console.log(message);&#125;greet();</code></pre><p>使用 ESLint 检查这个文件，就会报出错误。</p><pre><code class="bash">$ npx eslint index.jsindex.js  1:1  error  Unexpected var, use let or const instead          no-var  1:5  error  unused is defined but never used                 no-unused-vars  4:5  error  Expected indentation of 2 characters but found 4  indent  4:5  error  Unexpected var, use let or const instead          no-var  5:5  error  Expected indentation of 2 characters but found 4  indent✖ 5 problems (5 errors, 0 warnings)</code></pre><p>上面代码说明，原文件有五个错误，其中两个是不应该使用<code>var</code>命令，而要使用<code>let</code>或<code>const</code>；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Class 的继承</title>
      <link href="/2022/09/05/9class%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/09/05/9class%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF">私有属性和私有方法的继承</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class-extends#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF">静态属性和静态方法的继承</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class-extends#Object.getPrototypeOf()">Object.getPrototypeOf()</a></li><li>[super 关键字](<a href="https://es6.ruanyifeng.com/#docs/class-extends#super">https://es6.ruanyifeng.com/#docs/class-extends#super</a> 关键字)</li><li>[类的 prototype 属性和__proto__属性](<a href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%B1%BB%E7%9A%84">https://es6.ruanyifeng.com/#docs/class-extends#类的</a> prototype 属性和__proto__属性)</li><li><a href="https://es6.ruanyifeng.com/#docs/class-extends#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF">原生构造函数的继承</a></li><li>[Mixin 模式的实现](<a href="https://es6.ruanyifeng.com/#docs/class-extends#Mixin">https://es6.ruanyifeng.com/#docs/class-extends#Mixin</a> 模式的实现)</li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。</p><pre><code class="javascript">class Point &#123;&#125;class ColorPoint extends Point &#123;&#125;</code></pre><p>上面示例中，<code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。</p><p>下面，我们在<code>ColorPoint</code>内部加上代码。</p><pre><code class="javascript">class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123;  constructor(x, y, color) &#123;    super(x, y); // 调用父类的constructor(x, y)    this.color = color;  &#125;  toString() &#123;    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()  &#125;&#125;</code></pre><p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象。</p><p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p><pre><code class="javascript">class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123;  constructor() &#123;  &#125;&#125;let cp = new ColorPoint(); // ReferenceError</code></pre><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super()</code>，导致新建实例时报错。</p><p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p><p>注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。</p><pre><code class="javascript">class Foo &#123;  constructor() &#123;    console.log(1);  &#125;&#125;class Bar extends Foo &#123;  constructor() &#123;    super();    console.log(2);  &#125;&#125;const bar = new Bar();// 1// 2</code></pre><p>上面示例中，子类 Bar 新建实例时，会输出1和2。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p><pre><code class="javascript">class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;&#125;class ColorPoint extends Point &#123;  constructor(x, y, color) &#123;    this.color = color; // ReferenceError    super(x, y);    this.color = color; // 正确  &#125;&#125;</code></pre><p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。</p><p>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。</p><pre><code class="javascript">class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123;  constructor(...args) &#123;    super(...args);  &#125;&#125;</code></pre><p>有了子类的定义，就可以生成子类的实例了。</p><pre><code class="javascript">let cp = new ColorPoint(25, 8, &#39;green&#39;);cp instanceof ColorPoint // truecp instanceof Point // true</code></pre><p>上面示例中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p><h2 id="私有属性和私有方法的继承"><a href="#私有属性和私有方法的继承" class="headerlink" title="私有属性和私有方法的继承"></a>私有属性和私有方法的继承</h2><p>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。</p><p>子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。</p><pre><code class="javascript">class Foo &#123;  #p = 1;  #m() &#123;    console.log(&#39;hello&#39;);  &#125;&#125;class Bar extends Foo &#123;  constructor() &#123;    super();    console.log(this.#p); // 报错    this.#m(); // 报错  &#125;&#125;</code></pre><p>上面示例中，子类 Bar 调用父类 Foo 的私有属性或私有方法，都会报错。</p><p>如果父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性。</p><pre><code class="javascript">class Foo &#123;  #p = 1;  getP() &#123;    return this.#p;  &#125;&#125;class Bar extends Foo &#123;  constructor() &#123;    super();    console.log(this.getP()); // 1  &#125;&#125;</code></pre><p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，通过该方法，子类就可以读到父类的私有属性。</p><h2 id="静态属性和静态方法的继承"><a href="#静态属性和静态方法的继承" class="headerlink" title="静态属性和静态方法的继承"></a>静态属性和静态方法的继承</h2><p>父类的静态属性和静态方法，也会被子类继承。</p><pre><code class="javascript">class A &#123;  static hello() &#123;    console.log(&#39;hello world&#39;);  &#125;&#125;class B extends A &#123;&#125;B.hello()  // hello world</code></pre><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p><p>注意，静态属性是通过软拷贝实现继承的。</p><pre><code class="javascript">class A &#123; static foo = 100; &#125;class B extends A &#123;  constructor() &#123;    super();    B.foo--;  &#125;&#125;const b = new B();B.foo // 99A.foo // 100</code></pre><p>上面示例中，<code>foo</code>是 A 类的静态属性，B 类继承了 A 类，因此也继承了这个属性。但是，在 B 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code>，原因就是 B 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。</p><p>但是，由于这种拷贝是浅拷贝，如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。</p><pre><code class="javascript">class A &#123;  static foo = &#123; n: 100 &#125;;&#125;class B extends A &#123;  constructor() &#123;    super();    B.foo.n--;  &#125;&#125;const b = new B();B.foo.n // 99A.foo.n // 99</code></pre><p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>A</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf()</code>方法可以用来从子类上获取父类。</p><pre><code class="javascript">class Point &#123; /*...*/ &#125;class ColorPoint extends Point &#123; /*...*/ &#125;Object.getPrototypeOf(ColorPoint) === Point// true</code></pre><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><pre><code class="javascript">class A &#123;&#125;class B extends A &#123;  constructor() &#123;    super();  &#125;&#125;</code></pre><p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><pre><code class="javascript">class A &#123;  constructor() &#123;    console.log(new.target.name);  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();  &#125;&#125;new A() // Anew B() // B</code></pre><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><pre><code class="javascript">class A &#123;&#125;class B extends A &#123;  m() &#123;    super(); // 报错  &#125;&#125;</code></pre><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><pre><code class="javascript">class A &#123;  p() &#123;    return 2;  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    console.log(super.p()); // 2  &#125;&#125;let b = new B();</code></pre><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p><p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p><pre><code class="javascript">class A &#123;  constructor() &#123;    this.p = 2;  &#125;&#125;class B extends A &#123;  get m() &#123;    return super.p;  &#125;&#125;let b = new B();b.m // undefined</code></pre><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><pre><code class="javascript">class A &#123;&#125;A.prototype.x = 2;class B extends A &#123;  constructor() &#123;    super();    console.log(super.x) // 2  &#125;&#125;let b = new B();</code></pre><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><pre><code class="javascript">class A &#123;  constructor() &#123;    this.x = 1;  &#125;  print() &#123;    console.log(this.x);  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    this.x = 2;  &#125;  m() &#123;    super.print();  &#125;&#125;let b = new B();b.m() // 2</code></pre><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><pre><code class="javascript">class A &#123;  constructor() &#123;    this.x = 1;  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    this.x = 2;    super.x = 3;    console.log(super.x); // undefined    console.log(this.x); // 3  &#125;&#125;let b = new B();</code></pre><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><pre><code class="javascript">class Parent &#123;  static myMethod(msg) &#123;    console.log(&#39;static&#39;, msg);  &#125;  myMethod(msg) &#123;    console.log(&#39;instance&#39;, msg);  &#125;&#125;class Child extends Parent &#123;  static myMethod(msg) &#123;    super.myMethod(msg);  &#125;  myMethod(msg) &#123;    super.myMethod(msg);  &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2</code></pre><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><pre><code class="javascript">class A &#123;  constructor() &#123;    this.x = 1;  &#125;  static print() &#123;    console.log(this.x);  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    this.x = 2;  &#125;  static m() &#123;    super.print();  &#125;&#125;B.x = 3;B.m() // 3</code></pre><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><pre><code class="javascript">class A &#123;&#125;class B extends A &#123;  constructor() &#123;    super();    console.log(super); // 报错  &#125;&#125;</code></pre><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p><pre><code class="javascript">class A &#123;&#125;class B extends A &#123;  constructor() &#123;    super();    console.log(super.valueOf() instanceof B); // true  &#125;&#125;let b = new B();</code></pre><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p><pre><code class="javascript">var obj = &#123;  toString() &#123;    return &quot;MyObject: &quot; + super.toString();  &#125;&#125;;obj.toString(); // MyObject: [object Object]</code></pre><h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><pre><code class="javascript">class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true</code></pre><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><pre><code class="javascript">class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B();</code></pre><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p><pre><code class="javascript">Object.setPrototypeOf = function (obj, proto) &#123;  obj.__proto__ = proto;  return obj;&#125;</code></pre><p>因此，就得到了上面的结果。</p><pre><code class="javascript">Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A;</code></pre><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p><pre><code class="javascript">B.prototype = Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype;</code></pre><p><code>extends</code>关键字后面可以跟多种类型的值。</p><pre><code class="javascript">class B extends A &#123;&#125;</code></pre><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p><pre><code class="javascript">class A extends Object &#123;&#125;A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true</code></pre><p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p><p>第二种情况，不存在任何继承。</p><pre><code class="javascript">class A &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // true</code></pre><p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p><h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><pre><code class="javascript">var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, &#39;red&#39;);p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true</code></pre><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><pre><code class="javascript">p2.__proto__.__proto__.printName = function () &#123;  console.log(&#39;Ha&#39;);&#125;;p1.printName() // &quot;Ha&quot;</code></pre><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p><h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><pre><code class="javascript">function MyArray() &#123;  Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123;  constructor: &#123;    value: MyArray,    writable: true,    configurable: true,    enumerable: true  &#125;&#125;);</code></pre><p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><pre><code class="javascript">var colors = new MyArray();colors[0] = &quot;red&quot;;colors.length  // 0colors.length = 0;colors[0]  // &quot;red&quot;</code></pre><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><pre><code class="javascript">var e = &#123;&#125;;Object.getOwnPropertyNames(Error.call(e))// [ &#39;stack&#39; ]Object.getOwnPropertyNames(e)// []</code></pre><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p><pre><code class="javascript">class MyArray extends Array &#123;  constructor(...args) &#123;    super(...args);  &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined</code></pre><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><pre><code class="javascript">class VersionedArray extends Array &#123;  constructor() &#123;    super();    this.history = [[]];  &#125;  commit() &#123;    this.history.push(this.slice());  &#125;  revert() &#123;    this.splice(0, this.length, ...this.history[this.history.length - 1]);  &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.history // [[], [1, 2]]x.revert();x // [1, 2]</code></pre><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p><pre><code class="javascript">class ExtendableError extends Error &#123;  constructor(message) &#123;    super();    this.message = message;    this.stack = (new Error()).stack;    this.name = this.constructor.name;  &#125;&#125;class MyError extends ExtendableError &#123;  constructor(m) &#123;    super(m);  &#125;&#125;var myerror = new MyError(&#39;ll&#39;);myerror.message // &quot;ll&quot;myerror instanceof Error // truemyerror.name // &quot;MyError&quot;myerror.stack// Error//     at MyError.ExtendableError//     ...</code></pre><p>注意，继承<code>Object</code>的子类，有一个<a href="https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p><pre><code class="javascript">class NewObj extends Object&#123;  constructor()&#123;    super(...arguments);  &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);o.attr === true  // false</code></pre><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p><h2 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><pre><code class="javascript">const a = &#123;  a: &#39;a&#39;&#125;;const b = &#123;  b: &#39;b&#39;&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: &#39;a&#39;, b: &#39;b&#39;&#125;</code></pre><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p><pre><code class="javascript">function mix(...mixins) &#123;  class Mix &#123;    constructor() &#123;      for (let mixin of mixins) &#123;        copyProperties(this, new mixin()); // 拷贝实例属性      &#125;    &#125;  &#125;  for (let mixin of mixins) &#123;    copyProperties(Mix, mixin); // 拷贝静态属性    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性  &#125;  return Mix;&#125;function copyProperties(target, source) &#123;  for (let key of Reflect.ownKeys(source)) &#123;    if ( key !== &#39;constructor&#39;      &amp;&amp; key !== &#39;prototype&#39;      &amp;&amp; key !== &#39;name&#39;    ) &#123;      let desc = Object.getOwnPropertyDescriptor(source, key);      Object.defineProperty(target, key, desc);    &#125;  &#125;&#125;</code></pre><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><pre><code class="javascript">class DistributedEdit extends mix(Loggable, Serializable) &#123;  // ...&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Set 和 Map 数据结构</title>
      <link href="/2022/09/05/8%E6%96%B0%E5%A2%9ESet%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/05/8%E6%96%B0%E5%A2%9ESet%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/set-map#Set">Set</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakSet">WeakSet</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#Map">Map</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakMap">WeakMap</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#WeakRef">WeakRef</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#FinalizationRegistry">FinalizationRegistry</a></li></ol><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><pre><code class="javascript">const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123;  console.log(i);&#125;// 2 3 5 4</code></pre><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><pre><code class="javascript">// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll(&#39;div&#39;));set.size // 56// 类似于const set = new Set();document .querySelectorAll(&#39;div&#39;) .forEach(div =&gt; set.add(div));set.size // 56</code></pre><p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码也展示了一种去除数组重复成员的方法。</p><pre><code class="javascript">// 去除数组的重复成员[...new Set(array)]</code></pre><p>上面的方法也可以用于，去除字符串里面的重复字符。</p><pre><code class="javascript">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)// &quot;abc&quot;</code></pre><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><pre><code class="javascript">let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125;</code></pre><p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p><p>另外，两个对象总是不相等的。</p><pre><code class="javascript">let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2</code></pre><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法的实例如下。</p><pre><code class="javascript">s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false</code></pre><p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p><pre><code class="javascript">// 对象的写法const properties = &#123;  &#39;width&#39;: 1,  &#39;height&#39;: 1&#125;;if (properties[someName]) &#123;  // do something&#125;// Set的写法const properties = new Set();properties.add(&#39;width&#39;);properties.add(&#39;height&#39;);if (properties.has(someName)) &#123;  // do something&#125;</code></pre><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><pre><code class="javascript">const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);</code></pre><p>这就提供了去除数组重复成员的另一种方法。</p><pre><code class="javascript">function dedupe(array) &#123;  return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3]</code></pre><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);for (let item of set.keys()) &#123;  console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123;  console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123;  console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]</code></pre><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><pre><code class="javascript">Set.prototype[Symbol.iterator] === Set.prototype.values// true</code></pre><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p><pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);for (let x of set) &#123;  console.log(x);&#125;// red// green// blue</code></pre><p><strong>（2）<code>forEach()</code></strong></p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><pre><code class="javascript">let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))// 1 : 1// 4 : 4// 9 : 9</code></pre><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p><strong>（3）遍历的应用</strong></p><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p><pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);let arr = [...set];// [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]</code></pre><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><pre><code class="javascript">let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]</code></pre><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p><pre><code class="javascript">let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125;</code></pre><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><pre><code class="javascript">let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125;</code></pre><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p><pre><code class="javascript">// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6</code></pre><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><pre><code class="javascript">const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set</code></pre><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p><pre><code class="javascript">const ws = new WeakSet();</code></pre><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p><pre><code class="javascript">const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet &#123;[1, 2], [3, 4]&#125;</code></pre><p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p><p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p><pre><code class="javascript">const b = [3, 4];const ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…)</code></pre><p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>下面是一个例子。</p><pre><code class="javascript">const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo);    // falsews.delete(window);ws.has(window);    // false</code></pre><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><pre><code class="javascript">ws.size // undefinedws.forEach // undefinedws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)// TypeError: undefined is not a function</code></pre><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><p>下面是 WeakSet 的另一个例子。</p><pre><code class="javascript">const foos = new WeakSet()class Foo &#123;  constructor() &#123;    foos.add(this)  &#125;  method () &#123;    if (!foos.has(this)) &#123;      throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);    &#125;  &#125;&#125;</code></pre><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><pre><code class="javascript">const data = &#123;&#125;;const element = document.getElementById(&#39;myDiv&#39;);data[element] = &#39;metadata&#39;;data[&#39;[object HTMLDivElement]&#39;] // &quot;metadata&quot;</code></pre><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><pre><code class="javascript">const m = new Map();const o = &#123;p: &#39;Hello World&#39;&#125;;m.set(o, &#39;content&#39;)m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false</code></pre><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><pre><code class="javascript">const map = new Map([  [&#39;name&#39;, &#39;张三&#39;],  [&#39;title&#39;, &#39;Author&#39;]]);map.size // 2map.has(&#39;name&#39;) // truemap.get(&#39;name&#39;) // &quot;张三&quot;map.has(&#39;title&#39;) // truemap.get(&#39;title&#39;) // &quot;Author&quot;</code></pre><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><pre><code class="javascript">const items = [  [&#39;name&#39;, &#39;张三&#39;],  [&#39;title&#39;, &#39;Author&#39;]];const map = new Map();items.forEach(  ([key, value]) =&gt; map.set(key, value));</code></pre><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><pre><code class="javascript">const set = new Set([  [&#39;foo&#39;, 1],  [&#39;bar&#39;, 2]]);const m1 = new Map(set);m1.get(&#39;foo&#39;) // 1const m2 = new Map([[&#39;baz&#39;, 3]]);const m3 = new Map(m2);m3.get(&#39;baz&#39;) // 3</code></pre><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><pre><code class="javascript">const map = new Map();map.set(1, &#39;aaa&#39;).set(1, &#39;bbb&#39;);map.get(1) // &quot;bbb&quot;</code></pre><p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回<code>undefined</code>。</p><pre><code class="javascript">new Map().get(&#39;asfddfsasadf&#39;)// undefined</code></pre><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><pre><code class="javascript">const map = new Map();map.set([&#39;a&#39;], 555);map.get([&#39;a&#39;]) // undefined</code></pre><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p><pre><code class="javascript">const map = new Map();const k1 = [&#39;a&#39;];const k2 = [&#39;a&#39;];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222</code></pre><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p><pre><code class="javascript">let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set(&#39;true&#39;, 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123</code></pre><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p><p><strong>（1）size 属性</strong></p><p><code>size</code>属性返回 Map 结构的成员总数。</p><pre><code class="javascript">const map = new Map();map.set(&#39;foo&#39;, true);map.set(&#39;bar&#39;, false);map.size // 2</code></pre><p><strong>（2）Map.prototype.set(key, value)</strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><pre><code class="javascript">const m = new Map();m.set(&#39;edition&#39;, 6)        // 键是字符串m.set(262, &#39;standard&#39;)     // 键是数值m.set(undefined, &#39;nah&#39;)    // 键是 undefined</code></pre><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><pre><code class="javascript">let map = new Map()  .set(1, &#39;a&#39;)  .set(2, &#39;b&#39;)  .set(3, &#39;c&#39;);</code></pre><p><strong>（3）Map.prototype.get(key)</strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><pre><code class="javascript">const m = new Map();const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;m.set(hello, &#39;Hello ES6!&#39;) // 键是函数m.get(hello)  // Hello ES6!</code></pre><p><strong>（4）Map.prototype.has(key)</strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><pre><code class="javascript">const m = new Map();m.set(&#39;edition&#39;, 6);m.set(262, &#39;standard&#39;);m.set(undefined, &#39;nah&#39;);m.has(&#39;edition&#39;)     // truem.has(&#39;years&#39;)       // falsem.has(262)           // truem.has(undefined)     // true</code></pre><p><strong>（5）Map.prototype.delete(key)</strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><pre><code class="javascript">const m = new Map();m.set(undefined, &#39;nah&#39;);m.has(undefined)     // truem.delete(undefined)m.has(undefined)       // false</code></pre><p><strong>（6）Map.prototype.clear()</strong></p><p><code>clear</code>方法清除所有成员，没有返回值。</p><pre><code class="javascript">let map = new Map();map.set(&#39;foo&#39;, true);map.set(&#39;bar&#39;, false);map.size // 2map.clear()map.size // 0</code></pre><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><pre><code class="javascript">const map = new Map([  [&#39;F&#39;, &#39;no&#39;],  [&#39;T&#39;,  &#39;yes&#39;],]);for (let key of map.keys()) &#123;  console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123;  console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123;  console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123;  console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123;  console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;</code></pre><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p><pre><code class="javascript">map[Symbol.iterator] === map.entries// true</code></pre><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p><pre><code class="javascript">const map = new Map([  [1, &#39;one&#39;],  [2, &#39;two&#39;],  [3, &#39;three&#39;],]);[...map.keys()]// [1, 2, 3][...map.values()]// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;][...map.entries()]// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]][...map]// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]</code></pre><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p><pre><code class="javascript">const map0 = new Map()  .set(1, &#39;a&#39;)  .set(2, &#39;b&#39;)  .set(3, &#39;c&#39;);const map1 = new Map(  [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;&#125;const map2 = new Map(  [...map0].map(([k, v]) =&gt; [k * 2, &#39;_&#39; + v])    );// 产生 Map 结构 &#123;2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;&#125;</code></pre><p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p><pre><code class="javascript">map.forEach(function(value, key, map) &#123;  console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;);</code></pre><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p><pre><code class="javascript">const reporter = &#123;  report: function(key, value) &#123;    console.log(&quot;Key: %s, Value: %s&quot;, key, value);  &#125;&#125;;map.forEach(function(value, key, map) &#123;  this.report(key, value);&#125;, reporter);</code></pre><p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><pre><code class="javascript">const myMap = new Map()  .set(true, 7)  .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]</code></pre><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><pre><code class="javascript">new Map([  [true, 7],  [&#123;foo: 3&#125;, [&#39;abc&#39;]]])// Map &#123;//   true =&gt; 7,//   Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]// &#125;</code></pre><p><strong>（3）Map 转为对象</strong></p><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><pre><code class="javascript">function strMapToObj(strMap) &#123;  let obj = Object.create(null);  for (let [k,v] of strMap) &#123;    obj[k] = v;  &#125;  return obj;&#125;const myMap = new Map()  .set(&#39;yes&#39;, true)  .set(&#39;no&#39;, false);strMapToObj(myMap)// &#123; yes: true, no: false &#125;</code></pre><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><p><strong>（4）对象转为 Map</strong></p><p>对象转为 Map 可以通过<code>Object.entries()</code>。</p><pre><code class="javascript">let obj = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;let map = new Map(Object.entries(obj));</code></pre><p>此外，也可以自己实现一个转换函数。</p><pre><code class="javascript">function objToStrMap(obj) &#123;  let strMap = new Map();  for (let k of Object.keys(obj)) &#123;    strMap.set(k, obj[k]);  &#125;  return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</code></pre><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><pre><code class="javascript">function strMapToJson(strMap) &#123;  return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);strMapToJson(myMap)// &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39;</code></pre><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><pre><code class="javascript">function mapToArrayJson(map) &#123;  return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);mapToArrayJson(myMap)// &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;</code></pre><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><pre><code class="javascript">function jsonToStrMap(jsonStr) &#123;  return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&#39;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#39;)// Map &#123;&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false&#125;</code></pre><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><pre><code class="javascript">function jsonToMap(jsonStr) &#123;  return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;)// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]&#125;</code></pre><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);wm2.get(k2) // &quot;bar&quot;</code></pre><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p><pre><code class="javascript">const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key</code></pre><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p><p>不过，现在有一个<a href="https://github.com/tc39/proposal-symbols-as-weakmap-keys">提案</a>，允许 Symbol 值也可以作为 WeakMap 的键名。一旦纳入标准，就意味着键名存在两种可能：对象和 Symbol 值。</p><p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p><p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p><pre><code class="javascript">const e1 = document.getElementById(&#39;foo&#39;);const e2 = document.getElementById(&#39;bar&#39;);const arr = [  [e1, &#39;foo 元素&#39;],  [e2, &#39;bar 元素&#39;],];</code></pre><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><pre><code class="javascript">// 不需要 e1 和 e2 的时候// 必须手动删除引用arr [0] = null;arr [1] = null;</code></pre><p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p><p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p><pre><code class="javascript">const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。</p><p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p><p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p><pre><code class="javascript">const wm = new WeakMap();let key = &#123;&#125;;let obj = &#123;foo: 1&#125;;wm.set(key, obj);obj = null;wm.get(key)// Object &#123;foo: 1&#125;</code></pre><p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p><h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p><pre><code class="javascript">const wm = new WeakMap();// size、forEach、clear 方法都不存在wm.size // undefinedwm.forEach // undefinedwm.clear // undefined</code></pre><h3 id="WeakMap-的示例"><a href="#WeakMap-的示例" class="headerlink" title="WeakMap 的示例"></a>WeakMap 的示例</h3><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p><p>贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925">vtxf</a>补充了下面的例子。</p><p>首先，打开 Node 命令行。</p><pre><code class="bash">$ node --expose-gc</code></pre><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p><p>然后，执行下面的代码。</p><pre><code class="javascript">// 手动执行一次垃圾回收，保证获取的内存使用状态准确&gt; global.gc();undefined// 查看内存占用的初始状态，heapUsed 为 4M 左右&gt; process.memoryUsage();&#123; rss: 21106688,  heapTotal: 7376896,  heapUsed: 4153936,  external: 9059 &#125;&gt; let wm = new WeakMap();undefined// 新建一个变量 key，指向一个 5*1024*1024 的数组&gt; let key = new Array(5 * 1024 * 1024);undefined// 设置 WeakMap 实例的键名，也指向 key 数组// 这时，key 数组实际被引用了两次，// 变量 key 引用一次，WeakMap 的键名引用了第二次// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1&gt; wm.set(key, 1);WeakMap &#123;&#125;&gt; global.gc();undefined// 这时内存占用 heapUsed 增加到 45M 了&gt; process.memoryUsage();&#123; rss: 67538944,  heapTotal: 7376896,  heapUsed: 45782816,  external: 8945 &#125;// 清除变量 key 对数组的引用，// 但没有手动清除 WeakMap 实例的键名对数组的引用&gt; key = null;null// 再次执行垃圾回收&gt; global.gc();undefined// 内存占用 heapUsed 变回 4M 左右，// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收&gt; process.memoryUsage();&#123; rss: 20639744,  heapTotal: 8425472,  heapUsed: 3979792,  external: 8956 &#125;</code></pre><p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p><p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p><h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p><pre><code class="javascript">let myWeakmap = new WeakMap();myWeakmap.set(  document.getElementById(&#39;logo&#39;),  &#123;timesClicked: 0&#125;);document.getElementById(&#39;logo&#39;).addEventListener(&#39;click&#39;, function() &#123;  let logoData = myWeakmap.get(document.getElementById(&#39;logo&#39;));  logoData.timesClicked++;&#125;, false);</code></pre><p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><p>WeakMap 的另一个用处是部署私有属性。</p><pre><code class="javascript">const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123;  constructor(counter, action) &#123;    _counter.set(this, counter);    _action.set(this, action);  &#125;  dec() &#123;    let counter = _counter.get(this);    if (counter &lt; 1) return;    counter--;    _counter.set(this, counter);    if (counter === 0) &#123;      _action.get(this)();    &#125;  &#125;&#125;const c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;));c.dec()c.dec()// DONE</code></pre><p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p><h2 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h2><p>WeakSet 和 WeakMap 是基于弱引用的数据结构，<a href="https://github.com/tc39/proposal-weakrefs">ES2021</a> 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。</p><pre><code class="javascript">let target = &#123;&#125;;let wr = new WeakRef(target);</code></pre><p>上面示例中，<code>target</code>是原始对象，构造函数<code>WeakRef()</code>创建了一个基于<code>target</code>的新对象<code>wr</code>。这里，<code>wr</code>就是一个 WeakRef 的实例，属于对<code>target</code>的弱引用，垃圾回收机制不会计入这个引用，也就是说，<code>wr</code>的引用不会妨碍原始对象<code>target</code>被垃圾回收机制清除。</p><p>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</p><pre><code class="javascript">let target = &#123;&#125;;let wr = new WeakRef(target);let obj = wr.deref();if (obj) &#123; // target 未被垃圾回收机制清除  // ...&#125;</code></pre><p>上面示例中，<code>deref()</code>方法可以判断原始对象是否已被清除。</p><p>弱引用对象的一大用处，就是作为缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。</p><pre><code class="javascript">function makeWeakCached(f) &#123;  const cache = new Map();  return key =&gt; &#123;    const ref = cache.get(key);    if (ref) &#123;      const cached = ref.deref();      if (cached !== undefined) return cached;    &#125;    const fresh = f(key);    cache.set(key, new WeakRef(fresh));    return fresh;  &#125;;&#125;const getImageCached = makeWeakCached(getImage);</code></pre><p>上面示例中，<code>makeWeakCached()</code>用于建立一个缓存，缓存里面保存对原始文件的弱引用。</p><p>注意，标准规定，一旦使用<code>WeakRef()</code>创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。</p><h2 id="FinalizationRegistry"><a href="#FinalizationRegistry" class="headerlink" title="FinalizationRegistry"></a>FinalizationRegistry</h2><p><a href="https://github.com/tc39/proposal-weakrefs#finalizers">ES2021</a> 引入了清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。</p><p>首先，新建一个注册表实例。</p><pre><code class="javascript">const registry = new FinalizationRegistry(heldValue =&gt; &#123;  // ....&#125;);</code></pre><p>上面代码中，<code>FinalizationRegistry()</code>是系统提供的构造函数，返回一个清理器注册表实例，里面登记了所要执行的回调函数。回调函数作为<code>FinalizationRegistry()</code>的参数传入，它本身有一个参数<code>heldValue</code>。</p><p>然后，注册表实例的<code>register()</code>方法，用来注册所要观察的目标对象。</p><pre><code class="javascript">registry.register(theObject, &quot;some value&quot;);</code></pre><p>上面示例中，<code>theObject</code>就是所要观察的目标对象，一旦该对象被垃圾回收机制清除，注册表就会在清除完成后，调用早前注册的回调函数，并将<code>some value</code>作为参数（前面的<code>heldValue</code>）传入回调函数。</p><p>注意，注册表不对目标对象<code>theObject</code>构成强引用，属于弱引用。因为强引用的话，原始对象就不会被垃圾回收机制清除，这就失去使用注册表的意义了。</p><p>回调函数的参数<code>heldValue</code>可以是任意类型的值，字符串、数值、布尔值、对象，甚至可以是<code>undefined</code>。</p><p>最后，如果以后还想取消已经注册的回调函数，则要向<code>register()</code>传入第三个参数，作为标记值。这个标记值必须是对象，一般都用原始对象。接着，再使用注册表实例对象的<code>unregister()</code>方法取消注册。</p><pre><code class="javascript">registry.register(theObject, &quot;some value&quot;, theObject);// ...其他操作...registry.unregister(theObject);</code></pre><p>上面代码中，<code>register()</code>方法的第三个参数就是标记值<code>theObject</code>。取消回调函数时，要使用<code>unregister()</code>方法，并将标记值作为该方法的参数。这里<code>register()</code>方法对第三个参数的引用，也属于弱引用。如果没有这个参数，则回调函数无法取消。</p><p>由于回调函数被调用以后，就不再存在于注册表之中了，所以执行<code>unregister()</code>应该是在回调函数还没被调用之前。</p><p>下面使用<code>FinalizationRegistry</code>，对前一节的缓存函数进行增强。</p><pre><code class="javascript">function makeWeakCached(f) &#123;  const cache = new Map();  const cleanup = new FinalizationRegistry(key =&gt; &#123;    const ref = cache.get(key);    if (ref &amp;&amp; !ref.deref()) cache.delete(key);  &#125;);  return key =&gt; &#123;    const ref = cache.get(key);    if (ref) &#123;      const cached = ref.deref();      if (cached !== undefined) return cached;    &#125;    const fresh = f(key);    cache.set(key, new WeakRef(fresh));    cleanup.register(fresh, key);    return fresh;  &#125;;&#125;const getImageCached = makeWeakCached(getImage);</code></pre><p>上面示例与前一节的例子相比，就是增加一个清理器注册表，一旦缓存的原始对象被垃圾回收机制清除，会自动执行一个回调函数。该回调函数会清除缓存里面已经失效的键。</p><p>下面是另一个例子。</p><pre><code class="javascript">class Thingy &#123;  #file;  #cleanup = file =&gt; &#123;    console.error(      `The \`release\` method was never called for the \`Thingy\` for the file &quot;$&#123;file.name&#125;&quot;`    );  &#125;;  #registry = new FinalizationRegistry(this.#cleanup);  constructor(filename) &#123;    this.#file = File.open(filename);    this.#registry.register(this, this.#file, this.#file);  &#125;  release() &#123;    if (this.#file) &#123;      this.#registry.unregister(this.#file);      File.close(this.#file);      this.#file = null;    &#125;  &#125;&#125;</code></pre><p>上面示例中，如果由于某种原因，<code>Thingy</code>类的实例对象没有调用<code>release()</code>方法，就被垃圾回收机制清除了，那么清理器就会调用回调函数<code>#cleanup()</code>，输出一条错误信息。</p><p>由于无法知道清理器何时会执行，所以最好避免使用它。另外，如果浏览器窗口关闭或者进程意外退出，清理器则不会运行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-变量的解构赋值</title>
      <link href="/2022/09/05/7%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2022/09/05/7%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">数组的解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">对象的解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">字符串的解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E5%80%BC%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">数值和布尔值的解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">函数参数的解构赋值</a></li><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98">圆括号问题</a></li><li><a href="https://es6.ruanyifeng.com/#docs/destructuring#%E7%94%A8%E9%80%94">用途</a></li></ol><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><pre><code class="javascript">let a = 1;let b = 2;let c = 3;</code></pre><p>ES6 允许写成下面这样。</p><pre><code class="javascript">let [a, b, c] = [1, 2, 3];</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&#39;a&#39;];x // &quot;a&quot;y // undefinedz // []</code></pre><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><pre><code class="javascript">let [foo] = [];let [bar, foo] = [1];</code></pre><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><pre><code class="javascript">let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4</code></pre><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><pre><code class="javascript">// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;</code></pre><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p><p>对于 Set 结构，也可以使用数组的解构赋值。</p><pre><code class="javascript">let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);x // &quot;a&quot;</code></pre><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><pre><code class="javascript">function* fibs() &#123;  let a = 0;  let b = 1;  while (true) &#123;    yield a;    [a, b] = [b, a + b];  &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5</code></pre><p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。</p><pre><code class="javascript">let [foo = true] = [];foo // truelet [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;</code></pre><p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p><pre><code class="javascript">let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null</code></pre><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><pre><code class="javascript">function f() &#123;  console.log(&#39;aaa&#39;);&#125;let [x = f()] = [1];</code></pre><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p><pre><code class="javascript">let x;if ([1][0] === undefined) &#123;  x = f();&#125; else &#123;  x = [1][0];&#125;</code></pre><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><pre><code class="javascript">let [x = 1, y = x] = [];     // x=1; y=1let [x = 1, y = x] = [2];    // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = [];     // ReferenceError: y is not defined</code></pre><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="javascript">let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><pre><code class="javascript">let &#123; bar, foo &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;baz // undefined</code></pre><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p><p>如果解构失败，变量的值等于<code>undefined</code>。</p><pre><code class="javascript">let &#123;foo&#125; = &#123;bar: &#39;baz&#39;&#125;;foo // undefined</code></pre><p>上面代码中，等号右边的对象没有<code>foo</code>属性，所以变量<code>foo</code>取不到值，所以等于<code>undefined</code>。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><pre><code class="javascript">// 例一let &#123; log, sin, cos &#125; = Math;// 例二const &#123; log &#125; = console;log(&#39;hello&#39;) // hello</code></pre><p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><pre><code class="javascript">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;let &#123; first: f, last: l &#125; = obj;f // &#39;hello&#39;l // &#39;world&#39;</code></pre><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><pre><code class="javascript">let &#123; foo: foo, bar: bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><pre><code class="javascript">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined</code></pre><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>与数组一样，解构也可以用于嵌套结构的对象。</p><pre><code class="javascript">let obj = &#123;  p: [    &#39;Hello&#39;,    &#123; y: &#39;World&#39; &#125;  ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot;</code></pre><p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p><pre><code class="javascript">let obj = &#123;  p: [    &#39;Hello&#39;,    &#123; y: &#39;World&#39; &#125;  ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot;p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</code></pre><p>下面是另一个例子。</p><pre><code class="javascript">const node = &#123;  loc: &#123;    start: &#123;      line: 1,      column: 5    &#125;  &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc  // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125;</code></pre><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p><p>下面是嵌套赋值的例子。</p><pre><code class="javascript">let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true]</code></pre><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><pre><code class="javascript">// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &#39;baz&#39;&#125;;</code></pre><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p><p>注意，对象的解构赋值可以取到继承的属性。</p><pre><code class="javascript">const obj1 = &#123;&#125;;const obj2 = &#123; foo: &#39;bar&#39; &#125;;Object.setPrototypeOf(obj1, obj2);const &#123; foo &#125; = obj1;foo // &quot;bar&quot;</code></pre><p>上面代码中，对象<code>obj1</code>的原型对象是<code>obj2</code>。<code>foo</code>属性不是<code>obj1</code>自身的属性，而是继承自<code>obj2</code>的属性，解构赋值可以取到这个属性。</p><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>对象的解构也可以指定默认值。</p><pre><code class="javascript">var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &#39;Something went wrong&#39; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot;</code></pre><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><pre><code class="javascript">var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null</code></pre><p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><pre><code class="javascript">// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error</code></pre><p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><pre><code class="javascript">// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;);</code></pre><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><pre><code class="javascript">(&#123;&#125; = [true, false]);(&#123;&#125; = &#39;abc&#39;);(&#123;&#125; = []);</code></pre><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><pre><code class="javascript">let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3</code></pre><p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。</p><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;</code></pre><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><pre><code class="javascript">let &#123;length : len&#125; = &#39;hello&#39;;len // 5</code></pre><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><pre><code class="javascript">let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true</code></pre><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p><pre><code class="javascript">let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError</code></pre><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><pre><code class="javascript">function add([x, y])&#123;  return x + y;&#125;add([1, 2]); // 3</code></pre><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p><p>下面是另一个例子。</p><pre><code class="javascript">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]</code></pre><p>函数参数的解构也可以使用默认值。</p><pre><code class="javascript">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;  return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]</code></pre><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><pre><code class="javascript">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;  return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0]</code></pre><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p><p><code>undefined</code>就会触发函数参数的默认值。</p><pre><code class="javascript">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);// [ 1, &#39;yes&#39;, 3 ]</code></pre><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号。</p><p>（1）变量声明语句</p><pre><code class="javascript">// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</code></pre><p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><p>（2）函数参数</p><p>函数参数也属于变量声明，因此不能带有圆括号。</p><pre><code class="javascript">// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125;</code></pre><p>（3）赋值语句的模式</p><pre><code class="javascript">// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];</code></pre><p>上面代码将整个模式放在圆括号之中，导致报错。</p><pre><code class="javascript">// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</code></pre><p>上面代码将一部分模式放在圆括号之中，导致报错。</p><h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><pre><code class="javascript">[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确</code></pre><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>变量的解构赋值用途很多。</p><p><strong>（1）交换变量的值</strong></p><pre><code class="javascript">let x = 1;let y = 2;[x, y] = [y, x];</code></pre><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><pre><code class="javascript">// 返回一个数组function example() &#123;  return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123;  return &#123;    foo: 1,    bar: 2  &#125;;&#125;let &#123; foo, bar &#125; = example();</code></pre><p><strong>（3）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><pre><code class="javascript">// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;);</code></pre><p><strong>（4）提取 JSON 数据</strong></p><p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p><pre><code class="javascript">let jsonData = &#123;  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309]</code></pre><p>上面代码可以快速提取 JSON 数据的值。</p><p><strong>（5）函数参数的默认值</strong></p><pre><code class="javascript">jQuery.ajax = function (url, &#123;  async = true,  beforeSend = function () &#123;&#125;,  cache = true,  complete = function () &#123;&#125;,  crossDomain = false,  global = true,  // ... more config&#125; = &#123;&#125;) &#123;  // ... do stuff&#125;;</code></pre><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p><strong>（6）遍历 Map 结构</strong></p><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><pre><code class="javascript">const map = new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) &#123;  console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world</code></pre><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><pre><code class="javascript">// 获取键名for (let [key] of map) &#123;  // ...&#125;// 获取键值for (let [,value] of map) &#123;  // ...&#125;</code></pre><p><strong>（7）输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><pre><code class="javascript">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-运算符的扩展</title>
      <link href="/2022/09/05/6%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2022/09/05/6%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符的扩展"><a href="#运算符的扩展" class="headerlink" title="运算符的扩展"></a>运算符的扩展</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/operator#%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">指数运算符</a></li><li><a href="https://es6.ruanyifeng.com/#docs/operator#%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6">链判断运算符</a></li><li>[Null 判断运算符](<a href="https://es6.ruanyifeng.com/#docs/operator#Null">https://es6.ruanyifeng.com/#docs/operator#Null</a> 判断运算符)</li><li><a href="https://es6.ruanyifeng.com/#docs/operator#%E9%80%BB%E8%BE%91%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑赋值运算符</a></li></ol><p>本章介绍 ES6 后续标准添加的一些运算符。</p><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p><pre><code class="javascript">2 ** 2 // 42 ** 3 // 8</code></pre><p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p><pre><code class="javascript">// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512</code></pre><p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p><p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p><pre><code class="javascript">let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b;</code></pre><h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h2><p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。比如，读取<code>message.body.user.firstName</code>这个属性，安全的写法是写成下面这样。</p><pre><code class="javascript">// 错误的写法const  firstName = message.body.user.firstName || &#39;default&#39;;// 正确的写法const firstName = (message  &amp;&amp; message.body  &amp;&amp; message.body.user  &amp;&amp; message.body.user.firstName) || &#39;default&#39;;</code></pre><p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p><p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p><pre><code class="javascript">const fooInput = myForm.querySelector(&#39;input[name=foo]&#39;)const fooValue = fooInput ? fooInput.value : undefined</code></pre><p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p><p>这样的层层判断非常麻烦，因此 <a href="https://github.com/tc39/proposal-optional-chaining">ES2020</a> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</p><pre><code class="javascript">const firstName = message?.body?.user?.firstName || &#39;default&#39;;const fooValue = myForm.querySelector(&#39;input[name=foo]&#39;)?.value</code></pre><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p><p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p><pre><code class="javascript">iterator.return?.()</code></pre><p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p><p>对于那些可能没有实现的方法，这个运算符尤其有用。</p><pre><code class="javascript">if (myForm.checkValidity?.() === false) &#123;  // 表单校验失败  return;&#125;</code></pre><p>上面代码中，老式浏览器的表单对象可能没有<code>checkValidity()</code>这个方法，这时<code>?.</code>运算符就会返回<code>undefined</code>，判断语句就变成了<code>undefined === false</code>，所以就会跳过下面的代码。</p><p>链判断运算符<code>?.</code>有三种写法。</p><ul><li><code>obj?.prop</code> // 对象属性是否存在</li><li><code>obj?.[expr]</code> // 同上</li><li><code>func?.(...args)</code> // 函数或对象方法是否存在</li></ul><p>下面是<code>obj?.[expr]</code>用法的一个例子。</p><pre><code class="bash">let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1];</code></pre><p>上面例子中，字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，<code>?.</code>运算符起到了判断作用。</p><p>下面是<code>?.</code>运算符常见形式，以及不使用该运算符时的等价形式。</p><pre><code class="javascript">a?.b// 等同于a == null ? undefined : a.ba?.[x]// 等同于a == null ? undefined : a[x]a?.b()// 等同于a == null ? undefined : a.b()a?.()// 等同于a == null ? undefined : a()</code></pre><p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>和<code>a?.()</code>。如果<code>a?.b()</code>里面的<code>a.b</code>有值，但不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</p><p>使用这个运算符，有几个注意点。</p><p>（1）短路机制</p><p>本质上，<code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p><pre><code class="javascript">a?.[++x]// 等同于a == null ? undefined : a[++x]</code></pre><p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p><p>（2）括号的影响</p><p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p><pre><code class="javascript">(a?.b).c// 等价于(a == null ? undefined : a.b).c</code></pre><p>上面代码中，<code>?.</code>对圆括号外部没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p><p>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</p><p>（3）报错场合</p><p>以下写法是禁止的，会报错。</p><pre><code class="javascript">// 构造函数new a?.()new a?.b()// 链判断运算符的右侧有模板字符串a?.`&#123;b&#125;`a?.b`&#123;c&#125;`// 链判断运算符的左侧是 supersuper?.()super?.foo// 链运算符用于赋值运算符左侧a?.b = c</code></pre><p>（4）右侧不得为十进制数值</p><p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p><h2 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h2><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p><pre><code class="javascript">const headerText = response.settings.headerText || &#39;Hello, world!&#39;;const animationDuration = response.settings.animationDuration || 300;const showSplashScreen = response.settings.showSplashScreen || true;</code></pre><p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p><p>为了避免这种情况，<a href="https://github.com/tc39/proposal-nullish-coalescing">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p><pre><code class="javascript">const headerText = response.settings.headerText ?? &#39;Hello, world!&#39;;const animationDuration = response.settings.animationDuration ?? 300;const showSplashScreen = response.settings.showSplashScreen ?? true;</code></pre><p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p><p>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值。</p><pre><code class="javascript">const animationDuration = response.settings?.animationDuration ?? 300;</code></pre><p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p><p>这个运算符很适合判断函数参数是否赋值。</p><pre><code class="javascript">function Component(props) &#123;  const enable = props.enabled ?? true;  // …&#125;</code></pre><p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p><pre><code class="javascript">function Component(props) &#123;  const &#123;    enabled: enable = true,  &#125; = props;  // …&#125;</code></pre><p><code>??</code>本质上是逻辑运算，它与其他两个逻辑运算符<code>&amp;&amp;</code>和<code>||</code>有一个优先级问题，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。</p><p>现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p><pre><code class="javascript">// 报错lhs &amp;&amp; middle ?? rhslhs ?? middle &amp;&amp; rhslhs || middle ?? rhslhs ?? middle || rhs</code></pre><p>上面四个表达式都会报错，必须加入表明优先级的括号。</p><pre><code class="javascript">(lhs &amp;&amp; middle) ?? rhs;lhs &amp;&amp; (middle ?? rhs);(lhs ?? middle) &amp;&amp; rhs;lhs ?? (middle &amp;&amp; rhs);(lhs || middle) ?? rhs;lhs || (middle ?? rhs);(lhs ?? middle) || rhs;lhs ?? (middle || rhs);</code></pre><h2 id="逻辑赋值运算符"><a href="#逻辑赋值运算符" class="headerlink" title="逻辑赋值运算符"></a>逻辑赋值运算符</h2><p>ES2021 引入了三个新的<a href="https://github.com/tc39/proposal-logical-assignment">逻辑赋值运算符</a>（logical assignment operators），将逻辑运算符与赋值运算符进行结合。</p><pre><code class="javascript">// 或赋值运算符x ||= y// 等同于x || (x = y)// 与赋值运算符x &amp;&amp;= y// 等同于x &amp;&amp; (x = y)// Null 赋值运算符x ??= y// 等同于x ?? (x = y)</code></pre><p>这三个运算符<code>||=</code>、<code>&amp;&amp;=</code>、<code>??=</code>相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。</p><p>它们的一个用途是，为变量或属性设置默认值。</p><pre><code class="javascript">// 老的写法user.id = user.id || 1;// 新的写法user.id ||= 1;</code></pre><p>上面示例中，<code>user.id</code>属性如果不存在，则设为<code>1</code>，新的写法比老的写法更紧凑一些。</p><p>下面是另一个例子。</p><pre><code class="javascript">function example(opts) &#123;  opts.foo = opts.foo ?? &#39;bar&#39;;  opts.baz ?? (opts.baz = &#39;qux&#39;);&#125;</code></pre><p>上面示例中，参数对象<code>opts</code>如果不存在属性<code>foo</code>和属性<code>baz</code>，则为这两个属性设置默认值。有了“Null 赋值运算符”以后，就可以统一写成下面这样。</p><pre><code class="javascript">function example(opts) &#123;  opts.foo ??= &#39;bar&#39;;  opts.baz ??= &#39;qux&#39;;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-let 和 const 命令</title>
      <link href="/2022/09/05/5let%E5%92%8Cconst%E5%91%BD%E5%90%8D/"/>
      <url>/2022/09/05/5let%E5%92%8Cconst%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><ol><li>[let 命令](<a href="https://es6.ruanyifeng.com/#docs/let#let">https://es6.ruanyifeng.com/#docs/let#let</a> 命令)</li><li><a href="https://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</a></li><li>[const 命令](<a href="https://es6.ruanyifeng.com/#docs/let#const">https://es6.ruanyifeng.com/#docs/let#const</a> 命令)</li><li><a href="https://es6.ruanyifeng.com/#docs/let#%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">顶层对象的属性</a></li><li>[globalThis 对象](<a href="https://es6.ruanyifeng.com/#docs/let#globalThis">https://es6.ruanyifeng.com/#docs/let#globalThis</a> 对象)</li></ol><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><pre><code class="javascript">&#123;  let a = 10;  var b = 1;&#125;a // ReferenceError: a is not defined.b // 1</code></pre><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><pre><code class="javascript">for (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined</code></pre><p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p><pre><code class="javascript">var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[6](); // 10</code></pre><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><pre><code class="javascript">var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[6](); // 6</code></pre><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><pre><code class="javascript">for (let i = 0; i &lt; 3; i++) &#123;  let i = &#39;abc&#39;;  console.log(i);&#125;// abc// abc// abc</code></pre><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 <code>let</code> 重复声明同一个变量）。</p><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><pre><code class="javascript">// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;</code></pre><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><pre><code class="javascript">var tmp = 123;if (true) &#123;  tmp = &#39;abc&#39;; // ReferenceError  let tmp;&#125;</code></pre><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><pre><code class="javascript">if (true) &#123;  // TDZ开始  tmp = &#39;abc&#39;; // ReferenceError  console.log(tmp); // ReferenceError  let tmp; // TDZ结束  console.log(tmp); // undefined  tmp = 123;  console.log(tmp); // 123&#125;</code></pre><p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p><pre><code class="javascript">typeof x; // ReferenceErrorlet x;</code></pre><p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p><p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p><pre><code class="javascript">typeof undeclared_variable // &quot;undefined&quot;</code></pre><p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。</p><pre><code class="javascript">function bar(x = y, y = 2) &#123;  return [x, y];&#125;bar(); // 报错</code></pre><p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><pre><code class="javascript">function bar(x = 2, y = x) &#123;  return [x, y];&#125;bar(); // [2, 2]</code></pre><p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p><pre><code class="javascript">// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined</code></pre><p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p><p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><pre><code class="javascript">// 报错function func() &#123;  let a = 10;  var a = 1;&#125;// 报错function func() &#123;  let a = 10;  let a = 1;&#125;</code></pre><p>因此，不能在函数内部重新声明参数。</p><pre><code class="javascript">function func(arg) &#123;  let arg;&#125;func() // 报错function func(arg) &#123;  &#123;    let arg;  &#125;&#125;func() // 不报错</code></pre><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><pre><code class="javascript">var tmp = new Date();function f() &#123;  console.log(tmp);  if (false) &#123;    var tmp = &#39;hello world&#39;;  &#125;&#125;f(); // undefined</code></pre><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><pre><code class="javascript">var s = &#39;hello&#39;;for (var i = 0; i &lt; s.length; i++) &#123;  console.log(s[i]);&#125;console.log(i); // 5</code></pre><p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p><pre><code class="javascript">function f1() &#123;  let n = 5;  if (true) &#123;    let n = 10;  &#125;  console.log(n); // 5&#125;</code></pre><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p><p>ES6 允许块级作用域的任意嵌套。</p><pre><code class="javascript">&#123;&#123;&#123;&#123;  &#123;let insane = 'Hello World'&#125;  console.log(insane); // 报错&#125;&#125;&#125;&#125;;</code></pre><p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p><p>内层作用域可以定义外层作用域的同名变量。</p><pre><code class="javascript">&#123;&#123;&#123;&#123;  let insane = 'Hello World';  &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;</code></pre><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p><pre><code class="javascript">// IIFE 写法(function () &#123;  var tmp = ...;  ...&#125;());// 块级作用域写法&#123;  let tmp = ...;  ...&#125;</code></pre><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><pre><code class="javascript">// 情况一if (true) &#123;  function f() &#123;&#125;&#125;// 情况二try &#123;  function f() &#123;&#125;&#125; catch(e) &#123;  // ...&#125;</code></pre><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p><pre><code class="javascript">function f() &#123; console.log(&#39;I am outside!&#39;); &#125;(function () &#123;  if (false) &#123;    // 重复声明一次函数f    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;  &#125;  f();&#125;());</code></pre><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p><pre><code class="javascript">// ES5 环境function f() &#123; console.log(&#39;I am outside!&#39;); &#125;(function () &#123;  function f() &#123; console.log(&#39;I am inside!&#39;); &#125;  if (false) &#123;  &#125;  f();&#125;());</code></pre><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><pre><code class="javascript">// 浏览器的 ES6 环境function f() &#123; console.log(&#39;I am outside!&#39;); &#125;(function () &#123;  if (false) &#123;    // 重复声明一次函数f    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;  &#125;  f();&#125;());// Uncaught TypeError: f is not a function</code></pre><p>上面的代码在 ES6 浏览器中，都会报错。</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="https://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>。</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p><p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下。</p><pre><code class="javascript">// 浏览器的 ES6 环境function f() &#123; console.log(&#39;I am outside!&#39;); &#125;(function () &#123;  var f = undefined;  if (false) &#123;    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;  &#125;  f();&#125;());// Uncaught TypeError: f is not a function</code></pre><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><pre><code class="javascript">// 块级作用域内部的函数声明语句，建议不要使用&#123;  let a = &#39;secret&#39;;  function f() &#123;    return a;  &#125;&#125;// 块级作用域内部，优先使用函数表达式&#123;  let a = &#39;secret&#39;;  let f = function () &#123;    return a;  &#125;;&#125;</code></pre><p>另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p><pre><code class="javascript">// 第一种写法，报错if (true) let x = 1;// 第二种写法，不报错if (true) &#123;  let x = 1;&#125;</code></pre><p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而<code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p><p>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</p><pre><code class="javascript">// 不报错&#39;use strict&#39;;if (true) &#123;  function f() &#123;&#125;&#125;// 报错&#39;use strict&#39;;if (true)  function f() &#123;&#125;</code></pre><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><pre><code class="javascript">const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.</code></pre><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><pre><code class="javascript">const foo;// SyntaxError: Missing initializer in const declaration</code></pre><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><pre><code class="javascript">if (true) &#123;  const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined</code></pre><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><pre><code class="javascript">if (true) &#123;  console.log(MAX); // ReferenceError  const MAX = 5;&#125;</code></pre><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><pre><code class="javascript">var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30;</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><pre><code class="javascript">const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</code></pre><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。</p><pre><code class="javascript">const a = [];a.push(&#39;Hello&#39;); // 可执行a.length = 0;    // 可执行a = [&#39;Dave&#39;];    // 报错</code></pre><p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><pre><code class="javascript">const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;</code></pre><p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><pre><code class="javascript">var constantize = (obj) =&gt; &#123;  Object.freeze(obj);  Object.keys(obj).forEach( (key, i) =&gt; &#123;    if ( typeof obj[key] === &#39;object&#39; ) &#123;      constantize( obj[key] );    &#125;  &#125;);&#125;;</code></pre><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><pre><code class="javascript">window.a = 1;a // 1a = 2;window.a // 2</code></pre><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><pre><code class="javascript">var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined</code></pre><p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p><h2 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h2><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p><ul><li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li><li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li><li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li></ul><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>关键字，但是有局限性。</p><ul><li>全局环境中，<code>this</code>会返回顶层对象。但是，Node.js 模块中<code>this</code>返回的是当前模块，ES6 模块中<code>this</code>返回的是<code>undefined</code>。</li><li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li><li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li></ul><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><pre><code class="javascript">// 方法一(typeof window !== &#39;undefined&#39;   ? window   : (typeof process === &#39;object&#39; &amp;&amp;      typeof require === &#39;function&#39; &amp;&amp;      typeof global === &#39;object&#39;)     ? global     : this);// 方法二var getGlobal = function () &#123;  if (typeof self !== &#39;undefined&#39;) &#123; return self; &#125;  if (typeof window !== &#39;undefined&#39;) &#123; return window; &#125;  if (typeof global !== &#39;undefined&#39;) &#123; return global; &#125;  throw new Error(&#39;unable to locate global object&#39;);&#125;;</code></pre><p><a href="https://github.com/tc39/proposal-global">ES2020</a> 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p><p>垫片库<a href="https://github.com/ungap/global-this"><code>global-this</code></a>模拟了这个提案，可以在所有环境拿到<code>globalTh</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Class 的基本语法</title>
      <link href="/2022/09/05/4class%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/09/05/4class%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/class#%E7%B1%BB%E7%9A%84%E7%94%B1%E6%9D%A5">类的由来</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#constructor(">constructor() 方法</a> 方法)</li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">类的实例</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95">实例属性的新写法</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88getter%EF%BC%89%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88setter%EF%BC%89">取值函数（getter）和存值函数（setter）</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F">属性表达式</a></li><li>[Class 表达式](<a href="https://es6.ruanyifeng.com/#docs/class#Class">https://es6.ruanyifeng.com/#docs/class#Class</a> 表达式)</li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7">静态属性</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有方法和私有属性</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E9%9D%99%E6%80%81%E5%9D%97">静态块</a></li><li><a href="https://es6.ruanyifeng.com/#docs/class#%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">类的注意点</a></li><li>[new.target 属性](<a href="https://es6.ruanyifeng.com/#docs/class#new.target">https://es6.ruanyifeng.com/#docs/class#new.target</a> 属性)</li></ol><h2 id="类的由来"><a href="#类的由来" class="headerlink" title="类的由来"></a>类的由来</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><pre><code class="javascript">function Point(x, y) &#123;  this.x = x;  this.y = y;&#125;Point.prototype.toString = function () &#123;  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;&#125;;var p = new Point(1, 2);</code></pre><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p><pre><code class="javascript">class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  toString() &#123;    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  &#125;&#125;</code></pre><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数<code>Point</code>是一致的。</p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><pre><code class="javascript">class Point &#123;  // ...&#125;typeof Point // &quot;function&quot;Point === Point.prototype.constructor // true</code></pre><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p><pre><code class="javascript">class Bar &#123;  doStuff() &#123;    console.log(&#39;stuff&#39;);  &#125;&#125;const b = new Bar();b.doStuff() // &quot;stuff&quot;</code></pre><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><pre><code class="javascript">class Point &#123;  constructor() &#123;    // ...  &#125;  toString() &#123;    // ...  &#125;  toValue() &#123;    // ...  &#125;&#125;// 等同于Point.prototype = &#123;  constructor() &#123;&#125;,  toString() &#123;&#125;,  toValue() &#123;&#125;,&#125;;</code></pre><p>上面代码中，<code>constructor()</code>、<code>toString()</code>、<code>toValue()</code>这三个方法，其实都是定义在<code>Point.prototype</code>上面。</p><p>因此，在类的实例上面调用方法，其实就是调用原型上的方法。</p><pre><code class="javascript">class B &#123;&#125;const b = new B();b.constructor === B.prototype.constructor // true</code></pre><p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor()</code>方法就是<code>B</code>类原型的<code>constructor()</code>方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</p><pre><code class="javascript">class Point &#123;  constructor()&#123;    // ...  &#125;&#125;Object.assign(Point.prototype, &#123;  toString()&#123;&#125;,  toValue()&#123;&#125;&#125;);</code></pre><p><code>prototype</code>对象的<code>constructor()</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><pre><code class="javascript">Point.prototype.constructor === Point // true</code></pre><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><pre><code class="javascript">class Point &#123;  constructor(x, y) &#123;    // ...  &#125;  toString() &#123;    // ...  &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;]</code></pre><p>上面代码中，<code>toString()</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p><pre><code class="javascript">var Point = function (x, y) &#123;  // ...&#125;;Point.prototype.toString = function () &#123;  // ...&#125;;Object.keys(Point.prototype)// [&quot;toString&quot;]Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;]</code></pre><p>上面代码采用 ES5 的写法，<code>toString()</code>方法就是可枚举的。</p><h2 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor() 方法"></a>constructor() 方法</h2><p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p><pre><code class="javascript">class Point &#123;&#125;// 等同于class Point &#123;  constructor() &#123;&#125;&#125;</code></pre><p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor()</code>方法。</p><p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p><pre><code class="javascript">class Foo &#123;  constructor() &#123;    return Object.create(null);  &#125;&#125;new Foo() instanceof Foo// false</code></pre><p>上面代码中，<code>constructor()</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><pre><code class="javascript">class Foo &#123;  constructor() &#123;    return Object.create(null);  &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</code></pre><h2 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h2><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class()</code>，将会报错。</p><pre><code class="javascript">class Point &#123;  // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3);</code></pre><p>类的属性和方法，除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p><pre><code class="javascript">class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  toString() &#123;    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&#39;x&#39;) // truepoint.hasOwnProperty(&#39;y&#39;) // truepoint.hasOwnProperty(&#39;toString&#39;) // falsepoint.__proto__.hasOwnProperty(&#39;toString&#39;) // true</code></pre><p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>对象上），所以<code>hasOwnProperty()</code>方法返回<code>true</code>，而<code>toString()</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty()</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><pre><code class="javascript">var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true</code></pre><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p><p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><blockquote><p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf()</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p></blockquote><pre><code class="javascript">var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;p1.printName() // &quot;Oops&quot;p2.printName() // &quot;Oops&quot;var p3 = new Point(4,2);p3.printName() // &quot;Oops&quot;</code></pre><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><h2 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h2><p><a href="https://github.com/tc39/proposal-class-fields">ES2022</a> 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类内部的最顶层。</p><pre><code class="javascript">// 原来的写法class IncreasingCounter &#123;  constructor() &#123;    this._count = 0;  &#125;  get value() &#123;    console.log(&#39;Getting the current value!&#39;);    return this._count;  &#125;  increment() &#123;    this._count++;  &#125;&#125;</code></pre><p>上面示例中，实例属性<code>_count</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。</p><p>现在的新写法是，这个属性也可以定义在类的最顶层，其他都不变。</p><pre><code class="javascript">class IncreasingCounter &#123;  _count = 0;  get value() &#123;    console.log(&#39;Getting the current value!&#39;);    return this._count;  &#125;  increment() &#123;    this._count++;  &#125;&#125;</code></pre><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</p><p>注意，新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型上面。</p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><pre><code class="javascript">class foo &#123;  bar = &#39;hello&#39;;  baz = &#39;world&#39;;  constructor() &#123;    // ...  &#125;&#125;</code></pre><p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><h2 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h2><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><pre><code class="javascript">class MyClass &#123;  constructor() &#123;    // ...  &#125;  get prop() &#123;    return &#39;getter&#39;;  &#125;  set prop(value) &#123;    console.log(&#39;setter: &#39;+value);  &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// &#39;getter&#39;</code></pre><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p><pre><code class="javascript">class CustomHTMLElement &#123;  constructor(element) &#123;    this.element = element;  &#125;  get html() &#123;    return this.element.innerHTML;  &#125;  set html(value) &#123;    this.element.innerHTML = value;  &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor(  CustomHTMLElement.prototype, &quot;html&quot;);&quot;get&quot; in descriptor  // true&quot;set&quot; in descriptor  // true</code></pre><p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p><h2 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h2><p>类的属性名，可以采用表达式。</p><pre><code class="javascript">let methodName = &#39;getArea&#39;;class Square &#123;  constructor(length) &#123;    // ...  &#125;  [methodName]() &#123;    // ...  &#125;&#125;</code></pre><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p><h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p><pre><code class="javascript">const MyClass = class Me &#123;  getClassName() &#123;    return Me.name;  &#125;&#125;;</code></pre><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</p><pre><code class="javascript">let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined</code></pre><p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p><p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p><pre><code class="javascript">const MyClass = class &#123; /* ... */ &#125;;</code></pre><p>采用 Class 表达式，可以写出立即执行的 Class。</p><pre><code class="javascript">let person = new class &#123;  constructor(name) &#123;    this.name = name;  &#125;  sayName() &#123;    console.log(this.name);  &#125;&#125;(&#39;张三&#39;);person.sayName(); // &quot;张三&quot;</code></pre><p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><pre><code class="javascript">class Foo &#123;  static classMethod() &#123;    return &#39;hello&#39;;  &#125;&#125;Foo.classMethod() // &#39;hello&#39;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function</code></pre><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><pre><code class="javascript">class Foo &#123;  static bar() &#123;    this.baz();  &#125;  static baz() &#123;    console.log(&#39;hello&#39;);  &#125;  baz() &#123;    console.log(&#39;world&#39;);  &#125;&#125;Foo.bar() // hello</code></pre><p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。</p><pre><code class="javascript">class Foo &#123;  static classMethod() &#123;    return &#39;hello&#39;;  &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // &#39;hello&#39;</code></pre><p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p><p>静态方法也是可以从<code>super</code>对象上调用的。</p><pre><code class="javascript">class Foo &#123;  static classMethod() &#123;    return &#39;hello&#39;;  &#125;&#125;class Bar extends Foo &#123;  static classMethod() &#123;    return super.classMethod() + &#39;, too&#39;;  &#125;&#125;Bar.classMethod() // &quot;hello, too&quot;</code></pre><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p><pre><code class="javascript">class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1</code></pre><p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href="https://github.com/tc39/proposal-class-fields">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p><pre><code class="javascript">class MyClass &#123;  static myStaticProp = 42;  constructor() &#123;    console.log(MyClass.myStaticProp); // 42  &#125;&#125;</code></pre><p>这个新写法大大方便了静态属性的表达。</p><pre><code class="javascript">// 老写法class Foo &#123;  // ...&#125;Foo.prop = 1;// 新写法class Foo &#123;  static prop = 1;&#125;</code></pre><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><h2 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h2><h3 id="早期解决方案"><a href="#早期解决方案" class="headerlink" title="早期解决方案"></a>早期解决方案</h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但早期的 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><pre><code class="javascript">class Widget &#123;  // 公有方法  foo (baz) &#123;    this._bar(baz);  &#125;  // 私有方法  _bar(baz) &#123;    return this.snaf = baz;  &#125;  // ...&#125;</code></pre><p>上面代码中，<code>_bar()</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p><pre><code class="javascript">class Widget &#123;  foo (baz) &#123;    bar.call(this, baz);  &#125;  // ...&#125;function bar(baz) &#123;  return this.snaf = baz;&#125;</code></pre><p>上面代码中，<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。</p><p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p><pre><code class="javascript">const bar = Symbol(&#39;bar&#39;);const snaf = Symbol(&#39;snaf&#39;);export default class myClass&#123;  // 公有方法  foo(baz) &#123;    this[bar](baz);  &#125;  // 私有方法  [bar](baz) &#123;    return this[snaf] = baz;  &#125;  // ...&#125;;</code></pre><p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p><pre><code class="javascript">const inst = new myClass();Reflect.ownKeys(myClass.prototype)// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]</code></pre><p>上面代码中，Symbol 值的属性名依然可以从类的外部拿到。</p><h3 id="私有属性的正式写法"><a href="#私有属性的正式写法" class="headerlink" title="私有属性的正式写法"></a>私有属性的正式写法</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES2022</a>正式为<code>class</code>添加了私有属性，方法是在属性名之前使用<code>#</code>表示。</p><pre><code class="javascript">class IncreasingCounter &#123;  #count = 0;  get value() &#123;    console.log(&#39;Getting the current value!&#39;);    return this.#count;  &#125;  increment() &#123;    this.#count++;  &#125;&#125;</code></pre><p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</p><pre><code class="javascript">const counter = new IncreasingCounter();counter.#count // 报错counter.#count = 42 // 报错</code></pre><p>上面示例中，在类的外部，读取或写入私有属性<code>#count</code>，都会报错。</p><p>另外，不管在类的内部或外部，读取一个不存在的私有属性，也都会报错。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回<code>undefined</code>。</p><pre><code class="javascript">class IncreasingCounter &#123;  #count = 0;  get value() &#123;    console.log(&#39;Getting the current value!&#39;);    return this.#myCount; // 报错  &#125;  increment() &#123;    this.#count++;  &#125;&#125;const counter = new IncreasingCounter();counter.#myCount // 报错</code></pre><p>上面示例中，<code>#myCount</code>是一个不存在的私有属性，不管在函数内部或外部，读取该属性都会导致报错。</p><p>注意，私有属性的属性名必须包括<code>#</code>，如果不带<code>#</code>，会被当作另一个属性。</p><pre><code class="javascript">class Point &#123;  #x;  constructor(x = 0) &#123;    this.#x = +x;  &#125;  get x() &#123;    return this.#x;  &#125;  set x(value) &#123;    this.#x = +value;  &#125;&#125;</code></pre><p>上面代码中，<code>#x</code>就是私有属性，在<code>Point</code>类之外是读取不到这个属性的。由于井号<code>#</code>是属性名的一部分，使用时必须带有<code>#</code>一起使用，所以<code>#x</code>和<code>x</code>是两个不同的属性。</p><p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p><pre><code class="javascript">class Foo &#123;  #a;  #b;  constructor(a, b) &#123;    this.#a = a;    this.#b = b;  &#125;  #sum() &#123;    return this.#a + this.#b;  &#125;  printSum() &#123;    console.log(this.#sum());  &#125;&#125;</code></pre><p>上面示例中，<code>#sum()</code>就是一个私有方法。</p><p>另外，私有属性也可以设置 getter 和 setter 方法。</p><pre><code class="javascript">class Counter &#123;  #xValue = 0;  constructor() &#123;    console.log(this.#x);  &#125;  get #x() &#123; return this.#xValue; &#125;  set #x(value) &#123;    this.#xValue = value;  &#125;&#125;</code></pre><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>操作另一个私有属性<code>#xValue</code>来完成。</p><p>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</p><pre><code class="javascript">class Foo &#123;  #privateValue = 42;  static getPrivateValue(foo) &#123;    return foo.#privateValue;  &#125;&#125;Foo.getPrivateValue(new Foo()); // 42</code></pre><p>上面代码允许从实例<code>foo</code>上面引用私有属性。</p><p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p><pre><code class="javascript">class FakeMath &#123;  static PI = 22 / 7;  static #totallyRandomNumber = 4;  static #computeRandomNumber() &#123;    return FakeMath.#totallyRandomNumber;  &#125;  static random() &#123;    console.log(&#39;I heard you like random numbers…&#39;)    return FakeMath.#computeRandomNumber();  &#125;&#125;FakeMath.PI // 3.142857142857143FakeMath.random()// I heard you like random numbers…// 4FakeMath.#totallyRandomNumber // 报错FakeMath.#computeRandomNumber() // 报错</code></pre><p>上面代码中，<code>#totallyRandomNumber</code>是私有属性，<code>#computeRandomNumber()</code>是私有方法，只能在<code>FakeMath</code>这个类的内部调用，外部调用就会报错。</p><h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>前面说过，直接访问某个类不存在的私有属性会报错，但是访问不存在的公开属性不会报错。这个特性可以用来判断，某个对象是否为类的实例。</p><pre><code class="javascript">class C &#123;  #brand;  static isC(obj) &#123;    try &#123;      obj.#brand;      return true;    &#125; catch &#123;      return false;    &#125;  &#125;&#125;</code></pre><p>上面示例中，类<code>C</code>的静态方法<code>isC()</code>就用来判断，某个对象是否为<code>C</code>的实例。它采用的方法就是，访问该对象的私有属性<code>#brand</code>。如果不报错，就会返回<code>true</code>；如果报错，就说明该对象不是当前类的实例，从而<code>catch</code>部分返回<code>false</code>。</p><p>因此，<code>try...catch</code>结构可以用来判断某个私有属性是否存在。但是，这样的写法很麻烦，代码可读性很差，<a href="https://github.com/tc39/proposal-private-fields-in-in">ES2022</a> 改进了<code>in</code>运算符，使它也可以用来判断私有属性。</p><pre><code class="javascript">class C &#123;  #brand;  static isC(obj) &#123;    if (#brand in obj) &#123;      // 私有属性 #brand 存在      return true;    &#125; else &#123;      // 私有属性 #foo 不存在      return false;    &#125;  &#125;&#125;</code></pre><p>上面示例中，<code>in</code>运算符判断某个对象是否有私有属性<code>#foo</code>。它不会报错，而是返回一个布尔值。</p><p>这种用法的<code>in</code>，也可以跟<code>this</code>一起配合使用。</p><pre><code class="javascript">class A &#123;  #foo = 0;  m() &#123;    console.log(#foo in this); // true    console.log(#bar in this); // false  &#125;&#125;</code></pre><p>注意，判断私有属性时，<code>in</code>只能用在类的内部。</p><p>子类从父类继承的私有属性，也可以使用<code>in</code>运算符来判断。</p><pre><code class="javascript">class A &#123;  #foo = 0;  static test(obj) &#123;    console.log(#foo in obj);  &#125;&#125;class SubA extends A &#123;&#125;;A.test(new SubA()) // true</code></pre><p>上面示例中，<code>SubA</code>从父类继承了私有属性<code>#foo</code>，<code>in</code>运算符也有效。</p><p>注意，<code>in</code>运算符对于<code>Object.create()</code>、<code>Object.setPrototypeOf</code>形成的继承，是无效的，因为这种继承不会传递私有属性。</p><pre><code class="javascript">class A &#123;  #foo = 0;  static test(obj) &#123;    console.log(#foo in obj);  &#125;&#125;const a = new A();const o1 = Object.create(a);A.test(o1) // falseA.test(o1.__proto__) // trueconst o2 = &#123;&#125;;Object.setPrototypeOf(o2, a);A.test(o2) // falseA.test(o2.__proto__) // true</code></pre><p>上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以<code>in</code>运算符无效。</p><h2 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h2><p>静态属性的一个问题是，它的初始化要么写在类的外部，要么写在<code>constructor()</code>方法里面。</p><pre><code class="javascript">class C &#123;  static x = 234;  static y;  static z;&#125;try &#123;  const obj = doSomethingWith(C.x);  C.y = obj.y  C.z = obj.z;&#125; catch &#123;  C.y = ...;  C.z = ...;&#125;</code></pre><p>上面示例中，静态属性<code>y</code>和<code>z</code>的值依赖静态属性<code>x</code>，它们的初始化写在类的外部（上例的<code>try...catch</code>代码块）。另一种方法是写到类的<code>constructor()</code>方法里面。这两种方法都不是很理想，前者是将类的内部逻辑写到了外部，后者则是每次新建实例都会运行一次。</p><p>为了解决这个问题，ES2022 引入了<a href="https://github.com/tc39/proposal-class-static-block">静态块</a>（static block），允许在类的内部设置一个代码块，在类生成时运行一次，主要作用是对静态属性进行初始化。</p><pre><code class="javascript">class C &#123;  static x = ...;  static y;  static z;  static &#123;    try &#123;      const obj = doSomethingWith(this.x);      this.y = obj.y;      this.z = obj.z;    &#125;    catch &#123;      this.y = ...;      this.z = ...;    &#125;  &#125;&#125;</code></pre><p>上面代码中，类的内部有一个 static 代码块，这就是静态块。它的好处是将静态属性<code>y</code>和<code>z</code>的初始化逻辑，写入了类的内部，而且只运行一次。</p><p>每个类只能有一个静态块，在静态属性声明后运行。静态块的内部不能有<code>return</code>语句。</p><p>静态块内部可以使用类名或<code>this</code>，指代当前类。</p><pre><code class="c">class C &#123;  static x = 1;  static &#123;    this.x; // 1    // 或者    C.x; // 1  &#125;&#125;</code></pre><p>上面示例中，<code>this.x</code>和<code>C.x</code>都能获取静态属性<code>x</code>。</p><p>除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</p><pre><code class="javascript">let getX;export class C &#123;  #x = 1;  static &#123;    getX = obj =&gt; obj.#x;  &#125;&#125;console.log(getX(new C())); // 1</code></pre><p>上面示例中，<code>#x</code>是类的私有属性，如果类外部的<code>getX()</code>方法希望获取这个属性，以前是要写在类的<code>constructor()</code>方法里面，这样的话，每次新建实例都会定义一次<code>getX()</code>方法。现在可以写在静态块里面，这样的话，只在类生成时定义一次。</p><h2 id="类的注意点"><a href="#类的注意点" class="headerlink" title="类的注意点"></a>类的注意点</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><h3 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h3><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><pre><code class="javascript">new Foo(); // ReferenceErrorclass Foo &#123;&#125;</code></pre><p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><pre><code class="javascript">&#123;  let Foo = class &#123;&#125;;  class Bar extends Foo &#123;  &#125;&#125;</code></pre><p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p><pre><code class="javascript">class Point &#123;&#125;Point.name // &quot;Point&quot;</code></pre><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><h3 id="Generator-方法"><a href="#Generator-方法" class="headerlink" title="Generator 方法"></a>Generator 方法</h3><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p><pre><code class="javascript">class Foo &#123;  constructor(...args) &#123;    this.args = args;  &#125;  * [Symbol.iterator]() &#123;    for (let arg of this.args) &#123;      yield arg;    &#125;  &#125;&#125;for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) &#123;  console.log(x);&#125;// hello// world</code></pre><p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><pre><code class="javascript">class Logger &#123;  printName(name = &#39;there&#39;) &#123;    this.print(`Hello $&#123;name&#125;`);  &#125;  print(text) &#123;    console.log(text);  &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &#39;print&#39; of undefined</code></pre><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><pre><code class="javascript">class Logger &#123;  constructor() &#123;    this.printName = this.printName.bind(this);  &#125;  // ...&#125;</code></pre><p>另一种解决方法是使用箭头函数。</p><pre><code class="javascript">class Obj &#123;  constructor() &#123;    this.getThis = () =&gt; this;  &#125;&#125;const myObj = new Obj();myObj.getThis() === myObj // true</code></pre><p>箭头函数内部的<code>this</code>总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p><p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p><pre><code class="javascript">function selfish (target) &#123;  const cache = new WeakMap();  const handler = &#123;    get (target, key) &#123;      const value = Reflect.get(target, key);      if (typeof value !== &#39;function&#39;) &#123;        return value;      &#125;      if (!cache.has(value)) &#123;        cache.set(value, value.bind(target));      &#125;      return cache.get(value);    &#125;  &#125;;  const proxy = new Proxy(target, handler);  return proxy;&#125;const logger = selfish(new Logger());</code></pre><h2 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h2><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><pre><code class="javascript">function Person(name) &#123;  if (new.target !== undefined) &#123;    this.name = name;  &#125; else &#123;    throw new Error(&#39;必须使用 new 命令生成实例&#39;);  &#125;&#125;// 另一种写法function Person(name) &#123;  if (new.target === Person) &#123;    this.name = name;  &#125; else &#123;    throw new Error(&#39;必须使用 new 命令生成实例&#39;);  &#125;&#125;var person = new Person(&#39;张三&#39;); // 正确var notAPerson = Person.call(person, &#39;张三&#39;);  // 报错</code></pre><p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p><p>Class 内部调用<code>new.target</code>，返回当前 Class。</p><pre><code class="javascript">class Rectangle &#123;  constructor(length, width) &#123;    console.log(new.target === Rectangle);    this.length = length;    this.width = width;  &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true</code></pre><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><pre><code class="javascript">class Rectangle &#123;  constructor(length, width) &#123;    console.log(new.target === Rectangle);    // ...  &#125;&#125;class Square extends Rectangle &#123;  constructor(length, width) &#123;    super(length, width);  &#125;&#125;var obj = new Square(3); // 输出 false</code></pre><p>上面代码中，<code>new.target</code>会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><pre><code class="javascript">class Shape &#123;  constructor() &#123;    if (new.target === Shape) &#123;      throw new Error(&#39;本类不能实例化&#39;);    &#125;  &#125;&#125;class Rectangle extends Shape &#123;  constructor(length, width) &#123;    super();    // ...  &#125;&#125;var x = new Shape();  // 报错var y = new Rectangle(3, 4);  // 正确</code></pre><p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用<code>new.target</code>会报错。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Es6中import  as xxx from几种基本用法</title>
      <link href="/2022/09/05/3%E6%B5%85%E8%B0%88Es6%E4%B8%ADimport%20%20as%20xxx%20from%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2022/09/05/3%E6%B5%85%E8%B0%88Es6%E4%B8%ADimport%20%20as%20xxx%20from%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>以为<a href="https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020">ES6</a>，javascript第一次支持了module。ES6的模块化分为导出（export）与导入（import）两个模块，其中在项目中，我们会经常看到一种用法import * as obj from，这种写法是把所有的输出包裹到obj对象里。</p><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><pre><code class="javascript">// index.jsexport function fn1(data)&#123;  console.log(1)&#125;export function fn2(data)&#123;  console.log(2)&#125;import * as Fn from &#39;./index.js&#39;Fn.fn1()  // 1Fn.fn2()  // 2</code></pre><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><pre><code class="javascript">let myName = &quot;Jon&quot;;let myAge = 18;let myfn = function()&#123;    return &quot;我是&quot;+myName+&quot;！今年&quot;+myAge+&quot;岁了&quot;&#125;export &#123;    myName as name,    myAge as age,    myfn as fn&#125;</code></pre><h3 id="接收的代码"><a href="#接收的代码" class="headerlink" title="接收的代码"></a>接收的代码</h3><pre><code class="javascript">import &#123;fn,age,name&#125; from &quot;./test.js&quot;;console.log(fn()); //我是Jon！今年19岁了console.log(age); //19console.log(name); //Jon</code></pre><h3 id="或者写成"><a href="#或者写成" class="headerlink" title="或者写成"></a>或者写成</h3><pre><code class="javascript">import * as info from &quot;./test.js&quot;; //通过*来批量接收，as 来指定接收的名字console.log(info.fn()); //我是Jon！今年18岁了console.log(info.age); //18console.log(info.name); //Jon</code></pre><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><p>重命名export和import，如果导入的多个文件中，变量名字相同，即会产生命名冲突的问题，为了解决该问题，ES6为提供了重命名的方法，当你在导入名称时可以这样做。</p><pre><code class="javascript">/*************test1.js*****************/export let myName = &quot;我来自test1.js&quot;;/*************test2.js*****************/export let myName = &quot;我来自test2.js&quot;; /*************index.js****************/import &#123;myName as name1&#125; from &quot;./test1.js&quot;;import &#123;myName as name2&#125; from &quot;./test2.js&quot;;console.log(name1); //我来自test1.jsconsole.log(name2); //我来自test2.js</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Es6-Promise对象</title>
      <link href="/2022/09/05/2.Promise/"/>
      <url>/2022/09/05/2.Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><ol><li>[Promise 的含义](<a href="https://es6.ruanyifeng.com/#docs/promise#Promise">https://es6.ruanyifeng.com/#docs/promise#Promise</a> 的含义)</li><li><a href="https://es6.ruanyifeng.com/#docs/promise#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.then()">Promise.prototype.then()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.catch()">Promise.prototype.catch()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.prototype.finally()">Promise.prototype.finally()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.all()">Promise.all()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.race()">Promise.race()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.allSettled()">Promise.allSettled()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.any()">Promise.any()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.resolve()">Promise.resolve()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.reject()">Promise.reject()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#%E5%BA%94%E7%94%A8">应用</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise#Promise.try()">Promise.try()</a></li></ol><p><a href="https://wx.kaikeba.com/xiaoke/market/landing-page/v2/N3MIpFtF2DZ91C502gp?kol_ad_code=kKx4Fnfd9ENkHgIfwHb">【课程消息】《Vue 3.0 核心源码与实战》带大家动手，从零开发网页游戏《飞机大战》，快速上手 Vue 3.0 项目。开课吧的课程资料，现在 0 元领取。</a></p><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>下面代码创造了一个<code>Promise</code>实例。</p><pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);</code></pre><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><pre><code class="javascript">promise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);</code></pre><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><pre><code class="javascript">function timeout(ms) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(resolve, ms, &#39;done&#39;);  &#125;);&#125;timeout(100).then((value) =&gt; &#123;  console.log(value);&#125;);</code></pre><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><pre><code class="javascript">let promise = new Promise(function(resolve, reject) &#123;  console.log(&#39;Promise&#39;);  resolve();&#125;);promise.then(function() &#123;  console.log(&#39;resolved.&#39;);&#125;);console.log(&#39;Hi!&#39;);// Promise// Hi!// resolved</code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><pre><code class="javascript">function loadImageAsync(url) &#123;  return new Promise(function(resolve, reject) &#123;    const image = new Image();    image.onload = function() &#123;      resolve(image);    &#125;;    image.onerror = function() &#123;      reject(new Error(&#39;Could not load image at &#39; + url));    &#125;;    image.src = url;  &#125;);&#125;</code></pre><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><pre><code class="javascript">const getJSON = function(url) &#123;  const promise = new Promise(function(resolve, reject)&#123;    const handler = function() &#123;      if (this.readyState !== 4) &#123;        return;      &#125;      if (this.status === 200) &#123;        resolve(this.response);      &#125; else &#123;        reject(new Error(this.statusText));      &#125;    &#125;;    const client = new XMLHttpRequest();    client.open(&quot;GET&quot;, url);    client.onreadystatechange = handler;    client.responseType = &quot;json&quot;;    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);    client.send();  &#125;);  return promise;&#125;;getJSON(&quot;/posts.json&quot;).then(function(json) &#123;  console.log(&#39;Contents: &#39; + json);&#125;, function(error) &#123;  console.error(&#39;出错了&#39;, error);&#125;);</code></pre><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;  // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123;  // ...  resolve(p1);&#125;)</code></pre><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123;  setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2  .then(result =&gt; console.log(result))  .catch(error =&gt; console.log(error))// Error: fail</code></pre><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r =&gt; &#123;  console.log(r);&#125;);// 2// 1</code></pre><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;  return resolve(1);  // 后面的语句不会执行  console.log(2);&#125;)</code></pre><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;  return json.post;&#125;).then(function(post) &#123;  // ...&#125;);</code></pre><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;  return getJSON(post.commentURL);&#125;).then(function (comments) &#123;  console.log(&quot;resolved: &quot;, comments);&#125;, function (err)&#123;  console.log(&quot;rejected: &quot;, err);&#125;);</code></pre><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(  post =&gt; getJSON(post.commentURL)).then(  comments =&gt; console.log(&quot;resolved: &quot;, comments),  err =&gt; console.log(&quot;rejected: &quot;, err));</code></pre><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;  // ...&#125;).catch(function(error) &#123;  // 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#39;发生错误！&#39;, error);&#125;);</code></pre><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p><pre><code class="javascript">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));// 等同于p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</code></pre><p>下面是一个例子。</p><pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;  throw new Error(&#39;test&#39;);&#125;);promise.catch(function(error) &#123;  console.log(error);&#125;);// Error: test</code></pre><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><pre><code class="javascript">// 写法一const promise = new Promise(function(resolve, reject) &#123;  try &#123;    throw new Error(&#39;test&#39;);  &#125; catch(e) &#123;    reject(e);  &#125;&#125;);promise.catch(function(error) &#123;  console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123;  reject(new Error(&#39;test&#39;));&#125;);promise.catch(function(error) &#123;  console.log(error);&#125;);</code></pre><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p><p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;  resolve(&#39;ok&#39;);  throw new Error(&#39;test&#39;);&#125;);promise  .then(function(value) &#123; console.log(value) &#125;)  .catch(function(error) &#123; console.log(error) &#125;);// ok</code></pre><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;  return getJSON(post.commentURL);&#125;).then(function(comments) &#123;  // some code&#125;).catch(function(error) &#123;  // 处理前面三个Promise产生的错误&#125;);</code></pre><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><pre><code class="javascript">// badpromise  .then(function(data) &#123;    // success  &#125;, function(err) &#123;    // error  &#125;);// goodpromise  .then(function(data) &#123; //cb    // success  &#125;)  .catch(function(err) &#123;    // error  &#125;);</code></pre><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><pre><code class="javascript">const someAsyncThing = function() &#123;  return new Promise(function(resolve, reject) &#123;    // 下面一行会报错，因为x没有声明    resolve(x + 2);  &#125;);&#125;;someAsyncThing().then(function() &#123;  console.log(&#39;everything is great&#39;);&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);// Uncaught (in promise) ReferenceError: x is not defined// 123</code></pre><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><pre><code class="javascript">process.on(&#39;unhandledRejection&#39;, function (err, p) &#123;  throw err;&#125;);</code></pre><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p><p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>再看下面的例子。</p><pre><code class="javascript">const promise = new Promise(function (resolve, reject) &#123;  resolve(&#39;ok&#39;);  setTimeout(function () &#123; throw new Error(&#39;test&#39;) &#125;, 0)&#125;);promise.then(function (value) &#123; console.log(value) &#125;);// ok// Uncaught Error: test</code></pre><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><pre><code class="javascript">const someAsyncThing = function() &#123;  return new Promise(function(resolve, reject) &#123;    // 下面一行会报错，因为x没有声明    resolve(x + 2);  &#125;);&#125;;someAsyncThing().catch(function(error) &#123;  console.log(&#39;oh no&#39;, error);&#125;).then(function() &#123;  console.log(&#39;carry on&#39;);&#125;);// oh no [ReferenceError: x is not defined]// carry on</code></pre><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p><pre><code class="javascript">Promise.resolve().catch(function(error) &#123;  console.log(&#39;oh no&#39;, error);&#125;).then(function() &#123;  console.log(&#39;carry on&#39;);&#125;);// carry on</code></pre><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p><p><code>catch()</code>方法之中，还能再抛出错误。</p><pre><code class="javascript">const someAsyncThing = function() &#123;  return new Promise(function(resolve, reject) &#123;    // 下面一行会报错，因为x没有声明    resolve(x + 2);  &#125;);&#125;;someAsyncThing().then(function() &#123;  return someOtherAsyncThing();&#125;).catch(function(error) &#123;  console.log(&#39;oh no&#39;, error);  // 下面一行会报错，因为 y 没有声明  y + 2;&#125;).then(function() &#123;  console.log(&#39;carry on&#39;);&#125;);// oh no [ReferenceError: x is not defined]</code></pre><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><pre><code class="javascript">someAsyncThing().then(function() &#123;  return someOtherAsyncThing();&#125;).catch(function(error) &#123;  console.log(&#39;oh no&#39;, error);  // 下面一行会报错，因为y没有声明  y + 2;&#125;).catch(function(error) &#123;  console.log(&#39;carry on&#39;, error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined]</code></pre><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><pre><code class="javascript">promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;);</code></pre><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><pre><code class="javascript">server.listen(port)  .then(function () &#123;    // ...  &#125;)  .finally(server.stop);</code></pre><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><pre><code class="javascript">promise.finally(() =&gt; &#123;  // 语句&#125;);// 等同于promise.then(  result =&gt; &#123;    // 语句    return result;  &#125;,  error =&gt; &#123;    // 语句    throw error;  &#125;);</code></pre><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><p>它的实现也很简单。</p><pre><code class="javascript">Promise.prototype.finally = function (callback) &#123;  let P = this.constructor;  return this.then(    value  =&gt; P.resolve(callback()).then(() =&gt; value),    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)  );&#125;;</code></pre><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p><pre><code class="javascript">// resolve 的值是 undefinedPromise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// resolve 的值是 2Promise.resolve(2).finally(() =&gt; &#123;&#125;)// reject 的值是 undefinedPromise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// reject 的值是 3Promise.reject(3).finally(() =&gt; &#123;&#125;)</code></pre><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="javascript">const p = Promise.all([p1, p2, p3]);</code></pre><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>下面是一个具体的例子。</p><pre><code class="javascript">// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;  return getJSON(&#39;/post/&#39; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123;  // ...&#125;).catch(function(reason)&#123;  // ...&#125;);</code></pre><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><pre><code class="javascript">const databasePromise = connectDatabase();const booksPromise = databasePromise  .then(findAllBooks);const userPromise = databasePromise  .then(getCurrentUser);Promise.all([  booksPromise,  userPromise]).then(([books, user]) =&gt; pickTopRecommendations(books, user));</code></pre><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#39;hello&#39;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123;  throw new Error(&#39;报错了&#39;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了]</code></pre><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#39;hello&#39;);&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123;  throw new Error(&#39;报错了&#39;);&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了</code></pre><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="javascript">const p = Promise.race([p1, p2, p3]);</code></pre><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><pre><code class="javascript">const p = Promise.race([  fetch(&#39;/resource-that-may-take-a-while&#39;),  new Promise(function (resolve, reject) &#123;    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)  &#125;)]);p.then(console.log).catch(console.error);</code></pre><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p><p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p><pre><code class="javascript">const urls = [url_1, url_2, url_3];const requests = urls.map(x =&gt; fetch(x));try &#123;  await Promise.all(requests);  console.log(&#39;所有请求都成功。&#39;);&#125; catch &#123;  console.log(&#39;至少一个请求失败，其他请求可能还没结束。&#39;);&#125;</code></pre><p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p><p>为了解决这个问题，<a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p><p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p><pre><code class="javascript">const promises = [  fetch(&#39;/api-1&#39;),  fetch(&#39;/api-2&#39;),  fetch(&#39;/api-3&#39;),];await Promise.allSettled(promises);removeLoadingIndicator();</code></pre><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p><p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p><pre><code class="javascript">const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123;  console.log(results);&#125;);// [//    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,//    &#123; status: &#39;rejected&#39;, reason: -1 &#125;// ]</code></pre><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p><p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p><pre><code class="javascript">// 异步操作成功时&#123;status: &#39;fulfilled&#39;, value: value&#125;// 异步操作失败时&#123;status: &#39;rejected&#39;, reason: reason&#125;</code></pre><p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p><p>下面是返回值的用法例子。</p><pre><code class="javascript">const promises = [ fetch(&#39;index.html&#39;), fetch(&#39;https://does-not-exist/&#39;) ];const results = await Promise.allSettled(promises);// 过滤出成功的请求const successfulPromises = results.filter(p =&gt; p.status === &#39;fulfilled&#39;);// 过滤出失败的请求，并输出原因const errors = results  .filter(p =&gt; p.status === &#39;rejected&#39;)  .map(p =&gt; p.reason);</code></pre><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><pre><code class="javascript">Promise.any([  fetch(&#39;https://v8.dev/&#39;).then(() =&gt; &#39;home&#39;),  fetch(&#39;https://v8.dev/blog&#39;).then(() =&gt; &#39;blog&#39;),  fetch(&#39;https://v8.dev/docs&#39;).then(() =&gt; &#39;docs&#39;)]).then((first) =&gt; &#123;  // 只要有一个 fetch() 请求成功  console.log(first);&#125;).catch((error) =&gt; &#123; // 所有三个 fetch() 全部请求失败  console.log(error);&#125;);</code></pre><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p><p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p><pre><code class="javascript">const promises = [  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),];try &#123;  const first = await Promise.any(promises);  console.log(first);&#125; catch (error) &#123;  console.log(error);&#125;</code></pre><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><p><code>Promise.any()</code>抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><pre><code class="javascript">// new AggregateError() extends Arrayconst err = new AggregateError();err.push(new Error(&quot;first error&quot;));err.push(new Error(&quot;second error&quot;));// ...throw err;</code></pre><p>下面是一个例子。</p><pre><code class="javascript">var resolved = Promise.resolve(42);var rejected = Promise.reject(-1);var alsoRejected = Promise.reject(Infinity);Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;  console.log(result); // 42&#125;);Promise.any([rejected, alsoRejected]).catch(function (results) &#123;  console.log(results); // [-1, Infinity]&#125;);</code></pre><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><pre><code class="javascript">const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));</code></pre><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><pre><code class="javascript">Promise.resolve(&#39;foo&#39;)// 等价于new Promise(resolve =&gt; resolve(&#39;foo&#39;))</code></pre><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><pre><code class="javascript">let thenable = &#123;  then: function(resolve, reject) &#123;    resolve(42);  &#125;&#125;;</code></pre><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><pre><code class="javascript">let thenable = &#123;  then: function(resolve, reject) &#123;    resolve(42);  &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123;  console.log(value);  // 42&#125;);</code></pre><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p><p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><pre><code class="javascript">const p = Promise.resolve(&#39;Hello&#39;);p.then(function (s) &#123;  console.log(s)&#125;);// Hello</code></pre><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><pre><code class="javascript">const p = Promise.resolve();p.then(function () &#123;  // ...&#125;);</code></pre><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><pre><code class="javascript">setTimeout(function () &#123;  console.log(&#39;three&#39;);&#125;, 0);Promise.resolve().then(function () &#123;  console.log(&#39;two&#39;);&#125;);console.log(&#39;one&#39;);// one// two// three</code></pre><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><pre><code class="javascript">const p = Promise.reject(&#39;出错了&#39;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))p.then(null, function (s) &#123;  console.log(s)&#125;);// 出错了</code></pre><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><pre><code class="javascript">Promise.reject(&#39;出错了&#39;).catch(e =&gt; &#123;  console.log(e === &#39;出错了&#39;)&#125;)// true</code></pre><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><pre><code class="javascript">const preloadImage = function (path) &#123;  return new Promise(function (resolve, reject) &#123;    const image = new Image();    image.onload  = resolve;    image.onerror = reject;    image.src = path;  &#125;);&#125;;</code></pre><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><pre><code class="javascript">function getFoo () &#123;  return new Promise(function (resolve, reject)&#123;    resolve(&#39;foo&#39;);  &#125;);&#125;const g = function* () &#123;  try &#123;    const foo = yield getFoo();    console.log(foo);  &#125; catch (e) &#123;    console.log(e);  &#125;&#125;;function run (generator) &#123;  const it = generator();  function go(result) &#123;    if (result.done) return result.value;    return result.value.then(function (value) &#123;      return go(it.next(value));    &#125;, function (error) &#123;      return go(it.throw(error));    &#125;);  &#125;  go(it.next());&#125;run(g);</code></pre><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><pre><code class="javascript">Promise.resolve().then(f)</code></pre><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);Promise.resolve().then(f);console.log(&#39;next&#39;);// next// now</code></pre><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);(async () =&gt; f())();console.log(&#39;next&#39;);// now// next</code></pre><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><pre><code class="javascript">(async () =&gt; f())().then(...)</code></pre><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><pre><code class="javascript">(async () =&gt; f())().then(...).catch(...)</code></pre><p>第二种写法是使用<code>new Promise()</code>。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);(  () =&gt; new Promise(    resolve =&gt; resolve(f())  ))();console.log(&#39;next&#39;);// now// next</code></pre><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);Promise.try(f);console.log(&#39;next&#39;);// now// next</code></pre><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p><pre><code class="javascript">function getUsername(userId) &#123;  return database.users.get(&#123;id: userId&#125;)  .then(function(user) &#123;    return user.name;  &#125;);&#125;</code></pre><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><pre><code class="javascript">database.users.get(&#123;id: userId&#125;).then(...).catch(...)</code></pre><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><pre><code class="javascript">try &#123;  database.users.get(&#123;id: userId&#125;)  .then(...)  .catch(...)&#125; catch (e) &#123;  // ...&#125;</code></pre><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><pre><code class="javascript">Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))  .then(...)  .catch(...)</code></pre><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6-proxy</title>
      <link href="/2022/09/04/1.proxy/"/>
      <url>/2022/09/04/1.proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><ol><li><a href="https://es6.ruanyifeng.com/#docs/proxy#%E6%A6%82%E8%BF%B0">概述</a></li><li>[Proxy 实例的方法](<a href="https://es6.ruanyifeng.com/#docs/proxy#Proxy">https://es6.ruanyifeng.com/#docs/proxy#Proxy</a> 实例的方法)</li><li><a href="https://es6.ruanyifeng.com/#docs/proxy#Proxy.revocable()">Proxy.revocable()</a></li><li>[this 问题](<a href="https://es6.ruanyifeng.com/#docs/proxy#this">https://es6.ruanyifeng.com/#docs/proxy#this</a> 问题)</li><li>[实例：Web 服务的客户端](<a href="https://es6.ruanyifeng.com/#docs/proxy#%E5%AE%9E%E4%BE%8B%EF%BC%9AWeb">https://es6.ruanyifeng.com/#docs/proxy#实例：Web</a> 服务的客户端)</li></ol><p><a href="https://wx.kaikeba.com/xiaoke/market/landing-page/v2/N3MIpFtF2DZ91C502gp?kol_ad_code=kKx4Fnfd9ENkHgIfwHb">【课程消息】《Vue 3.0 核心源码与实战》带大家动手，从零开发网页游戏《飞机大战》，快速上手 Vue 3.0 项目。开课吧的课程资料，现在 0 元领取。</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><pre><code class="javascript">var obj = new Proxy(&#123;&#125;, &#123;  get: function (target, propKey, receiver) &#123;    console.log(`getting $&#123;propKey&#125;!`);    return Reflect.get(target, propKey, receiver);  &#125;,  set: function (target, propKey, value, receiver) &#123;    console.log(`setting $&#123;propKey&#125;!`);    return Reflect.set(target, propKey, value, receiver);  &#125;&#125;);</code></pre><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><pre><code class="javascript">obj.count = 1//  setting count!++obj.count//  getting count!//  setting count!//  2</code></pre><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><pre><code class="javascript">var proxy = new Proxy(target, handler);</code></pre><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面是另一个拦截读取属性行为的例子。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, propKey) &#123;    return 35;  &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35</code></pre><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p><pre><code class="javascript">var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = &#39;b&#39;;target.a // &quot;b&quot;</code></pre><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p><p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p><pre><code class="javascript">var object = &#123; proxy: new Proxy(target, handler) &#125;;</code></pre><p>Proxy 实例也可以作为其他对象的原型对象。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, propKey) &#123;    return 35;  &#125;&#125;);let obj = Object.create(proxy);obj.time // 35</code></pre><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><pre><code class="javascript">var handler = &#123;  get: function(target, name) &#123;    if (name === &#39;prototype&#39;) &#123;      return Object.prototype;    &#125;    return &#39;Hello, &#39; + name;  &#125;,  apply: function(target, thisBinding, args) &#123;    return args[0];  &#125;,  construct: function(target, args) &#123;    return &#123;value: args[1]&#125;;  &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123;  return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1, 2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo === &quot;Hello, foo&quot; // true</code></pre><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><pre><code class="javascript">var person = &#123;  name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123;  get: function(target, propKey) &#123;    if (propKey in target) &#123;      return target[propKey];    &#125; else &#123;      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);    &#125;  &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误</code></pre><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p><p><code>get</code>方法可以继承。</p><pre><code class="javascript">let proto = new Proxy(&#123;&#125;, &#123;  get(target, propertyKey, receiver) &#123;    console.log(&#39;GET &#39; + propertyKey);    return target[propertyKey];  &#125;&#125;);let obj = Object.create(proto);obj.foo // &quot;GET foo&quot;</code></pre><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><pre><code class="javascript">function createArray(...elements) &#123;  let handler = &#123;    get(target, propKey, receiver) &#123;      let index = Number(propKey);      if (index &lt; 0) &#123;        propKey = String(target.length + index);      &#125;      return Reflect.get(target, propKey, receiver);    &#125;  &#125;;  let target = [];  target.push(...elements);  return new Proxy(target, handler);&#125;let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);arr[-1] // c</code></pre><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><pre><code class="javascript">var pipe = function (value) &#123;  var funcStack = [];  var oproxy = new Proxy(&#123;&#125; , &#123;    get : function (pipeObject, fnName) &#123;      if (fnName === &#39;get&#39;) &#123;        return funcStack.reduce(function (val, fn) &#123;          return fn(val);        &#125;,value);      &#125;      funcStack.push(window[fnName]);      return oproxy;    &#125;  &#125;);  return oproxy;&#125;var double = n =&gt; n * 2;var pow    = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;pipe(3).double.pow.reverseInt.get; // 63</code></pre><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p><pre><code class="javascript">const dom = new Proxy(&#123;&#125;, &#123;  get(target, property) &#123;    return function(attrs = &#123;&#125;, ...children) &#123;      const el = document.createElement(property);      for (let prop of Object.keys(attrs)) &#123;        el.setAttribute(prop, attrs[prop]);      &#125;      for (let child of children) &#123;        if (typeof child === &#39;string&#39;) &#123;          child = document.createTextNode(child);        &#125;        el.appendChild(child);      &#125;      return el;    &#125;  &#125;&#125;);const el = dom.div(&#123;&#125;,  &#39;Hello, my name is &#39;,  dom.a(&#123;href: &#39;//example.com&#39;&#125;, &#39;Mark&#39;),  &#39;. I like:&#39;,  dom.ul(&#123;&#125;,    dom.li(&#123;&#125;, &#39;The web&#39;),    dom.li(&#123;&#125;, &#39;Food&#39;),    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)  ));document.body.appendChild(el);</code></pre><p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, key, receiver) &#123;    return receiver;  &#125;&#125;);proxy.getReceiver === proxy // true</code></pre><p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p><pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;  get: function(target, key, receiver) &#123;    return receiver;  &#125;&#125;);const d = Object.create(proxy);d.a === d // true</code></pre><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;  foo: &#123;    value: 123,    writable: false,    configurable: false  &#125;,&#125;);const handler = &#123;  get(target, propKey) &#123;    return &#39;abc&#39;;  &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo// TypeError: Invariant check failed</code></pre><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p><pre><code class="javascript">let validator = &#123;  set: function(obj, prop, value) &#123;    if (prop === &#39;age&#39;) &#123;      if (!Number.isInteger(value)) &#123;        throw new TypeError(&#39;The age is not an integer&#39;);      &#125;      if (value &gt; 200) &#123;        throw new RangeError(&#39;The age seems invalid&#39;);      &#125;    &#125;    // 对于满足条件的 age 属性以及其他属性，直接保存    obj[prop] = value;    return true;  &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &#39;young&#39; // 报错person.age = 300 // 报错</code></pre><p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p><pre><code class="javascript">const handler = &#123;  get (target, key) &#123;    invariant(key, &#39;get&#39;);    return target[key];  &#125;,  set (target, key, value) &#123;    invariant(key, &#39;set&#39;);    target[key] = value;    return true;  &#125;&#125;;function invariant (key, action) &#123;  if (key[0] === &#39;_&#39;) &#123;    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);  &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private &quot;_prop&quot; propertyproxy._prop = &#39;c&#39;// Error: Invalid attempt to set private &quot;_prop&quot; property</code></pre><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><p>下面是<code>set</code>方法第四个参数的例子。</p><pre><code class="javascript">const handler = &#123;  set: function(obj, prop, value, receiver) &#123;    obj[prop] = receiver;    return true;  &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);proxy.foo = &#39;bar&#39;;proxy.foo === proxy // true</code></pre><p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p><pre><code class="javascript">const handler = &#123;  set: function(obj, prop, value, receiver) &#123;    obj[prop] = receiver;    return true;  &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);const myObj = &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo = &#39;bar&#39;;myObj.foo === myObj // true</code></pre><p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p><p>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</p><pre><code class="javascript">const obj = &#123;&#125;;Object.defineProperty(obj, &#39;foo&#39;, &#123;  value: &#39;bar&#39;,  writable: false&#125;);const handler = &#123;  set: function(obj, prop, value, receiver) &#123;    obj[prop] = &#39;baz&#39;;    return true;  &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = &#39;baz&#39;;proxy.foo // &quot;bar&quot;</code></pre><p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p><p>注意，<code>set</code>代理应当返回一个布尔值。严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p><pre><code class="javascript">&#39;use strict&#39;;const handler = &#123;  set: function(obj, prop, value, receiver) &#123;    obj[prop] = receiver;    // 无论有没有下面这一行，都会报错    return false;  &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);proxy.foo = &#39;bar&#39;;// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;</code></pre><p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p><p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><pre><code class="javascript">var handler = &#123;  apply (target, ctx, args) &#123;    return Reflect.apply(...arguments);  &#125;&#125;;</code></pre><p>下面是一个例子。</p><pre><code class="javascript">var target = function () &#123; return &#39;I am the target&#39;; &#125;;var handler = &#123;  apply: function () &#123;    return &#39;I am the proxy&#39;;  &#125;&#125;;var p = new Proxy(target, handler);p()// &quot;I am the proxy&quot;</code></pre><p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p><p>下面是另外一个例子。</p><pre><code class="javascript">var twice = &#123;  apply (target, ctx, args) &#123;    return Reflect.apply(...arguments) * 2;  &#125;&#125;;function sum (left, right) &#123;  return left + right;&#125;;var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30</code></pre><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p><p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p><pre><code class="javascript">Reflect.apply(proxy, null, [9, 10]) // 38</code></pre><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p><p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p><p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p><pre><code class="javascript">var handler = &#123;  has (target, key) &#123;    if (key[0] === &#39;_&#39;) &#123;      return false;    &#125;    return key in target;  &#125;&#125;;var target = &#123; _prop: &#39;foo&#39;, prop: &#39;foo&#39; &#125;;var proxy = new Proxy(target, handler);&#39;_prop&#39; in proxy // false</code></pre><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p><p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p><pre><code class="javascript">var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123;  has: function(target, prop) &#123;    return false;  &#125;&#125;);&#39;a&#39; in p // TypeError is thrown</code></pre><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p><p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p><p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p><pre><code class="javascript">let stu1 = &#123;name: &#39;张三&#39;, score: 59&#125;;let stu2 = &#123;name: &#39;李四&#39;, score: 99&#125;;let handler = &#123;  has(target, prop) &#123;    if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;      console.log(`$&#123;target.name&#125; 不及格`);      return false;    &#125;    return prop in target;  &#125;&#125;let oproxy1 = new Proxy(stu1, handler);let oproxy2 = new Proxy(stu2, handler);&#39;score&#39; in oproxy1// 张三 不及格// false&#39;score&#39; in oproxy2// truefor (let a in oproxy1) &#123;  console.log(oproxy1[a]);&#125;// 张三// 59for (let b in oproxy2) &#123;  console.log(oproxy2[b]);&#125;// 李四// 99</code></pre><p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p><h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p><pre><code class="javascript">const handler = &#123;  construct (target, args, newTarget) &#123;    return new target(...args);  &#125;&#125;;</code></pre><p><code>construct()</code>方法可以接受三个参数。</p><ul><li><code>target</code>：目标对象。</li><li><code>args</code>：构造函数的参数数组。</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li></ul><pre><code class="javascript">const p = new Proxy(function () &#123;&#125;, &#123;  construct: function(target, args) &#123;    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));    return &#123; value: args[0] * 10 &#125;;  &#125;&#125;);(new p(1)).value// &quot;called: 1&quot;// 10</code></pre><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p><pre><code class="javascript">const p = new Proxy(function() &#123;&#125;, &#123;  construct: function(target, argumentsList) &#123;    return 1;  &#125;&#125;);new p() // 报错// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)</code></pre><p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p><pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;  construct: function(target, argumentsList) &#123;    return &#123;&#125;;  &#125;&#125;);new p() // 报错// Uncaught TypeError: p is not a constructor</code></pre><p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p><p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p><pre><code class="javascript">const handler = &#123;  construct: function(target, args) &#123;    console.log(this === handler);    return new target(...args);  &#125;&#125;let p = new Proxy(function () &#123;&#125;, handler);new p() // true</code></pre><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><pre><code class="javascript">var handler = &#123;  deleteProperty (target, key) &#123;    invariant(key, &#39;delete&#39;);    delete target[key];    return true;  &#125;&#125;;function invariant (key, action) &#123;  if (key[0] === &#39;_&#39;) &#123;    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);  &#125;&#125;var target = &#123; _prop: &#39;foo&#39; &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private &quot;_prop&quot; property</code></pre><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p><pre><code class="javascript">var handler = &#123;  defineProperty (target, key, descriptor) &#123;    return false;  &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = &#39;bar&#39; // 不会生效</code></pre><p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p><p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p><pre><code class="javascript">var handler = &#123;  getOwnPropertyDescriptor (target, key) &#123;    if (key[0] === &#39;_&#39;) &#123;      return;    &#125;    return Object.getOwnPropertyDescriptor(target, key);  &#125;&#125;;var target = &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)// undefinedObject.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)// undefinedObject.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)// &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;</code></pre><p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p>下面是一个例子。</p><pre><code class="javascript">var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123;  getPrototypeOf(target) &#123;    return proto;  &#125;&#125;);Object.getPrototypeOf(p) === proto // true</code></pre><p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p><p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p><pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;  isExtensible: function(target) &#123;    console.log(&quot;called&quot;);    return true;  &#125;&#125;);Object.isExtensible(p)// &quot;called&quot;// true</code></pre><p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p><p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p><pre><code class="javascript">Object.isExtensible(proxy) === Object.isExtensible(target)</code></pre><p>下面是一个例子。</p><pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;  isExtensible: function(target) &#123;    return false;  &#125;&#125;);Object.isExtensible(p)// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)</code></pre><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for...in</code>循环</li></ul><p>下面是拦截<code>Object.keys()</code>的例子。</p><pre><code class="javascript">let target = &#123;  a: 1,  b: 2,  c: 3&#125;;let handler = &#123;  ownKeys(target) &#123;    return [&#39;a&#39;];  &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy)// [ &#39;a&#39; ]</code></pre><p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p><p>下面的例子是拦截第一个字符为下划线的属性名。</p><pre><code class="javascript">let target = &#123;  _bar: &#39;foo&#39;,  _prop: &#39;bar&#39;,  prop: &#39;baz&#39;&#125;;let handler = &#123;  ownKeys (target) &#123;    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;);  &#125;&#125;;let proxy = new Proxy(target, handler);for (let key of Object.keys(proxy)) &#123;  console.log(target[key]);&#125;// &quot;baz&quot;</code></pre><p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p><ul><li>目标对象上不存在的属性</li><li>属性名为 Symbol 值</li><li>不可遍历（<code>enumerable</code>）的属性</li></ul><pre><code class="javascript">let target = &#123;  a: 1,  b: 2,  c: 3,  [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;,&#125;;Object.defineProperty(target, &#39;key&#39;, &#123;  enumerable: false,  configurable: true,  writable: true,  value: &#39;static&#39;&#125;);let handler = &#123;  ownKeys(target) &#123;    return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;];  &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy)// [&#39;a&#39;]</code></pre><p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p><p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p><pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;  ownKeys: function(target) &#123;    return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  &#125;&#125;);Object.getOwnPropertyNames(p)// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]</code></pre><p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p><pre><code class="javascript">const obj = &#123; hello: &#39;world&#39; &#125;;const proxy = new Proxy(obj, &#123;  ownKeys: function () &#123;    return [&#39;a&#39;, &#39;b&#39;];  &#125;&#125;);for (let key in proxy) &#123;  console.log(key); // 没有任何输出&#125;</code></pre><p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p><p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p><pre><code class="javascript">var obj = &#123;&#125;;var p = new Proxy(obj, &#123;  ownKeys: function(target) &#123;    return [123, true, undefined, null, &#123;&#125;, []];  &#125;&#125;);Object.getOwnPropertyNames(p)// Uncaught TypeError: 123 is not a valid property name</code></pre><p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p><p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p><pre><code class="javascript">var obj = &#123;&#125;;Object.defineProperty(obj, &#39;a&#39;, &#123;  configurable: false,  enumerable: true,  value: 10 &#125;);var p = new Proxy(obj, &#123;  ownKeys: function(target) &#123;    return [&#39;b&#39;];  &#125;&#125;);Object.getOwnPropertyNames(p)// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39;</code></pre><p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p><p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p><pre><code class="javascript">var obj = &#123;  a: 1&#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123;  ownKeys: function(target) &#123;    return [&#39;a&#39;, &#39;b&#39;];  &#125;&#125;);Object.getOwnPropertyNames(p)// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible</code></pre><p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;  preventExtensions: function(target) &#123;    return true;  &#125;&#125;);Object.preventExtensions(proxy)// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible</code></pre><p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p><p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;  preventExtensions: function(target) &#123;    console.log(&#39;called&#39;);    Object.preventExtensions(target);    return true;  &#125;&#125;);Object.preventExtensions(proxy)// &quot;called&quot;// Proxy &#123;&#125;</code></pre><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p><p>下面是一个例子。</p><pre><code class="javascript">var handler = &#123;  setPrototypeOf (target, proto) &#123;    throw new Error(&#39;Changing the prototype is forbidden&#39;);  &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden</code></pre><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p><h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p><pre><code class="javascript">let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked</code></pre><p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><pre><code class="javascript">const target = &#123;  m: function () &#123;    console.log(this === proxy);  &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m()  // true</code></pre><p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。所以，虽然<code>proxy</code>没有做任何拦截，<code>target.m()</code>和<code>proxy.m()</code>返回不一样的结果。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p><pre><code class="javascript">const _name = new WeakMap();class Person &#123;  constructor(name) &#123;    _name.set(this, name);  &#125;  get name() &#123;    return _name.get(this);  &#125;&#125;const jane = new Person(&#39;Jane&#39;);jane.name // &#39;Jane&#39;const proxy = new Proxy(jane, &#123;&#125;);proxy.name // undefined</code></pre><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p><pre><code class="javascript">const target = new Date();const handler = &#123;&#125;;const proxy = new Proxy(target, handler);proxy.getDate();// TypeError: this is not a Date object.</code></pre><p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><pre><code class="javascript">const target = new Date(&#39;2015-01-01&#39;);const handler = &#123;  get(target, prop) &#123;    if (prop === &#39;getDate&#39;) &#123;      return target.getDate.bind(target);    &#125;    return Reflect.get(target, prop);  &#125;&#125;;const proxy = new Proxy(target, handler);proxy.getDate() // 1</code></pre><p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p><pre><code class="javascript">const handler = &#123;  get: function (target, key, receiver) &#123;    console.log(this === handler);    return &#39;Hello, &#39; + key;  &#125;,  set: function (target, key, value) &#123;    console.log(this === handler);    target[key] = value;    return true;  &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);proxy.foo// true// Hello, fooproxy.foo = 1// true</code></pre><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p><h2 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p><pre><code class="javascript">const service = createWebService(&#39;http://example.com/data&#39;);service.employees().then(json =&gt; &#123;  const employees = JSON.parse(json);  // ···&#125;);</code></pre><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><pre><code class="javascript">function createWebService(baseUrl) &#123;  return new Proxy(&#123;&#125;, &#123;    get(target, propKey, receiver) &#123;      return () =&gt; httpGet(baseUrl + &#39;/&#39; + propKey);    &#125;  &#125;);&#125;</code></pre><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS-隐式类型转换</title>
      <link href="/2022/09/04/result/"/>
      <url>/2022/09/04/result/</url>
      
        <content type="html"><![CDATA[<p><code>[] == 0</code> //返回结果是 true<br><code>![] == 0</code> //返回结果是 true<br>[] == ‘’ //返回结果是 true<br>!![] == ‘’ //返回结果是 false<br>‘’ == true //返回结果是 false</p><p>隐式转换内容：<a href="https://blog.csdn.net/u014465934/article/details/84642329">https://blog.csdn.net/u014465934/article/details/84642329</a><br>不建议在开发中使用==与 let，let 应极力避免。而且应该在开发中避免隐式转换的使用，方便自己也方便他人的代码阅读</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SVN-修改svn密码</title>
      <link href="/2022/09/02/01%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/09/02/01%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>修改svn密码:<br> 办法1：<br>SVN的密码保存在服务器上，一般能通过Web方式修改密码（前提是服务器上安装了SVNManager或者其它的PHP或者CGI程序）<br>如果SVN是和Apache一起使用的话，可以找到Apache目录下的 conf\httpd.conf文件，里面的&lt;Location /svn&gt;段中 AuthUserFile 指定的就是用户密码文件，是文本形式的，密码用MD5加密。<br>如果不是SVN，那就找SVN库下的conf/passwd文件，是文本文件，密码未加密</p><p> 办法2：<br>TortoiseSVN更改用户名密码<br>在项目上右键，选择TortoiseSVN–&gt;settings,在弹出的TortoiseSVN Settings页面中选择“Saved Data”选项，然后点击“Authentication data”对应的“Clear”按钮，清除一下之前的认证信息就可以了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git-git常用操作命令</title>
      <link href="/2022/09/02/01%20git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/02/01%20git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><pre><code>git add</code></pre><blockquote><p>新增文件</p></blockquote><pre><code>git commit -m</code></pre><blockquote><p>新增日志</p></blockquote><pre><code>git log</code></pre><blockquote><p>查看日志</p></blockquote><pre><code>git reflog</code></pre><blockquote><p>查看日志操作日志哦</p></blockquote><pre><code>git status</code></pre><blockquote><p>查看状态</p></blockquote><pre><code>git diff</code></pre><blockquote><p>查看不同</p></blockquote><pre><code>gid reset --hard +&quot;版本号&quot;</code></pre><blockquote><p>回退版本</p></blockquote><pre><code>git clone url</code></pre><p>​ 克隆需远程仓库的地址 url</p><pre><code>gitk</code></pre><p>查看代码图解</p><pre><code>git checkout  -b  name</code></pre><p>创建分支前先在本地切换到 develop 分支并且 pull 一下此时分支为 develop，然后进行下面指令操作本地创建新分支</p><pre><code>git checkout -b name origin/develop</code></pre><p>创建远程已有分支，远程分支是以 develop 复制创建的</p><pre><code>git branch</code></pre><p>查看当前分支</p><pre><code>git checkout  name</code></pre><p>切换分支</p><pre><code>git pull</code></pre><p>拉去远程代码</p><pre><code>git merge</code></pre><p>合并代码，交叉合并</p><pre><code>git merge  --no-ff</code></pre><p>合并代码，交叉合并</p><pre><code>git rebase</code></pre><p>合并代码，不产生交叉合并</p><pre><code>git fetch  origin</code></pre><p>分支名 从远程仓库拉取到本地：</p><pre><code>git fetch</code></pre><p>分支名 从远程仓库中抓取与拉去</p><pre><code>git push origin master</code></pre><p>提交到远程仓库 master 上</p><pre><code>git  config -l</code></pre><p>查看 git 名字和 email</p><pre><code>git config --global  user.name &#39;mingzi&#39;</code></pre><p>修改用户名</p><pre><code>git config --global   user.email &#39;邮箱地址&#39;</code></pre><p>修改邮箱地址</p><pre><code>git remote rm origin</code></pre><p>​ 删除远程 Git 仓库</p><pre><code>git remote add origin https:......git</code></pre><p>​ 本地项目关联远程仓库</p><p>运行</p><pre><code>git fetch</code></pre><p>，可以将远程分支信息获取到本地，再运行</p><pre><code>git checkout -b local-branchname origin/remote_branchname</code></pre><p>就可以将远程分支映射到本地命名为 local-branchname 的一分支</p><pre><code>git branch --set-upstream-to=origin/dev</code></pre><p>设置</p><pre><code>git push,pul</code></pre><p>l 默认的提交获取分支,这样就很方便的使用 git push 提交信息或 git pull 获取信息</p><pre><code> git branch --unset-upstream master</code></pre><p>​ 取消对 master 的跟踪</p><p><em>git</em> <em>config</em> –<em>global</em> <em>gui</em>.<em>encoding</em> <em>utf</em>-<em>8</em> 修改 gitk 乱码现象</p><p><strong>如何放弃本地文件修改</strong></p><p>1.git reset HEAD . 清除已经 git add 缓存的文件</p><p>2.git checkout . 未使用 git add 放弃所有文件修改</p><p>3.git reset –hard HEAD^ 文件已提交 commit，可以回退到上个 commit 版本</p><p>生成安全密钥：</p><p>ssh-keygen -t rsa -C “<a href="mailto:&#x39;&#52;&#x35;&#52;&#x39;&#x37;&#x33;&#52;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x39;&#52;&#x35;&#52;&#x39;&#x37;&#x33;&#52;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>“</p><p>git stash 保存到暂存区</p><p>git stash pop 从暂存区拉去代码</p><p>git cherry-pick 某个commit id  从其他分支拉取commit到本分支上</p><p><strong>PRO GIT</strong></p><p>1.<a href="https://www.progit.cn/">https://www.progit.cn</a> pro git 里面有最全的 git 命令讲解</p><p>修改 git 密码：解决方法三<br>进入控制面板》用户账号》凭据管理器？windows 凭据》普通凭据，在里面找到 git，点开编辑密码，更新为最新密码之后就可以正常操作了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装 TypeScript</title>
      <link href="/2022/08/29/1.%E5%88%9D%E5%A7%8Bts/"/>
      <url>/2022/08/29/1.%E5%88%9D%E5%A7%8Bts/</url>
      
        <content type="html"><![CDATA[<p>1.在线笔记地址<a href="http://huaxhe.gitee.io/vue3_study_docs/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.htm">http://huaxhe.gitee.io/vue3_study_docs/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.htm</a></p><p>2.安装 TypeScript</p><p>命令行运行如下命令，全局安装 TypeScript：</p><pre><code class="bash">npm install -g typescript</code></pre><p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p><pre><code class="bash">tsc -V</code></pre><p>3.<a href="https://vitejs.cn/guide/why.html#slow-updates">https://vitejs.cn/guide/why.html#slow-updates</a>   vite官网</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3-Vue3快速上手</title>
      <link href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve</code></pre><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><pre><code class="bash">## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev</code></pre><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)</code></pre></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><pre><code class="js">new Proxy(data, &#123;    // 拦截读取属性值    get (target, prop) &#123;        return Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;        return Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;        return Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#39;tom&#39;   </code></pre></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><pre><code class="js">import &#123;computed&#125; from &#39;vue&#39;setup()&#123;    ...    //计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#39;-&#39; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#39;-&#39; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#39;-&#39;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;</code></pre></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><pre><code class="js">//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</code></pre></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#39;watchEffect配置的回调执行了&#39;)&#125;)</code></pre></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li></ul><ul><li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre><code class="vue">&lt;template&gt;    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;    import &#123;ref,customRef&#125; from &#39;vue&#39;    export default &#123;        name:&#39;Demo&#39;,        setup()&#123;            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref            //自定义一个myRef            function myRef(value,delay)&#123;                let timer                //通过customRef去实现自定义                return customRef((track,trigger)=&gt;&#123;                    return&#123;                        get()&#123;                            track() //告诉Vue这个value值是需要被“追踪”的                            return value                        &#125;,                        set(newValue)&#123;                            clearTimeout(timer)                            timer = setTimeout(()=&gt;&#123;                                value = newValue                                trigger() //告诉Vue去更新界面                            &#125;,delay)                        &#125;                    &#125;                &#125;)            &#125;            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref            return &#123;                keyword            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre><code class="js">setup()&#123;    ......    let car = reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)    provide(&#39;car&#39;,car)    ......&#125;</code></pre></li><li><p>后代组件中：</p><pre><code class="js">setup(props,context)&#123;    ......    const car = inject(&#39;car&#39;)    return &#123;car&#125;    ......&#125;</code></pre></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><pre><code class="vue">&lt;teleport to=&quot;移动位置&quot;&gt;    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;</code></pre></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre><code class="js">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))</code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre><code class="vue">&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;            &lt;template v-slot:default&gt;                &lt;Child/&gt;            &lt;/template&gt;            &lt;template v-slot:fallback&gt;                &lt;h3&gt;加载中.....&lt;/h3&gt;            &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre><code class="js">//注册全局组件Vue.component(&#39;MyButton&#39;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#39;&#125;)//注册全局指令Vue.directive(&#39;focus&#39;, &#123;  inserted: el =&gt; el.focus()&#125;</code></pre></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><pre><code class="css">.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li><li><p>Vue3.x写法</p><pre><code class="css">.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre><code class="vue">&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;</code></pre></li><li><p>子组件中声明自定义事件</p><pre><code class="vue">&lt;script&gt;  export default &#123;    emits: [&#39;close&#39;]  &#125;&lt;/script&gt;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vuex身上的要用Action管理异步操作</title>
      <link href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Action%E7%AE%A1%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Action%E7%AE%A1%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Action 类似于 mutation，不同在于：</p><p>1.Action 提交的是 mutation，而不是直接变更状态。</p><p>2.Action 可以包含任意异步操作。</p><p>  官方给的定义我没什么意见,事实上我通过mutation异步操作,好像跟用action管理也没什么区别。关于为什么要用Action管理异步操作，我会通过一个简单的例子和一个复杂的例子来进行说明，事实上，如果初学者没有考虑到实际场景的复杂情况，会觉得Action根本没有一点软用，这个时候就要把问题想得复杂一些了，然后才能看到Action的作用。</p><p>  先来看一个简单的例子，也是我对如果不用Action进行异步操作的一些初步探索。</p><p>  第一步：我非常作死的重写了mutation状态管理器中对状态操作的一些写法，我使用了异步操作代替了之前的操作。</p><p>// mutation.js<br>const increment = (state) =&gt; {<br>  setTimeout(() =&gt; {<br>    state.count++<br>  }, 1000)<br>}<br>const decrement = (state) =&gt; {<br>  setTimeout(() =&gt; {<br>    state.count–<br>  }, 2000)<br>  state.count–<br>}<br>export {increment, decrement}<br>  第二步：试验一下能否成功</p><template>  <div>    <button @click="decrement">-</button>    <span></span>    <button @click="increment">+</button>  </div></template> <script>import { mapState, mapMutations} from 'vuex'export default {  computed: {    ...mapState(['count'])  },  methods: {    ...mapMutations(['increment', 'decrement']),  }}</script><style> </style><p>  第三步：发现除了每次操作加减时候有一秒的延时，不管你怎么操作，结果都是正确的，是符合社会主义核心价值观的。</p><p> 第四步:用Action处理异步操作（先得把之前作死改掉的mutation的代码改回来）</p><p>// 正常的mutation<br>const increment = (state) =&gt; {<br>  state.count++<br>}<br>const decrement = (state) =&gt; {<br>  state.count–<br>}<br>export {increment, decrement}<br>// action.js处理一些异步操作<br>// Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象<br>let incrementAsync = (content) =&gt; {<br>  setTimeout(() =&gt; {<br>    content.commit(‘increment’)<br>  }, 1000)<br>}<br>let decrementAsync = (content) =&gt; {<br>  setTimeout(() =&gt; {<br>    content.commit(‘decrement’)<br>  }, 1000)<br>}<br>export {incrementAsync, decrementAsync}<br><template><br>  <div><br>    &lt;button @click=”decrementAsync”&gt;-</button><br>    <span></span><br>    &lt;button @click=”incrementAsync”&gt;+</button><br>  </div><br></template></p><script>import { mapState, mapMutations, mapActions } from 'vuex'export default {  computed: {    ...mapState(['count'])  },  methods: {    ...mapMutations(['increment', 'decrement']),    ...mapActions(['incrementAsync', 'decrementAsync']) //这里用了辅助函数，不了解的可以看这个系列的第二篇文章  }}</script><style> </style><p>第五步：测试一下效果，你会感觉跟没有用action直接用mutation的结果一毛一样。再看一下官网说明。</p><p> 所以，官网说的这句话有问题？<br> 确实有问题，因为在mutation中执行异步操作并不会报错，也能正确更改状态，所以并不是所谓的“必须同步执行”这么苛刻，只能说你最好不要这么做。（这里说一句题外话，我初学vuex的时候，大概去年，在mutaition中一旦有异步操作，控制台立马就会有警告，不知道是记错了还是现在删除了这个设定）</p><p>上面的例子可能太过简单，以至于Action看起来都发挥不了什么作用。</p><p>下面来看一个复杂的例子，这个例子有助于理解为什么要用Action管理异步操作<br>需求如下</p><p>state中存储了一个状态，我们还是复用刚才的count</p><p>现在有两个异步操作，他们都能改变count的值</p><p>第二个异步操作的条件依赖第一个异步操作的结果，比如第一个异步操作执行了count ++ ，count :0 = &gt;1，第二个异步操作会先判断当前count的值，if(count === 1) { do something…} else { do something… }</p><p> 当异步操作涉及互相依赖的情况的时候，我们肯定希望被依赖的操作执行完成之后，再执行依赖项，这样能保证程序执行得到正确的结果，但异步操作，如接口访问这种，往往是不能确定执行完成的时间的，</p><p>通常你在接口A中得到一个值，a</p><p>接口B需要使用这个值结合B接口返回的值进行一些判断操作，if(a&amp;&amp;b){ … }</p><p>这个时候如果B接口执行完毕了，A接口的值还没过来的话，就可能得到错误的结果。 a =&gt; undefined</p><p>  所以这里牵扯到了一个异步操作的顺序执行问题，既然是异步操作问题，基本都会用到ES6的promise函数去解决，有兴趣的可以用看一下我的文章——关于promise的一些使用和原理。</p><p>  下面我们重写一下代码</p><p>// Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象<br>let incrementAsync = (content) =&gt; {<br>  return new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; {<br>      content.commit(‘increment’)<br>      resolve()<br>    }, 1000)<br>  })<br>}<br>let decrementAsync = (content) =&gt; {<br>  return new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; {<br>      content.commit(‘decrement’)<br>      resolve()<br>    }, 1000)<br>  })<br>}<br>export {incrementAsync, decrementAsync}</p><template>  <div>    <button @click="dec">-</button>    <span></span>    <button @click="add">+</button>  </div></template> <script>import { mapState, mapMutations, mapActions } from 'vuex'export default {  computed: {    ...mapState(['count'])  },  methods: {    ...mapMutations(['increment', 'decrement']),    ...mapActions(['incrementAsync', 'decrementAsync']),    add () {      this.incrementAsync().then(() => {        this.increment()      })    },    dec () {      this.decrementAsync().then(() => {        // do something      })    }  }}</script><style> </style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vuex-1, vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现</title>
      <link href="/2022/08/29/32vuex/"/>
      <url>/2022/08/29/32vuex/</url>
      
        <content type="html"><![CDATA[<p>1.state<br>  state是什么?</p><p>  定义:state(vuex) ≈ data (vue)</p><p>  vuex的state和vue的data有很多相似之处,都是用于存储一些数据,或者说状态值.这些值都将被挂载 数据和dom的双向绑定事件,也就是当你改变值的时候可以触发dom的更新.</p><p>  虽然state和data有很多相似之处,但state在使用的时候一般被挂载到子组件的computed计算属性上,这样有利于state的值发生改变的时候及时响应给子组件.如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题,那你可以针是一个杠精</p><p>  综上所述,请用computed去接收state,如下</p><p>//state.js<br>let state = {<br>  count: 1,<br>  name: ‘dkr’,<br>  sex: ‘男’,<br>  from: ‘china’<br>}<br>export default state</p><template>  <div id="example">    <button @click="decrement">-</button>            <button @click="increment">+</button>  </div></template><script>export default {  data () {    return {      dataCount: this.$store.state.count //用data接收    }  },  computed:{    count(){      return this.$store.state.count //用computed接收    }  }  methods: {    increment () {      this.$store.commit('increment')    },    decrement () {      this.$store.commit('decrement')    }  }}</script>结果如下,用data接收的值不能及时响应更新,用computed就可以. <p>2.mapState 辅助函数<br>  mapState是什么?</p><p>  表面意思:mapState是state的辅助函数.这么说可能很难理解</p><p>  抽象形容:mapState是state的语法糖,这么说可能你还想骂我,因为你根本不了解什么叫做语法糖,事实上我说的语法糖有自己的定义,什么是语法糖?我对语法糖的理解就是,用之前觉得,我明明已经对一种操作很熟练了,并且这种操作也不存在什么问题,为什么要用所谓的”更好的操作”,用了一段时间后,真香!</p><p>  实际作用:当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键</p><p>  在使用mapState之前,要导入这个辅助函数.</p><p>import { mapState } from ‘vuex’<br>  然后就是使用方式了</p><template>  <div id="example">    <button @click="decrement">-</button>            <button @click="increment">+</button>    <div></div>    <div></div>    <div></div>  </div></template><script>import { mapState } from 'vuex'export default {  data () {    return {      str: '国籍',      dataCount: this.$store.state.count    }  },  computed: mapState({    count: 'count', // 第一种写法    sex: (state) => state.sex, // 第二种写法    from: function (state) { // 用普通函数this指向vue实例,要注意      return this.str + ':' + state.from    },    // 注意下面的写法看起来和上面相同,事实上箭头函数的this指针并没有指向vue实例,因此不要滥用箭头函数    // from: (state) => this.str + ':' + state.from    myCmpted: function () {      // 这里不需要state,测试一下computed的原有用法      return '测试' + this.str    }  }),  methods: {    increment () {      this.$store.commit('increment')    },    decrement () {      this.$store.commit('decrement')    }  },  created () {    // 写个定时器，发现computed依旧保持了只要内部有相关属性发生改变不管是当前实例data中的改变，还是vuex中的值改变都会触发dom和值更新    setTimeout(() => {      this.str = '国家'    }, 1000)  }}</script><p>  在使用的时候,computed接收mapState函数的返回值,你可以用三种方式去接收store中的值,具体可以看注释.</p><p>  事实上第二种和第三种是同一种,只是前者用了ES6的偷懒语法,箭头函数,在偷懒的时候要注意一个问题,this指针的指向问题,我已经在很多篇文章中提到不要在vue中为了偷懒使用箭头函数,会导致很多很难察觉的错误,如果你在用到state的同时还需要借助当前vue实例的this,请务必使用常规写法.</p><p>  当然computed不会因为引入mapState辅助函数而失去原有的功能—用于扩展当前vue的data,只是写法会有一些奇怪,如果你已经写了一大堆的computed计算属性,做了一半发现你要引入vuex,还想使用mapState辅助函数的方便,你可以需要做下列事情.</p><p>//之前的computed<br>computed:{<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……..<br>}<br>//引入mapState辅助函数之后</p><p>computed:mapState({<br>    //先复制粘贴<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……<br>    //再维护vuex<br>    count:’count’<br>    …….<br>})<br>   从上述写法可以看出来,这不符合代码的某些说不明道不清的特性,我们希望我们可以不用去做一些复制粘贴的无用操作,而是直接使用mapState,希望它能自动融入到当前生产环境中,ok,ES6+(或者说ES7)提供了这个方便.</p><p>3 …mapState<br>  事实上…mapState并不是mapState的扩展,而是…对象展开符的扩展.当然如果你把他用在这里会发现他能使得代码看起来变得,更加符合常规逻辑了,为什么这么说,你等下就会知道了.</p><p>  首先,来回顾一下…对象展开符在数组中的表现,这在ES6语法学习分类里有相关说明,如果有兴趣可以关注我的ES6分类中的文章.</p><p>let arr = [1,2,3]<br>console.log(…arr) //1,2,3<br> 然后来看一个例子.</p><p>let MapState = mapState({<br>      count: ‘count’,<br>      sex: (state) =&gt; state.sex<br>    })<br>    let json = {<br>      ‘a’: ‘我是json自带的’,<br>      …MapState<br>    }<br>    console.log(json)<br>这里的json可以成功将mapState return的json格式,和json自带的a属性成功融合成一个新的对象.你可以将这个称为对象混合</p><p>这样,你就可以自由的使用mapState了.</p><p>//之前的computed<br>computed:{<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……..<br>}<br>//引入mapState辅助函数之后</p><p>computed:{<br>    //原来的继续保留<br>    fn1(){ return …},<br>    fn2(){ return …},<br>    fn3(){ return …}<br>    ……<br>    //再维护vuex<br>    …mapState({  //这里的…不是省略号了,是对象扩展符<br>        count:’count’<br>    })<br>}</p><h1 id="vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现"><a href="#vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现" class="headerlink" title="vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现"></a>vuex-persistedstate插件使用解决刷新页面数据丢失问题及简单自定义插件模拟功能实现</h1><p>Vuex 作为一个专为 Vue.js 应用程序开发的<strong>状态管理模式，</strong>在中大型项目中备受青睐，它有着天然的优势：<em>响应式的共享状态</em> 及<em>可跟踪的状态变化。</em>然而它也存在着明显的缺陷：<strong>页面刷新数据丢失</strong>。这非常容易理解，页面刷新重新加载需要重新实例化store：<em>const</em> store = new Vuex.Store({state: {}})，状态当然会变为<a href="https://www.zhihu.com/search?q=%E5%88%9D%E5%A7%8B%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:143181165%7D">初始值</a>。那么如何在刷新页面后保存之前的状态呢？</p><p>一、使用vuex-persistedstate，只需简单的配置即可解决</p><p>1、安装vuex-persistedstate：npm install vuex-persistedstate -s    引入 import createPersistedState from ‘vuex-persistedstate’</p><p>2、实例化store时配置vuex-persistedstate插件：</p><p><img src="https://pic2.zhimg.com/80/v2-02ed572dfa687bee50dec2188cc46379_720w.jpg" alt="img"></p><p>3、选项配置：</p><p>vuex-persistedstate默认会将state缓存在localstorage里：</p><p><img src="https://pic3.zhimg.com/80/v2-0306245559d65005dd26a6fcd4dd10b2_720w.jpg" alt="img"></p><p>这里只给出常用的两个配置选项，<a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/vuex-persistedstate">查看全部配置</a></p><p>（1）指定缓存的位置：storage: window.sessionStorage</p><p>（2）reducer: 指定需要缓存的状态</p><p><img src="https://pic2.zhimg.com/80/v2-3b17a543cffd5c0d49004e1fd06f6079_720w.jpg" alt="img"></p><p>如上图：将<a href="https://www.zhihu.com/search?q=state.user&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:143181165%7D">state.user</a>缓存到本地的sessionStorage。而state.tag并没有缓存，此时，刷新页面后state.user的状态得以保存，而state.tag的数据丢失。</p><p><img src="https://pic1.zhimg.com/80/v2-719583a160d7bbb13dfe8b2689a947d8_720w.jpg" alt="img"></p><p>二、自定义插件简单模拟vuex-persistedstate</p><p>现在我们自定义插件来缓存state.tag。</p><p>（1）缓存state.tag</p><p>Vuex 的 store 接受<code>plugins</code>选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数。</p><p><img src="https://pic1.zhimg.com/80/v2-ff1cbc3f6d5ce63a84e3ad93478d9660_720w.jpg" alt="img"></p><p>（2）初始化Store实例时获取缓存的state.tag</p><p><img src="https://pic1.zhimg.com/80/v2-d0e77e7ce038e7d12ac1e52d2ee86618_720w.jpg" alt="img"></p><p>（3）使用插件</p><p><img src="https://pic2.zhimg.com/80/v2-383a6f70713058cc605ca97e7b580dad_720w.jpg" alt="img"></p><p>（4）查看效果</p><p>刷新页面后state.user和state.tag的状态都得到保存</p><p><img src="https://pic1.zhimg.com/80/v2-5b9d66d6d82d22f69c09db4c25094ebc_720w.jpg" alt="img"></p><p>（5）带参数的插件</p><p>这类似于带参装饰器，即在上述插件函数作为一个带参函数的返回值</p><p><img src="https://pic2.zhimg.com/80/v2-1d9b3735633fdca743465203844c588d_720w.jpg" alt="img"></p><p>使用插件时，调用插件函数并传递参数</p><p><img src="https://pic2.zhimg.com/80/v2-ddb08bc74ef5f5fa16085e3348f6bfb9_720w.jpg" alt="img"></p><p>打开控制台，输出‘带参插件的参数’</p><p><img src="https://pic3.zhimg.com/80/v2-ef685a2062218e8c78e3a5b7967bc656_720w.jpg" alt="img"></p><p>发布于 2020-05-24 14:53</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vuex身上的mutation,mapMutations 辅助函数</title>
      <link href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%20%E7%94%A8Mutation%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81/"/>
      <url>/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%20%E7%94%A8Mutation%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p><p>  关于vuex为什么这样做,先不要管,但请相信他这么做必然有很多的好处.在vue中,我们要修改data中的值,一般会怎么做.</p><p>this.count = 2 //count from 1 to 2,触发视图更新<br>   很简单,直接赋值,这也符合我们写代码的”一般规律”,很舒服.但如果我们要修改vuex store中的状态值,我们就不能简单的通过赋值的方式来做了,如果你这样做,控制台便会报错.</p><p>this.$store.state.count = 2 //控制台打印错误<br>   当然vuex的state是可以更改的,不然就太睿智了,vuex提供了mutation来追踪你对state的值的操作,这肯定有什么好处在里面,暂时先把为什么放一边,先了解一下mutation的用法.</p><p>   Vuex 中的 mutation 非常类似于vue中的$emit事件,</p><p>   每个 mutation 都有一个字符串的事件类型 (type) ,相当于当前事件的唯一标识,以便于你用commit触发它.</p><p>   每个mutation都有一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数.同时他也支持额外参数的传入,额外参数的术语叫’载荷’.</p><p>  直接看代码和注释吧,不想过多解释这个</p><p>//state.js<br>let state = {<br>  count: 1,<br>  name: ‘dkr’,<br>}<br>export default state</p><p>//mutation.js<br>// 第一个参数默认接收state对象<br>const increment = (state) =&gt; {<br>  state.count++<br>}<br>const decrement = (state) =&gt; {<br>  state.count–<br>}<br>//第二个参数接收’载荷’<br>const add = (state, n) =&gt; {<br>  state.count += n<br>}<br>const fn = (state, json) =&gt; {<br>  state.name = json.first + json.second + state.name<br>}<br>export {increment, decrement, add, fn}</p><template>  <div>    <div>      <button @click="decrement">-</button>      <span></span>      <button @click="increment">+</button>    </div>    <div style="margin-top:20px;">      <button @click="add(1)">+1</button>      <button @click="add(2)">+2</button>    </div>    <button style="margin-top:20px" @click = "changeName('my ','name is ')"></button>  </div></template> <script>export default {  computed: {    count () {      return this.$store.state.count    },    name () {      return this.$store.state.name    }  },  methods: {    decrement () {      this.$store.commit('decrement')    },    increment () {      this.$store.commit('increment')    },    add (n) {      // 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）      this.$store.commit('add', n)    },    changeName (first, second) {      // this.$store.commit('fn', {      //   'first': first,      //   'second': second      // })      // 上面的写法等同于下面，对象风格的提交方式，个人觉得上面的写法更清晰      this.$store.commit({        'type': 'fn',        'first': first,        'second': second      })    }  }}</script><p>结果如下:</p><p>关于mutation的辅助函数,我这里提供一下上述代码的辅助函数写法,具体原理请看本系列第二篇文章,不想过多赘述.</p><template>  <div>    <div>      <button @click="decrement">-</button>      <span></span>      <button @click="increment">+</button>    </div>    <div style="margin-top:20px;">      <button @click="add(1)">+1</button>      <button @click="add(2)">+2</button>    </div>    <button style="margin-top:20px" @click = "changeName({'first':'my ',second:'name is '})"></button>  </div></template> <script>import { mapMutations } from 'vuex'export default {  computed: {    count () {      return this.$store.state.count    },    name () {      return this.$store.state.name    }  },  // 辅助函数写法  methods: {    ...mapMutations({      decrement: 'decrement',      increment: 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`      add: 'add',      changeName: 'fn' // 将 `this.changeName(json)` 映射为 `this.$store.commit('fn', json)`    })  }}</script><style> </style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vuex身上的getters,mapGetters 辅助函数</title>
      <link href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%20getters,mapGetters,...mapGetters%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%20getters,mapGetters,...mapGetters%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>  Vuex提供了state这样的状态统一管理树,你可以在vue中用computed计算属性接收这些公共状态,以便使用,当然你也可以在接收原值的基础上对这个值做出一些改造,如</p><p>computed:{<br>  sex:function(){<br>      return this.$store.state.sex + ‘加个字符串,算是改造’<br>  }<br>}<br>  但是如果你的其他组件也要使用这种改造方式去改造这个值,那你可能不得不去复制粘贴这个函数到别的组件中,当然,为了解决这个问题,vuex本身就提供了类似于计算属性的方式,getters可以让你从store的state中派生出一些新的状态,当然如果不是多个组件要用到这个状态,或者说每个子组件用到的派生属性不一样,那么,你完全可以不用getters.(这里多说一句吧,vuex的出现是为了解决组件间的通信问题,如果你的操作或者数据不涉及到公共操作,只是单一组件操作,请务必不要把这些状态值或者function存储到vuex中,因为vuex会把自身挂载到所有组件上,不管当前组件是否用到里面的东西,因此这事实上肯定增加了性能的损耗,注意是肯定,因为你很难保证每个子组件都用到同一个状态,除非是路由这样的特殊状态,当然路由的事情也无需归vuex管理,在后面vue-router系列中会讲到.)</p><p>1.getters<br>  Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。说白了就是vue的computed,如果你了解computed的话,那你可以像使用computed一样去使用getters,当然还是有点区别的.</p><p>//state.js<br>let state = {<br>  from: ‘china’,<br>  arr: [2, 3, 1, 4, 6]<br>}<br>export default state<br>// getters.js<br>// 第一个参数是state<br>let address = (state) =&gt; {<br>  return ‘国籍:’ + state.from<br>}<br>// 第二个参数可以访问getters<br>let addressMore = (state, getters) =&gt; {<br>  return ‘其他描述’ + getters.address<br>}<br>// return 一个function,这个function可以传参,当然这个function最后会返回一个具体的数值<br>//本例中这个方法用于查询state中的arr数组是否存在某个值<br>let findArr = (state) =&gt; (number) =&gt; {<br>  let ifExit = state.arr.find((n) =&gt; n === number) // arr.find是ES6语法中数组的扩展<br>  if (typeof (ifExit) === ‘undefined’) {<br>    return false<br>  } else {<br>    return true<br>  }<br>}<br>export {address, addressMore, findArr}<br>  关于getters如何使用,可以看一下上面代码的注释,这里我重点介绍一下getters和computed的不同,就是上面的第三种用法,我之前在vue进阶系列中探讨过computed，filters两种数据处理工具的局限性,有兴趣的可以去看这篇文章,computed的一个缺点就是不能传参,假设你要去判断一个数组里是否存在某个值,那你没法将某个值传到computed中去,这其实是一个很蛋疼的事情,当然你可以通过某些特殊手段,这里我不展开,有兴趣的可以留言.而getters则没有这个烦恼,有些对ES6语法使用较为吃力的同学可以看下面的简易版本,来看看findArr究竟做了什么.</p><p>let findArr = function(state){<br>  // 返回一个匿名函数<br>  return function(number){<br>    // 如果有相同的则返回n，如果找不到则返回undefined<br>    let ifExit = state.arr.find(function(n){<br>      return n===number<br>    })<br>    if (typeof (ifExit) === ‘undefined’) {<br>      return false<br>    } else {<br>      return true<br>    }<br>  }<br>}<br>  最后我们在子组件中展示一下效果</p><template>  <div>    <div></div>    <div></div>  </div></template><script>// import { mapGetters } from 'vuex'export default {  computed: {    from: function () {      return this.$store.getters.address    },    from2: function () {      return this.$store.getters.addressMore    }  },  created () {    console.log(this.$store.getters.findArr(2))    console.log(this.$store.getters.findArr(7))  }}</script><p>结果如下所示.</p><p> 2.mapGetters 辅助函数<br>  关于辅助函数的使用和对象展开符的使用我在本系列的第二章中已经说的很明白了,有兴趣的可以看一下这个链接</p><template>  <div>    <div></div>    <div></div>  </div></template><script>import { mapGetters } from 'vuex'export default {  computed:  mapGetters({      'from': 'address',      'from2': 'addressMore',      'find': 'findArr'  }),  created () {    console.log(this.find(1)) // 由于getters已经通过computed挂载到当前组件实例,所以你不需要再通过this.$store.getters的方法去访问    console.log(this.$store.getters.findArr(2))    console.log(this.$store.getters.findArr(7))  }}</script><p> 3….mapGetters<br><template><br>  <div><br>    <div></div><br>    <div></div><br>  </div><br></template></p><script>import { mapGetters } from 'vuex'export default {  computed:  {    ...mapGetters({      'from': 'address',      'from2': 'addressMore',      'find': 'findArr'    })  },  created () {    console.log(this.find(1)) // 由于getters已经通过computed挂载到当前实例,所以你不需要再通过this.$store.getters的方法去访问    console.log(this.$store.getters.findArr(2))    console.log(this.$store.getters.findArr(7))  }}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vuex身上的state,mapState</title>
      <link href="/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%20state,mapState,...mapState%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E7%AC%A6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/29/Vuex%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%20state,mapState,...mapState%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E7%AC%A6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>1.state<br>  state是什么?</p><p>  定义:state(vuex) ≈ data (vue)</p><p>  vuex的state和vue的data有很多相似之处,都是用于存储一些数据,或者说状态值.这些值都将被挂载 数据和dom的双向绑定事件,也就是当你改变值的时候可以触发dom的更新.</p><p>  虽然state和data有很多相似之处,但state在使用的时候一般被挂载到子组件的computed计算属性上,这样有利于state的值发生改变的时候及时响应给子组件.如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题,那你可以针是一个杠精</p><p>  综上所述,请用computed去接收state,如下</p><p>//state.js<br>let state = {<br>  count: 1,<br>  name: ‘dkr’,<br>  sex: ‘男’,<br>  from: ‘china’<br>}<br>export default state</p><template>  <div id="example">    <button @click="decrement">-</button>            <button @click="increment">+</button>  </div></template><script>export default {  data () {    return {      dataCount: this.$store.state.count //用data接收    }  },  computed:{    count(){      return this.$store.state.count //用computed接收    }  }  methods: {    increment () {      this.$store.commit('increment')    },    decrement () {      this.$store.commit('decrement')    }  }}</script>结果如下,用data接收的值不能及时响应更新,用computed就可以. <p>2.mapState 辅助函数<br>  mapState是什么?</p><p>  表面意思:mapState是state的辅助函数.这么说可能很难理解</p><p>  抽象形容:mapState是state的语法糖,这么说可能你还想骂我,因为你根本不了解什么叫做语法糖,事实上我说的语法糖有自己的定义,什么是语法糖?我对语法糖的理解就是,用之前觉得,我明明已经对一种操作很熟练了,并且这种操作也不存在什么问题,为什么要用所谓的”更好的操作”,用了一段时间后,真香!</p><p>  实际作用:当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键</p><p>  在使用mapState之前,要导入这个辅助函数.</p><p>import { mapState } from ‘vuex’<br>  然后就是使用方式了</p><template>  <div id="example">    <button @click="decrement">-</button>            <button @click="increment">+</button>    <div></div>    <div></div>    <div></div>  </div></template><script>import { mapState } from 'vuex'export default {  data () {    return {      str: '国籍',      dataCount: this.$store.state.count    }  },  computed: mapState({    count: 'count', // 第一种写法    sex: (state) => state.sex, // 第二种写法    from: function (state) { // 用普通函数this指向vue实例,要注意      return this.str + ':' + state.from    },    // 注意下面的写法看起来和上面相同,事实上箭头函数的this指针并没有指向vue实例,因此不要滥用箭头函数    // from: (state) => this.str + ':' + state.from    myCmpted: function () {      // 这里不需要state,测试一下computed的原有用法      return '测试' + this.str    }  }),  methods: {    increment () {      this.$store.commit('increment')    },    decrement () {      this.$store.commit('decrement')    }  },  created () {    // 写个定时器，发现computed依旧保持了只要内部有相关属性发生改变不管是当前实例data中的改变，还是vuex中的值改变都会触发dom和值更新    setTimeout(() => {      this.str = '国家'    }, 1000)  }}</script><p>  在使用的时候,computed接收mapState函数的返回值,你可以用三种方式去接收store中的值,具体可以看注释.</p><p>  事实上第二种和第三种是同一种,只是前者用了ES6的偷懒语法,箭头函数,在偷懒的时候要注意一个问题,this指针的指向问题,我已经在很多篇文章中提到不要在vue中为了偷懒使用箭头函数,会导致很多很难察觉的错误,如果你在用到state的同时还需要借助当前vue实例的this,请务必使用常规写法.</p><p>  当然computed不会因为引入mapState辅助函数而失去原有的功能—用于扩展当前vue的data,只是写法会有一些奇怪,如果你已经写了一大堆的computed计算属性,做了一半发现你要引入vuex,还想使用mapState辅助函数的方便,你可以需要做下列事情.</p><pre><code>//之前的computedcomputed:&#123;    fn1()&#123; return ...&#125;,    fn2()&#123; return ...&#125;,    fn3()&#123; return ...&#125;    ........&#125;//引入mapState辅助函数之后computed:mapState(&#123;    //先复制粘贴    fn1()&#123; return ...&#125;,    fn2()&#123; return ...&#125;,    fn3()&#123; return ...&#125;    ......    //再维护vuex    count:&#39;count&#39;    .......&#125;)</code></pre><p>   从上述写法可以看出来,这不符合代码的某些说不明道不清的特性,我们希望我们可以不用去做一些复制粘贴的无用操作,而是直接使用mapState,希望它能自动融入到当前生产环境中,ok,ES6+(或者说ES7)提供了这个方便.</p><p>3 …mapState<br>  事实上…mapState并不是mapState的扩展,而是…对象展开符的扩展.当然如果你把他用在这里会发现他能使得代码看起来变得,更加符合常规逻辑了,为什么这么说,你等下就会知道了.</p><p>  首先,来回顾一下…对象展开符在数组中的表现,这在ES6语法学习分类里有相关说明,如果有兴趣可以关注我的ES6分类中的文章.</p><pre><code>let arr = [1,2,3]console.log(...arr) //1,2,3 然后来看一个例子.let MapState = mapState(&#123;      count: &#39;count&#39;,      sex: (state) =&gt; state.sex    &#125;)    let json = &#123;      &#39;a&#39;: &#39;我是json自带的&#39;,      ...MapState    &#125;    console.log(json)</code></pre><p>这里的json可以成功将mapState return的json格式,和json自带的a属性成功融合成一个新的对象.你可以将这个称为对象混合</p><p>这样,你就可以自由的使用mapState了.</p><pre><code>//之前的computedcomputed:&#123;    fn1()&#123; return ...&#125;,    fn2()&#123; return ...&#125;,    fn3()&#123; return ...&#125;    ........&#125;//引入mapState辅助函数之后computed:&#123;    //原来的继续保留    fn1()&#123; return ...&#125;,    fn2()&#123; return ...&#125;,    fn3()&#123; return ...&#125;    ......    //再维护vuex    ...mapState(&#123;  //这里的...不是省略号了,是对象扩展符        count:&#39;count&#39;    &#125;)&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vue-router身上的属性跟方法</title>
      <link href="/2022/08/29/vueRouter(2)%E8%BA%AB%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2022/08/29/vueRouter(2)%E8%BA%AB%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a><strong>vue-router</strong></h2><p>学习vue-router首先要认识的两个属性 $router 和 $route。</p><p>$router指的是router实例，$route则是当前激活的路由信息对象，是只读属性，不可更改，但是可以watch（监听）。</p><p>在浏览器中分别打印出$router 和 $route </p><p>$router：</p><p><img src="https://images2018.cnblogs.com/blog/1000555/201805/1000555-20180515115000885-1630475356.png" alt="img"></p><p>属性：</p><p>$router.app ：配置了router的Vue根实例</p><p>$router.mode：路由模式，这里是hash</p><p>$router.currentRoute：当前路由的路由信息对象，包含了当前匹配路由的信息</p><p>方法：</p><p>router.addRoutes(routes)：动态添加路由规则，参数为符合routes选项要求的数组。</p><p>router.beforeEach(to,from,next) ：全局前置守卫</p><pre><code>router.beforeEach((to,from,next)=&gt;&#123;     //... &#125;)</code></pre><p>　　当路由改变时，全局前置守卫执行，接受三个参数，to，from，next，分别代表即将要进入的目标路由，当前要离开的路由，和回调函数next()。next的执行效果依赖于参数。next()，执行下一个钩子，若钩子执行完毕，导航状态是confirm；next(false)中断当前导航，回到from路由对应的地址；next({path:’/‘}),跳转到自定义路由地址。next(error)，如果传入一个error实例，则导航终止并将错误传递给router.onError()注册过的回调。</p><p>router.beforeResolve()：全局解析守卫 , 在导航被确认之前，且在锁头组件内守卫和异步路由组件被解析之后调用，参数和全局前置守卫相同；</p><p>router.afterEach()：全局后置守卫</p><pre><code>router.afterEach((to,from)=&gt;&#123;    //....没有next()函数参数，也不会改变导航本身&#125;)</code></pre><p>router.go(n)：接受一个整数作为参数，类似window.history.go(n)，在浏览器历史记录中前进或后退几步</p><p>router.push( location )：跳转导航的方法，这种方法会向history栈添加一个新的记录</p><p>router.replace( location )：和router.push()类似，但是它会替换掉当前的history记录，不会添加新的记录</p><p>router.back()：相当于router.go(-1)</p><p>router.forward()：相当于router.go(1)</p><p>router.resolve(location)：解析目标路由，接受一个地址参数，返回location,route,href等属性信息，还可以接受当前默认路由current和当前路由上附加路径append　两个参数</p><p>router.onReady(callback,[errorCallback]){}：把一个回调排队，在路由完成初始导航时调用。</p><p>router.onError(callback)：注册一个回调，该回调会在路由导航过程中出错的时候被调用，但是对被调用的错误情形有要求：</p><p>　　1、错误在一个路由守卫函数中被同步抛出</p><p>　　2、错误在一个路由守卫函数中通过调用next(error)的方式异步捕获并处理</p><p>　　3、渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误</p><p>$route：</p><p><img src="https://images2018.cnblogs.com/blog/1000555/201805/1000555-20180515143116376-1104044711.png" alt="img"></p><p>route是路由信息对象，包含了当前路由的各种信息。路由对象是不可更改的，每次路由导航成功后都会产生一个新的对象。router.match（location）的返回值也是一个路由信息对象，导航守卫的参数to，from也是路由信息对象。</p><p>属性：</p><p>$route.fullPath ：完成解析后的url，包含查询参数和hash的完整路径</p><p>$route.path：路径，字符串类型，解析为绝对路径</p><p>$route.hash： 当前路由的hash值（带#号的），如果没有hash值则为空字符串</p><p>$route.name：当前路由的名称，如果有的话（用于命名路由）</p><p>$route.params：一个键值对对象，路由参数</p><p>$route.query：一个键值对对象，表示url查询参数</p><p>$route.matched：一个包含了当前路由的所有嵌套路径片段的路由记录（routes配置数组中的对象副本）</p><p>$route.redirectedFrom：重定向来源的路由的名字，如果存在重定向的话。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Vue项目配置文件</title>
      <link href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>1.当我们使用右键格式化的时候,就会自动帮我们补全符号,但是,有些符号在eslint中就会报语法错误,那我们需要怎么办呢?可以通过.prettierrc来进行文件配置</p><p>在文件的根目录建一个.prettierrc文件,在文件里写上如下代码:<br>{<br>    “semi”: false,    // 使用分号, 默认true<br>    “singleQuote”: true,   // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)<br>    “bracketSpacing”: true   // 对象中的空格 默认true<br>}<br>1<br>2<br>3<br>4<br>5</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Vue项目配置服务器的环境变量</title>
      <link href="/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2022/08/29/vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>vue项目配置服务器的环境变量.md</p><p>1.配置vue项目开发环境跟生产环境的全局环境变量<br> 在vue根目录新建.env.development和.env.production两个文件，然后配置变量<br> .env.development文件放：<br> VUE_APP_ENV=’development’<br> VUE_APP_URL=’<a href="http://www.baidu.com/api&#39;">www.baidu.com/api&#39;</a><br> .env.production文件放：<br> VUE_APP_ENV=’production’<br> VUE_APP_URL=’<a href="http://www.baidu.com/api&#39;">www.baidu.com/api&#39;</a></p><p> 如何获取配置的全局变量：process.env.VUE_APP_ENV   / process.env.VUE_APP_URL</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-什么是组件</title>
      <link href="/2022/08/29/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%BB%84%E4%BB%B6Component%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/29/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%BB%84%E4%BB%B6Component%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>文章目录</p><ul><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader0">一.什么是组件？</a></li><li>二.注册组件<ul><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader2">全局注册</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader3">局部注册</a></li></ul></li><li>三.Prop<ul><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader5">使用 Prop 传递数据</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader6">动态 Prop</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader7">字面量语法 vs 动态语法</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader8">单向数据流</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader9">Prop 验证</a></li></ul></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader10">四.非Prop特性</a></li><li>五.自定义事件<ul><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader12">使用 v-on 绑定自定义事件</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader13">给组件绑定原生事件.native</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader14">.sync 修饰符(2.3.0+)</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader15">使用自定义事件的表单输入组件</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader16">自定义组件的 v-model（2.2.0 新增）</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader17">非父子组件的通信</a></li></ul></li><li>六.使用插槽slot分发内容<ul><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader19">单个插槽</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader20">具名插槽</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader21">作用域插槽(2.1.0 新增)</a></li></ul></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader22">七.动态组件</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader23">keep-alive</a></li><li>八.杂项<ul><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader25">编写可复用组件</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader26">子组件引用</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader27">异步组件</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader28">高级异步组件(2.3.0 新增)</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader29">组件命名约定</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader30">递归组件</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader31">组件间的循环引用</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader32">X-Template</a></li><li><a href="https://www.cnblogs.com/moqiutao/p/8328931.html#articleHeader33">对低开销的静态组件使用 v-once</a></li></ul></li></ul><h2 id="一-什么是组件？"><a href="#一-什么是组件？" class="headerlink" title="一.什么是组件？"></a>一.什么是组件？</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用<code>is</code>特性进行了扩展的原生 HTML 元素。</p><blockquote><p>所有的<code>Vue 组件</code>同时也都是 <code>Vue 的实例</code>，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p></blockquote><h2 id="二-注册组件"><a href="#二-注册组件" class="headerlink" title="二.注册组件"></a>二.注册组件</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>html代码：</p><pre><code>&lt;div id=&quot;example&quot;&gt;  &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;</code></pre><p>JS代码：</p><pre><code>// 注册Vue.component(&#39;my-component&#39;, &#123;  template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39;&#125;)var vm = new Vue(&#123;  el: &#39;#example&#39;,  data: &#123;         &#125; &#125;)</code></pre><p>渲染结果为：</p><pre><code>&lt;div id=&quot;example&quot;&gt;  &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt;</code></pre><p>或者另外一种注册方式，通过 全局API：<code>Vue.extend()</code><br>代码如下：</p><pre><code>// 注册var MyComponent = Vue.extend(&#123;  template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39;&#125;);// 注册Vue.component(&#39;my-component&#39;, MyComponent);var vm = new Vue(&#123;  el: &#39;#example&#39;,  data: &#123;         &#125;&#125;)</code></pre><h4 id="Vue-extend-使用说明"><a href="#Vue-extend-使用说明" class="headerlink" title="Vue.extend()使用说明"></a>Vue.extend()使用说明</h4><p>下面说明下<code>Vue.extend( options )</code>的使用。<br>参数：<code>&#123;Object&#125; options</code><br>用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个<code>包含组件选项的对象</code>。<br><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code>中它必须是<code>函数</code>。</p><pre><code>&lt;div id=&quot;mount-point&quot;&gt;&lt;/div&gt;// 创建构造器var Profile = Vue.extend(&#123;  template: &#39;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#39;,  data: function () &#123;    return &#123;      firstName: &#39;Walter&#39;,      lastName: &#39;White&#39;,      alias: &#39;Heisenberg&#39;    &#125;  &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount(&#39;#mount-point&#39;)</code></pre><p>结果如下：</p><pre><code>&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;</code></pre><p>上面又用到了实例方法<code>vm.$mount()</code>，下面说明下它的使用方式。</p><h4 id="vm-mount-elementOrSelector-使用说明"><a href="#vm-mount-elementOrSelector-使用说明" class="headerlink" title="vm.$mount( [elementOrSelector] )使用说明"></a>vm.$mount( [elementOrSelector] )使用说明</h4><p>参数：</p><ul><li><code>&#123;Element | string&#125; [elementOrSelector]</code></li><li><code>&#123;boolean&#125; [hydrating]</code></li></ul><p>返回值：<code>vm</code> - 实例自身<br>用法：<br>如果 <code>Vue</code> 实例在实例化时没有收到<code>el</code>选项，则它处于“<code>未挂载</code>”状态，没有关联的<code>DOM</code>元素。可以使用<code>vm.$mount()</code>手动地挂载一个未挂载的实例。</p><p>如果没有提供 <code>elementOrSelector</code>参数，模板将被渲染为文档之外的的元素，并且你必须使用<code>原生 DOM API</code>把它插入文档中。</p><p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p><pre><code>var MyComponent = Vue.extend(&#123;  template: &#39;&lt;div&gt;Hello!&lt;/div&gt;&#39;&#125;)// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount(&#39;#app&#39;)// 同上new MyComponent(&#123; el: &#39;#app&#39; &#125;)// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById(&#39;app&#39;).appendChild(component.$el)</code></pre><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>你不必把每个组件都注册到全局。你可以通过某个 Vue 实例/组件的实例选项 components 注册仅在其作用域中可用的组件：</p><pre><code>var Child = &#123;  template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39;&#125;new Vue(&#123;  // ...  components: &#123;    // &lt;my-component&gt; 将只在父组件模板中可用    &#39;my-component&#39;: Child  &#125;&#125;)</code></pre><p>这种封装也适用于其它可注册的 Vue 功能，比如<code>指令</code>。</p><h4 id="DOM-模板解析注意事项"><a href="#DOM-模板解析注意事项" class="headerlink" title="DOM 模板解析注意事项"></a>DOM 模板解析注意事项</h4><p>像 <code>&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;、&lt;select&gt;</code> 这样的元素里允许包含的元素有限制，而另一些像 <code>&lt;option&gt;</code> 这样的元素只能出现在某些特定元素的内部。</p><p>例如：</p><pre><code>&lt;table&gt;  &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt;</code></pre><p>自定义组件<code>&lt;my-row&gt;</code> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的<code>is</code>特性：</p><pre><code>&lt;table&gt;  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制：</strong></p><ul><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li><li><code>JavaScript</code> 内联模板字符串</li><li><code>.vue</code> 组件</li></ul><p>因此，请尽可能使用字符串模板。</p><h4 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data 必须是函数"></a>data 必须是函数</h4><p>如下代码：</p><pre><code>Vue.component(&#39;my-component&#39;, &#123;  template: &#39;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#39;,  data: &#123;    message: &#39;hello&#39;  &#125;&#125;)</code></pre><p>那么 Vue 会停止运行，并在控制台发出警告，告诉你在组件实例中 <code>data</code> 必须是一个函数。<br>我们来理解下，看下面代码：</p><pre><code>&lt;div id=&quot;example-2&quot;&gt;  &lt;simple-counter&gt;&lt;/simple-counter&gt;  &lt;simple-counter&gt;&lt;/simple-counter&gt;  &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;var data = &#123; counter: 0 &#125;Vue.component(&#39;simple-counter&#39;, &#123;  template: &#39;&lt;button v-on:click=&quot;counter += 1&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&#39;,  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，  // 但是我们却给每个组件实例返回了同一个对象的引用  data: function () &#123;    return data  &#125;&#125;)new Vue(&#123;  el: &#39;#example-2&#39;&#125;)</code></pre><p>由于这三个组件实例<code>共享</code>了同一个<code>data</code>对象，因此递增一个 <code>counter</code>会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p><pre><code>data: function () &#123;  return &#123;    counter: 0  &#125;&#125;</code></pre><p>现在每个 counter 都有它自己内部的状态了,不会相互影响。</p><h2 id="三-Prop"><a href="#三-Prop" class="headerlink" title="三.Prop"></a>三.Prop</h2><p>最常见的应用就是：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。</p><p>在 Vue 中，父子组件的关系可以总结为 <code>prop</code> 向下传递，<code>事件</code>向上传递。父组件通过 <code>prop</code> 给子组件下发数据，子组件通过<code>事件</code>给父组件发送消息。</p><h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><p>实例1：</p><pre><code>Vue.component(&#39;child&#39;, &#123;  // 声明 props  props: [&#39;message&#39;],  // 就像 data 一样，prop 也可以在模板中使用  // 同样也可以在 vm 实例中通过 this.message 来使用  template: &#39;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#39;&#125;)&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;</code></pre><p>结果：<code>hello!</code></p><p>实例2：<br>HTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：</p><pre><code>Vue.component(&#39;child&#39;, &#123;  // 在 JavaScript 中使用 camelCase  props: [&#39;myMessage&#39;],  template: &#39;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&#39;&#125;)&lt;!-- 在 HTML 中使用 kebab-case --&gt;&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;</code></pre><p>如果你使用字符串模板，则没有这些限制。</p><h3 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h3><pre><code>&lt;div&gt;  &lt;input v-model=&quot;parentMsg&quot;&gt;  &lt;br&gt;  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;/div&gt;</code></pre><p>你也可以使用 v-bind 的缩写语法：</p><pre><code>&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</code></pre><p>**<code>（重要）</code>**如果你想把一个<code>对象</code>的所有<code>属性</code>作为 prop 进行传递，可以使用不带任何参数的 <code>v-bind</code>(即用 v-bind 而不是 v-bind:prop-name)。例如，已知一个<code>todo</code> 对象：</p><pre><code>todo: &#123;  text: &#39;Learn Vue&#39;,  isComplete: false&#125;</code></pre><p>然后：</p><pre><code>&lt;todo-item v-bind=&quot;todo&quot;&gt;&lt;/todo-item&gt;</code></pre><p>将等价于：</p><pre><code>&lt;todo-item  v-bind:text=&quot;todo.text&quot;  v-bind:is-complete=&quot;todo.isComplete&quot;&gt;&lt;/todo-item&gt;</code></pre><h3 id="字面量语法-vs-动态语法"><a href="#字面量语法-vs-动态语法" class="headerlink" title="字面量语法 vs 动态语法"></a>字面量语法 vs 动态语法</h3><p>初学者常犯的一个错误是使用字面量语法传递数值：</p><pre><code>&lt;!-- 传递了一个字符串 &quot;1&quot; --&gt;&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</code></pre><p>因为它是一个字面量 <code>prop</code>，它的值是字符串 “1” 而不是一个数值。如果想传递一个真正的 JavaScript 数值，则需要使用 <code>v-bind</code>，从而让它的值被当作 <code>JavaScript 表达式</code>计算：</p><pre><code>&lt;!-- 传递真正的数值 --&gt;&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</code></pre><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</p><p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你<code>不应该</code>在子组件内部改变<code>prop</code>。如果你这么做了，Vue 会在控制台给出警告。</p><p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><ul><li>Prop 作为初始值传入后，子组件想把它当作局部数据来用；</li><li>Prop 作为原始数据传入，由子组件处理成其它数据输出。</li></ul><p>对这两种情况，正确的应对方式是：<br>1.定义一个局部变量，并用 prop 的值初始化它：</p><pre><code>props: [&#39;initialCounter&#39;],data: function () &#123;  return &#123; counter: this.initialCounter &#125;&#125;</code></pre><p>2.定义一个计算属性，处理 prop 的值并返回：</p><pre><code>props: [&#39;size&#39;],computed: &#123;  normalizedSize: function () &#123;    return this.size.trim().toLowerCase()  &#125;&#125;</code></pre><blockquote><p>注意在 JavaScript 中<code>对象</code>和<code>数组</code>是引用类型，指向<code>同一个内存空间</code>，如果 prop 是一个对象或数组，在子组件内部改变它<code>会影响</code>父组件的状态。</p></blockquote><h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><p>我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。<br>要指定验证规则，需要用<code>对象的形式</code>来定义 prop，而<code>不能用字符串数组</code>：</p><pre><code>Vue.component(&#39;example&#39;, &#123;  props: &#123;    // 基础类型检测 (`null` 指允许任何类型)    propA: Number,    // 可能是多种类型    propB: [String, Number],    // 必传且是字符串    propC: &#123;      type: String,      required: true    &#125;,    // 数值且有默认值    propD: &#123;      type: Number,      default: 100    &#125;,    // 数组/对象的默认值应当由一个工厂函数返回    propE: &#123;      type: Object,      default: function () &#123;        return &#123; message: &#39;hello&#39; &#125;      &#125;    &#125;,    // 自定义验证函数    propF: &#123;      validator: function (value) &#123;        return value &gt; 10      &#125;    &#125;  &#125;&#125;)</code></pre><p><code>type</code> 可以是下面原生构造器：String ，Number，Boolean，Function，Object，Array，Symbol。</p><p><code>type</code> 也可以是一个自定义构造器函数，使用 <code>instanceof</code> 检测。</p><p>当<code>prop</code>验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 prop 会在组件实例创建之前进行校验，所以在<code>default</code> 或 <code>validator</code> 函数里，诸如 <code>data</code>、<code>computed</code> 或 <code>methods</code> 等实例属性还无法使用。</p><p>其它实例：</p><pre><code>Vue.component(&#39;modal&#39;, &#123;  template: &#39;#modal-template&#39;,  props: &#123;    show: &#123;      type: Boolean,      required: true,      twoWay: true        &#125;  &#125;&#125;);</code></pre><p><code>twoWay Prop</code> 的参数 <code>移除</code>。Props 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。所以上面的的最后一个实例只是贴出来代码而已，最新版本已经移除了。</p><h2 id="四-非Prop特性"><a href="#四-非Prop特性" class="headerlink" title="四.非Prop特性"></a>四.非Prop特性</h2><p>所谓非 prop 特性，就是指它可以直接传入组件，而不需要定义相应的 prop。</p><p>尽管为组件定义明确的 prop 是推荐的传参方式，组件的作者却并不总能预见到组件被使用的场景。所以，<code>组件可以接收任意传入的特性</code>，这些特性都会被添加到组件的<code>根元素上</code>。</p><p>例如，假设我们使用了第三方组件 bs-date-input，它包含一个 Bootstrap 插件，该插件需要在 input 上添加 data-3d-date-picker 这个特性。这时可以把特性直接添加到组件上 (不需要事先定义 prop)：</p><pre><code>&lt;bs-date-input data-3d-date-picker=&quot;true&quot;&gt;&lt;/bs-date-input&gt;</code></pre><p>添加属性 <code>data-3d-date-picker=&quot;true&quot;</code> 之后，它会被自动添加到<code>bs-date-input</code> 的根元素上。</p><p>假设这是 bs-date-input 的模板：</p><pre><code>&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;</code></pre><p>为了给该日期选择器插件增加一个特殊的主题，我们可能需要增加一个特殊的 class，比如：</p><pre><code>&lt;bs-date-input  data-3d-date-picker=&quot;true&quot;  class=&quot;date-picker-theme-dark&quot;&gt;&lt;/bs-date-input&gt;</code></pre><p>最终在根元素上生成的class值为：form-control date-picker-theme-dark。</p><h2 id="五-自定义事件"><a href="#五-自定义事件" class="headerlink" title="五.自定义事件"></a>五.自定义事件</h2><p>我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。</p><h3 id="使用-v-on-绑定自定义事件"><a href="#使用-v-on-绑定自定义事件" class="headerlink" title="使用 v-on 绑定自定义事件"></a>使用 v-on 绑定自定义事件</h3><p>每个 Vue 实例都实现了事件接口，即：</p><ul><li>使用 $on(eventName) 监听事件</li><li>使用 $emit(eventName) 触发事件</li></ul><blockquote><p>Vue 的事件系统与浏览器的 <code>EventTarget API</code> 有所不同。尽管它们的运行起来类似，但是 <code>$on</code>和 <code>$emit</code> 并不是<code>addEventListener</code> 和<code>dispatchEvent</code> 的别名。</p></blockquote><p>另外，父组件可以在使用子组件的地方直接用 <code>v-on</code> 来监听子组件触发的事件。</p><p>不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定，参见下面的例子。</p><pre><code>&lt;div id=&quot;counter-event-example&quot;&gt;  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;&lt;/div&gt;Vue.component(&#39;button-counter&#39;, &#123;  template: &#39;&lt;button v-on:click=&quot;incrementCounter&quot;&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;&#39;,  data: function () &#123;    return &#123;      counter: 0    &#125;  &#125;,  methods: &#123;    incrementCounter: function () &#123;      this.counter += 1      this.$emit(&#39;increment&#39;)    &#125;  &#125;,&#125;)new Vue(&#123;  el: &#39;#counter-event-example&#39;,  data: &#123;    total: 0  &#125;,  methods: &#123;    incrementTotal: function () &#123;      this.total += 1    &#125;  &#125;&#125;)</code></pre><h3 id="给组件绑定原生事件-native"><a href="#给组件绑定原生事件-native" class="headerlink" title="给组件绑定原生事件.native"></a>给组件绑定原生事件.native</h3><p>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 <code>.native</code>。例如：</p><pre><code>&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</code></pre><h3 id="sync-修饰符-2-3-0"><a href="#sync-修饰符-2-3-0" class="headerlink" title=".sync 修饰符(2.3.0+)"></a>.sync 修饰符(2.3.0+)</h3><pre><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</code></pre><p>会被扩展为：</p><pre><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</code></pre><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p><pre><code>this.$emit(&#39;update:foo&#39;, newValue)</code></pre><h3 id="使用自定义事件的表单输入组件"><a href="#使用自定义事件的表单输入组件" class="headerlink" title="使用自定义事件的表单输入组件"></a>使用自定义事件的表单输入组件</h3><p>自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。要牢记：</p><pre><code>&lt;input v-model=&quot;something&quot;&gt;</code></pre><p>这不过是以下示例的语法糖：</p><pre><code>&lt;input  v-bind:value=&quot;something&quot;  v-on:input=&quot;something = $event.target.value&quot;&gt;</code></pre><p>所以在组件中使用时，它相当于下面的简写：</p><pre><code>&lt;custom-input  v-bind:value=&quot;something&quot;  v-on:input=&quot;something = arguments[0]&quot;&gt;&lt;/custom-input&gt;</code></pre><p>所以要让组件的 v-model 生效，它应该 (从 2.2.0 起是可配置的)：</p><ul><li>接受一个 <code>value prop</code></li><li>在有新的值时触发 <code>input</code> 事件并将新值作为参数</li></ul><p>例子1：</p><pre><code>&lt;div id=&quot;app&quot;&gt;      &lt;custom-input v-model=&quot;something&quot;&gt;&lt;/custom-input&gt;    &lt;br/&gt;    &#123;&#123;something&#125;&#125;&lt;/div&gt;// 注册Vue.component(&#39;custom-input&#39;, &#123;  props:[&#39;something&#39;],  template: &#39;&lt;input type=&quot;text&quot;  v-bind:value=&quot;something&quot; v-on:input=&quot;updateValue($event.target.value)&quot;/&gt;&#39;,  methods:&#123;      updateValue:function(value)&#123;           this.$emit(&#39;input&#39;, value)      &#125;  &#125;&#125;)var vm = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;       something:&#39;&#39;  &#125;  &#125;)</code></pre><p>例子2：货币输入的自定义控件</p><pre><code>&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currency-input&gt;Vue.component(&#39;currency-input&#39;, &#123;  template: &#39;\    &lt;span&gt;\      $\      &lt;input\        ref=&quot;input&quot;\        v-bind:value=&quot;value&quot;\        v-on:input=&quot;updateValue($event.target.value)&quot;\      &gt;\    &lt;/span&gt;\  &#39;,  props: [&#39;value&#39;],  methods: &#123;    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制    updateValue: function (value) &#123;      var formattedValue = value        // 删除两侧的空格符        .trim()        // 保留 2 位小数        .slice(          0,          value.indexOf(&#39;.&#39;) === -1            ? value.length            : value.indexOf(&#39;.&#39;) + 3        )      // 如果值尚不合规，则手动覆盖为合规的值      if (formattedValue !== value) &#123;        this.$refs.input.value = formattedValue      &#125;      // 通过 input 事件带出数值      this.$emit(&#39;input&#39;, Number(formattedValue))    &#125;  &#125;&#125;)</code></pre><p>实例3：更加完善的货币过滤器</p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;currency-input     label=&quot;Price&quot;     v-model=&quot;price&quot;  &gt;&lt;/currency-input&gt;  &lt;currency-input     label=&quot;Shipping&quot;     v-model=&quot;shipping&quot;  &gt;&lt;/currency-input&gt;  &lt;currency-input     label=&quot;Handling&quot;     v-model=&quot;handling&quot;  &gt;&lt;/currency-input&gt;  &lt;currency-input     label=&quot;Discount&quot;     v-model=&quot;discount&quot;  &gt;&lt;/currency-input&gt;    &lt;p&gt;Total: $&#123;&#123; total &#125;&#125;&lt;/p&gt;&lt;/div&gt;Vue.component(&#39;currency-input&#39;, &#123;  template: &#39;\    &lt;div&gt;\      &lt;label v-if=&quot;label&quot;&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;\      $\      &lt;input\        ref=&quot;input&quot;\        v-bind:value=&quot;value&quot;\        v-on:input=&quot;updateValue($event.target.value)&quot;\        v-on:focus=&quot;selectAll&quot;\        v-on:blur=&quot;formatValue&quot;\      &gt;\    &lt;/div&gt;\  &#39;,  props: &#123;    value: &#123;      type: Number,      default: 0    &#125;,    label: &#123;      type: String,      default: &#39;&#39;    &#125;  &#125;,  mounted: function () &#123;    this.formatValue()  &#125;,  methods: &#123;    updateValue: function (value) &#123;      var result = currencyValidator.parse(value, this.value)      if (result.warning) &#123;        this.$refs.input.value = result.value      &#125;      this.$emit(&#39;input&#39;, result.value)    &#125;,    formatValue: function () &#123;      this.$refs.input.value = currencyValidator.format(this.value)    &#125;,    selectAll: function (event) &#123;      // Workaround for Safari bug      // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome      setTimeout(function () &#123;          event.target.select()      &#125;, 0)    &#125;  &#125;&#125;)new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;    price: 0,    shipping: 0,    handling: 0,    discount: 0  &#125;,  computed: &#123;    total: function () &#123;      return ((        this.price * 100 +         this.shipping * 100 +         this.handling * 100 -         this.discount * 100      ) / 100).toFixed(2)    &#125;  &#125;&#125;)</code></pre><h3 id="自定义组件的-v-model（2-2-0-新增）"><a href="#自定义组件的-v-model（2-2-0-新增）" class="headerlink" title="自定义组件的 v-model（2.2.0 新增）"></a>自定义组件的 v-model（2.2.0 新增）</h3><p>默认情况下，一个组件的 v-model 会使用 value prop 和 input 事件。但是诸如单选框、复选框之类的输入类型可能把 value 用作了别的目的。model 选项可以避免这样的冲突：</p><pre><code>Vue.component(&#39;my-checkbox&#39;, &#123;  model: &#123;    prop: &#39;checked&#39;,    event: &#39;change&#39;  &#125;,  props: &#123;    checked: Boolean,    // 这样就允许拿 `value` 这个 prop 做其它事了    value: String  &#125;,  // ...&#125;)&lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;</code></pre><p>上述代码等价于：</p><pre><code>&lt;my-checkbox  :checked=&quot;foo&quot;  @change=&quot;val =&gt; &#123; foo = val &#125;&quot;  value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;</code></pre><blockquote><p>注意你仍然需要显式声明 <code>checked</code> 这个<code>prop</code>。</p></blockquote><p>完整的代码：<br>html：</p><pre><code>&lt;div id=&quot;app&quot;&gt;      &lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;    &#123;&#123;foo&#125;&#125;&lt;/div&gt;</code></pre><p>JS代码：</p><pre><code>Vue.component(&#39;my-checkbox&#39;, &#123;  model: &#123;    prop: &#39;checked&#39;,    event: &#39;change&#39;  &#125;,  props: &#123;    checked: Boolean,    // 这样就允许拿 `value` 这个 prop 做其它事了    value: String  &#125;,  template:&#39;&lt;input type=&quot;checkbox&quot; @change=&quot;changefun(ischecked)&quot;/&gt;&#39;,  data:function()&#123;      return &#123;          ischecked:this.checked      &#125;  &#125;,  methods:&#123;      changefun(state)&#123;          this.ischecked = !state;          this.$emit(&#39;change&#39;, this.ischecked);      &#125;  &#125;&#125;)var vm = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;       foo:false  &#125;  &#125;)</code></pre><h3 id="非父子组件的通信"><a href="#非父子组件的通信" class="headerlink" title="非父子组件的通信"></a>非父子组件的通信</h3><p>有时候，非父子关系的两个组件之间也需要通信。在简单的场景下，可以使用一个空的 Vue 实例作为事件总线：</p><pre><code>var bus = new Vue()// 触发组件 A 中的事件bus.$emit(&#39;id-selected&#39;, 1)// 在组件 B 创建的钩子中监听事件bus.$on(&#39;id-selected&#39;, function (id) &#123;  // ...&#125;)</code></pre><p>在复杂的情况下，我们应该考虑使用专门的状态管理模式<code>Vuex</code>。</p><p>来看一个完整的例子：<br>html代码：</p><pre><code>&lt;div id=&quot;app&quot;&gt;     &lt;comp-a v-on:id-selected=&quot;getdate&quot;&gt;&lt;/comp-a&gt;     &lt;comp-b&gt;&lt;/comp-b&gt;&lt;/div&gt;</code></pre><p>JS代码：</p><pre><code>var bus = new Vue();Vue.component(&#39;comp-a&#39;, &#123;  template:&#39;&lt;button class=&quot;compa&quot; @click=&quot;comfuna&quot;&gt;组件A&lt;/button&gt;&#39;,  data:function()&#123;      return &#123;                &#125;  &#125;,  methods:&#123;      comfuna()&#123;          bus.$emit(&#39;id-selected&#39;, 1);          this.$emit(&#39;id-selected&#39;, 1);      &#125;  &#125;&#125;)Vue.component(&#39;comp-b&#39;, &#123;  template:&#39;&lt;div class=&quot;compb&quot;&gt;组件B&lt;/div&gt;&#39;,  data:function()&#123;      return &#123;                &#125;  &#125;,  mounted()&#123;      // 在组件 B 创建的钩子中监听事件    bus.$on(&#39;id-selected&#39;, function (id) &#123;         console.log(&#39;在B组件中得到的值：&#39;+id);    &#125;)  &#125; &#125;)var vm = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;&#125;,  methods:&#123;      getdate(value)&#123;          console.log(&#39;得到当前的值：&#39;+value);      &#125;  &#125;  &#125;)</code></pre><h2 id="六-使用插槽slot分发内容"><a href="#六-使用插槽slot分发内容" class="headerlink" title="六.使用插槽slot分发内容"></a>六.使用插槽slot分发内容</h2><p>在使用组件时，我们常常要像这样组合它们：</p><pre><code>&lt;app&gt;  &lt;app-header&gt;&lt;/app-header&gt;  &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt;</code></pre><p>注意两点：</p><ul><li><code>&lt;app&gt;</code> 组件不知道它会收到什么内容。这是由使用 <code>&lt;app&gt;</code> 的父组件决定的。</li><li><code>&lt;app&gt;</code> 组件很可能有它自己的模板。</li></ul><p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p><p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p><pre><code>&lt;!-- 无效 --&gt;&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</code></pre><p>正确做法：</p><pre><code>Vue.component(&#39;child-component&#39;, &#123;  // 有效，因为是在正确的作用域内  template: &#39;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&#39;,  data: function () &#123;    return &#123;      someChildProperty: true    &#125;  &#125;&#125;)</code></pre><h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><p>假定 my-component 组件有如下模板：</p><pre><code>&lt;div&gt;  &lt;h2&gt;我是子组件的标题&lt;/h2&gt;  &lt;slot&gt;    只有在没有要分发的内容时才会显示。  &lt;/slot&gt;&lt;/div&gt;</code></pre><p>父组件模板：</p><pre><code>&lt;div&gt;  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;  &lt;my-component&gt;    &lt;p&gt;这是一些初始内容&lt;/p&gt;    &lt;p&gt;这是更多的初始内容&lt;/p&gt;  &lt;/my-component&gt;&lt;/div&gt;</code></pre><p>渲染结果：</p><pre><code>&lt;div&gt;  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;  &lt;div&gt;    &lt;h2&gt;我是子组件的标题&lt;/h2&gt;    &lt;p&gt;这是一些初始内容&lt;/p&gt;    &lt;p&gt;这是更多的初始内容&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>&lt;slot&gt;</code> 元素可以用一个特殊的特性 <code>name</code> 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 <code>slot</code> 特性的元素。</p><p>仍然可以有一个<strong>匿名插槽</strong>，它是<strong>默认插槽</strong>，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。</p><p>例如，假定我们有一个 app-layout 组件，它的模板为：</p><pre><code>&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/footer&gt;&lt;/div&gt;</code></pre><p>父组件模板：</p><pre><code>&lt;app-layout&gt;  &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;  &lt;p&gt;主要内容的一个段落。&lt;/p&gt;  &lt;p&gt;另一个主要段落。&lt;/p&gt;  &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt;</code></pre><p>渲染结果为：</p><pre><code>&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;    &lt;p&gt;另一个主要段落。&lt;/p&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;p&gt;这里有一些联系信息&lt;/p&gt;  &lt;/footer&gt;&lt;/div&gt;</code></pre><h3 id="作用域插槽-2-1-0-新增"><a href="#作用域插槽-2-1-0-新增" class="headerlink" title="作用域插槽(2.1.0 新增)"></a>作用域插槽(2.1.0 新增)</h3><p>作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。</p><p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p><pre><code>&lt;div class=&quot;child&quot;&gt;  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</code></pre><p>在父级中，具有特殊特性 <code>slot-scope</code>的<code>&lt;template&gt;</code> 元素必须存在，表示它是作用域插槽的模板。<code>slot-scope</code>的值将被用作一个临时变量名，此变量接收从子组件传递过来的 <code>prop</code> 对象：</p><pre><code>&lt;div class=&quot;parent&quot;&gt;  &lt;child&gt;    &lt;template slot-scope=&quot;props&quot;&gt;      &lt;span&gt;hello from parent&lt;/span&gt;      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;    &lt;/template&gt;  &lt;/child&gt;&lt;/div&gt;</code></pre><p>如果我们渲染上述模板，得到的输出会是：</p><pre><code>&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;span&gt;hello from parent&lt;/span&gt;    &lt;span&gt;hello from child&lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><blockquote><p>在 <code>2.5.0+</code>，<code>slot-scope</code> 能被用在任意元素或组件中而<code>不再局限于 &lt;template&gt;</code></p></blockquote><p>作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项：</p><pre><code>&lt;my-awesome-list :items=&quot;items&quot;&gt;  &lt;!-- 作用域插槽也可以是具名的 --&gt;  &lt;li    slot=&quot;item&quot;    slot-scope=&quot;props&quot;    class=&quot;my-fancy-item&quot;&gt;    &#123;&#123; props.text &#125;&#125;  &lt;/li&gt;&lt;/my-awesome-list&gt;</code></pre><p>列表组件的模板：</p><pre><code>&lt;ul&gt;  &lt;slot name=&quot;item&quot;    v-for=&quot;item in items&quot;    :text=&quot;item.text&quot;&gt;    &lt;!-- 这里写入备用内容 --&gt;  &lt;/slot&gt;&lt;/ul&gt;</code></pre><p><strong>解构</strong></p><p><code>slot-scope</code>的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境 (单文件组件或现代浏览器) 中，您还可以在表达式中使用 ES2015 解构：</p><pre><code>&lt;child&gt;  &lt;span slot-scope=&quot;&#123; text &#125;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/child&gt;</code></pre><h2 id="七-动态组件"><a href="#七-动态组件" class="headerlink" title="七.动态组件"></a>七.动态组件</h2><p>通过使用保留的<code>&lt;component&gt;</code>元素，并对其<code>is</code>特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：</p><pre><code>var vm = new Vue(&#123;  el: &#39;#example&#39;,  data: &#123;    currentView: &#39;home&#39;  &#125;,  components: &#123;    home: &#123; /* ... */ &#125;,    posts: &#123; /* ... */ &#125;,    archive: &#123; /* ... */ &#125;  &#125;&#125;)&lt;component v-bind:is=&quot;currentView&quot;&gt;  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt;</code></pre><p>也可以直接绑定到组件对象上：</p><pre><code>var Home = &#123;  template: &#39;&lt;p&gt;Welcome home!&lt;/p&gt;&#39;&#125;var vm = new Vue(&#123;  el: &#39;#example&#39;,  data: &#123;    currentView: Home  &#125;&#125;)</code></pre><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 <code>keep-alive</code> 指令参数：</p><pre><code>&lt;keep-alive&gt;  &lt;component :is=&quot;currentView&quot;&gt;    &lt;!-- 非活动组件将被缓存！ --&gt;  &lt;/component&gt;&lt;/keep-alive&gt;</code></pre><h2 id="八-杂项"><a href="#八-杂项" class="headerlink" title="八.杂项"></a>八.杂项</h2><h3 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h3><p>Vue 组件的 API 来自三部分——prop、事件和插槽：</p><ul><li><code>Prop</code> 允许外部环境传递数据给组件；</li><li><code>事件</code>允许从组件内触发外部环境的副作用；</li><li><code>插槽</code>允许外部环境将额外的内容组合在组件中。</li></ul><p>使用 v-bind 和 v-on 的简写语法，模板的意图会更清楚且简洁：</p><pre><code>&lt;my-component  :foo=&quot;baz&quot;  :bar=&quot;qux&quot;  @event-a=&quot;doThis&quot;  @event-b=&quot;doThat&quot;&gt;  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;&lt;/my-component&gt;</code></pre><h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><p>尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 <code>ref</code>为子组件指定一个引用 ID。例如：</p><pre><code>&lt;div id=&quot;parent&quot;&gt;  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: &#39;#parent&#39; &#125;)// 访问子组件实例var child = parent.$refs.profile</code></pre><p>当 <code>ref</code>和<code>v-for</code> 一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。</p><blockquote><p><code>$refs</code>只在组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 <code>$refs</code>。</p></blockquote><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了进一步简化，Vue.js 允许将组件定义为一个工厂函数，异步地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p><pre><code>Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;  setTimeout(function () &#123;    // 将组件定义传入 resolve 回调函数    resolve(&#123;      template: &#39;&lt;div&gt;I am async!&lt;/div&gt;&#39;    &#125;)  &#125;, 1000)&#125;)</code></pre><p>工厂函数接收一个 <code>resolve</code> 回调，在收到从服务器下载的组件定义时调用。也可以调用 <code>reject(reason)</code>指示加载失败。这里使用 setTimeout 只是为了演示，实际上如何获取组件完全由你决定。</p><p>推荐配合 webpack 的代码分割功能 来使用：</p><pre><code>Vue.component(&#39;async-webpack-example&#39;, function (resolve) &#123;  // 这个特殊的 require 语法告诉 webpack  // 自动将编译后的代码分割成不同的块，  // 这些块将通过 Ajax 请求自动下载。  require([&#39;./my-async-component&#39;], resolve)&#125;)</code></pre><p>你可以在工厂函数中返回一个 Promise，所以当使用 webpack 2 + ES2015 的语法时可以这样：</p><pre><code>Vue.component(  &#39;async-webpack-example&#39;,  // 该 `import` 函数返回一个 `Promise` 对象。  () =&gt; import(&#39;./my-async-component&#39;))</code></pre><p>当使用局部注册时，也可以直接提供一个返回 Promise 的函数：</p><pre><code>new Vue(&#123;  // ...  components: &#123;    &#39;my-component&#39;: () =&gt; import(&#39;./my-async-component&#39;)  &#125;&#125;)</code></pre><h3 id="高级异步组件-2-3-0-新增"><a href="#高级异步组件-2-3-0-新增" class="headerlink" title="高级异步组件(2.3.0 新增)"></a>高级异步组件(2.3.0 新增)</h3><p>自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象：</p><pre><code>const AsyncComp = () =&gt; (&#123;  // 需要加载的组件。应当是一个 Promise  component: import(&#39;./MyComp.vue&#39;),  // 加载中应当渲染的组件  loading: LoadingComp,  // 出错时渲染的组件  error: ErrorComp,  // 渲染加载中组件前的等待时间。默认：200ms。  delay: 200,  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity  timeout: 3000&#125;)</code></pre><blockquote><p>注意，当一个异步组件被作为<code>vue-router</code>的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用 <code>vue-router 2.4.0 以上</code>的版本。</p></blockquote><h3 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h3><p>当注册组件 (或者 prop) 时，可以使用 kebab-case (短横线分隔命名)、camelCase (驼峰式命名) 或 PascalCase (单词首字母大写命名)。</p><pre><code>// 在组件定义中components: &#123;  // 使用 kebab-case 注册  &#39;kebab-cased-component&#39;: &#123; /* ... */ &#125;,  // 使用 camelCase 注册  &#39;camelCasedComponent&#39;: &#123; /* ... */ &#125;,  // 使用 PascalCase 注册  &#39;PascalCasedComponent&#39;: &#123; /* ... */ &#125;&#125;</code></pre><p>在 HTML 模板中，请使用 kebab-case：</p><pre><code>&lt;!-- 在 HTML 模板中始终使用 kebab-case --&gt;&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;</code></pre><p>当使用字符串模式时，可以不受 HTML 大小写不敏感的限制。这意味实际上在模板中，你可以使用下面的方式来引用你的组件：</p><ul><li>kebab-case</li><li>camelCase 或 kebab-case (如果组件已经被定义为 camelCase)</li><li>kebab-case、camelCase 或 PascalCase (如果组件已经被定义为 PascalCase)</li></ul><pre><code>components: &#123;  &#39;kebab-cased-component&#39;: &#123; /* ... */ &#125;,  camelCasedComponent: &#123; /* ... */ &#125;,  PascalCasedComponent: &#123; /* ... */ &#125;&#125;&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;camelCasedComponent&gt;&lt;/camelCasedComponent&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;&lt;pascalCasedComponent&gt;&lt;/pascalCasedComponent&gt;&lt;PascalCasedComponent&gt;&lt;/PascalCasedComponent&gt;</code></pre><p>这意味着 PascalCase 是最通用的声明约定而 kebab-case 是最通用的使用约定。</p><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件在它的模板内可以递归地调用自己。不过，只有当它有<code>name</code> 选项时才可以这么做：</p><pre><code>name: &#39;unique-name-of-my-component&#39;</code></pre><p>当你利用 <code>Vue.component</code> 全局注册了一个组件，全局的 <code>ID</code>会被自动设置为组件的 <code>name</code>。</p><pre><code>Vue.component(&#39;unique-name-of-my-component&#39;, &#123;  // ...&#125;)</code></pre><p>如果稍有不慎，递归组件可能导致死循环：</p><pre><code>name: &#39;stack-overflow&#39;,template: &#39;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#39;</code></pre><p>上面组件会导致一个“max stack size exceeded”错误，所以要确保递归调用有终止条件 (比如递归调用时使用 <code>v-if</code>并最终解析为 <code>false</code>)。</p><h3 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a>组件间的循环引用</h3><p>假设你正在构建一个文件目录树，像在 Finder 或资源管理器中。你可能有一个 <code>tree-folder</code>组件：</p><pre><code>&lt;p&gt;  &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt;  &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;&lt;/p&gt;</code></pre><p>以及一个 tree-folder-contents 组件：</p><pre><code>&lt;ul&gt;  &lt;li v-for=&quot;child in children&quot;&gt;    &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;    &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><p>当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点——这是矛盾的！当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。</p><p>然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：</p><pre><code>Failed to mount component: template or render function not defined.</code></pre><p>在我们的例子中，可以选择让 tree-folder 组件中来做这件事。我们知道引起矛盾的子组件是 tree-folder-contents，所以我们要等到 beforeCreate 生命周期钩子中才去注册它：</p><pre><code>beforeCreate: function () &#123;  this.$options.components.TreeFolderContents = require(&#39;./tree-folder-contents.vue&#39;)&#125;</code></pre><h3 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a>X-Template</h3><p>另一种定义模板的方式是在 JavaScript 标签里使用 <code>text/x-template</code>类型，并且指定一个 id。例如：</p><pre><code>&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;  &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&#39;hello-world&#39;, &#123;  template: &#39;#hello-world-template&#39;&#125;)</code></pre><p>这在有很多大模板的演示应用或者特别小的应用中可能有用，其它场合应该避免使用，因为这将模板和组件的其它定义分离了。</p><h3 id="对低开销的静态组件使用-v-once"><a href="#对低开销的静态组件使用-v-once" class="headerlink" title="对低开销的静态组件使用 v-once"></a>对低开销的静态组件使用 <code>v-once</code></h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：</p><pre><code>Vue.component(&#39;terms-of-service&#39;, &#123;  template: &#39;\    &lt;div v-once&gt;\      &lt;h1&gt;Terms of Service&lt;/h1&gt;\      ...很多静态内容...\    &lt;/div&gt;\  &#39;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vue-cli4/vue-cil3使用process.env.VUE_APP_BASE_API全局地址代替vue-cli2的process.env.BASE_API</title>
      <link href="/2022/08/29/vue-cli4vue-cil3%E4%BD%BF%E7%94%A8process.env.VUE_APP_BASE_API%E5%85%A8%E5%B1%80%E5%9C%B0%E5%9D%80%E4%BB%A3%E6%9B%BFvue-cli2%E7%9A%84process.env.BASE_API/"/>
      <url>/2022/08/29/vue-cli4vue-cil3%E4%BD%BF%E7%94%A8process.env.VUE_APP_BASE_API%E5%85%A8%E5%B1%80%E5%9C%B0%E5%9D%80%E4%BB%A3%E6%9B%BFvue-cli2%E7%9A%84process.env.BASE_API/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-cli4-vue-cil3使用process-env-VUE-APP-BASE-API全局地址代替vue-cli2的process-env-BASE-API"><a href="#vue-cli4-vue-cil3使用process-env-VUE-APP-BASE-API全局地址代替vue-cli2的process-env-BASE-API" class="headerlink" title="vue-cli4/vue-cil3使用process.env.VUE_APP_BASE_API全局地址代替vue-cli2的process.env.BASE_API"></a>vue-cli4/vue-cil3使用process.env.VUE_APP_BASE_API全局地址代替vue-cli2的process.env.BASE_API</h1><p>前几天Vue3.0正式发布，也说明了Vue3.0后面不会再有大规模改动，大家可以开始系统性学习了，虽然目前大多数公司使用的还是Vue2.0，但这只是一个过渡阶段，Vue3.0经历了两年的开发，在去年Vue2.0也引入了Vue3.0体验组件，后面基本是新项目肯定会使用Vue3.0，Vue2.0到Vue3.0变化还是蛮大的。今天就一起学一下vue-cli4/vue-cil3和vue-cli2在全局地址.env上的使用吧。</p><p>由于我们的项目需要在不同环境下进行运行(开发，生产，测试等)，这避免我们需要多次的去切换请求的地址以及相关的配置，vue-cli2是可以直接在config文件中进行配置的，但是vue-cli4和vue-cli3已经简化了，没有config文件怎么办？</p><p>一、建立.env系列文件<br>首先我们在根 <a href="vue%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.md">vue项目配置文件.md</a> 目录新建3个文件，分别为.env.development，.env.production，.env.test<br>注意文件是只有后缀的。</p><p>.env.development 模式用于serve，开发环境，就是开始环境的时候会引用这个文件里面的配置</p><p>.env.production模式用于build，线上环境。</p><p>.env.test 测试环境</p><p>二、修改文件<br>分别在文件内写上：</p><p>1.开发环境<br>//.env.development<br>VUE_APP_BASE_API = ‘需要请求API’<br>1<br>2<br>2.线上环境<br>//.env.production<br>VUE_APP_BASE_API = ‘需要请求API’<br>1<br>2<br>3.测试环境<br>//.env.test<br>VUE_APP_BASE_API = ‘需要请求API’<br>1<br>2<br>三、更改package.json文件<br> “scripts”: {<br>    “dev”: “vue-cli-service serve”,<br>    “test”: “vue-cli-service serve –mode test”,<br>    “build”: “vue-cli-service build”,<br>    “build:test”: “vue-cli-service build –mode test”,<br>    “lint”: “vue-cli-service lint”<br>  },<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>四、使用<br>当需要用到该变量是可以用process.env.VUE_APP_BASE_API进行取值。</p><p>例如：</p><p>在js文件中直接使用</p><p>const service = axios.create({<br>    baseURL: process.env.VUE_APP_BASE_API,<br>    timeout: 10000,<br>})<br>1<br>2<br>3<br>4<br>1.Vue2.0页面写法<br>通过data定义</p><template>    <div>        <a :href="this.uploadUrl">点击</a>    </div></template><script>export default {    data() {        return {            uploadUrl: process.env.VUE_APP_BASE_API,        }    }}</script><style scoped></style><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>使用computed()</p><template>    <div>        <a :href="VUE_APP_BASE_API">点击</a>    </div></template><script>export default {    computed: {        VUE_APP_BASE_API(){            return process.env.VUE_APP_BASE_API        }    }}</script><style scoped></style><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>2.Vue3.0页面写法<br>Vue3.0使用setup()的一个写法</p><template>    <div>        <a :href="uploadUrl">点击</a>    </div></template><script>export default {    setup() {        return {            uploadUrl:'process.env.VUE_APP_BASE_API'        }    }}</script><style scoped></style><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>或使用computed()</p><template>    <div>        <a :href="VUE_APP_BASE_API">点击</a>    </div></template><script>import { computed } from 'vue'export default {    setup() {        const VUE_APP_BASE_API = computed(()=>{            return process.env.VUE_APP_BASE_API        })        return {            VUE_APP_BASE_API        }    }}</script><style scoped></style><p>————————————————<br>版权声明：本文为CSDN博主「文化沙漠麦七」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_42783654/article/details/108842949">https://blog.csdn.net/qq_42783654/article/details/108842949</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-使用v-bind与v-on实现v-model</title>
      <link href="/2022/08/29/vue%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20v-bind%20%E4%B8%8E%20v-on%20%E6%9D%A5%E5%AE%9E%E7%8E%B0%20v-model%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%20%EF%BC%9F/"/>
      <url>/2022/08/29/vue%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20v-bind%20%E4%B8%8E%20v-on%20%E6%9D%A5%E5%AE%9E%E7%8E%B0%20v-model%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%20%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>vue — 使用v-bind与v-on实现v-model<br>v-model其实是一个语法糖，他的背后本质包含两个操作：1.v-bind绑定一个value属性2.v-on指令给当前元素绑定input事件</p><p>实现步骤如下：① 通过v-bind实现，若修改app.message，则使得网页显示的input中的value也发生改变。</p><body><div id="app">  <input type="text" :value='message'>  <h2></h2></div><script src="../JS/vue.js"></script><script>  const app = new Vue({      el:'#app',      data:{          message:'你好！',      }  })</script></body>② 通过v-on实现，若通过键入input，则修改app.message的值。<body><div id="app">  <input type="text" :value='message' @input='valueChange'>  <h2></h2></div><script src="../JS/vue.js"></script><script>  const app = new Vue({      el:'#app',      data:{          message:'你好！',      },      methods:{          valueChange(event){              app.message = event.target.value;           }      }  })</script></body>③ 更简单的书写方式实现v-on 根本不用绑定方法<body><div id="app">  <!-- 更简单的书写方式——根本不用绑定方法 -->  <input type="text" :value = 'message' @input='message = $event.target.value'>  <h2></h2></div><script src="../JS/vue.js"></script><script>  const app = new Vue({      el:'#app',      data:{          message:'你好！',      }  })</script></body>全部代码：<body><div id="app">  <!-- v-model其实是一个语法糖，他的背后本质包含两个操作：      1.v-bind绑定一个value属性      2.v-on指令给当前元素绑定input事件 -->  <!-- <input type="text" v-model = 'message'> -->  <!-- 上面语句 等同于 下面的连写 -->  <!-- 利用 v-bind: 和v-on: 即可实现 --><p>  &lt;input type=”text” :value=’message’ @input=’valueChange’&gt;</p>  <!-- 更简单的方法——根本不用绑定方法 --><p>  &lt;input type=”text” :value = ‘message’ @input=’message = $event.target.value’&gt;</p>  <h2></h2></div><script src="../JS/vue.js"></script><script>  const app = new Vue({      el:'#app',      data:{          message:'你好！',      },      methods:{          valueChange(event){              app.message = event.target.value;           }      }  })</script></body><p>总结：<br>以下两种方式是等同的<br><input type="text" v-model = 'message'><br>&lt;input type=”text” :value = ‘message’ @input=’message = $event.target.value’&gt;<br>————————————————<br>版权声明：本文为CSDN博主「青梅主码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qmzma/article/details/119327257">https://blog.csdn.net/qmzma/article/details/119327257</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-nextTick()</title>
      <link href="/2022/08/29/nextTick%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/08/29/nextTick%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>this.$nextTick()的使用场景</p><p>vue<br>专栏收录该内容<br>86 篇文章1 订阅<br>订阅专栏<br>一、用途</p><p>应用场景：需要在视图更新之后，基于新的视图进行操作。</p><p>this.$nextTick()方法主要是用在数据改变，dom改变应用场景中。vue中数据和dom渲染由于是异步的，所以，要让dom结构随数据改变这样的操作都应该放进this.$nextTick()的回调函数中。created()中使用的方法时，dom还没有渲染，如果此时在该钩子函数中进行dom赋值数据（或者其它dom操作）时无异于徒劳，所以，此时this.$nextTick()就会被大量使用，而与created()对应的是mounted()的钩子函数则是在dom完全渲染后才开始渲染数据，所以在mounted()中操作dom基本不会存在渲染问题。</p><p>二、官方说明：<br>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><p>三、原理：<br>this.$nextTick()将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><p>假设我们更改了某个dom元素内部的文本，而这时候我们想直接打印出这个被改变后的文本是需要dom更新之后才会实现的，也就好比我们将打印输出的代码放在setTimeout(fn, 0)中；</p><p>异步说明</p><p>事件循环说明</p><p>实例<br>（1）实例一</p><template>  <section>    <div ref="hello">      <h1>Hello World ~</h1>    </div>    <el-button type="danger" @click="get">点击</el-button>  </section></template><script>  export default {    methods: {      get() {      }    },    mounted() {      console.log(333);      console.log(this.$refs['hello']);      this.$nextTick(() => {        console.log(444);        console.log(this.$refs['hello']);      });    },    created() {      console.log(111);      console.log(this.$refs['hello']);      this.$nextTick(() => {        console.log(222);        console.log(this.$refs['hello']);      });    }  }</script><p>可以根据打印的顺序看到，在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作并无作用，而在created()里使用this.$nextTick()可以等待dom生成以后再来获取dom对象</p><p>（1）实例二</p><template>  <section>    <h1 ref="hello"></h1>    <el-button type="danger" @click="get">点击</el-button>  </section></template><script>  export default {    data() {      return {        value: 'Hello World ~'      };    },    methods: {      get() {        this.value = '你好啊';        console.log(this.$refs['hello'].innerText);          console.log(this.$refs['hello'].innerText);        });      }    },    mounted() {    },    created() {    }  }</script><p>结果：Hello world</p><p>​            你好啊</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-keep-alive-2</title>
      <link href="/2022/08/29/keepalive/"/>
      <url>/2022/08/29/keepalive/</url>
      
        <content type="html"><![CDATA[<p>vue单页面，多路由，前进刷新，后退不刷新<br>目的：vue-cli构建的vue单页面应用，某些特定的页面，实现前进刷新，后退不刷新，类似app般的用户体验。</p><p>注：　此处的刷新特指当进入此页面时，触发ajax请求，向服务器获取数据。不刷新特指当进入此页面时，不触发ajax请求，而是使用之前缓存的数据，以便减少服务器请求，用户体验更流畅。</p><p>1.在app.vue中改写router-view</p><pre><code>&lt;keep-alive&gt;    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;        &lt;!-- 这里是会被缓存的视图组件 --&gt;    &lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;    &lt;!-- 这里是不被缓存的视图组件 --&gt;&lt;/router-view&gt;</code></pre><p>2.在router/index.js中添加路由元信息，设置需要缓存的页面</p><pre><code>routes: [&#123;        path: &#39;/&#39;,        name: &#39;index&#39;,        component: index,        meta: &#123;            keepAlive: false, //此组件不需要被缓存        &#125;    &#125;,    &#123;        path: &#39;/page1&#39;,        name: &#39;page1&#39;,        component: page1,        meta: &#123;            keepAlive: true, //此组件需要被缓存            </code></pre><pre><code>    &#125;&#125;,&#123;    path: &#39;/page2&#39;,    name: &#39;page2&#39;,    component: page2,    meta: &#123;          keepAlive: true, // 此组件需要被缓存          isBack:false, //用于判断上一个页面是哪个      &#125;&#125;,&#123;    path: &#39;/page3&#39;,    name: &#39;page3&#39;,    component: page3,    meta: &#123;        keepAlive: false, // 此组件不需要被缓存    &#125;&#125;</code></pre><p>]</p><p>3.beforeRouteEnter中判断是从哪个页面过来的<br>判断是从哪个路由过来的，如果是page2过来的，表明当前页面不需要刷新获取新数据，直接用之前缓存的数据即可</p><pre><code class="js">beforeRouteEnter(to, from, next) &#123;  // 路由导航钩子，此时还不能获取组件实例 `this`，所以无法在data中定义变量（利用vm除外）  // 参考 https://router.vuejs.org/zh-cn/advanced/navigation-guards.html  // 所以，利用路由元信息中的meta字段设置变量，方便在各个位置获取。这就是为什么在meta中定义isBack  // 参考 https://router.vuejs.org/zh-cn/advanced/meta.html  if(from.name==&#39;page2&#39;)&#123;      to.meta.keepAlive=true;      //判断是从哪个路由过来的，      //如果是page2过来的，表明当前页面不需要刷新获取新数据，直接用之前缓存的数据即可  &#125;  next();&#125;,</code></pre><p>钩子函数的执行顺序<br>不使用keep-alive<br>beforeRouteEnter –&gt; created –&gt; mounted –&gt; destroyed</p><p>使用keep-alive<br>beforeRouteEnter –&gt; created –&gt; mounted –&gt; activated –&gt; deactivated<br>再次进入缓存的页面，只会触发beforeRouteEnter –&gt;activated –&gt; deactivated 。created和mounted不会再执行。我们可以利用不同的钩子函数，做不同的事。务必理解上述钩子函数的执行时机和执行顺序，本教程的核心就依赖于此钩子函数</p><p>activated和deactivated是使用keep-alive后，vue中比较重要的两个钩子函数，建议详细了解下。<br>4.activated中执行getData这个获取数据的方法<br>因为这个页面需要缓存。只有第一次进入时才会执行created和mounted方法，再次进入就不执行了。而activated每次进入都执行，所以在这个钩子函数中获取数据。</p><pre><code>activated() &#123;  if(!this.$route.meta.isBack)&#123;    // 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据    this.getData();  &#125;  // 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据  this.$route.meta.isBack=false&#125;</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「一只正在成长的程序猿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_44251396/article/details/97391206">https://blog.csdn.net/weixin_44251396/article/details/97391206</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vue checkbox使用v-model和@click遇到的坑</title>
      <link href="/2022/08/29/detail/"/>
      <url>/2022/08/29/detail/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-checkbox使用v-model和-click遇到的坑"><a href="#vue-checkbox使用v-model和-click遇到的坑" class="headerlink" title="vue checkbox使用v-model和@click遇到的坑"></a>vue checkbox使用v-model和@click遇到的坑</h2><h3 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h3><ul><li>使用v<code>-model=&quot;value&quot;</code>对checkbox进行了绑定，同时监听checkbox 的<code>click事件</code>，在click方法中使用了this.value取值。发现不同浏览器下，取到的this.value的值是<code>不同</code>的。</li></ul><p>代码如下：</p><pre><code>&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkboxValue&quot; @click=&quot;onClick&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;HelloWorld&#39;,  data () &#123;    return &#123;      checkboxValue: false    &#125;  &#125;  methods:&#123;    onClick()&#123;      console.log(this.checkboxValue);    &#125;  &#125;&#125;</code></pre><p> 以上代码默认checkbox是未选中状态，value是false。<br>当点击Checkbox选中的时候，会进入onClick的方法中。<br> 发现不同浏览器读取的<code>this.checkboxValue</code>的值是不同的</p><pre><code>Firefox / Chrome``打印输出： false``IE:``打印输出： true</code></pre><p> 也就是说在<code>Firefox/Chrome</code>浏览器下，是先执行click方法，然后再对checkboxValue进行赋值。<br> 而在<code>IE</code>下，是先对checkboxValue进行赋值，然后在执行click方法。</p><h3 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2. 原因分析"></a>2. 原因分析</h3><p> 与v-model的语法糖有关，详情请看<a href="http://jessyhong.github.io/2018/03/25/v-model-explain-detail/">《v-model语法糖》</a></p><pre><code>&lt;input type=&quot;checkbox&quot; v-model=&quot;sth&quot; /&gt;&lt;input type=&quot;checkbox&quot; :checked=&quot;checkboxValue&quot; @change=&quot;checkboxValue= $event.target.checked&quot; /&gt;</code></pre><p> 第一行的代码其实只是第二行的语法糖。<br> 问题是：click方法中使用了变量<code>this.checkboxValue</code>,因此如果是先触发了<code>change</code>事件，对checkboxValue进行了赋值。之后再触发<code>click</code>那么获取的结果就是正确的。<br> 有了以上想法之后：对<code>change,click</code>事件做了实验<br>实验浏览器版本：</p><pre><code>IE(11.0.9600.18977)``Firefox(52.7.3)``Chrome(66.0.3359.139)</code></pre><p> Firefox / Chrome: <code>先执行click事件，后执行change事件</code><br> IE: <code>先执行change事件，后执行click事件</code></p><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><h4 id="方法一：直接获取checked的值"><a href="#方法一：直接获取checked的值" class="headerlink" title="方法一：直接获取checked的值"></a>方法一：直接获取checked的值</h4><pre><code>&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkboxValue&quot; @click=&quot;onClick($event)&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;HelloWorld&#39;,  data () &#123;    return &#123;      checkboxValue: false    &#125;  &#125;,  methods:&#123;    onClick(event)&#123;      console.log(event.target.checked)    &#125;  &#125;,&#125;</code></pre><h4 id="方法二：使用-change进行监听，等值变化了再使用"><a href="#方法二：使用-change进行监听，等值变化了再使用" class="headerlink" title="方法二：使用@change进行监听，等值变化了再使用"></a>方法二：使用@change进行监听，等值变化了再使用</h4><pre><code>&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkboxValue&quot; @change=&quot;onChange&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;HelloWorld&#39;,  data () &#123;    return &#123;      checkboxValue: false    &#125;  &#125;,  methods:&#123;    onChange()&#123;      console.log(this.checkboxValue)    &#125;  &#125;,&#125;</code></pre><hr><p>作者： <a href="http://jessyhong.github.io/">Jessy Hong</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js-提供保存和打开按钮</title>
      <link href="/2022/08/29/%E4%B8%8B%E8%BD%BD%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/"/>
      <url>/2022/08/29/%E4%B8%8B%E8%BD%BD%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>1.msSaveOrOpenBlob：提供保存和打开按钮</p><pre><code>window.navigator.msSaveOrOpenBlob(blobObject, &#39;msSaveBlobOrOpenBlob_testFile.txt&#39;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-使用**JSEncrypt**给证件号手机号加密解密</title>
      <link href="/2022/08/29/35%E7%BB%99%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/2022/08/29/35%E7%BB%99%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>一。使用<strong>JSEncrypt</strong>给证件号手机号加密解密</p><p>1.vue项目首先通过npm insatll jsencrypt –save  下载下来</p><p>2.在需要的组件引入次模块   import  JSEncrypt from ‘jsencrypt’</p><pre><code class="js">  // 加密公钥​    const key = `----`​    // 加密​    export function setEncrypt(msg) &#123;​      const jsencrypt = new JSEncrypt()​      jsencrypt.setPublicKey(key)​      return jsencrypt.encrypt(msg)​    &#125;//现在main.js中将函数挂载到Vue原型上面Vue.prototype.setEncrypt = function(msg)&#123;    const jsencrypt = new JSEncrypt()​      jsencrypt.setPublicKey(key)​      return jsencrypt.encrypt(msg)&#125;​    // 解密私钥​    const privateKey = `---`​    // 解密​    export function decrypt(msg) &#123;​      let decrypt = new JSEncrypt()​      decrypt.setPrivateKey(privateKey)​      var decryptMsg = decrypt.decrypt(msg)​      return decryptMsg​    &#125;//现在main.js中将函数挂载到Vue原型上面Vue.prototype.decrypt = function(msg)&#123;    let decrypt = new JSEncrypt()​      decrypt.setPrivateKey(privateKey)​      return decrypt.decrypt(msg)&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Vue监视数据的原理</title>
      <link href="/2022/08/29/34vue%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/29/34vue%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>1.&lt;!–</p><p>​      Vue监视数据的原理：</p><p>​        \1. vue会监视data中所有层次的数据。</p><p>​        \2. 如何监测对象中的数据？</p><p>​                通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><p>​                  (1).对象中后追加的属性，Vue默认不做响应式处理</p><p>​                  (2).如需给后添加的属性做响应式，请使用如下API：</p><p>​                          Vue.set(target，propertyName/index，value) 或 </p><p>​                          vm.$set(target，propertyName/index，value)</p><p>​        \3. 如何监测数组中的数据？</p><p>​                  通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>​                    (1).调用原生对应的方法对数组进行更新。</p><p>​                    (2).重新解析模板，进而更新页面。</p><p>​        4.在Vue修改数组中的某个元素一定要用如下方法：</p><p>​              1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>​              2.Vue.set() 或 vm.$set()</p><p>​        特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p><p>​    –&gt;</p><ol start="2"><li><pre><code class="javascript">2.  &lt;!-- 准备好一个容器--&gt;        &lt;div id=&quot;root&quot;&gt;​      &lt;h1&gt;学生信息&lt;/h1&gt;​      &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;student.sex = &#39;未知&#39; &quot;&gt;修改性别&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt;​      &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt;​      &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;/h3&gt;​      &lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;/h3&gt;​      &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;​      &lt;h3&gt;爱好：&lt;/h3&gt;​      &lt;ul&gt;​        &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;​          &#123;&#123;h&#125;&#125;​        &lt;/li&gt;​      &lt;/ul&gt;​      &lt;h3&gt;朋友们：&lt;/h3&gt;​      &lt;ul&gt;​        &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;​          &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;​        &lt;/li&gt;​      &lt;/ul&gt;​    &lt;/div&gt;</code></pre></li></ol><p>3.</p><pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        const vm = new Vue(&#123;            el:&#39;#root&#39;,            data:&#123;                student:&#123;                    name:&#39;tom&#39;,                    age:18,                    hobby:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],                    friends:[                        &#123;name:&#39;jerry&#39;,age:35&#125;,                        &#123;name:&#39;tony&#39;,age:36&#125;                    ]                &#125;            &#125;,            methods: &#123;                addSex()&#123;                    // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)                    this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)                &#125;,                addFriend()&#123;                    this.student.friends.unshift(&#123;name:&#39;jack&#39;,age:70&#125;)                &#125;,                updateFirstFriendName()&#123;                    this.student.friends[0].name = &#39;张三&#39;                &#125;,                addHobby()&#123;                    this.student.hobby.push(&#39;学习&#39;)                &#125;,                updateHobby()&#123;                    // this.student.hobby.splice(0,1,&#39;开车&#39;)                    // Vue.set(this.student.hobby,0,&#39;开车&#39;)                    this.$set(this.student.hobby,0,&#39;开车&#39;)                &#125;,                removeSmoke()&#123;                    this.student.hobby = this.student.hobby.filter((h)=&gt;&#123;                        return h !== &#39;抽烟&#39;                    &#125;)                &#125;            &#125;        &#125;)    &lt;/script&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vuex-2</title>
      <link href="/2022/08/29/33vuex-2/"/>
      <url>/2022/08/29/33vuex-2/</url>
      
        <content type="html"><![CDATA[<p>一.前言<br>　　本文章是vuex系列的最后一篇，主要总结的是如何使用mapState和mapGetters访问vuex中的state和getters。</p><p>二.多个模块中mapState和mapGetters的使用<br>　　上一篇文章《Vuex实践（中）》里面我们总结的就是多模块的内容，所以关于store.js、moduleA.js和moduleB.js的代码保持不变。</p><p>　　在此为了方便观看，我将这三个文件的代码在贴在这里</p><p>E:\MyStudy\test\VueDemo\src\vuex\store.js</p><p> 1 import Vue from ‘vue’<br> 2 import Vuex from ‘vuex’<br> 3 import moduleA from ‘./moduleA’<br> 4 import moduleB from ‘./moduleB’<br> 5<br> 6 Vue.use(Vuex)<br> 7<br> 8 export default new Vuex.Store({<br> 9     state: {<br>10         counter: 1000<br>11     },<br>12     mutations: {<br>13         //递增<br>14         increase(state) {<br>15             console.log(“store-increase”)<br>16             state.counter++<br>17         },<br>18         //递减<br>19         decrement(state) {<br>20             state.counter–<br>21         }<br>22     },<br>23     actions: {<br>24         increaseAction(context) {<br>25             setTimeout(function(){<br>26                 //action通过提交mutation改变共享数据状态<br>27                 context.commit(‘increase’);<br>28             },3000)<br>29         },<br>30         decrementAction(context){<br>31             setTimeout(function(){<br>32                 //action通过提交mutation改变共享数据状态<br>33                 context.commit(‘decrement’);<br>34             },3000)<br>35         }<br>36     },<br>37     getters: {<br>38         doubleCounter(state) {<br>39             return state.counter*state.counter<br>40         }<br>41     },<br>42     modules: {<br>43         a: moduleA,<br>44         b: moduleB<br>45     }<br>46 })</p><p>E:\MyStudy\test\VueDemo\src\vuex\moduleA.js</p><p>const moduleA = {<br>    namespaced: true,<br>    state:{<br>        counter: 100<br>    },<br>    mutations: {<br>        //递增<br>        increase(state) {<br>            console.log(“moduleA-increase”)<br>            state.counter++<br>        },<br>        //递减<br>        decrement(state) {<br>            state.counter–<br>        }<br>    },<br>    actions: {<br>        increaseAction(context) {<br>            setTimeout(function(){<br>                //action通过提交mutation改变共享数据状态<br>                context.commit(‘increase’);<br>            },3000)<br>        },<br>        decrementAction(context){<br>            setTimeout(function(){<br>                //action通过提交mutation改变共享数据状态<br>                context.commit(‘decrement’);<br>            },3000)<br>        }<br>    },<br>    getters: {<br>        doubleCounter(state) {<br>            return state.counter*state.counter<br>        }<br>    }<br>}</p><p>export default moduleA</p><p>E:\MyStudy\test\VueDemo\src\vuex\moduleB.js</p><p> 1 const moduleB = {<br> 2     namespaced: true,<br> 3     state:{<br> 4         counter: 5<br> 5     },<br> 6     mutations: {<br> 7         //递增<br> 8         increase(state) {<br> 9             console.log(“moduleB-increase”)<br>10             state.counter++<br>11         },<br>12         //递减<br>13         decrementAction(state) {<br>14             state.counter–<br>15         }<br>16     },<br>17     actions: {<br>18         increaseAction(context) {<br>19             setTimeout(function(){<br>20                 //action通过提交mutation改变共享数据状态<br>21                 context.commit(‘increase’);<br>22             },3000)<br>23         },<br>24         decrementAction(context){<br>25             setTimeout(function(){<br>26                 //action通过提交mutation改变共享数据状态<br>27                 context.commit(‘decrement’);<br>28             },3000)<br>29         }<br>30     },<br>31     getters: {<br>32         doubleCounter(state){<br>33             return state.counter*state.counter<br>34         }<br>35     }<br>36 }<br>37<br>38 export default moduleB</p><p>　　现在需要在组件中使用mapState和mapGetters</p><p>　　还是按照之前的套路</p><p>　　在App.vue组件中访问根根模块store和a模块moduleA的state和getters。</p><p>　　在Index.vue组件中访问b模块moduleB的state和getters</p><p>1.使用mapState</p><p>　　使用mapState访问state的写法也有多种，我们一个一个来实践（不包含es6的写法）</p><p>　　[第一种写法]</p><p>E:\MyStudy\test\VueDemo\src\App.vue　　</p><template>  <div id="app">    <img src="./assets/logo.png">    <!-- 获取共享数据 -->    <h1>这里是App组件</h1>    <h3> App组件获取共享数据 </h3>    <h3>使用mapState访问根组件counter : </h3>    <h3>使用mapState访问a组件counter : </h3>    <hr/>    <Index></Index>  </div></template><script>import Index  from './components/Index'import { mapState } from 'vuex'export default {  name: 'App',  components: { Index },  computed: mapState({    //访问store根模块    counter: function(state){      return state.counter    },    //访问a模块    counterA: function(state){      return state.a.counter    }  })}</script><style>#app {  font-family: 'Avenir', Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;}</style><p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p><template>    <div>          <h1>这里是Index.vue组件</h1>        <h3>Index组件获取共享数据 </h3>        <h3>使用mapState访问b模块counter ：</h3>    </div></template><script>import { mapState } from 'vuex'export default {    name: 'Index',    computed: mapState({        counterB: function(state){            return state.b.counter        }    })}</script><p>　　在App.vue、Index.vue组件中使用mapState，首先第一步需要引入mapState。</p><p>　　接着就是在计算属性computed中使用，以Index.vue中的代码为例</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>computed: mapState({</p><pre><code>counterB: function(state)&#123;     return state.b.counter&#125;</code></pre><p>})</p><p> 　   可以看到mapState关联到vue的计算属性中。</p><p>　　获取b模块的state，只需要以vue计算属性的形式在函数中返回state.b.counter即可。</p><p>　 （获取根模块state返回state.counter；获取a模块state返回state.a.counter）</p><p>　　这样在模板中就可以使用计算属性的语法访问state</p><p>　　备注：这种方式，当注释掉命名空间的配置后，依然可以正常访问到不同模块的state</p><p>　　[第二种写法]</p><p>　　第二种写法和第一种有些类似，只是以字符串的形式返回计算属性。</p><p>　　我们先在Index.vue组件中访问b模块的数据。</p><p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p><p> 1 <template><br> 2     <div><br> 3         <h1>这里是Index.vue组件</h1><br> 4         <h3>Index组件获取共享数据 </h3><br> 5         <h3>使用mapState访问b模块counter ：</h3><br> 6     </div><br> 7 </template><br> 8 <script><br> 9 import { mapState } from 'vuex'<br>10 export default {<br>11     name: 'Index',<br>12     computed: mapState('b',{<br>13         counterB: 'counter'<br>14     })<br>15 }<br>16 </script></p><p>　　核心代码如下</p><p>1</p><p>2</p><p>3</p><p>computed: mapState(‘b’,{</p><pre><code>counterB: &#39;counter&#39;</code></pre><p>})</p><p> 　  可以看到，mapState第一个参数限定了模块名称。</p><p>　　接着就是以’counter’字符串的形式返回了b模块的counter值。</p><p>　　那么根据之前一系列的总结，可知</p><p>　　　　访问根模块的数据，不需要限定第一个参数；</p><p>　　　　访问a模块的数据，需要限定第一个参数为a</p><p>　　然而，因为访问根模块和访问a模块同在App.vue组件中，那么因为mapState第一个参数限定的问题，我们需要编写两个mapState。</p><p>　　现在直接上代码（只把computed中的核心代码贴上）</p><p>E:\MyStudy\test\VueDemo\src\App.vue　　</p><p>computed: {<br>    …mapState({<br>      //访问store根模块<br>      counter: ‘counter’,<br>    }),<br>    …mapState(‘a’,{<br>      //访问a模块<br>      counterA: ‘counter’<br>    })<br>}</p><p>　　可以看到，我写了两个mapState，还是…mapState的形式。</p><p>　　…mapState它是ES6中扩展运算符的语法，应用在mapState上，官方文档是这样说的</p><p>　　</p><p> 　 （</p><p>　　　　此处若对此有疑问，可以在去仔细研究一下对象扩展运算符的内容。</p><p>　　　　我这里贴一个简单的示例</p><p>　　　　</p><p> 　　　  最终newObj的打印结果为　　</p><p>　　　　相信这个示例可以很清楚的解释我们写的两个…mapState的写法</p><p>　　）</p><p>　　官方文档处提到这个对象展开运算符的场景是为了将一个组件中原本的计算属性和mapState混合使用</p><p>　　（混合使用这个点日常开发会用到，很实用的一个点）。</p><p>　　那本次我们也是使用这个语法成功的获取到了不同模块的state。</p><p>　　最后我们在使用浏览器查看一下最终App.vue和Index.vue中的结果</p><p>　　</p><p>　　我们已经使用mapState成功的访问到了多模块中的state数据。</p><p>　</p><p>　　备注：这种关于mapState的写法不能删除moduleA和moduleB中关于命令空间的配置，否则会报错。</p><p>　　最后作者还尝试了一个问题，就是将moduleA.js中的state属性改为counterA</p><p>　　</p><p>　　然后修改了App.vue组件中computed访问a模块数据的代码</p><p>　　</p><p>　　最后发现这样并不能正常访问到a模块的state数据。（删除a模块的命名空间配置也无法正常访问）</p><p>　　这个尝试仅给大家一个反面的示例。</p><p>2.使用mapGetters</p><p>　　前面使用mapState访问了state数据，那么现在我们使用mapGetters访问一下vuex中的getters。</p><p>　　在研究之后发现，暂时发现使用mapGetters访问一下vuex中的getters只有字符串的形式。</p><p>E:\MyStudy\test\VueDemo\src\App.vue</p><p> 1 <template><br> 2   <div id="app"><br> 3     <img src="./assets/logo.png"><br> 4     <!-- 获取共享数据 --><br> 5     <h1>这里是App组件</h1><br> 6     <h3> App组件获取共享数据 </h3><br> 7     <h3>使用mapState访问根组件counter : </h3><br> 8     <h3>使用mapState访问a组件counter : </h3><br> 9     <h3>使用mapGetters访问根组件doubleCounter : </h3><br>10     <h3>使用mapGetters访问a组件doubleCounter : </h3><br>11     <hr/><br>12     <Index></Index><br>13   </div><br>14 </template><br>15<br>16 <script><br>17 import Index  from './components/Index'<br>18 import { mapState,mapGetters } from 'vuex'<br>19 export default {<br>20   name: 'App',<br>21   components: { Index },<br>22   computed: {<br>23     ...mapState({<br>24       //访问store根模块<br>25       counter: 'counter',<br>26     }),<br>27     ...mapState('a',{<br>28       //访问a模块<br>29       counterA: 'counter'<br>30     }),<br>31     ...mapGetters({<br>32       //访问store根模块<br>33       doubleCounter: 'doubleCounter'<br>34     }),<br>35     ...mapGetters('a',{<br>36       //访问store根模块<br>37       doubleCounterA: 'doubleCounter'<br>38     })<br>39<br>40   }<br>41<br>42 }<br>43 </script><br>44<br>45 <style><br>46 #app {<br>47   font-family: ‘Avenir’, Helvetica, Arial, sans-serif;<br>48   -webkit-font-smoothing: antialiased;<br>49   -moz-osx-font-smoothing: grayscale;<br>50   text-align: center;<br>51   color: #2c3e50;<br>52   margin-top: 60px;<br>53 }<br>54 </style></p><p>E:\MyStudy\test\VueDemo\src\components\Index.vue</p><p> 1 <strong><strong><template><br> 2     <div><br> 3         <h1>这里是Index.vue组件</h1><br> 4         <h3>Index组件获取共享数据 </h3><br> 5         <h3>使用mapState访问b模块counter ：</h3><br> 6         <h3>使用mapGetters访问b组件doubleCounter : </h3><br> 7     </div><br> 8 </template></strong><br> 9 <script><br>10 import { mapState,mapGetters } from 'vuex'<br>11 export default {<br>12     name: 'Index',<br>13     computed: {<br>14         ...mapState('b',{<br>15             counterB: 'counter'<br>16          }),<br>17         ...mapGetters('b',{<br>18             doubleCounterB: 'doubleCounter'<br>19         }),<br>20     }<br>21 }<br>22 </script></strong></p><p>　　浏览器查看结果</p><p>　　</p><p>三.总结</p><p>　　在最后呢，再补充一点，不管是mapState和mapGetters，我们给传入的都是一个字典。</p><p>　　简单一些的，假如我们的state和getters不重名，我们可以给mapState和mapGetters传入一个数组</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-自定义属性props</title>
      <link href="/2022/08/29/31%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7props/"/>
      <url>/2022/08/29/31%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7props/</url>
      
        <content type="html"><![CDATA[<h3 id="一、属性"><a href="#一、属性" class="headerlink" title="一、属性"></a>一、属性</h3><h4 id="1-自定义属性props"><a href="#1-自定义属性props" class="headerlink" title="1. 自定义属性props"></a>1. 自定义属性props</h4><p>prop 定义了这个组件有哪些可配置的属性，组件的核心功能也都是它来确定的。写通用组件时，props 最好用对象的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，这点在组件开发中很重要，然而很多人却忽视，直接使用 props 的数组用法，这样的组件往往是不严谨的。</p><pre><code>// 父组件 &lt;props name=&#39;属性&#39;          :type=&#39;type&#39;         :is-visible=&quot;false&quot;          :on-change=&quot;handlePropChange&quot;          :list=[22,33,44]          title=&quot;属性Demo&quot;          class=&quot;test1&quot;          :class=&quot;[&#39;test2&#39;]&quot;           :style=&quot;&#123; marginTop: &#39;20px&#39; &#125;&quot; //注意:style 的优先级是要高于style  style=&quot;margin-top: 10px&quot;&gt;  &lt;/props&gt;// 子组件  props: &#123;     name: String,        type: &#123;//从父级传入的 type，它的值必须是指定的 &#39;success&#39;, &#39;warning&#39;,&#39;danger&#39;中的一个，如果传入这三个以外的值，都会抛出一条警告         validator: (value) =&gt; &#123;                return [&#39;success&#39;, &#39;warning&#39;,&#39;danger&#39;].includes(value)       &#125;       &#125;,        onChange: &#123;//对于接收的数据，可以是各种数据类型，同样也可以传递一个函数           type: Function,              default: () =&gt; &#123; &#125;        &#125;,       isVisible: &#123;      type: Boolean,      default: false    &#125;,     list: &#123;  type: Array, // 对象或数组默认值必须从一个工厂函数获取             default: () =&gt; []       &#125;  &#125;</code></pre><p>从上面的例中，可以得出props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，<strong>同样也可以传递一个函数。通过一般属性实现父向子通信；通过函数属性实现子向父通信</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vue-router</title>
      <link href="/2022/08/29/30%20vue-router/"/>
      <url>/2022/08/29/30%20vue-router/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>Vue Router 是 <a href="http://cn.vuejs.org/">Vue.js</a> 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：</p><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    // 动态路径参数 以冒号开头    &#123; path: &#39;/user/:id&#39;, component: User &#125;  ]&#125;)</code></pre><p>现在呢，像 <code>/user/foo</code> 和 <code>/user/bar</code> 都将映射到相同的路由。</p><p>一个“路径参数”使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 ID：</p><pre><code class="js">const User = &#123;  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#39;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-vue/cli</title>
      <link href="/2022/08/29/29%20vuecli/"/>
      <url>/2022/08/29/29%20vuecli/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue/cli"></a>vue/cli</h1><h2 id="全局-CLI-配置"><a href="#全局-CLI-配置" class="headerlink" title="全局 CLI 配置"></a>全局 CLI 配置</h2><p>有些针对 <code>@vue/cli</code> 的全局配置，例如你惯用的包管理器和你本地保存的 preset，都保存在 home 目录下一个名叫 <code>.vuerc</code> 的 JSON 文件。你可以用编辑器直接编辑这个文件来更改已保存的选项。</p><p>你也可以使用 <code>vue config</code> 命令来审查或修改全局的 CLI 配置。</p><h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。你也可以使用 <code>package.json</code> 中的 <code>vue</code> 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p><p>这个文件应该导出一个包含了选项的对象：</p><pre><code class="js">// vue.config.jsmodule.exports = &#123;  // 选项...&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-单文件组件</title>
      <link href="/2022/08/29/28%20%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/"/>
      <url>/2022/08/29/28%20%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><p>在很多 Vue 项目中，我们使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue(&#123; el: &#39;#container &#39;&#125;)</code> 在每个页面内指定一个容器元素。</p><p>这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：</p><ul><li><strong>全局定义 (Global definitions)</strong> 强制要求每个 component 中的命名不得重复</li><li><strong>字符串模板 (String templates)</strong> 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\</code></li><li><strong>不支持 CSS (No CSS support)</strong> 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li><li><strong>没有构建步骤 (No build step)</strong> 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li></ul><p>文件扩展名为 <code>.vue</code> 的 <strong>single-file components(单文件组件)</strong> 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。</p><p>这是一个文件名为 <code>Hello.vue</code> 的简单实例：</p><p><a href="https://gist.github.com/chrisvfritz/e2b6a6110e0829d78fa4aedf7cf6b235"><img src="https://cn.vuejs.org/images/vue-component.png" alt="单文件组件的示例 (点击查看文本版的代码)"></a></p><p>现在我们获得：</p><ul><li><a href="https://github.com/vuejs/awesome-vue#source-code-editing">完整语法高亮</a></li><li><a href="https://webpack.js.org/concepts/modules/#what-is-a-webpack-module">CommonJS 模块</a></li><li><a href="https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html">组件作用域的 CSS</a></li></ul><p>正如我们说过的，我们可以使用预处理器来构建简洁和功能更丰富的组件，比如 Pug，Babel (with ES2015 modules)，和 Stylus。</p><p><a href="https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587"><img src="https://cn.vuejs.org/images/vue-component-with-preprocessors.png" alt="带预处理器的单文件组件的示例 (点击查看文本版的代码)"></a></p><p>这些特定的语言只是例子，你可以只是简单地使用 Babel，TypeScript，SCSS，PostCSS - 或者其他任何能够帮助你提高生产力的预处理器。如果搭配 <code>vue-loader</code> 使用 webpack，它也能为 CSS Modules 提供头等支持。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-过滤器</title>
      <link href="/2022/08/29/27%20%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/08/29/27%20%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>过滤器</p><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p><pre><code class="html">&lt;!-- 在双花括号中 --&gt;&lt;div&gt;&#123;&#123;myname | myfilter1 | myfilter2&#125;&#125;&lt;/div&gt;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</code></pre><p>你可以在一个组件的选项中定义本地的过滤器：</p><pre><code class="js">  Vue.filter(&quot;myfilter1&quot;, data =&gt; &#123;    return data.substring(0, 1)  &#125;)  Vue.filter(&quot;myfilter2&quot;, data =&gt; &#123;    return data.toUpperCase()  &#125;)  Vue.filter(&quot;myimg&quot;, data =&gt; &#123;    return `https://cube.elemecdn.com/$&#123;data[0]&#125;/$&#123;data.substring(1,3)&#125;/$&#123;data.substring(3,data.length)&#125;.jpeg?x-oss-process=image/format,webp/resize,w_90,h_90,m_fixed`  &#125;)</code></pre><p>或者在创建 Vue 实例之前全局定义过滤器：</p><pre><code class="js">Vue.filter(&#39;capitalize&#39;, function (value) &#123;    if (!value) return &#39;&#39;    value = value.toString()    return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123;    // ...&#125;)</code></pre><p>当全局过滤器和局部过滤器重名时，会采用局部过滤器</p><p>过滤器可以串联：</p><pre><code class="html">&#123;&#123; message | filterA | filterB &#125;&#125;</code></pre><p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p><p>过滤器是 JavaScript 函数，因此可以接收参数：</p><pre><code class="html">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</code></pre><p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>&#39;arg1&#39;</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-自定义指令</title>
      <link href="/2022/08/29/26%20%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/08/29/26%20%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="Vue-directives"><a href="#Vue-directives" class="headerlink" title="Vue.directives"></a>Vue.directives</h2><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：</p><p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p><pre><code class="js">// 注册一个全局自定义指令 `v-focus`Vue.directive(&#39;focus&#39;, &#123;  // 当被绑定的元素插入到 DOM 中时……  inserted: function (el) &#123;    // 聚焦元素    el.focus()  &#125;&#125;)</code></pre><p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p><pre><code class="js">directives: &#123;  focus: &#123;    // 指令的定义    inserted: function (el) &#123;      el.focus()    &#125;  &#125;&#125;</code></pre><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p><pre><code class="html">&lt;input v-focus&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-生命周期</title>
      <link href="/2022/08/29/25%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/08/29/25%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p><h2 id="选项-生命周期钩子"><a href="#选项-生命周期钩子" class="headerlink" title="选项 / 生命周期钩子"></a><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">选项 / 生命周期钩子</a></h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><a href="https://cn.vuejs.org/v2/api/#beforeCreate">beforeCreate</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置前被调用。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="created"><a href="#created" class="headerlink" title="created"></a><a href="https://cn.vuejs.org/v2/api/#created">created</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前尚不可用。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><a href="https://cn.vuejs.org/v2/api/#beforeMount">beforeMount</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><a href="https://cn.vuejs.org/v2/api/#mounted">mounted</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。 如果根实例挂载到了一个文档内的元素上，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。</p><p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p><pre><code>mounted: function () &#123;  this.$nextTick(function () &#123;    // Code that will run only after the    // entire view has been rendered  &#125;)&#125;</code></pre><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a><a href="https://cn.vuejs.org/v2/api/#beforeUpdate">beforeUpdate</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p><p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a><a href="https://cn.vuejs.org/v2/api/#updated">updated</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p><p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p><pre><code>updated: function () &#123;  this.$nextTick(function () &#123;    // Code that will run only after the    // entire view has been re-rendered  &#125;)&#125;</code></pre><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a><a href="https://cn.vuejs.org/v2/api/#activated">activated</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>被 keep-alive 缓存的组件激活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#keep-alive">构建组件 - keep-alive</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive">动态组件 - keep-alive</a></li></ul></li></ul><h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a><a href="https://cn.vuejs.org/v2/api/#deactivated">deactivated</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>被 keep-alive 缓存的组件停用时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/api/#keep-alive">构建组件 - keep-alive</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive">动态组件 - keep-alive</a></li></ul></li></ul><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a><a href="https://cn.vuejs.org/v2/api/#beforeDestroy">beforeDestroy</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a><a href="https://cn.vuejs.org/v2/api/#destroyed">destroyed</a></h3><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul><h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a><a href="https://cn.vuejs.org/v2/api/#errorCaptured">errorCaptured</a></h3><blockquote><p>2.5.0+ 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p></li><li><p><strong>详细</strong>：</p><p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p><p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p><p><strong>错误传播规则</strong></p><ul><li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li><li>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li><li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</li><li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-过渡效果</title>
      <link href="/2022/08/29/24%20%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/"/>
      <url>/2022/08/29/24%20%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开 &amp; 列表过渡"></a>进入/离开 &amp; 列表过渡</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染 (使用 <code>v-if</code>)</li><li>条件展示 (使用 <code>v-show</code>)</li><li>动态组件</li><li>组件根节点</li></ul><p>这里是一个典型的例子：</p><pre><code class="html">&lt;div id=&quot;demo&quot;&gt;    &lt;button v-on:click=&quot;show = !show&quot;&gt;        Toggle    &lt;/button&gt;    &lt;transition name=&quot;fade&quot;&gt;        &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;    &lt;/transition&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;  el: &#39;#demo&#39;,  data: &#123;    show: true  &#125;&#125;).fade-enter-active, .fade-leave-active &#123;  transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;  opacity: 0;&#125;</code></pre><p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p><ol><li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li><li>如果过渡组件提供了 <a href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90">JavaScript 钩子函数</a>，这些钩子函数将在恰当的时机被调用。</li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 <code>nextTick</code> 概念不同)</li></ol><h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有 6 个 class 切换。</p><ol><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li><code>v-enter-to</code>: <strong>2.1.8版及以上</strong> 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>: <strong>2.1.8版及以上</strong> 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li></ol><p><img src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"></p><p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>，则 `v-` 是这些类名的默认前缀。如果你使用了 </code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p><p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。</p><h3 id="初始化渲染页面时过渡"><a href="#初始化渲染页面时过渡" class="headerlink" title="初始化渲染页面时过渡"></a>初始化渲染页面时过渡</h3><p>需要利用apper属性</p><pre><code class="html">&lt;transition name=&#39;retr0&#39; appear&gt;    &lt;div v-if=&#39;isshow&#39; style=&#39;background:red;&#39;&gt;        show    &lt;/div&gt;&lt;/transition&gt;</code></pre><h3 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h3><p>我们可以通过以下 attribute 来自定义过渡类名：</p><ul><li><code>enter-class</code></li><li><code>enter-active-class</code></li><li><code>enter-to-class</code> (2.1.8+)</li><li><code>leave-class</code></li><li><code>leave-active-class</code></li><li><code>leave-to-class</code> (2.1.8+)</li></ul><pre><code class="html">&lt;transition enter-active-class=&#39;animated bounceInRight&#39; leave-active-class=&#39;animated bounceOutRight&#39; appear&gt;    &lt;div v-if=&#39;isshow&#39;&gt;动画&lt;/div&gt;&lt;/transition&gt;</code></pre><h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><ul><li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li><li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><pre><code class="html">&lt;transition enter-active-class=&#39;animated bounceInRight&#39; leave-active-class=&#39;animated bounceOutRight&#39; appear mode-&#39;out-in&#39;&gt;    &lt;div v-if=&#39;isshow&#39;&gt;动画一&lt;/div&gt;    &lt;div v-else&gt;动画一&lt;/div&gt;&lt;/transition&gt;</code></pre><h2 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h2><p>多个组件的过渡简单很多 - 我们不需要使用 <code>key</code> attribute。相反，我们只需要使用<a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a>：</p><pre><code class="html">&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;  &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;</code></pre><pre><code class="css">.component-fade-enter-active, .component-fade-leave-active &#123;  transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to/* .component-fade-leave-active for below version 2.1.8 */ &#123;  opacity: 0;&#125;</code></pre><pre><code class="js">new Vue(&#123;  el: &#39;#transition-components-demo&#39;,  data: &#123;    view: &#39;v-a&#39;  &#125;,  components: &#123;    &#39;v-a&#39;: &#123;      template: &#39;&lt;div&gt;Component A&lt;/div&gt;&#39;    &#125;,    &#39;v-b&#39;: &#123;      template: &#39;&lt;div&gt;Component B&lt;/div&gt;&#39;    &#125;  &#125;&#125;)</code></pre><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>目前为止，关于过渡我们已经讲到：</p><ul><li>单个节点</li><li>同一时间渲染多个节点中的一个</li></ul><p>那么怎么同时渲染整个列表，比如使用 <code>v-for</code> ？在这种场景中，使用 `` 组件。在我们深入例子之前，先了解关于这个组件的几个特点：</p><ul><li>不同于 <code>，它会以一个真实元素呈现：默认为一个 </code>。你也可以通过 <code>tag</code> attribute 更换为其他元素。</li><li><a href="https://cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E6%A8%A1%E5%BC%8F">过渡模式</a>不可用，因为我们不再相互切换特有的元素。</li><li>内部元素 <strong>总是需要</strong> 提供唯一的 <code>key</code> 属性值。</li><li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。</li></ul><h3 id="列表的进入-离开过渡"><a href="#列表的进入-离开过渡" class="headerlink" title="列表的进入/离开过渡"></a>列表的进入/离开过渡</h3><p>现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。</p><pre><code class="html">&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt;    &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;    &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;    &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;        &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;            &#123;&#123; item &#125;&#125;        &lt;/span&gt;    &lt;/transition-group&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el: &#39;#list-demo&#39;,    data: &#123;        items: [1,2,3,4,5,6,7,8,9],        nextNum: 10    &#125;,    methods: &#123;        randomIndex: function () &#123;            return Math.floor(Math.random() * this.items.length)        &#125;,        add: function () &#123;            this.items.splice(this.randomIndex(), 0, this.nextNum++)        &#125;,        remove: function () &#123;            this.items.splice(this.randomIndex(), 1)        &#125;,    &#125;&#125;)</code></pre><h2 id="可复用的过渡"><a href="#可复用的过渡" class="headerlink" title="可复用的过渡"></a>可复用的过渡</h2><p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>或者</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p><p>使用 template 的简单例子：</p><pre><code class="js">Vue.component(&#39;my-special-transition&#39;, &#123;  template: &#39;\    &lt;transition\      name=&quot;very-special-transition&quot;\      mode=&quot;out-in&quot;\      v-on:before-enter=&quot;beforeEnter&quot;\      v-on:after-enter=&quot;afterEnter&quot;\    &gt;\      &lt;slot&gt;&lt;/slot&gt;\    &lt;/transition&gt;\  &#39;,  methods: &#123;    beforeEnter: function (el) &#123;      // ...    &#125;,    afterEnter: function (el) &#123;      // ...    &#125;  &#125;&#125;)</code></pre><p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6">函数式组件</a>更适合完成这个任务：</p><pre><code class="js">Vue.component(&#39;my-special-transition&#39;, &#123;  functional: true,  render: function (createElement, context) &#123;    var data = &#123;      props: &#123;        name: &#39;very-special-transition&#39;,        mode: &#39;out-in&#39;      &#125;,      on: &#123;        beforeEnter: function (el) &#123;          // ...        &#125;,        afterEnter: function (el) &#123;          // ...        &#125;      &#125;    &#125;    return createElement(&#39;transition&#39;, data, context.children)  &#125;&#125;)</code></pre><p>第三方过渡动画库</p><pre><code class="shell">npm istall animate.css --save 下载依赖包</code></pre><pre><code class="js">import &#39;animate.css&#39;; 引入</code></pre><p><a href="https://animate.style/">https://animate.style/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React- React Hooks</title>
      <link href="/2022/08/25/22%20react%20hooks/"/>
      <url>/2022/08/25/22%20react%20hooks/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><h2 id="使用hooks的理由"><a href="#使用hooks的理由" class="headerlink" title="使用hooks的理由"></a>使用hooks的理由</h2><ol><li>高阶组件为了复用，导致代码层级复杂</li><li>生命周期的复杂</li><li>写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高</li></ol><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><pre><code class="js">import React , &#123;useState&#125; from &#39;react&#39;</code></pre><pre><code class="jsx">export default function App () &#123;    const [name,setname] = useState(&#39;xiaoming&#39;)    const changeName = ()=&gt;&#123;        setname(&#39;retr0&#39;)    &#125;    return (        &lt;div&gt;            &#123;name&#125;            &lt;button onClick=&#123;changeName&#125;&gt;&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><pre><code class="js">import React, &#123;useRef&#125; from &#39;react&#39;</code></pre><pre><code class="jsx">export default function App () &#123;    const ref = useRef(null)    return (        &lt;div&gt;            &lt;input type=&#39;text&#39; ref=&#123;ref&#125;/&gt;             &lt;button onClick=&#123;()=&gt;&#123;                       console.log(ref.current)                &#125;&#125;&gt;&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><blockquote><p>Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。</p><p>useEffect(处理函数，[依赖]) 副作用方法:每次依赖改变都会执行一次，如果没有依赖只有一个空数组，那么只会执行一次（有点像componentDidmount）</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li>回调函数</li><li>数组<ul><li>不传数组：无法起到只渲染一次的作用</li><li>空数组：一次生命周期中只调用一次回调函数</li><li>[text,name]：如果text状态或者name状态变化，就会调用该回调函数</li></ul></li></ol><pre><code class="js">import React , &#123;useState,useEffect&#125; from &#39;react&#39;</code></pre><pre><code class="jsx">export default function App () &#123;    const [name,setname] = useState(&#39;xiaoming&#39;)    useEffect(()=&gt;&#123;        let index =1        let t = setInterval(()=&gt;&#123;            console.log(++index)        &#125;,500)        return ()=&gt;&#123;            console.log(&#39;销毁&#39;)            clearInterval(t)        &#125;    &#125;,[])    return (        &lt;div&gt;&lt;/div&gt;    )&#125;</code></pre><p>不要对 Dependencies 撒谎, 如果你明明使用了某个变量，却没有申明在依赖中，你等于向 React撒了谎，后果就是，当依赖的变量改变时，useEffect 也不会再次执行, eslint会报警告</p><p>Preview页面改造成函数式组件，在路径上从id=1切换到id=2也会自动重新加载，比class组件方便,class组件需要通过componentWillMout和</p><pre><code class="jsx">useEffect(()=&gt;&#123;    axios.get(`/articles/$&#123;props.match.params.id&#125;`)    .then(res =&gt; &#123;        settitle(res.data.title)        setcontent(res.data.content)        setcategory(res.data.category)    &#125;)&#125;,[props])</code></pre><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><blockquote><p>防止因为组件重新渲染，导致方法被重新创建，起到缓存作用; 只有第二个参数变化了，才重新声明一次</p></blockquote><pre><code class="js">import React , &#123;useState,useCallback&#125; from &#39;react&#39;</code></pre><pre><code class="jsx">export default function App () &#123;    const [text,settext] = useState(&#39;xxx&#39;)    useCallback(()=&gt;&#123;        console.log(text)    &#125;,[text])    return (        &lt;div&gt;            &#123;text&#125;            &lt;button onClick=&#123;()=&gt;&#123;                    settext(&#39;retr0&#39;)                &#125;&#125;&gt;&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><h2 id="useReducer和useContext"><a href="#useReducer和useContext" class="headerlink" title="useReducer和useContext"></a>useReducer和useContext</h2><blockquote><p>redux-react-hook 无缝使用原来的 redux,和中间件 promise,thunk,saga</p></blockquote><pre><code class="js">import React, &#123;useReducer,useContext&#125; from &#39;react&#39;import reducer from &#39;./reducer&#39;const GlobalContext = React.createContext()</code></pre><h3 id="reducer-js"><a href="#reducer-js" class="headerlink" title="reducer.js"></a>reducer.js</h3><pre><code class="js">// 纯函数设计 reudx中的reducer一个概念const reducer = (prevState,action)=&gt;&#123;  let &#123;type,payload&#125; = action  switch(type)&#123;    case &quot;isShow&quot;:      //深复制老状态，返回新状态    return &#123;      ...prevState,      isShow:payload    &#125; // immutable    case &quot;list&quot;:      //深复制老状态，返回新状态    return &#123;      ...prevState,      list:payload    &#125;  &#125;&#125;export default reducer</code></pre><h3 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a>App.js</h3><pre><code class="jsx">const Child1 = ()=&gt;&#123;    const &#123;state,dispatch&#125; = useContext(GlobalContext)       return (        &lt;div&gt;            &lt;button onClick=&#123;()=&gt;&#123;                    dispatch(&#123;                        type:&#39;isShow&#39;,                        payload:!state.isShow                    &#125;)                &#125;&#125;&gt;&lt;/button&gt;        &lt;/div&gt;    )&#125;const Child2 = ()=&gt;&#123;    &#125;export default function App () &#123;    let [state,dispatch] = useReducer(reducer,&#123;        isShow:false,        list:[]    &#125;)    return (        &lt;GlobalContext.Provider value=&#123;&#123;                state,                dispatch            &#125;&#125;&gt;            &lt;Child1/&gt;            &#123;                state.isShow?&lt;Child2/&gt;:null            &#125;        &lt;/GlobalContext.Provider&gt;    )&#125;</code></pre><h2 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h2><blockquote><p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。必须以“use”开头吗？必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则</p></blockquote><pre><code class="jsx">import React, &#123; useState, useEffect &#125; from &#39;react&#39;import axios from &#39;axios&#39;import &#123; PageHeader &#125; from &#39;antd&#39;;import store from &#39;../../mobx/store&#39;//为preview提供数据const usePreviewData = (props)=&gt;&#123;  const [title, setTitle] = useState(&#39;&#39;)  const [category, setCategory] = useState(&#39;&#39;)  const [content, setContent] = useState(&#39;&#39;)  useEffect(() =&gt; &#123;    store.set(&#39;isShow&#39;, false)    axios.get(`http://localhost:12138/articles/$&#123;props.match.params.myid&#125;`).then(res =&gt; &#123;      let &#123; title, category, content &#125; = res.data      setTitle(title)      setCategory(category)      setContent(content)    &#125;)  &#125;, [props.match.params.myid])  return &#123;    title,    category,    content  &#125;&#125;export default function HookPreview(props) &#123;   // console.log(this.props);//函数式组件从函数的形参中就能拿到属性  let &#123;title,category,content&#125; = usePreviewData(props)  return (    &lt;div&gt;      &lt;PageHeader        className=&quot;site-page-header&quot;        onBack=&#123;() =&gt; &#123;          props.history.goBack()        &#125;&#125;        title=&#123;title&#125;        subTitle=&#123;category ? category.join(&#39;/&#39;) : null&#125;      /&gt;      &lt;div style=&#123;&#123; padding: '24px' &#125;&#125; dangerouslySetInnerHTML=&#123;&#123;        __html: content      &#125;&#125;&gt;      &lt;/div&gt;    &lt;/div&gt;  )&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React- Redux最主要是用作应用状态的管理</title>
      <link href="/2022/08/25/21%20redux/"/>
      <url>/2022/08/25/21%20redux/</url>
      
        <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（state对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers），这样就可以进行数据追踪，实现时光旅行。</p><h2 id="redux介绍及设计和使用的三大原则"><a href="#redux介绍及设计和使用的三大原则" class="headerlink" title="redux介绍及设计和使用的三大原则"></a>redux介绍及设计和使用的三大原则</h2><ul><li>state以单一对象存储在store对象中</li><li>state只读（每次都返回一个新对象）</li><li>使用纯函数reducer执行state更新</li></ul><h2 id="redux工作流"><a href="#redux工作流" class="headerlink" title="redux工作流"></a>redux工作流</h2><p><img src="https://upload-images.jianshu.io/upload_images/2547292-cae4b69ca467d0f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/638/format/webp" alt="img"></p><p>我个人粗浅的理解是：<br> Store的角色是整个应用的数据存储中心，集中大部分页面需要的状态数据；<br> ActionCreators ,view 层与data层的介质；<br> Reduce ，接收action并更新Store。<br> 所以流程是 用户通过界面组件 触发ActionCreator，携带Store中的旧State与Action 流向Reducer,Reducer返回新的state，并更新界面。</p><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>首先，让我们来给 action 下个定义。</p><p><strong>Action</strong> 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。一般来说你会通过 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 将 action 传到 store。</p><p>添加新 todo 任务的 action 是这样的：</p><pre><code class="js">const ADD_TODO = &#39;ADD_TODO&#39;&#123;  type: ADD_TODO,  text: &#39;Build my first Redux app&#39;&#125;</code></pre><p>Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作。多数情况下，<code>type</code> 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p><pre><code class="js">import &#123; ADD_TODO, REMOVE_TODO &#125; from &#39;../actionTypes&#39;</code></pre><blockquote><h5 id="样板文件使用提醒"><a href="#样板文件使用提醒" class="headerlink" title="样板文件使用提醒"></a>样板文件使用提醒</h5><p>使用单独的模块或文件来定义 action type 常量并不是必须的，甚至根本不需要定义。对于小应用来说，使用字符串做 action type 更方便些。不过，在大型应用中把它们显式地定义成常量还是利大于弊的。参照 <a href="https://www.redux.org.cn/docs/recipes/ReducingBoilerplate.html">减少样板代码</a> 获取更多保持代码简洁的实践经验。</p></blockquote><p>除了 <code>type</code> 字段外，action 对象的结构完全由你自己决定。参照 <a href="https://github.com/acdlite/flux-standard-action">Flux 标准 Action</a> 获取关于如何构造 action 的建议。</p><p>这时，我们还需要再添加一个 action index 来表示用户完成任务的动作序列号。因为数据是存放在数组中的，所以我们通过下标 <code>index</code> 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。</p><pre><code class="js">&#123;  type: TOGGLE_TODO,  index: 5&#125;</code></pre><p><strong>我们应该尽量减少在 action 中传递的数据</strong>。比如上面的例子，传递 <code>index</code> 就比把整个任务对象传过去要好。</p><p>最后，再添加一个 action type 来表示当前的任务展示选项。</p><pre><code class="js">&#123;  type: SET_VISIBILITY_FILTER,  filter: SHOW_COMPLETED&#125;</code></pre><p>Action 创建函数</p><p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p><p>在 Redux 中的 action 创建函数只是简单的返回一个 action:</p><pre><code class="js">function addTodo(text) &#123;  return &#123;    type: ADD_TODO,    text  &#125;&#125;</code></pre><p>这样做将使 action 创建函数更容易被移植和测试。</p><p>在 <a href="http://facebook.github.io/flux">传统的 Flux</a> 实现中，当调用 action 创建函数时，一般会触发一个 dispatch，像这样：</p><pre><code class="js">function addTodoWithDispatch(text) &#123;  const action = &#123;    type: ADD_TODO,    text  &#125;  dispatch(action)&#125;</code></pre><p>不同的是，Redux 中只需把 action 创建函数的结果传给 <code>dispatch()</code> 方法即可发起一次 dispatch 过程。</p><pre><code class="js">dispatch(addTodo(text))dispatch(completeTodo(index))</code></pre><p>或者创建一个 <strong>被绑定的 action 创建函数</strong> 来自动 dispatch：</p><pre><code class="js">const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index))</code></pre><p>然后直接调用它们：</p><pre><code>boundAddTodo(text);boundCompleteTodo(index);</code></pre><p>store 里能直接通过 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 调用 <code>dispatch()</code> 方法，但是多数情况下你会使用 <a href="http://github.com/gaearon/react-redux">react-redux</a> 提供的 <code>connect()</code> 帮助器来调用。<a href="https://www.redux.org.cn/docs/api/bindActionCreators.html"><code>bindActionCreators()</code></a> 可以自动把多个 action 创建函数 绑定到 <code>dispatch()</code> 方法上。</p><p>Action 创建函数也可以是异步非纯函数。你可以通过阅读 <a href="https://www.redux.org.cn/docs/advanced/">高级教程</a> 中的 <a href="https://www.redux.org.cn/docs/advanced/AsyncActions.html">异步 action</a>章节，学习如何处理 AJAX 响应和如何把 action 创建函数组合进异步控制流。因为基础教程中包含了阅读高级教程和异步 action 章节所需要的一些重要基础概念, 所以请在移步异步 action 之前, 务必先完成基础教程。</p><p>源码</p><h3 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a><code>actions.js</code></h3><pre><code class="js">/* * action 类型 */export const ADD_TODO = &#39;ADD_TODO&#39;;export const TOGGLE_TODO = &#39;TOGGLE_TODO&#39;export const SET_VISIBILITY_FILTER = &#39;SET_VISIBILITY_FILTER&#39;/* * 其它的常量 */export const VisibilityFilters = &#123;  SHOW_ALL: &#39;SHOW_ALL&#39;,  SHOW_COMPLETED: &#39;SHOW_COMPLETED&#39;,  SHOW_ACTIVE: &#39;SHOW_ACTIVE&#39;&#125;/* * action 创建函数 */export function addTodo(text) &#123;  return &#123; type: ADD_TODO, text &#125;&#125;export function toggleTodo(index) &#123;  return &#123; type: TOGGLE_TODO, index &#125;&#125;export function setVisibilityFilter(filter) &#123;  return &#123; type: SET_VISIBILITY_FILTER, filter &#125;&#125;</code></pre><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><strong>Reducers</strong> 指定了应用状态的变化如何响应 <a href="https://www.redux.org.cn/docs/basics/Actions.html">actions</a> 并发送到 store 的，记住 actions 只是描述了<em>有事情发生了</em>这一事实，并没有描述应用如何更新 state。</p><h3 id="设计-State-结构"><a href="#设计-State-结构" class="headerlink" title="设计 State 结构"></a>设计 State 结构</h3><p>在 Redux 应用中，所有的 state 都被保存在一个单一对象中。建议在写代码前先想一下这个对象的结构。如何才能以最简的形式把应用的 state 用对象描述出来？</p><p>以 todo 应用为例，需要保存两种不同的数据：</p><ul><li>当前选中的任务过滤条件；</li><li>完整的任务列表。</li></ul><p>通常，这个 state 树还需要存放其它一些数据，以及一些 UI 相关的 state。这样做没问题，但尽量把这些数据与 UI 相关的 state 分开。</p><pre><code class="js">&#123;  visibilityFilter: &#39;SHOW_ALL&#39;,  todos: [    &#123;      text: &#39;Consider using Redux&#39;,      completed: true,    &#125;,    &#123;      text: &#39;Keep all state in a single tree&#39;,      completed: false    &#125;  ]&#125;</code></pre><blockquote><h5 id="处理-Reducer-关系时的注意事项"><a href="#处理-Reducer-关系时的注意事项" class="headerlink" title="处理 Reducer 关系时的注意事项"></a>处理 Reducer 关系时的注意事项</h5><p>开发复杂的应用时，不可避免会有一些数据相互引用。建议你尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 state 想像成数据库。这种方法在 <a href="https://github.com/gaearon/normalizr">normalizr</a> 文档里有详细阐述。例如，实际开发中，在 state 里同时存放 <code>todosById: &#123; id -&gt; todo &#125;</code> 和 <code>todos: array</code> 是比较好的方式，本文中为了保持示例简单没有这样处理。</p></blockquote><h3 id="Action-处理"><a href="#Action-处理" class="headerlink" title="Action 处理"></a>Action 处理</h3><p>现在我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</p><pre><code class="js">(previousState, action) =&gt; newState</code></pre><p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a> 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。<strong>永远不要</strong>在 reducer 里做这些操作：</p><ul><li>修改传入参数；</li><li>执行有副作用的操作，如 API 请求和路由跳转；</li><li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li></ul><p>在<a href="https://www.redux.org.cn/docs/advanced/">高级篇</a>里会介绍如何执行有副作用的操作。现在只需要谨记 reducer 一定要保持纯净。<strong>只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p><p>明白了这些之后，就可以开始编写 reducer，并让它来处理之前定义过的 <a href="https://www.redux.org.cn/docs/basics/Actions.html">action</a>。</p><p>我们将以指定 state 的初始状态作为开始。Redux 首次执行时，state 为 <code>undefined</code>，此时我们可借机设置并返回应用的初始 state。</p><pre><code class="js">import &#123; VisibilityFilters &#125; from &#39;./actions&#39;const initialState = &#123;  visibilityFilter: VisibilityFilters.SHOW_ALL,  todos: []&#125;;function todoApp(state, action) &#123;  if (typeof state === &#39;undefined&#39;) &#123;    return initialState  &#125;  // 这里暂不处理任何 action，  // 仅返回传入的 state。  return state&#125;</code></pre><p>这里一个技巧是使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters">ES6 参数默认值语法</a> 来精简代码。</p><pre><code class="js">function todoApp(state = initialState, action) &#123;  // 这里暂不处理任何 action，  // 仅返回传入的 state。  return state&#125;</code></pre><p>现在可以处理 <code>SET_VISIBILITY_FILTER</code>。需要做的只是改变 state 中的 <code>visibilityFilter</code>。</p><pre><code class="js">function todoApp(state = initialState, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return Object.assign(&#123;&#125;, state, &#123;        visibilityFilter: action.filter      &#125;)    default:      return state  &#125;&#125;</code></pre><p>注意:</p><ol><li><strong>不要修改 <code>state</code>。</strong> 使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> 新建了一个副本。不能这样使用 <code>Object.assign(state, &#123; visibilityFilter: action.filter &#125;)</code>，因为它会改变第一个参数的值。你<strong>必须</strong>把第一个参数设置为空对象。你也可以开启对ES7提案<a href="https://www.redux.org.cn/docs/recipes/UsingObjectSpreadOperator.html">对象展开运算符</a>的支持, 从而使用 <code>&#123; ...state, ...newState &#125;</code> 达到相同的目的。</li><li><strong>在 <code>default</code> 情况下返回旧的 <code>state</code>。</strong>遇到未知的 action 时，一定要返回旧的 <code>state</code>。</li></ol><blockquote><h5 id="Object-assign-须知"><a href="#Object-assign-须知" class="headerlink" title="Object.assign 须知"></a><code>Object.assign</code> 须知</h5><p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，<a href="https://github.com/babel-plugins/babel-plugin-object-assign">Babel 插件</a>，或者使用其它库如 <a href="https://lodash.com/docs#assign"><code>_.assign()</code></a> 提供的帮助方法。</p><h5 id="switch-和样板代码须知"><a href="#switch-和样板代码须知" class="headerlink" title="switch 和样板代码须知"></a><code>switch</code> 和样板代码须知</h5><p><code>switch</code> 语句并不是严格意义上的样板代码。Flux 中真实的样板代码是概念性的：更新必须要发送、Store 必须要注册到 Dispatcher、Store 必须是对象（开发同构应用时变得非常复杂）。为了解决这些问题，Redux 放弃了 event emitters（事件发送器），转而使用纯 reducer。</p><p>很不幸到现在为止，还有很多人存在一个误区：根据文档中是否使用 <code>switch</code> 来决定是否使用它。如果你不喜欢 <code>switch</code>，完全可以自定义一个 <code>createReducer</code> 函数来接收一个事件处理函数列表，参照<a href="https://www.redux.org.cn/docs/recipes/ReducingBoilerplate.html#reducers">“减少样板代码”</a>。</p></blockquote><h3 id="处理多个-action"><a href="#处理多个-action" class="headerlink" title="处理多个 action"></a>处理多个 action</h3><p>还有两个 action 需要处理。就像我们处理 <code>SET_VISIBILITY_FILTER</code> 一样，我们引入 <code>ADD_TODO</code> 和 <code>TOGGLE_TODO</code> 两个actions 并且扩展我们的 reducer 去处理 <code>ADD_TODO</code>.</p><pre><code class="js">import &#123;  ADD_TODO,  TOGGLE_TODO,  SET_VISIBILITY_FILTER,  VisibilityFilters&#125; from &#39;./actions&#39;...function todoApp(state = initialState, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return Object.assign(&#123;&#125;, state, &#123;        visibilityFilter: action.filter      &#125;)    case ADD_TODO:      return Object.assign(&#123;&#125;, state, &#123;        todos: [          ...state.todos,          &#123;            text: action.text,            completed: false          &#125;        ]      &#125;)    default:      return state  &#125;&#125;</code></pre><p>如上，不直接修改 <code>state</code> 中的字段，而是返回新对象。新的 <code>todos</code> 对象就相当于旧的 <code>todos</code> 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的。</p><p>最后，<code>TOGGLE_TODO</code> 的实现也很好理解：</p><pre><code class="js">case TOGGLE_TODO:  return Object.assign(&#123;&#125;, state, &#123;    todos: state.todos.map((todo, index) =&gt; &#123;      if (index === action.index) &#123;        return Object.assign(&#123;&#125;, todo, &#123;          completed: !todo.completed        &#125;)      &#125;      return todo    &#125;)  &#125;)</code></pre><p>我们需要修改数组中指定的数据项而又不希望导致<strong>突变</strong>, 因此我们的做法是在创建一个新的数组后, 将那些无需修改的项原封不动移入, 接着对需修改的项用新生成的对象替换。(译者注：Javascript中的对象存储时均是由值和指向值的引用两个部分构成。此处<strong>突变</strong>指直接修改引用所指向的值, 而引用本身保持不变。) 如果经常需要这类的操作，可以选择使用帮助类 <a href="https://facebook.github.io/react/docs/update.html">React-addons-update</a>，<a href="https://github.com/substantial/updeep">updeep</a>，或者使用原生支持深度更新的库 <a href="http://facebook.github.io/immutable-js/">Immutable</a>。最后，时刻谨记永远不要在克隆 <code>state</code> 前修改它。</p><h3 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 Reducer</h3><p>目前的代码看起来有些冗长：</p><pre><code class="js">function todoApp(state = initialState, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return Object.assign(&#123;&#125;, state, &#123;        visibilityFilter: action.filter      &#125;)    case ADD_TODO:      return Object.assign(&#123;&#125;, state, &#123;        todos: [          ...state.todos,          &#123;            text: action.text,            completed: false          &#125;        ]      &#125;)    case TOGGLE_TODO:      return Object.assign(&#123;&#125;, state, &#123;        todos: state.todos.map((todo, index) =&gt; &#123;          if (index === action.index) &#123;            return Object.assign(&#123;&#125;, todo, &#123;              completed: !todo.completed            &#125;)          &#125;          return todo        &#125;)      &#125;)    default:      return state  &#125;&#125;</code></pre><p>上面代码能否变得更通俗易懂？这里的 <code>todos</code> 和 <code>visibilityFilter</code> 的更新看起来是相互独立的。有时 state 中的字段是相互依赖的，需要认真考虑，但在这个案例中我们可以把 <code>todos</code> 更新的业务逻辑拆分到一个单独的函数里：</p><pre><code class="js">function todos(state = [], action) &#123;  switch (action.type) &#123;    case ADD_TODO:      return [        ...state,        &#123;          text: action.text,          completed: false        &#125;      ]    case TOGGLE_TODO:      return state.map((todo, index) =&gt; &#123;        if (index === action.index) &#123;          return Object.assign(&#123;&#125;, todo, &#123;            completed: !todo.completed          &#125;)        &#125;        return todo      &#125;)    default:      return state  &#125;&#125;function todoApp(state = initialState, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return Object.assign(&#123;&#125;, state, &#123;        visibilityFilter: action.filter      &#125;)    case ADD_TODO:      return Object.assign(&#123;&#125;, state, &#123;        todos: todos(state.todos, action)      &#125;)    case TOGGLE_TODO:      return Object.assign(&#123;&#125;, state, &#123;        todos: todos(state.todos, action)      &#125;)    default:      return state  &#125;&#125;</code></pre><p>注意 <code>todos</code> 依旧接收 <code>state</code>，但它变成了一个数组！现在 <code>todoApp</code> 只把需要更新的一部分 state 传给 <code>todos</code> 函数，<code>todos</code> 函数自己确定如何更新这部分数据。<strong>这就是所谓的 *reducer 合成*，它是开发 Redux 应用最基础的模式。</strong></p><p>下面深入探讨一下如何做 reducer 合成。能否抽出一个 reducer 来专门管理 <code>visibilityFilter</code>？当然可以：</p><p>首先引用, 让我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 对象结构</a> 去声明 <code>SHOW_ALL</code>:</p><pre><code class="js">const &#123; SHOW_ALL &#125; = VisibilityFilters</code></pre><p>接下来：</p><pre><code class="js">function visibilityFilter(state = SHOW_ALL, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return action.filter    default:      return state  &#125;&#125;</code></pre><p>现在我们可以开发一个函数来做为主 reducer，它调用多个子 reducer 分别处理 state 中的一部分数据，然后再把这些数据合成一个大的单一对象。主 reducer 并不需要设置初始化时完整的 state。初始时，如果传入 <code>undefined</code>, 子 reducer 将负责返回它们的默认值。</p><pre><code class="js">function todos(state = [], action) &#123;  switch (action.type) &#123;    case ADD_TODO:      return [        ...state,        &#123;          text: action.text,          completed: false        &#125;      ]    case TOGGLE_TODO:      return state.map((todo, index) =&gt; &#123;        if (index === action.index) &#123;          return Object.assign(&#123;&#125;, todo, &#123;            completed: !todo.completed          &#125;)        &#125;        return todo      &#125;)    default:      return state  &#125;&#125;function visibilityFilter(state = SHOW_ALL, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return action.filter    default:      return state  &#125;&#125;function todoApp(state = &#123;&#125;, action) &#123;  return &#123;    visibilityFilter: visibilityFilter(state.visibilityFilter, action),    todos: todos(state.todos, action)  &#125;&#125;</code></pre><p><strong>注意每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 <code>state</code> 参数都不同，分别对应它管理的那部分 state 数据。</strong></p><p>现在看起来好多了！随着应用的膨胀，我们还可以将拆分后的 reducer 放到不同的文件中, 以保持其独立性并用于专门处理不同的数据域。</p><p>最后，Redux 提供了 <a href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers()</code></a> 工具类来做上面 <code>todoApp</code> 做的事情，这样就能消灭一些样板代码了。有了它，可以这样重构 <code>todoApp</code>：</p><pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;const todoApp = combineReducers(&#123;  visibilityFilter,  todos&#125;)export default todoApp</code></pre><p>注意上面的写法和下面完全等价：</p><pre><code class="js">export default function todoApp(state = &#123;&#125;, action) &#123;  return &#123;    visibilityFilter: visibilityFilter(state.visibilityFilter, action),    todos: todos(state.todos, action)  &#125;&#125;</code></pre><p>你也可以给它们设置不同的 key，或者调用不同的函数。下面两种合成 reducer 方法完全等价：</p><pre><code class="js">const reducer = combineReducers(&#123;  a: doSomethingWithA,  b: processB,  c: c&#125;)function reducer(state = &#123;&#125;, action) &#123;  return &#123;    a: doSomethingWithA(state.a, action),    b: processB(state.b, action),    c: c(state.c, action)  &#125;&#125;</code></pre><p><a href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers()</code></a> 所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer <strong>根据它们的 key 来筛选出 state 中的一部分数据并处理</strong>，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。<a href="https://github.com/gaearon/redux/issues/428#issuecomment-129223274">没有任何魔法。</a>正如其他 reducers，如果 combineReducers() 中包含的所有 reducers 都没有更改 state，那么也就不会创建一个新的对象。</p><blockquote><h5 id="ES6-用户使用注意"><a href="#ES6-用户使用注意" class="headerlink" title="ES6 用户使用注意"></a>ES6 用户使用注意</h5><p><code>combineReducers</code> 接收一个对象，可以把所有顶级的 reducer 放到一个独立的文件中，通过 <code>export</code> 暴露出每个 reducer 函数，然后使用 <code>import * as reducers</code> 得到一个以它们名字作为 key 的 object：</p><pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;import * as reducers from &#39;./reducers&#39;const todoApp = combineReducers(reducers)</code></pre><p>由于 <code>import *</code> 还是比较新的语法，为了避免<a href="https://github.com/gaearon/redux/issues/428#issuecomment-129223274">困惑</a>，我们不会在本文档中使用它。但在一些社区示例中你可能会遇到它们。</p></blockquote><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="reducers-js"><a href="#reducers-js" class="headerlink" title="reducers.js"></a><code>reducers.js</code></h4><pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;import &#123;  ADD_TODO,  TOGGLE_TODO,  SET_VISIBILITY_FILTER,  VisibilityFilters&#125; from &#39;./actions&#39;const &#123; SHOW_ALL &#125; = VisibilityFiltersfunction visibilityFilter(state = SHOW_ALL, action) &#123;  switch (action.type) &#123;    case SET_VISIBILITY_FILTER:      return action.filter    default:      return state  &#125;&#125;function todos(state = [], action) &#123;  switch (action.type) &#123;    case ADD_TODO:      return [        ...state,        &#123;          text: action.text,          completed: false        &#125;      ]    case TOGGLE_TODO:      return state.map((todo, index) =&gt; &#123;        if (index === action.index) &#123;          return Object.assign(&#123;&#125;, todo, &#123;            completed: !todo.completed          &#125;)        &#125;        return todo      &#125;)    default:      return state  &#125;&#125;const todoApp = combineReducers(&#123;  visibilityFilter,  todos&#125;)export default todoApp</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React- mobx</title>
      <link href="/2022/08/25/20%20mobx/"/>
      <url>/2022/08/25/20%20mobx/</url>
      
        <content type="html"><![CDATA[<h1 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h1><blockquote><p><a href="https://cn.mobx.js.org/">https://cn.mobx.js.org/</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li>Mobx是一个功能强大，上手非常容易的状态管理工具。</li><li>Mobx背后的哲学很简单: 任何源自应用状态的东西都应该自动地获得。</li><li>Mobx利用getter和setter来收集组件的数据依赖关系，从而在数据发生变化的时候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更 新。</li></ol><h2 id="Mobx与redux的区别"><a href="#Mobx与redux的区别" class="headerlink" title="Mobx与redux的区别"></a>Mobx与redux的区别</h2><ul><li>Mobx写法上更偏向于OOP </li><li>对一份数据直接进行修改操作，不需要始终返回一个新的数据 </li><li>并非单一store,可以多store</li><li> Redux默认以JavaScript原生对象形式存储数据，而Mobx使 用可观察对象</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>学习成本小 </li><li>面向对象编程 </li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>过于自由：Mobx提供的约定及模版代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一</li><li>相关的中间件很少，逻辑层业务整合是问题。</li></ul><h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h2><pre><code class="js">import &#123;observable&#125; from &#39;mobx&#39;</code></pre><h3 id="box"><a href="#box" class="headerlink" title=".box"></a>.box</h3><pre><code class="js">const store = observable.box(true) //生成一个可以观察的布尔值,box只能观察简单数据类型</code></pre><h3 id="map"><a href="#map" class="headerlink" title=".map"></a>.map</h3><pre><code class="js">const store = observable.map(&#123;    isShow:true,    age:12,    roleList:[],    rightList:[]&#125;)//如果要观察复杂数据类型，需要用map方法</code></pre><h2 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h2><pre><code class="js">import &#123;autorun&#125; from &#39;mobx&#39;import store from &#39;../../mobx/store&#39;</code></pre><pre><code class="js">autorun(()=&gt;&#123;    console.log(store.get())&#125;)</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="js">import &#123; observable, autorun &#125; from &#39;mobx&#39;;const value = observable.box(0);const number = observable.box(100);autorun(() =&gt; &#123;    console.log(value.get());&#125;);value.set(1);value.set(2);number.set(101);//0,1,2。 // autorun 使用到才能被执行//只能是同步，异步需要处理//观察对象，通过mapconst map = observable.map(&#123; key: &quot;value&quot;&#125;);//map.set(&quot;key&quot;, &quot;new value&quot;);//map.get(&quot;key&quot;)//观察对象，不通过mapconst map = observable(&#123; key: &quot;value&quot;&#125;);// map.key map.key=&quot;xiaoming&quot;//观察数组const list = observable([1, 2, 4]);list[2] = 3;</code></pre><h2 id="mobx取消绑定"><a href="#mobx取消绑定" class="headerlink" title="mobx取消绑定"></a>mobx取消绑定</h2><pre><code class="js">componentWillMount () &#123;    this.cancel = autorun(()=&gt;&#123;        this.setState(&#123;            isShow:store.get(&#39;isShow&#39;)        &#125;)    &#125;)&#125;componentWillUnMount () &#123;    this.cancel()    //或者直接更改setState函数，这样就不会触发上一个组件销毁，但上一个组件中定义的autorun没销毁，导致进行setState操作，但上个组件已经销毁，因此会报一个warning：无法设置一个状态到unmount的组件&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React- redux-persist实现redux持久化，存到localStorage</title>
      <link href="/2022/08/25/19%20redux-persist/"/>
      <url>/2022/08/25/19%20redux-persist/</url>
      
        <content type="html"><![CDATA[<h1 id="redux-persist"><a href="#redux-persist" class="headerlink" title="redux-persist"></a>redux-persist</h1><blockquote><p>实现redux持久化，存到localStorage</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install redux-persist</code></pre><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre><code class="js">// configureStore.jsimport &#123; createStore &#125; from &#39;redux&#39;import &#123; persistStore, persistReducer &#125; from &#39;redux-persist&#39;import storage from &#39;redux-persist/lib/storage&#39; // defaults to localStorage for webimport rootReducer from &#39;./reducers&#39;const persistConfig = &#123;  key: &#39;root&#39;,  storage,&#125;const persistedReducer = persistReducer(persistConfig, rootReducer)export default () =&gt; &#123;  let store = createStore(persistedReducer)  let persistor = persistStore(store)  return &#123; store, persistor &#125;&#125;</code></pre><h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code class="js">import &#123;createStore,applyMiddleware,combineReducers,compose &#125; from &#39;redux&#39; //createStore 方法创建一个store对象//创建一个reducer，“修改状态”，（老状态，修改的值）深复制之后，再返回一个新的状态import reduxThunk from &#39;redux-thunk&#39;import reduxPromise from &#39;redux-promise&#39;import roleListReducer from &#39;./reducess/role&#39;import rightListReducer from &#39;./reducess/right&#39;import sliderReducer from &#39;./reducess/slider&#39;import &#123; persistStore, persistReducer &#125; from &#39;redux-persist&#39;import storage from &#39;redux-persist/lib/storage&#39; // defaults to localStorage for webconst persistConfig = &#123;  key: &#39;root&#39;,  storage,&#125;const reducer = combineReducers(&#123;  isCollapsed : sliderReducer,  rightList:rightListReducer,  roleList:roleListReducer&#125;)const persistedReducer = persistReducer(persistConfig, reducer) //把reducer进行包裹//store，只能接受一个reducer//app开发，只能有一个store//轮船运货车（reducer拆开一个一个，每个reducer一个文件，combineReducer：合并所有的reducer）//redux devtools的配置：Advanced store setupconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(persistedReducer,/* preloadedState, */ composeEnhancers(applyMiddleware(reduxThunk,reduxPromise)))const persistor = persistStore(store)//默认action是普通对象//创建store，顺便应用中间件thunk,如果action是函数，我来处理//创建store，顺便应用中间件promise,那么action就变成了promise对象export  &#123;  store,  persistor&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-immutable</title>
      <link href="/2022/08/25/18%20immutable/"/>
      <url>/2022/08/25/18%20immutable/</url>
      
        <content type="html"><![CDATA[<h1 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h1><blockquote><p><a href="https://github.com/immutable-js/immutable-js">https://github.com/immutable-js/immutable-js</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>每次修改一个 Immutable 对象时都会创建一个新的不可变的对象，在新对象上操作并不会影响到原对象的数据。这个库的实现是深拷贝还是浅拷贝？</p><h2 id="深拷贝和浅拷贝的关系"><a href="#深拷贝和浅拷贝的关系" class="headerlink" title="深拷贝和浅拷贝的关系"></a>深拷贝和浅拷贝的关系</h2><ol><li><pre><code class="js">var arr = &#123;&#125;;var arr2 = arr//浅拷贝，引用地址相同</code></pre></li><li><p> Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。</p></li><li><pre><code class="js">const obj1 = JSON.parse(JSON.stringify(obj))//数组，对象都好用(缺点: 不能有undefined)</code></pre></li></ol><h2 id="Immutable优化性能的方式"><a href="#Immutable优化性能的方式" class="headerlink" title="Immutable优化性能的方式"></a>Immutable优化性能的方式</h2><p>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构）， 也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p><a href="https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772">https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772</a></p><pre><code class="js">import &#123;Map&#125; from &#39;immutable&#39;let a = Map(&#123;    select:&#39;users&#39;,    filter:Map(&#123;name:&#39;Cam&#39;&#125;)&#125;)let b = a.set(&#39;select&#39;,&#39;people&#39;);a===b; //falsea.get(&#39;filter&#39;) === b.get(&#39;filter&#39;); // true</code></pre><p>延伸：如果上述select 属性 给一个组件用，因为此值改变了，shouldComponentUpdate 应该返回true, 而filter 属性给另一个组件用，通过判断并无变化，shouldComponentUpdate 应该返回false，此组件就避免了重复进行diff对比</p><h2 id="Immutable中常用类型（Map，List）"><a href="#Immutable中常用类型（Map，List）" class="headerlink" title="Immutable中常用类型（Map，List）"></a>Immutable中常用类型（Map，List）</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code class="js">const &#123;Map&#125; = require(&quot;immutable&quot;)const preState = &#123;  a:1,  b:2&#125;let map1 = Map(preState)let map2 = map1.set(&#39;b&#39;,&#39;3&#39;)console.log(map1.toJS(),map2.toJS());//&#123; a: 1, b: 2 &#125; &#123; a: 1, b: &#39;3&#39; &#125;</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code class="js">const &#123;List&#125; = require(&quot;immutable&quot;)const preState = [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;]let arr1 = List(preState)//List内置绝大部分的数组方法let arr2 = arr1.push(444)console.log(arr1.toJS(),arr2.toJS());//[&#39;111&#39;,&#39;222&#39;,&#39;333&#39;]   [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;,444]</code></pre><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><pre><code class="js">const &#123;Map&#125; = require(&quot;immutable&quot;)const preState = &#123;  a:1,  b:2&#125;let map1 = Map(preState)let map2 = map1.merge(&#123;name:&#39;admin&#39;&#125;)console.log(map1.toJS(),map2.toJS());//&#123; a: 1, b: 2 &#125; &#123; a: 1, b: 2, name: &#39;admin&#39; &#125;</code></pre><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><pre><code class="js">const &#123;List&#125; = require(&quot;immutable&quot;)const preState = [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;]let arr1 = List(preState)//List内置绝大部分的数组方法let arr2 = arr1.concat([444,555,666])console.log(arr1.toJS(),arr2.toJS());//[&#39;111&#39;,&#39;222&#39;,&#39;333&#39;] [&#39;111&#39;,&#39;222&#39;,&#39;333&#39;,444,555,666]</code></pre><h3 id="fromJS"><a href="#fromJS" class="headerlink" title="fromJS"></a>fromJS</h3><pre><code class="js">const &#123;fromJS&#125; = require(&quot;immutable&quot;)const prevState = &#123;  name:&#39;retr0&#39;,  age:1,  location:&#123;    city:1,    sss:2,    ddd:&#123;      aaa:34    &#125;  &#125;&#125; let map1 = fromJS(prevState)let map2 = map1.setIn([&#39;location&#39;,&#39;city&#39;],231231)console.log(map2.toJS());/*    &#123;      name: &#39;retr0&#39;,      age: 1,      location: &#123; city: 231231, sss: 2, ddd: &#123; aaa: 34 &#125; &#125;      &#125;*/</code></pre><h2 id="Immutable-Redux的开发方式"><a href="#Immutable-Redux的开发方式" class="headerlink" title="Immutable+Redux的开发方式"></a>Immutable+Redux的开发方式</h2><pre><code class="js">import &#123;fromJS&#125; from &#39;immutable&#39;const righteducer = (prevState=[],action)=&gt;&#123;  let &#123;type,payload&#125; = action;  switch(type)&#123;    case &quot;right&quot;:      let newState = fromJS(prevState).concat(payload).toJS()      return newState    default:return prevState  &#125;  &#125;export default righteducer</code></pre><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>容易跟原生混淆</li><li>文档与调试不方便</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-redux-thunk</title>
      <link href="/2022/08/25/17%20redux-thunk/"/>
      <url>/2022/08/25/17%20redux-thunk/</url>
      
        <content type="html"><![CDATA[<h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><h1 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm i --save redux-thunk</code></pre><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><pre><code class="js">import ReduxThunk from &#39;redux-promise&#39;</code></pre><h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code class="js">import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;const reducer = ()=&gt;&#123;    ....&#125;const store = createStore(reducer,applyMiddleware(ReduxThunk))</code></pre><h2 id="组件-js"><a href="#组件-js" class="headerlink" title="组件.js"></a>组件.js</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import store from &#39;.....&#39;class App extends Component &#123;    actionCreator = ()=&gt;&#123;        return dispatch =&gt;&#123;  //返回一个函数,并传了一个dispath函数到回调函数的形参中            axios....then(res=&gt;&#123;                dispatch(...) //就可以在任意自己想return的地方运行dispatch函数            &#125;)        &#125;    &#125;    componentWillMount()&#123;        if(store.getState().xxxx.length===0)&#123;            //  store.dispath只能接受一个普通对象            store.dispatch(this.actionCreator())        &#125;else&#123;               this.setState(&#123;                xxx:store.getState().xxxx            &#125;)        &#125;        //要抓第一次redux改变的的时候，因此要订阅一下        this.unsub = store.subscribe(&#123;            this.setState(&#123;                ...:store.getState().xxxx            &#125;)        &#125;)    &#125;    render () &#123;        return (            &lt;div&gt;&lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-redux-promise</title>
      <link href="/2022/08/25/16%20redux-promise/"/>
      <url>/2022/08/25/16%20redux-promise/</url>
      
        <content type="html"><![CDATA[<h1 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm i --save redux-promise</code></pre><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><pre><code class="js">import ReduxPromise from &#39;redux-promise&#39;</code></pre><h2 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h2><pre><code class="js">import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;const reducer = ()=&gt;&#123;    ....&#125;const store = createStore(reducer,applyMiddleware(ReduxPromise))</code></pre><h2 id="组件-js"><a href="#组件-js" class="headerlink" title="组件.js"></a>组件.js</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import store from &#39;.....&#39;class App extends Component &#123;    actionCreator = ()=&gt;&#123;        return ( //返回一个promise对象            axios.....        )    &#125;    componentWillMount()&#123;        if(store.getState().xxxx.length===0)&#123;            //  store.dispath只能接受一个普通对象            store.dispatch(this.actionCreator())            .then(res=&gt;&#123;                this.setState(&#123;                     ...:res.payload                &#125;)            &#125;)        &#125;else&#123;               this.setState(&#123;                xxx:store.getState().xxxx            &#125;)        &#125;    &#125;    render () &#123;        return (            &lt;div&gt;&lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-React-Radux</title>
      <link href="/2022/08/25/15%20react-redux/"/>
      <url>/2022/08/25/15%20react-redux/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Radux"><a href="#React-Radux" class="headerlink" title="React-Radux"></a>React-Radux</h2><p>实际项目中，需要权衡是直接使用Redux还是用React-Redux。<br> React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）</p><h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h3><ul><li>只负责 UI 的呈现，不带有任何业务逻辑</li><li>没有状态（即不使用this.state这个变量）</li><li>所有数据都由参数（this.props）提供</li><li>不使用任何 Redux 的 API</li></ul><h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><ul><li>负责管理数据和业务逻辑，不负责 UI 的呈现</li><li>带有内部状态</li><li>使用 Redux 的 API</li></ul><p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p><p>如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p><p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><pre><code class="javascript">import &#123; connect &#125; from &#39;react-redux&#39;const VisibleTodoList = connect()(TodoList);</code></pre><p>上面VisibleTodoList 便是通过UI组件TodoList,通过connect方法自动生成的容器组件。<br> 但需要定义业务逻辑，组件才有意义。</p><pre><code class="javascript">import &#123; connect &#125; from &#39;react-redux&#39;const VisibleTodoList = connect(  mapStateToProps,  mapDispatchToProps)(TodoList)</code></pre><p>connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p><h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h3><p>它是一个函数，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。<br> mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。</p><pre><code class="jsx">const mapStateToProps = (state) =&gt; &#123;  return &#123;    todos: getVisibleTodos(state.todos, state.visibilityFilter)  &#125;&#125;</code></pre><p>mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。</p><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h3><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p><ul><li>是函数则会得到dispatch和ownProps（容器组件的props对象）两个参数。</li></ul><pre><code class="tsx">const mapDispatchToProps = (  dispatch,  ownProps) =&gt; &#123;  return &#123;    onClick: () =&gt; &#123;      dispatch(&#123;        type: &#39;SET_VISIBILITY_FILTER&#39;,        filter: ownProps.filter      &#125;);    &#125;  &#125;;&#125;</code></pre><p>从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p><ul><li>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。</li></ul><pre><code class="tsx">const mapDispatchToProps = &#123;  onClick: (filter) =&gt; &#123;    type: &#39;SET_VISIBILITY_FILTER&#39;,    filter: filter  &#125;;&#125;</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title=" 组件"></a><Provider> 组件</h3><p>connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。<br> React-Redux 提供Provider组件，可以让容器组件拿到state。</p><pre><code class="jsx">import &#123; Provider &#125; from &#39;react-redux&#39;import &#123; createStore &#125; from &#39;redux&#39;import todoApp from &#39;./reducers&#39;import App from &#39;./components/App&#39;let store = createStore(todoApp);render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;))</code></pre><p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p><h2 id="简单计数器"><a href="#简单计数器" class="headerlink" title="简单计数器"></a>简单计数器</h2><pre><code class="javascript">import React, &#123; Component &#125; from &#39;react&#39;import PropTypes from &#39;prop-types&#39;   //类型检查import ReactDOM from &#39;react-dom&#39;import &#123; createStore &#125; from &#39;redux&#39;import &#123; Provider, connect &#125; from &#39;react-redux&#39;// 定义counter组件class Counter extends Component &#123;  render() &#123;    const &#123; value, onIncreaseClick &#125; = this.props    // const value = this.props.value    return (      &lt;div&gt;        &lt;span&gt;&#123;value&#125;&lt;/span&gt;        &lt;button onClick=&#123;onIncreaseClick&#125;&gt; +1&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;//对Counter组件接受的props进行类型检查Counter.propTypes = &#123;  value: PropTypes.number.isRequired,   //要求数字类型，没有提供会警告  onIncreaseClick: PropTypes.func.isRequired //要求函数类型&#125;// Action  const increaseAction = &#123; type: &#39;increase&#39; &#125;// Reducer   基于原有state根据action得到新的statefunction counter(state = &#123; count: 0 &#125;, action) &#123;  const count = state.count  switch (action.type) &#123;    case &#39;increase&#39;:      return &#123; count: count + 1 &#125;    default:      return state  &#125;&#125;// 根据reducer函数通过createStore()创建storeconst store = createStore(counter)//  将state映射到Counter组件的propsfunction mapStateToProps(state) &#123;  return &#123;    value: state.count  &#125;&#125;//  将action映射到Counter组件的propsfunction mapDispatchToProps(dispatch) &#123;  return &#123;    onIncreaseClick: () =&gt; dispatch(increaseAction)  &#125;&#125;//  传入上面两个函数参数，将Counter组件变为App组件const App = connect(  mapStateToProps,  mapDispatchToProps)(Counter)ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;))</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-纯函数</title>
      <link href="/2022/08/25/14%20%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
      <url>/2022/08/25/14%20%E7%BA%AF%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>当我第一次听到 “纯函数 (Pure Function)” 这个术语的时候我很疑惑。常规的函数做错了什么？为什么要变纯？ 为什么我需要纯的函数？</p><p>除非你已经知道什么是纯函数，否则你可能会问同样的疑惑。不过这个概念其实很简单。我们可以花个 5 分钟一起来看以下。</p><h3 id="什么函数是纯的？"><a href="#什么函数是纯的？" class="headerlink" title="什么函数是纯的？"></a>什么函数是纯的？</h3><p>纯函数的定义是：</p><ol><li>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。</li><li>该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。</li></ol><p>这就是纯的函数。 如果一个函数符合上述 2 个要求，它就是纯函数。 你可能在过去甚至无意地情况下编写过纯函数。</p><p>在我们研究一个函数一个纯或不纯之前，让我们先讨论一下可怕的“副作用”。</p><h3 id="什么是可观察的副作用？"><a href="#什么是可观察的副作用？" class="headerlink" title="什么是可观察的副作用？"></a>什么是可观察的副作用？</h3><p>一个可以被观察的副作用是在函数内部与其外部的<strong>任意</strong>交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。</p><p><strong>注:</strong> 如果纯函数调用纯函数，则不产生副作用依旧是纯函数。</p><p>副作用来自，但不限于：</p><ul><li>进行一个 HTTP 请求</li><li>Mutating data</li><li>输出数据到屏幕或者控制台</li><li>DOM 查询/操作</li><li>Math.random()</li><li>获取的当前时间</li></ul><p>副作用本身并不是毒药，某些时候往往是必需的。 但是，对于要保持纯粹的函数，它不能包含任何副作用。当然，并非所有函数都需要是纯函数。 我将在稍后讨论这个情况。</p><p>不过首先，让我们来看一些纯的和不纯的函数对比的例子……</p><h3 id="纯函数的例子"><a href="#纯函数的例子" class="headerlink" title="纯函数的例子"></a><strong>纯函数的例子</strong></h3><p>以下是一个计算产品税后价格（英国税率是20%）的纯函数的例子：</p><pre><code class="js">function priceAfterTax(productPrice) &#123; return (productPrice * 0.20) + productPrice;&#125;</code></pre><p>它符合我们所说的两条纯函数的定义。不依赖于任何外部输入，不改变任何外部数据、没有副作用。</p><p>即使你用同样的输入运行运行这个函数 100,000,000 次它<strong>依旧产生同样的结果</strong>。</p><h3 id="非纯函数"><a href="#非纯函数" class="headerlink" title="非纯函数"></a><strong>非纯函数</strong></h3><p>我们已经看了纯函数的例子，现在一起来看一个非纯函数（Impure function）的 JavaScript 例子:</p><pre><code class="js">var tax = 20;function calculateTax(productPrice) &#123;    return (productPrice * (tax/100)) + productPrice;&#125;</code></pre><p>暂停片刻，看看你是否能看出为什么这个函数不纯。</p><p>其中函数的计算结果取决于外部 tax 变量，而纯函数不能依赖外部变量。它没有满足定义中的第一个要求，因此这个函数是不纯的。</p><h3 id="为什么说纯函数在-JavaScript-很重要？"><a href="#为什么说纯函数在-JavaScript-很重要？" class="headerlink" title="为什么说纯函数在 JavaScript 很重要？"></a>为什么说纯函数在 JavaScript 很重要？</h3><p>纯函数在函数式编程中被大量使用。而且诸如 <a href="https://facebook.github.io/react/docs/components-and-props.html">ReactJS</a> 和 <a href="http://redux.js.org/docs/introduction/ThreePrinciples.html">Redux</a> 等优质的库都需要使用纯函数。</p><p>不过，纯函数也可以用在平常的 JavaScript 开发中使用，不一定要限死在某个编程范例中。 你可以混合纯的和不纯的函数，这完全没问题。</p><p>并非所有函数都需要是纯的。 例如，操作 DOM 的按钮按下的事件处理程序就不适合纯函数。 不过，这种事件处理函数可以调用其他纯函数来处理，以此减少项目中不纯函数的数量。</p><h4 id="可测试性和重构"><a href="#可测试性和重构" class="headerlink" title="可测试性和重构"></a>可测试性和重构</h4><p>另一个使用纯函数的原因是测试以及重构。</p><p>使用纯函数的一个主要好处是它们可以直接测。 如果传入相同的参数，它们将始终产生相同的结果。</p><p>同时纯函数还使得维护和重构代码变得更加容易。你可以放心地重构一个纯函数，不必操心没注意到的副作用搞乱了整个应用而导致终调试地狱。（译注：如果项目中充斥着副作用，那么函数/模块之间的逻辑可能互相交织耦合，在后期新增逻辑时可能由于依赖复杂而难以重构，更常见的是开发为了应付需求而不断的引入新的副作用到原本的逻辑上从而导致代码变得越来越糟糕。）</p><p>正确地使用纯函数可以产生更加高质量的代码。并且也是一种更加干净的编码方式。</p><p>此外，纯函数不不是 JavaScript 的专利。想要了解更多内容可以参见 <a href="https://en.wikipedia.org/wiki/Pure_function">Wiki</a>。同时也推荐阅读 <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/ch3.html">开发建议手册</a> 以及 <a href="https://toddmotto.com/pure-versus-impure-functions">纯函数 vs. 非纯函数</a>.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-react-router路由</title>
      <link href="/2022/08/25/12%20react-router/"/>
      <url>/2022/08/25/12%20react-router/</url>
      
        <content type="html"><![CDATA[<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p>React Router 是一个基于 <a href="http://facebook.github.io/react/">React</a> 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="j">npm i --save react-router-dom</code></pre><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><pre><code class="js">import &#123;HashRouter as Router,Route,Redirect,Switch,Link&#125; from &#39;react-router-dom&#39;</code></pre><h2 id="定义路由及重定向"><a href="#定义路由及重定向" class="headerlink" title="定义路由及重定向"></a>定义路由及重定向</h2><pre><code class="jsx">const MyRouter = ()=&gt;(    &lt;Router&gt;        &lt;Switch&gt;            &lt;Route path=&#39;/home&#39; component=&#123;Home&#125;&gt;&lt;/Route&gt;             &lt;Route path=&#39;/user&#39; component=&#123;User&#125;&gt;&lt;/Route&gt;             &lt;Redirect from=&#39;/&#39; to=&#39;/home&#39; exact &gt;&lt;/Redirect&gt;        &lt;/Switch&gt;    &lt;/Router&gt;)</code></pre><h3 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h3><p>注意事项：exact 精确匹配 (Redirect 即使使用了exact, 外面还要嵌套Switch 来用)</p><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>注意事项：Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack,这个警告只有在hash 模式会出现。在NavLink 加上 replace 来解决</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><pre><code class="jsx">const MyRouter = ()=&gt;(    &lt;Router&gt;        &lt;Switch&gt;            &lt;Route path=&#39;/home&#39; component=&#123;Home&#125;&gt;&lt;/Route&gt;             &lt;Route path=&#39;/user&#39; component=&#123;User&#125;&gt;&lt;/Route&gt;             &lt;Route path=&#39;/right&#39; render=&#123;()=&gt;(                    &lt;Right&gt;                        &lt;Route path=&#39;/right/roles&#39; component=&#123;Roles&#125;&gt;&lt;/Route&gt;                        &lt;Route path=&#39;/right/find&#39; component=&#123;Find&#125;&gt;&lt;/Route&gt;                    &lt;/Right&gt;                )&#125;&lt;/Route&gt;             &lt;Redirect from=&#39;/&#39; to=&#39;/home&#39; exact &gt;&lt;/Redirect&gt;        &lt;/Switch&gt;    &lt;/Router&gt;)</code></pre><h2 id="路由跳转方式"><a href="#路由跳转方式" class="headerlink" title="路由跳转方式"></a>路由跳转方式</h2><p>声明式导航</p><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import &#123;NavLink&#125; from &#39;react-router-dom&#39;export default class Right extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &lt;ul&gt;                    &lt;li&gt;                        &lt;NavLink to=&#39;/right/roles&#39;&gt;roles&lt;/NavLink&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;NavLink to=&#39;/right/find&#39;&gt;find&lt;/NavLink&gt;                    &lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><pre><code class="js">handleClick = (data)=&gt;&#123;    this.props.history.push(`/right/preview/$&#123;data&#125;`)&#125;</code></pre><pre><code class="jsx">&lt;Route path=&#39;/home/:id&#39;&gt;&lt;/Route&gt;</code></pre><pre><code class="jsx">&lt;div&gt;&#123;this.props.match.params.id&#125;&lt;/div&gt;</code></pre><h2 id="路由匹配原理"><a href="#路由匹配原理" class="headerlink" title="路由匹配原理"></a>路由匹配原理</h2><p><a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#route">路由</a>拥有三个属性来决定是否“匹配“一个 URL：</p><ol><li><a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteMatching.html#nesting">嵌套关系</a> 和</li><li>它的 <a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteMatching.html#path-syntax"><code>路径语法</code></a></li><li>它的 <a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteMatching.html#precedence">优先级</a></li></ol><h3 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h3><p>React Router 使用路由嵌套的概念来让你定义 view 的嵌套集合，当一个给定的 URL 被调用时，整个集合中（命中的部分）都会被渲染。嵌套路由被描述成一种树形结构。React Router 会深度优先遍历整个<a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#routeconfig">路由配置</a>来寻找一个与给定的 URL 相匹配的路由。</p><h3 id="路径语法"><a href="#路径语法" class="headerlink" title="路径语法"></a>路径语法</h3><p>路由路径是匹配一个（或一部分）URL 的 <a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#routepattern">一个字符串模式</a>。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p><ul><li><code>:paramName</code> – 匹配一段位于 <code>/</code>、<code>?</code> 或 <code>#</code> 之后的 URL。 命中的部分将被作为一个<a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#params">参数</a></li><li><code>()</code> – 在它内部的内容被认为是可选的</li><li><code>*</code> – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 <code>splat</code> <a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/docs/Glossary.md#params">参数</a></li></ul><pre><code class="js">&lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan&lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan&lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg</code></pre><p>如果一个路由使用了相对<code>路径</code>，那么完整的路径将由它的所有祖先节点的<code>路径</code>和自身指定的相对<code>路径</code>拼接而成。<a href="http://react-guide.github.io/react-router-cn/docs/guides/basics/RouteConfiguration.html#decoupling-the-ui-from-the-url">使用绝对<code>路径</code></a>可以使路由匹配行为忽略嵌套关系。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>最后，路由算法会根据定义的顺序自顶向下匹配路由。因此，当你拥有两个兄弟路由节点配置时，你必须确认前一个路由不会匹配后一个路由中的<code>路径</code>。例如，千万<strong>不要</strong>这么做：</p><pre><code class="js">&lt;Route path=&quot;/comments&quot; ... /&gt;&lt;Redirect from=&quot;/comments&quot; ... /&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-slot插槽</title>
      <link href="/2022/08/25/11%20slot/"/>
      <url>/2022/08/25/11%20slot/</url>
      
        <content type="html"><![CDATA[<h1 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h1><p>插槽的应用场景大致分为2种：</p><h2 id="子组件通信-this-props-children"><a href="#子组件通信-this-props-children" class="headerlink" title="子组件通信-this.props.children"></a>子组件通信-this.props.children</h2><p>插槽可以很好地把按钮的事件处理函数留在父组件，但是插槽又可以将按钮插入子组件，非常方便的实现了2个子组件之间的通信</p><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;class Navbar extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &#123;this.props.children&#125;            &lt;/div&gt;        )    &#125;&#125;class Sidebar extends Component &#123;    render () &#123;        return (            &lt;div&gt;                Sidebar            &lt;/div&gt;        )    &#125;&#125;export default class App extends Component &#123;    state= &#123;        isShow:true    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;Navbar&gt;                    &lt;button onClick=&#123;()=&gt;&#123;                            this.setState(&#123;                                isShow:!this.state.isShow                            &#125;)                        &#125;&#125;&#125;&gt;&lt;/button&gt;                &lt;/Navbar&gt;                &#123;                    this.state.isShow?&lt;Sidebar/&gt;:null                &#125;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h2 id="嵌套路由-this-props-children"><a href="#嵌套路由-this-props-children" class="headerlink" title="嵌套路由-this.props.children"></a>嵌套路由-this.props.children</h2><p>插槽可以很好地时间路由配置中，在父路由js中通过{this.props.children}实现子路由的插入</p><p>router.js</p><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import &#123;HashRouter as Router,Route,Redirect,Switch&#125; from &#39;react-router-dom&#39;import Home from &#39;....&#39;import Homelist from &#39;....&#39;import Homenav from &#39;....&#39;export default class MyRouter extends Component &#123;    render () &#123;        return (            &lt;Router&gt;                &lt;Swtich&gt;                    &lt;Route path=&#39;/home&#39; render=&#123;()=&gt;(                        &lt;Home&gt;                              &lt;Route path=&#39;/home/list&#39; compoennt=&#123;Homelist&#125;&gt;&lt;/Route&gt;                             &lt;Route path=&#39;/home/nav&#39; compoennt=&#123;Homenav&#125;&gt;&lt;/Route&gt;                        &lt;/Home&gt;                    )&#125;&gt;&lt;/Route&gt;                &lt;/Swtich&gt;            &lt;/Router&gt;        )    &#125;&#125;</code></pre><p>Home.js</p><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;export default class Home extends Component &#123;    render () &#123;        return (            &lt;div&gt;                Home                &#123;this.props.children&#125; &#123;//通过this.props.children即可引入路由中定义的component=&#123;&#125;中的组件&#125;            &lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-性能优化方案</title>
      <link href="/2022/08/25/10%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/2022/08/25/10%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a>性能优化方案</h1><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>作为一个性能调优函数，控制组件自身或者子组件是否需要更新，尤其在子组件非常多的情况下， 需要进行优化</p><h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>PureComponent按以下流程进行操作：</p><ol><li>比较新props跟旧的props</li><li>比较新的state和老的state（值相等,或者对象含有相同的属性、且属性值相等  ）</li><li>决定shouldcomponentUpdate 返回true或者false，</li><li>从而决定要不要呼叫 render function。</li></ol><p>注意：如果你的 state 或 props 『永远都会变』，那 PureComponent 并不会比较快，因为 shallowEqual 也需要花时间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-pureComponent</title>
      <link href="/2022/08/25/09%20pureComponent/"/>
      <url>/2022/08/25/09%20pureComponent/</url>
      
        <content type="html"><![CDATA[<h1 id="pureComponent"><a href="#pureComponent" class="headerlink" title="pureComponent"></a>pureComponent</h1><p>React15.3中新加了一个 <code>PureComponent</code> 类，顾名思义， <code>pure</code> 是纯的意思，<code>PureComponent</code> 也就是纯组件，取代其前身 <code>PureRenderMixin</code> ,<code>PureComponent</code> 是优化 <code>React</code> 应用程序最重要的方法之一，易于实施，只要把继承类从 <code>Component</code> 换成 <code>PureComponent</code> 即可，可以减少不必要的 <code>render</code> 操作的次数，从而提高性能，而且可以少写 <code>shouldComponentUpdate</code> 函数，节省了点代码。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当组件更新时，如果组件的 <code>props</code> 和 <code>state</code> 都没发生改变，<code>render</code> 方法就不会触发，省去 <code>Virtual DOM</code> 的生成和比对过程，达到提升性能的目的。具体就是 <code>React</code> 自动帮我们做了一层浅比较：</p><pre><code class="jsx">if (this._compositeType === CompositeTypes.PureClass) &#123;  shouldUpdate = !shallowEqual(prevProps, nextProps)  || !shallowEqual(inst.state, nextState);&#125;</code></pre><p>而 <code>shallowEqual</code> 又做了什么呢？会比较 <code>Object.keys(state | props)</code> 的长度是否一致，每一个 <code>key</code>是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</p><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="易变数据不能使用一个引用"><a href="#易变数据不能使用一个引用" class="headerlink" title="易变数据不能使用一个引用"></a>易变数据不能使用一个引用</h3><p>案例：</p><pre><code class="jsx">class App extends PureComponent &#123;  state = &#123;    items: [1, 2, 3]  &#125;  handleClick = () =&gt; &#123;    const &#123; items &#125; = this.state;    items.pop();    this.setState(&#123; items &#125;);  &#125;  render() &#123;    return (&lt; div&gt;      &lt; ul&gt;        &#123;this.state.items.map(i =&gt; &lt; li key=&#123;i&#125;&gt;&#123;i&#125;&lt; /li&gt;)&#125;      &lt; /ul&gt;      &lt; button onClick=&#123;this.handleClick&#125;&gt;delete&lt; /button&gt;    &lt; /div&gt;)  &#125;&#125;</code></pre><p>会发现，无论怎么点 <code>delete</code> 按钮，<code>li</code>都不会变少，因为用的是一个引用，<code>shallowEqual</code> 的结果为 <code>true</code>。改正：</p><pre><code class="jsx">handleClick = () =&gt; &#123;  const &#123; items &#125; = this.state;  items.pop();  this.setState(&#123; items: [].concat(items) &#125;);&#125;</code></pre><p>这样每次改变都会产生一个新的数组，也就可以 <code>render</code> 了。这里有一个矛盾的地方，如果没有 <code>items.pop();</code> 操作，每次 <code>items</code> 数据并没有变，但还是 <code>render</code> 了，这不就很操蛋么？呵呵，数据都不变，你 <code>setState</code> 干嘛？</p><h3 id="不变数据使用一个引用"><a href="#不变数据使用一个引用" class="headerlink" title="不变数据使用一个引用"></a>不变数据使用一个引用</h3><h4 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h4><p>我们在给组件传一个函数的时候，有时候总喜欢:</p><pre><code class="jsx">&lt; MyInput onChange=&#123;e =&gt; this.props.update(e.target.value)&#125; /&gt;//或者update(e) &#123;  this.props.update(e.target.value)&#125;render() &#123;  return &lt; MyInput onChange=&#123;this.update.bind(this)&#125; /&gt;&#125;</code></pre><p>由于每次 <code>render</code> 操作 <code>MyInput</code> 组件的 <code>onChange</code> 属性都会返回一个新的函数，由于引用不一样，所以父组件的 <code>render</code> 也会导致 <code>MyInput</code> 组件的 <code>render</code>，即使没有任何改动，所以需要尽量避免这样的写法，最好这样写：</p><pre><code class="jsx">update = (e) =&gt; &#123;  this.props.update(e.target.value)&#125;render() &#123;  return &lt; MyInput onChange=&#123;this.update&#125; /&gt;&#125;</code></pre><h4 id="空对象或空数组"><a href="#空对象或空数组" class="headerlink" title="空对象或空数组"></a>空对象或空数组</h4><p>有时候后台返回的数据中，数组长度为0或者对象没有属性会直接给一个 <code>null</code>，这时候我们需要做一些容错：</p><pre><code class="jsx">class App extends PureComponent &#123;  state = &#123;    items: [&#123; name: &#39;test1&#39; &#125;, null, &#123; name: &#39;test3&#39;  &#125;]  &#125;  store = (id, value) =&gt; &#123;    const &#123; items &#125; = this.state;    items[id]  = assign(&#123;&#125;, items[id], &#123; name: value &#125;);    this.setState(&#123; items: [].concat(items) &#125;);  &#125;  render() &#123;    return (&lt; div&gt;      &lt; ul&gt;        &#123;this.state.items.map((i, k) =&gt;          &lt; Item store=&#123;this.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || &#123;&#125;&#125; /&gt;)        &#125;      &lt; /ul&gt;    &lt; /div&gt;)  &#125;&#125;</code></pre><p>当某一个子组件调用 <code>store</code> 函数改变了自己的那条属性，触发 <code>render</code> 操作，如果数据是 <code>null</code> 的话 <code>data</code> 属性每次都是一个 <code>&#123;&#125;</code>，<code>&#123;&#125; ==== &#123;&#125;</code> 是 <code>false</code> 的，这样无端的让这几个子组件重新 <code>render</code> 了。</p><p>最好设置一个 <code>defaultValue</code> 为 <code>&#123;&#125;</code>,如下：</p><pre><code class="jsx">defaultValue = &#123;&#125;&lt; Item store=&#123;this.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || defaultValue&#125; /&gt;</code></pre><h3 id="复杂状态与简单状态不要共用一个组件"><a href="#复杂状态与简单状态不要共用一个组件" class="headerlink" title="复杂状态与简单状态不要共用一个组件"></a>复杂状态与简单状态不要共用一个组件</h3><p>这点可能和<code>PureComponent</code>没多少关系，但做的不好可能会浪费很多性能，比如一个页面上面一部分是一个复杂的列表，下面是一个输入框，抽象代码：</p><pre><code class="jsx">change = (e) =&gt; &#123;  this.setState(&#123; value: e.target.value &#125;);&#125;render() &#123;  return (&lt; div&gt;    &lt; ul&gt;      &#123;this.state.items.map((i, k) =&gt; &lt; li key=&#123;k&#125;&gt; &#123;...&#125;&lt; /li&gt;)&#125;    &lt; /ul&gt;    &lt; input value=&#123;this.state.value&#125; onChange=&#123;this.change&#125; /&gt;  &lt; /div&gt;)&#125;</code></pre><p>表单和列表其实是没有什么关联的，表单的值也可能经常变动，但它的会给列表也带来必然的<code>diff</code>操作，这是没必要的，最好是给列表抽出成一个单独的 <code>PureComponent</code> 组件，这样 <code>state.items</code> 不变的话，列表就不会重新 <code>render</code> 了。</p><h3 id="与shouldComponentUpdate共存"><a href="#与shouldComponentUpdate共存" class="headerlink" title="与shouldComponentUpdate共存"></a>与<code>shouldComponentUpdate</code>共存</h3><p>如果 <code>PureComponent</code> 里有 <code>shouldComponentUpdate</code> 函数的话，直接使用 <code>shouldComponentUpdate</code> 的结果作为是否更新的依据，没有<code>shouldComponentUpdate</code> 函数的话，才会去判断是不是 <code>PureComponent</code> ，是的话再去做 <code>shallowEqual</code>浅比较。</p><pre><code class="jsx">// 这个变量用来控制组件是否需要更新var shouldUpdate = true;// inst 是组件实例if (inst.shouldComponentUpdate) &#123;  shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);&#125; else &#123;  if (this._compositeType === CompositeType.PureClass) &#123;    shouldUpdate = !shallowEqual(prevProps, nextProps) ||      !shallowEqual(inst.state, nextState);  &#125;&#125;</code></pre><h3 id="老版本兼容写法"><a href="#老版本兼容写法" class="headerlink" title="老版本兼容写法"></a>老版本兼容写法</h3><pre><code class="jsx">import React &#123; PureComponent, Component &#125; from &#39;react&#39;;class Foo extends (PureComponent || Component) &#123;  //...&#125;</code></pre><p>这样在老版本的 <code>React</code> 里也不会挂掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>PureComponent</code>真正起作用的，只是在一些纯展示组件上，复杂组件用了也没关系，反正<code>shallowEqual</code>那一关就过不了，不过记得 <code>props</code> 和 <code>state</code> 不能使用同一个引用哦。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-生命周期</title>
      <link href="/2022/08/25/08%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/08/25/08%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="https://segmentfault.com/img/bVbrzRm?w=800&h=799" alt="53884612-fa2b0800-4056-11e9-879f-050e0b33e0e9.png?ynotemdtimestamp=1551878671356"></p><p><strong>初始化阶段</strong></p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><blockquote><p>只能访问this.props和this.state，不允许修改状态和DOM输出</p></blockquote><h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><blockquote><p>render之前最后一次修改状态的机会</p></blockquote><p>在ssr中 这个方法将会被多次调用，所以会重复触发多少遍，同时在这里如果绑定事件，将无法解绑，导致内存泄漏，变得不够安全高效逐步废弃。</p><p>因此需要加上UNSAFE</p><pre><code class="jsx">UNSAFE_componentWillMount () &#123;&#125;</code></pre><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><blockquote><p>成功render并渲染完成真实DOM之后触发，可以修改DOM</p></blockquote><pre><code>componentWillMount () &#123;&#125;</code></pre><p><strong>运行中阶段</strong></p><h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><p>外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求</p><h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p><code>UNSAFE_componentWillReceiveProps(nextProps)</code> 在组件接收到新的参数时被触发，当父组件导致子组件更新的时候, 即使接收的 props 并没有变化, 这个函数也会被调用.</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>参数是组件接收到的新的 props , 用于比对新的 props 和原有的 props, 用户需要在函数体中调用 setState() 来更新组件的数据.</p><pre><code class="jsx">UNSAFE_componentWillReceiveProps(nextProps)&#123;    if (this.props.currentExercise.id !== nextProps.currentExercise.id)&#123;        this.setState(&#123;...nextProps.currentExercise&#125;)    &#125;&#125;</code></pre><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><ol><li><p>setState()函数在任何情况下都会导致组件重渲染吗？如果setState()中参数还是原来没有发生任何变化的state呢？</p></li><li><p>如果组件的state没有变化，并且从父组件接受的props也没有变化，那它就一定不会重渲染吗？</p></li><li><p>如果1，2两种情况下都会导致重渲染，我们该如何避免这种冗余的操作，从而优化性能？</p></li></ol><p><strong>没有导致state的值发生变化的setState是否会导致重渲染 ——【会！】</strong></p><p>shouldComponentUpdate是一个性能调优函数，是重渲染时render()函数调用前被调用的函数，它<strong>接受两个参数：nextProps和nextState</strong>，分别表示下一个props和下一个state的值。并且<strong>，当函数返回false时候，阻止接下来的render()函数的调用，阻止组件重渲染</strong>，而返回true时，组件照常重渲染。</p><p>nextProps：修改后的属性</p><p>nextState：修改后的状态</p><p>可以根据状态和参数中的状态的对比，返回true/false来判断是否需要更新</p><pre><code>shouldComponentUpdate (nextProps,nextState) &#123;    return !(this.state.myname === nextState.myname) ||!(this.state.myage === nextState.myage) &#125;</code></pre><h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><p>更新前记录DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致状态不太信</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  state= &#123;    myname:&#39;retr0&#39;  &#125;  UNSAFE_componentWillUpdate () &#123;    console.log(&#39;componentWillUpdate&#39;);  &#125;  render() &#123;    return (      &lt;div&gt;        &#123;this.state.myname&#125;        &lt;button onClick=&#123;()=&gt;&#123;          this.setState(&#123;            myname:&#39;xiaoming&#39;          &#125;)        &#125;&#125;&gt;Click&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  state= &#123;    myname:&#39;retr0&#39;  &#125;  componentDidUpdate () &#123;    console.log(&#39;componentDidUpdate&#39;);  &#125;  render() &#123;    return (      &lt;div&gt;        &#123;this.state.myname&#125;        &lt;button onClick=&#123;()=&gt;&#123;          this.setState(&#123;            myname:&#39;xiaoming&#39;          &#125;)        &#125;&#125;&gt;Click&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><strong>销毁阶段</strong></p><h2 id="componentWillUnMount"><a href="#componentWillUnMount" class="headerlink" title="componentWillUnMount"></a>componentWillUnMount</h2><p>用于清除计时器，window.scroll=null等操作</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;class Navar extends Component &#123;  render () &#123;    return (      &lt;div style=&#123;&#123;background:'#f99'&#125;&#125;&gt;         navbar-&lt;button onClick=&#123;this.handleClick&#125;&gt;Click&lt;/button&gt;      &lt;/div&gt;    )  &#125;  handleClick = ()=&gt;&#123;    this.props.onEvent();  &#125;&#125;class Slidebar extends Component &#123;  render () &#123;    return (      &lt;div style=&#123;&#123;background:'#99f'&#125;&#125;&gt;        slidebar        &lt;ul&gt;          &lt;li&gt;11111&lt;/li&gt;          &lt;li&gt;22222&lt;/li&gt;          &lt;li&gt;33333&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    )  &#125;  //销毁声明周期  componentWillUnmount () &#123;    console.log(&#39;componentWillUnmount&#39;);  &#125;&#125;export default class 子传父 extends Component &#123;  state = &#123;    isShow:true  &#125;  render() &#123;    return (      &lt;div&gt;        App        &lt;Navar onEvent=&#123;()=&gt;&#123;          this.setState(&#123;            isShow : !this.state.isShow          &#125;)        &#125;&#125;/&gt;        &#123;this.state.isShow?&lt;Slidebar/&gt;:&#39;&#39;&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><strong>新增</strong></p><h2 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps"></a>static getDerivedStateFromProps</h2><p><code>getDerivedStateFromProps</code> 是一个静态方法, 是一个和组件自身”不相关”的角色. 在这个静态方法中, 除了两个默认的位置参数 nextProps 和 currentState 以外, 你无法访问任何组件上的数据。第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子) ，返回一个对象作为新的state，返回null则说明不需要在这里更新state</p><h3 id="会被频繁地触发"><a href="#会被频繁地触发" class="headerlink" title="会被频繁地触发"></a>会被频繁地触发</h3><p>无论是组件调用了 setState(), 接收的 props 发生了变化, 或是父组件的更新都会导致子组件上的 <code>getDerivedStateFromProps</code>被触发.</p><h3 id="使用的时候必须非常小心"><a href="#使用的时候必须非常小心" class="headerlink" title="使用的时候必须非常小心"></a>使用的时候必须非常小心</h3><p>由于 <code>getDerivedStateFromProps</code> 会在 setState() 后被调用, 并且它的返回值会被用于更新数据. 这意味着你会在 setState() 之后触发 <code>getDerivedStateFromProps</code>, 然后可能意外地再次 “setState()”.</p><p><code>getDerivedStateFromProps(nextProps)</code> 函数中的第一个位置参数未必是 “新” 的 props. 在组件内调用了 setState() 时, <code>getDerivedStateFromProps</code> 会被调用. 但是此时的组件其实并没有获得 “新” 的 props, 是的, 这个 nextProps 的值和原来的 props 是一样的.</p><p>这就导致了我们在使用 <code>getDerivedStateFromProps</code> 时, 必须添加很多逻辑判断语句来处理 props 上的更新和 state 上的更新, 避免意外地返回了一个 Updater 再次更新数据, 导致数据异常.</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;class Child extends Component &#123;  state=&#123;    ajax:&#39;&#39;  &#125;  // UNSAFE_componentWillReceiveProps () &#123;  //   console.log(&#39;componentWillReceiveProps&#39;);  // &#125;  componentDidUpdate () &#123;    console.log(this.state.ajax);  &#125;  static getDerivedStateFromProps (nextProps,currentState)&#123;    return &#123;      ajax:nextProps.ajax    &#125;  &#125;  render () &#123;    return (      &lt;div&gt;        child - &#123;this.props.ajax&#125;      &lt;/div&gt;    )  &#125;&#125;export default class App extends Component &#123;  state= &#123;    ajax:9000  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;Child ajax=&#123;this.state.ajax&#125;/&gt;        &lt;button onClick=&#123;()=&gt;&#123;          this.setState(&#123;            ajax:1000          &#125;)        &#125;&#125;&gt;Click&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="更优雅的做法"><a href="#更优雅的做法" class="headerlink" title="更优雅的做法"></a>更优雅的做法</h3><p>React 官方博客中提供了以下几种方案:</p><ol><li>让表单控件变成完全受控组件, 不论是 onChange 处理函数还是 value 都由父组件控制, 这样用户无需再考虑这个组件 props 的变化和 state 的更新.</li></ol><pre><code class="jsx">function EmailInput(props) &#123;  return &lt;input onChange=&#123;props.onChange&#125; value=&#123;props.email&#125; /&gt;;&#125;</code></pre><ol start="2"><li>让表单控件变成完全不受控组件, 但是具有 key 属性.<br> 仍然用自身的数据来控制 value. 但是接收 props 中的某个字段作为 key 属性的值, 以此响应 props 的更新: 当 key 的值变化时 React 会替换 (reset)组件, 从而重新生成初始化数据.</li></ol><blockquote><p>When a key changes, React will create a new component instance rather than update the current one.</p></blockquote><p>示例代码:</p><pre><code class="jsx">//组件内的代码class EmailInput extends Component &#123;  state = &#123; email: this.props.defaultEmail &#125;;  handleChange = event =&gt; &#123;    this.setState(&#123; email: event.target.value &#125;);  &#125;;  render() &#123;    return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;  &#125;&#125;</code></pre><pre><code class="kotlin">// 在父组件中接收 props 中的数据作为 key&lt;EmailInput  defaultEmail=&#123;this.props.user.email&#125;  key=&#123;this.props.user.id&#125;/&gt;</code></pre><ul><li>其他方法请参考 <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#alternative-1-reset-uncontrolled-component-with-an-id-prop">这里</a></li></ul><h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>取代了 componetWillUpdate ,触发时间为update发生的时候，在<code>render之后,dom渲染之前</code>返回一个值，作为componentDidUpdate的第三个参数。</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  state = &#123;    mytext :&#39;retr0&#39;,  &#125;  // componentWillUpdate () &#123;  //   console.log(this.state.mytext);  // &#125;  getSnapshotBeforeUpdate () &#123;    console.log(this.state.mytext,&#39;获取滚动条的位置&#39;);    return &#123;      y:100    &#125;  &#125;  componentDidUpdate(prevProps, prevState,data) &#123;    console.log(prevProps,prevState,data);  &#125;    render() &#123;    console.log(&#39;render&#39;);    return (      &lt;div&gt;        &#123;this.state.mytext&#125;        &lt;button onClick=&#123;()=&gt;&#123;          this.setState(&#123;            mytext:&#39;xiaoming&#39;          &#125;)        &#125;&#125;&gt;Click&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</title>
      <link href="/2022/08/25/07%20context/"/>
      <url>/2022/08/25/07%20context/</url>
      
        <content type="html"><![CDATA[<h1 id="context"><a href="#context" class="headerlink" title="context"></a>context</h1><blockquote><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p></blockquote><p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>跨组件访问数据</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>react组件树种某个<strong>上级组件shouldComponetUpdate返回false</strong>,当 context更新时，<strong>不会引起下级组件更新</strong></p><h2 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h2><pre><code>const MyContext = React.createContext(defaultValue);</code></pre><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p><p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</p><h3 id=""><a href="#" class="headerlink" title=" "></a><code> </code></h3><h2 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h2><pre><code>&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;</code></pre><p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><p>通过新旧值检测来确定变化，使用了与 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code></a> 相同的算法。</p><h2 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h2><p>注意：Context.Consumer内必须是回调函数，通过context方法改变根组件状态</p><pre><code>&lt;MyContext.Consumer&gt;  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;&lt;/MyContext.Consumer&gt;</code></pre><p>这里，React 组件也可以订阅到 context 变更。这能让你在<a href="https://react.docschina.org/docs/components-and-props.html#function-and-class-components">函数式组件</a>中完成订阅 context。</p><p>这需要<a href="https://react.docschina.org/docs/render-props.html#using-props-other-than-render">函数作为子元素（function as a child）</a>这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 <code>value</code> 值等同于往上组件树离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;const myContext = React.createContext()class Child extends Component&#123;  UNSAFE_componentWillUpdate ()&#123;    console.log(&#39;componentWillUpdate1&#39;);  &#125;  componentDidUpdate () &#123;    console.log(&#39;componentDidUpdate1&#39;);  &#125;  render () &#123;    return (      &lt;myContext.Consumer&gt;        &#123;          context=&gt;(            &lt;div&gt;              child -- &#123;context.myname&#125; -- &#123;context.age&#125;  -- &#123;context.sex&#125;              &lt;button onClick=&#123;this.handleClick.bind(this,context)&#125;&gt;change&lt;/button&gt;            &lt;/div&gt;          )        &#125;      &lt;/myContext.Consumer&gt;    )  &#125;  handleClick = (context)=&gt;&#123;    context.changeState(&#39;xiaoming&#39;)  &#125;&#125;export default class App extends Component &#123;  state=&#123;    myname:&#39;retr0&#39;  &#125;  UNSAFE_componentWillUpdate ()&#123;    console.log(&#39;componentWillUpdate&#39;);  &#125;  componentDidUpdate () &#123;    console.log(&#39;componentDidUpdate&#39;);  &#125;  shouldComponentUpdate (nextProps,nextState) &#123;    return !(this.state.myname===nextState.myname)  &#125;  changeState = (data)=&gt;&#123;    this.setState(&#123;      myname:data    &#125;)  &#125;  render () &#123;    return (      &lt;myContext.Provider value=&#123;&#123;        myname:this.state.myname,        age:12,        sex:1,        changeState:this.changeState      &#125;&#125;&gt;         &lt;div&gt;          app          &lt;Child&gt;&lt;/Child&gt;        &lt;/div&gt;      &lt;/myContext.Provider&gt;    )  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)</title>
      <link href="/2022/08/25/06%20ref%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/08/25/06%20ref%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="ref通信"><a href="#ref通信" class="headerlink" title="ref通信"></a>ref通信</h1><p>ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)</p><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;class Navbar extends Component &#123;        state = &#123;            mytext = &#39;&#39;        &#125;        reset= ()=&gt;&#123;            this.setState(&#123;                mytext:&#39;&#39;            &#125;)        &#125;        render () &#123;            return (                &lt;div&gt;                    &lt;input type=&#39;text&#39; onChange=&#123;this.saveText&#125;/&gt;                &lt;/div&gt;            )        &#125;        saveText= (eve)=&gt;&#123;            this.setState(&#123;                mytext:eve.target.value        &#125;)    &#125;&#125;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt;                 &#123;//建立子组件ref的引用&#125;                &lt;Navbar ref=&#39;text&#39;/&gt;                               &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt;            &lt;/div&gt;        )    &#125;    handleClick = ()=&gt;&#123;        console.log(this.refs.text.state.mytext)&#123;//查询子组件的state&#125;        this.refs.text.reset()&#123;//调用子组件的方法&#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-onEvent通过调用父的函数，实现由子组件控制父组件状态的变化</title>
      <link href="/2022/08/25/05%20onEvent/"/>
      <url>/2022/08/25/05%20onEvent/</url>
      
        <content type="html"><![CDATA[<h1 id="onEvent"><a href="#onEvent" class="headerlink" title="onEvent"></a>onEvent</h1><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;class Navbar extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt;            &lt;/div&gt;        )    &#125;    handleClick = ()=&gt;&#123;        this.props.onEvent() //通过调用父的函数，实现由子组件控制父组件状态的变化    &#125;&#125;class Slidebar extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &lt;ul&gt;                    &lt;li&gt;1111&lt;/li&gt;                    &lt;li&gt;2222&lt;/li&gt;                    &lt;li&gt;3333&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;        )    &#125;&#125;export default class App extends Component &#123;    state = &#123;        isShow:true    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;Navbar onEvent=&#123;()=&gt;&#123;                        this.setState(&#123;                            isShow:!this.state.isShow                        &#125;)                    &#125;&#125;/&gt;                &#123;                    this.state.isShow?&lt;Slidebar&gt;&lt;/Slidebar&gt;:null                &#125;            &lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-父子通信-父传子</title>
      <link href="/2022/08/25/04%20props/"/>
      <url>/2022/08/25/04%20props/</url>
      
        <content type="html"><![CDATA[<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><h2 id="父子通信-父传子"><a href="#父子通信-父传子" class="headerlink" title="父子通信-父传子"></a>父子通信-父传子</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;class Navbar extends Component &#123;    render () &#123;        return (            &lt;button&gt;back&lt;/button&gt;            &lt;div&gt;Navbar&lt;/div&gt;            &lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;        )    &#125;&#125;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &lt;Navbar mytitle=&#39;home&#39;&gt;&lt;/Navbar&gt;                &lt;Navbar mytitle=&#39;list&#39;&gt;&lt;/Navbar&gt;                &lt;Navbar mytitle=&#39;shopbar&#39;&gt;&lt;/Navbar&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><ol><li>引入’prop-types’模块</li><li>利用static声明符定义类属性</li><li>在类中定义一个属性：propTypes，值为一个对象</li></ol><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import MyPropType from &#39;prop-types&#39;class Navbar extends Component &#123;   static propTypes = &#123;       isShow:MyPropType.bool,       mytitle:MyPropType.string   &#125;    render () &#123;        return (            &lt;div&gt;                &lt;button&gt;left&lt;/button&gt;                &lt;div&gt;Navbar&lt;/div&gt;                &#123;                    this.props.isShow?&lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;:null                &#125;            &lt;/div&gt;        )    &#125;&#125;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &lt;Navbar mytitle=&#39;home&#39; isShow=&#123;true&#125;/&gt;                &lt;Navbar mytitle=&#39;list&#39; isShow=&#123;false&#125;/&gt;                &lt;Navbar mytitle=&#39;shopbar&#39; isShow=&#123;&#39;false&#39;&#125;/&gt;                &#123;//这里传入的是字符串而非布尔值&#125;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h2 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import MyPropTypes from &#39;prop-types&#39;class Navbar extends Component &#123;    static propTypes = &#123;        mytitle:MyPropTypes.string    &#125;    static defaultProps = &#123;        mytitle:&#39;Click&#39;    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;button&gt;left&lt;/button&gt;                &lt;div&gt;Navbar&lt;/div&gt;                &lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt;                &lt;Navbar mytitle=&#39;Home&#39;&gt;&lt;/Navbar&gt;                &lt;Navbar&gt;&lt;/Navbar&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h2 id="React自带的属性展开语法"><a href="#React自带的属性展开语法" class="headerlink" title="React自带的属性展开语法"></a>React自带的属性展开语法</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import MyPropTypes from &#39;prop-types&#39;class Navbar extends Component &#123;    static propTypes = &#123;        mytitle:MyPropTypes.string,        myshow:MyPropTypes.bool    &#125;    static defaultProps = &#123;        mytitle:&#39;Click&#39;,        myshow:true    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;button&gt;left&lt;/button&gt;                &lt;div&gt;Navbar&lt;/div&gt;                &lt;button&gt;&#123;this.props.mytitle&#125;&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default class App extends Component &#123;    render () &#123;        let obj = &#123;            mytitle:&#39;list&#39;,            myshow:false        &#125;        return (            &lt;div&gt;                &lt;Navbar mytitle=&#39;Home&#39;&gt;&lt;/Navbar&gt;                &lt;Navbar&gt;&lt;/Navbar&gt;                &lt;Navbar &#123;...obj&#125;/&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-条件渲染</title>
      <link href="/2022/08/25/03%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
      <url>/2022/08/25/03%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="显示或隐藏"><a href="#显示或隐藏" class="headerlink" title="显示或隐藏"></a>显示或隐藏</h2><pre><code class="css">.hide&#123;display:none&#125;</code></pre><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;import &#39;./css/index/css&#39; //引入上面的css文件export default class App extends Component &#123;    state = &#123;        isHide:false    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;div className=&#123;isHide?&#39;hide&#39;:&#39;&#39;&#125;&gt;1111111&lt;/div&gt;                &lt;button onClick=&#123;this.isshow&#125;&gt;show/hide&lt;/button&gt;            &lt;/div&gt;        )    &#125;    isshow = ()=&gt;&#123;        this.setState(&#123;            isHide:!this.state.isHide        &#125;)    &#125;&#125;</code></pre><h2 id="创建或删除"><a href="#创建或删除" class="headerlink" title="创建或删除"></a>创建或删除</h2><pre><code class="jsx">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    state= &#123;        isshow:true    &#125;    render () &#123;        let odiv = &lt;div&gt;11111111111&lt;/div&gt;        return (            &lt;div&gt;            &#123;                isshow?odiv:null            &#125;                &lt;button onClick=&#123;(prevState)=&gt;&#123;                        this.setState(&#123;                            isshow:!prevState.isshow                        &#125;)                    &#125;&#125;&gt;show/hide&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React-jsx语法与组件</title>
      <link href="/2022/08/25/02%20jsx%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6/"/>
      <url>/2022/08/25/02%20jsx%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="jsx语法与组件"><a href="#jsx语法与组件" class="headerlink" title="jsx语法与组件"></a>jsx语法与组件</h1><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由Babel 的 JSX 编译器实现。</p><blockquote><p><a href="https://reactjs.org/docs/hello-world.html">https://reactjs.org/docs/hello-world.html</a></p></blockquote><h2 id="组件首字母大写"><a href="#组件首字母大写" class="headerlink" title="组件首字母大写"></a>组件首字母大写</h2><p>组件首字母是大写 会被认为是自定义组件,首字母是小写，会被认为是 原生dom节点</p><pre><code class="js">import App from &#39;./App.js&#39;import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;ReactDOM.render(&lt;App/&gt;,document.getElementById(&quot;root&quot;))//ReactDOM.render(&lt;div&gt;hello react&lt;/div&gt;,document.getElementById(&quot;root&quot;))//只要使用jsx,必须引入React//babel将上面的&lt;div&gt;hello react&lt;/div&gt;转换成 ==&gt; React.createElement(&#39;div&#39;,&#39;hello&#39;)</code></pre><h2 id="组件标签"><a href="#组件标签" class="headerlink" title="组件标签"></a>组件标签</h2><p>组件最外层需要被一个标签包裹，不能有兄弟节点</p><p>return (加上小括号,可以回车)</p><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt; //组件最外层标签                &lt;ul&gt;&lt;li&gt;hello&lt;/li&gt;&lt;/ul&gt;                &lt;p&gt;world&lt;/p&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h2 id="组件可以嵌套"><a href="#组件可以嵌套" class="headerlink" title="组件可以嵌套"></a>组件可以嵌套</h2><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt; //组件最外层标签                &lt;ul&gt;&lt;li&gt;hello&lt;/li&gt;&lt;/ul&gt;                &lt;p&gt;world&lt;/p&gt;                &lt;Child/&gt;            &lt;/div&gt;        )    &#125;&#125;class Child extends Component &#123;    render () &#123;        return (            &lt;div&gt;child&lt;/div&gt;        )    &#125;&#125;</code></pre><h2 id="函数式写法"><a href="#函数式写法" class="headerlink" title="函数式写法"></a>函数式写法</h2><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    render () &#123;        return (            &lt;div&gt; //组件最外层标签                &lt;ul&gt;&lt;li&gt;hello&lt;/li&gt;&lt;/ul&gt;                &lt;p&gt;world&lt;/p&gt;                &lt;Child1/&gt;                &lt;Child2/&gt;                &lt;Child3/&gt;            &lt;/div&gt;        )    &#125;&#125;class Child extends Component &#123;    render () &#123;        return (            &lt;div&gt;child1&lt;/div&gt;        )    &#125;&#125;function Child2 () &#123;    return (&lt;div&gt;child2&lt;/div&gt;)&#125;const Child3 = ()=&gt;&#123;    return (&lt;div&gt;child3&lt;/div&gt;)&#125;</code></pre><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><pre><code class="html">&lt;div class=&#39;box&#39;&gt;&lt;/div&gt; ==&gt; &lt;div className=&#39;box&#39;&gt;&lt;/div&gt; </code></pre><h3 id="label-for"><a href="#label-for" class="headerlink" title="label for"></a>label for</h3><pre><code class="html">&lt;label for=&#39;box&#39;&gt;&lt;/label&gt; ==&gt; &lt;label htmlFor=&#39;box&#39;&gt;&lt;/label&gt;</code></pre><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><pre><code class="js">let styleobj = &#123;    fontSize:&#39;10px&#39;,    color:&#39;red&#39;&#125;...&lt;div style=&#123;styleboj&#125;&gt;111&lt;/div&gt;&lt;div style=&#123;&#123;background:'red',color:'yellow'&#125;&#125;&gt;111&lt;/div&gt;</code></pre><h3 id="引入格式"><a href="#引入格式" class="headerlink" title="引入格式"></a>引入格式</h3><pre><code class="js">import &#39;./css/index.css&#39;</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    render () &#123;        return (            &lt;input type=&#39;text&#39;/&gt;            &lt;button onClick=&#123;()=&gt;&#123;                console.log(&#39;click&#39;)            &#125;&#125;&gt;Add1&lt;/button&gt;              &lt;button onClick=&#123;()=&gt;&#123;                this.handleClick(&#39;aaa&#39;,&#39;bbb&#39;)            &#125;&#125;&gt;Add2&lt;/button&gt;        )    &#125;    handleClick (x,y) &#123;        console.log(x+y)    &#125;&#125;</code></pre><h3 id="bind改变this指向"><a href="#bind改变this指向" class="headerlink" title="bind改变this指向"></a>bind改变this指向</h3><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    render () &#123;        return (            &lt;input type=&#39;text&#39;/&gt;            &lt;button onClick=&#123;this.handleClick.bind(this,&#39;aaa&#39;,&#39;bbb&#39;)&#125;&gt;Add&lt;/button&gt;        )    &#125;    handleClick (x,y) &#123;        console.log(&#39;click&#39;,x+y)    &#125;&#125;</code></pre><h3 id="ES6语法糖"><a href="#ES6语法糖" class="headerlink" title="ES6语法糖"></a>ES6语法糖</h3><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    render () &#123;        return (            &lt;input type=&#39;text&#39;/&gt;            &lt;button onClick=&#123;this.handleClick&#125;&gt;Add&lt;/button&gt;        )    &#125;    handleClick = ()=&gt;&#123;        console.log(&#39;click&#39;)    &#125;&#125;</code></pre><h2 id="react组件的数据挂载方式"><a href="#react组件的数据挂载方式" class="headerlink" title="react组件的数据挂载方式"></a>react组件的数据挂载方式</h2><h3 id="属性-默认属性与属性验证"><a href="#属性-默认属性与属性验证" class="headerlink" title="属性(默认属性与属性验证)"></a>属性(默认属性与属性验证)</h3><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><pre><code class="js">import React,&#123;Component&#125; from &#39;react&#39;export default class App extends Component &#123;    state = &#123;        myname: &#39;retr0&#39;    &#125;    render () &#123;        return (            &lt;div&gt;                &lt;p&gt;&#123;myname&#125;&lt;/p&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-slot</title>
      <link href="/2022/08/25/23%20slot/"/>
      <url>/2022/08/25/23%20slot/</url>
      
        <content type="html"><![CDATA[<h1 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h1><ul><li><p><strong>Props</strong>：</p><ul><li><code>name</code> - string，用于命名插槽。</li></ul></li><li><p><strong>Usage</strong>：</p><p><code> 元素作为组件模板之中的内容分发插槽。</code> 元素自身将被替换。</p><p>详细用法，请参考下面教程的链接。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87%E6%8F%92%E6%A7%BD%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9">通过插槽分发内容</a></p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="slot-’val’"><a href="#slot-’val’" class="headerlink" title="slot=’val’"></a>slot=’val’</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;child&gt;        &lt;div slot=&#39;a&#39;&gt;a&lt;/div&gt;        &lt;div slot=&#39;b&#39;&gt;b&lt;/div&gt;        &lt;div slot=&#39;c&#39;&gt;c&lt;/div&gt;    &lt;/child&gt;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&quot;child&quot;,&#123;    template:`        &lt;div&gt;            &lt;slot name=&#39;a&#39;&gt;&lt;/slot&gt;            &lt;slot name=&#39;b&#39;&gt;&lt;/slot&gt;            &lt;slot name=&#39;c&#39;&gt;&lt;/slot&gt;        &lt;/div&gt;    `,&#125;)</code></pre><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;template v-slot:a&gt;&lt;/template&gt;    &lt;template v-slot:b&gt;&lt;/template&gt;    &lt;template v-slot:c&gt;&lt;/template&gt;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&quot;child&quot;,&#123;    template:`        &lt;div&gt;            &lt;slot name=&#39;a&#39;&gt;&lt;/slot&gt;            &lt;slot name=&#39;b&#39;&gt;&lt;/slot&gt;            &lt;slot name=&#39;c&#39;&gt;&lt;/slot&gt;        &lt;/div&gt;    `,&#125;)</code></pre><h2 id="slot抽屉效果"><a href="#slot抽屉效果" class="headerlink" title="slot抽屉效果"></a>slot抽屉效果</h2><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;child&gt;         &lt;button @click=&#39;isshow=!isshow&#39;&gt;显示/隐藏&lt;/button&gt;    &lt;/child&gt;    &lt;slidebar v-show=&#39;isshow&#39;&gt;&lt;/slidebar&gt;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&#39;child&#39;,&#123;    template:`        &lt;div&gt;            &lt;slot&gt;&lt;/slot&gt;        &lt;/div&gt;    `&#125;)Vue.component(&#39;slidebar&#39;,&#123;    template:`        &lt;ul&gt;            ....        &lt;/ul&gt;    `&#125;)new Vue(&#123;    el:&#39;@#box&#39;,    data:&#123;        isshow:false    &#125;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-keep-alive1</title>
      <link href="/2022/08/25/22%20keep-alive/"/>
      <url>/2022/08/25/22%20keep-alive/</url>
      
        <content type="html"><![CDATA[<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><ul><li><p><strong>Props</strong>：</p><ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li><code>max</code> - 数字。最多可以缓存多少组件实例。</li></ul></li><li><p><strong>用法</strong>：</p><p><code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和</code> 相似，`` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 `` 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p><blockquote><p>在 2.2.0 及其更高版本中，<code>activated</code> 和 <code>deactivated</code> 将会在 `` 树内的所有嵌套组件中触发。</p></blockquote><p>主要用于保留组件状态或避免重新渲染。</p><pre><code class="html">&lt;!-- 基本 --&gt;&lt;keep-alive&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt;  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;  &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt;  &lt;keep-alive&gt;    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;  &lt;/keep-alive&gt;&lt;/transition&gt;</code></pre><p>注意，<code> 是用在其一个直属的子组件被开关的情形。如果你在其中有 `v-for` 则不会工作。如果有上述的多个条件性的子元素，</code> 要求同时只有一个子元素被渲染。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-动态组件</title>
      <link href="/2022/08/25/21%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/"/>
      <url>/2022/08/25/21%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><ul><li><p><strong>Props</strong>：</p><ul><li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li><li><code>inline-template</code> - boolean</li></ul></li><li><p><strong>用法</strong>：</p><p>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</p><pre><code class="html">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is=&quot;$options.components.child&quot;&gt;&lt;/component&gt;</code></pre></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a></p></li><li><p><strong>实例</strong></p><pre><code class="html">&lt;div id=&quot;box&quot;&gt;    &lt;!-- &lt;home v-if=&#39;type===&quot;home&quot;&#39;&gt;&lt;/home&gt;&lt;list v-else-if=&#39;type===&quot;list&quot;&#39;&gt;&lt;/list&gt;&lt;shopbar v-else=&#39;type===&quot;shopbar&quot;&#39;&gt;&lt;/shopbar&gt; --&gt;    &lt;keep-alive&gt;        &lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;    &lt;footer&gt;        &lt;ul&gt;            &lt;li @click=&#39;type=&quot;home&quot;&#39;&gt;首页&lt;/li&gt;            &lt;li @click=&#39;type=&quot;list&quot;&#39;&gt;列表&lt;/li&gt;            &lt;li @click=&#39;type=&quot;shopbar&quot;&#39;&gt;购物车&lt;/li&gt;        &lt;/ul&gt;    &lt;/footer&gt;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&quot;home&quot;, &#123;    template: `&lt;div&gt;home--&lt;input&gt;&lt;/div&gt;`&#125;)Vue.component(&quot;list&quot;, &#123;    template: `&lt;div&gt;list&lt;/div&gt;`&#125;)Vue.component(&quot;shopbar&quot;, &#123;    template: `&lt;div&gt;shopbar&lt;/div&gt;`&#125;)new Vue(&#123;    el: &#39;#box&#39;,    data: &#123;        type: &#39;home&#39;,    &#125;&#125;)</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-v-model通信</title>
      <link href="/2022/08/25/20%20v-model%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/08/25/20%20v-model%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="v-model通信"><a href="#v-model通信" class="headerlink" title="v-model通信"></a>v-model通信</h1><pre><code class="html">&lt;div id=&quot;box&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&#39;mytxt&#39;&gt;    &lt;child :text=&#39;mytxt&#39;&gt;&lt;/child&gt;    &lt;childmodel v-model=&#39;mytxt&#39;&gt;&lt;/childmodel&gt;&lt;/div&gt;</code></pre><pre><code class="JS">Vue.component(&quot;childmodel&quot;, &#123;    template: `            &lt;div&gt;                childmodel -- &#123;&#123;value&#125;&#125;                &lt;qbutton&gt;click&lt;/qbutton&gt;            &lt;/div&gt;`,   props:[&#39;value&#39;]&#125;)Vue.component(&quot;child&quot;, &#123;    template: `            &lt;div&gt;                child -- &#123;&#123;text&#125;&#125;                &lt;button&gt;click&lt;/button&gt;            &lt;/div&gt;`,    props: [&#39;text&#39;]&#125;)new Vue(&#123;    el: &#39;#box&#39;,    data: &#123;        mytxt: &quot;&quot;    &#125;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-事件总线</title>
      <link href="/2022/08/25/19%20%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
      <url>/2022/08/25/19%20%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h1><h2 id="bus"><a href="#bus" class="headerlink" title="bus"></a>bus</h2><blockquote><p>var bus = new Vue();</p></blockquote><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input v-model=&#39;mytxt&#39;&gt;    &lt;child&gt;&lt;/child&gt;    &lt;childmodel&gt;&lt;/childmodel&gt;&lt;/div&gt;</code></pre><pre><code class="js">let bus = new Vue();Vue.component(&quot;child&quot;,&#123;    template:`&lt;div&gt;child -- &lt;button @click=&#39;handelClick&#39;&gt;&lt;/button&gt;&lt;/div&gt;`,    methods:&#123;        handelClick()&#123;            bus.$emit(&#39;event&#39;，22222);        &#125;    &#125;&#125;)Vue.component(&quot;childmodel&quot;,&#123;    template:`&lt;div&gt;child&lt;/div&gt;`,    mounted()&#123;        bus.$on(&#39;event&#39;,data=&gt;&#123;            console.log(data)        &#125;)    &#125;&#125;)new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        mytxt:&#39;&#39;    &#125;&#125;)</code></pre><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><blockquote><p>生命周期中进行监听</p></blockquote><ul><li><p><strong>类型</strong>：<code>Function</code></p></li><li><p><strong>详细</strong>：</p><p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。 如果根实例挂载到了一个文档内的元素上，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。</p><p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a>：</p><pre><code class="js">mounted: function () &#123;    this.$nextTick(function () &#123;        // Code that will run only after the        // entire view has been rendered    &#125;)&#125;</code></pre><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期图示</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-18 .sync和update</title>
      <link href="/2022/08/25/18%20.sync%E5%92%8Cupdate/"/>
      <url>/2022/08/25/18%20.sync%E5%92%8Cupdate/</url>
      
        <content type="html"><![CDATA[<h1 id="属性可不可以修改"><a href="#属性可不可以修改" class="headerlink" title="属性可不可以修改"></a>属性可不可以修改</h1><p>严格来说,Vue子组件不能随便更改父组件传递过来的属性,但是可以通过props 配合 $emit 改变父组件传入的值</p><p>//父组件<my-input :warning.sync="warning" /></p><p>在父组件传入值时，需要有xxx.sync修饰符；</p><p>//子组件$emit(‘update:warning’,val)</p><p>子组件可以在$emit(‘update:xxxx’,val)，派发事件修改传入的值</p><blockquote><p>2.3.0+ 新增</p></blockquote><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p><p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p><pre><code class="js">this.$emit(&#39;update:title&#39;, newTitle)</code></pre><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：</p><pre><code class="html">&lt;text-document  v-bind:title=&quot;doc.title&quot;  v-on:update:title=&quot;doc.title = $event&quot;&gt;&lt;/text-document&gt;</code></pre><p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p><pre><code class="html">&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</code></pre><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。</p><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p><pre><code class="html">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</code></pre><p>这样会把 <code>doc</code> 对象中的每一个属性 (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p><p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="html">&lt;div id=&quot;box&quot;&gt;    &lt;child :title.sync=&#39;mytitle&#39;&gt;&lt;/child&gt;    &lt;br&gt;    &#123;&#123;mytitle&#125;&#125;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&#39;child&#39;, &#123;    template: `            &lt;div&gt;                child---&#123;&#123;title&#125;&#125; --                 &lt;button @click=&#39;change&#39;&gt;click&lt;/button&gt;            &lt;/div&gt;`,    props: [&#39;title&#39;],    methods: &#123;        change() &#123;            this.$emit(&#39;update:title&#39;, this.title + 1)        &#125;    &#125;&#125;)new Vue(&#123;    el: &#39;#box&#39;,    data: &#123;        mytitle: 11111    &#125;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-组件通信</title>
      <link href="/2022/08/25/17%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/08/25/17%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;navbar :myname=&#39;dataname&#39;&gt;&lt;/navbar&gt;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&#39;navbar&#39;,&#123;    template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,    props:[&#39;myname&#39;]&#125;)new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        dataname:&quot;retr0&quot;    &#125;&#125;)</code></pre><h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;navbar @event=&#39;handleGet&#39;&gt;&lt;/navbar&gt;&lt;/div&gt;</code></pre><pre><code class="js">Vue.component(&#39;navbar&#39;,&#123;    template:`&lt;div&gt;&lt;button @click=handlClick&gt;&lt;/button&gt;&lt;/div&gt;`,    data()&#123;        return &#123;            myname:&#39;retr0&#39;        &#125;    &#125;,    methods:&#123;        handlClick()&#123;            this.$emit(&#39;event&#39;,myname)        &#125;    &#125;&#125;)new Vue(&#123;    el:&#39;#box&#39;,    methods:&#123;        handleGet(data)&#123;            console.log(data) //retr0        &#125;    &#125;&#125;)</code></pre><ul><li>子组件向父组件中传递数据<ul><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label0_0">一. 通过props从父向子组件传递函数,调用函数改变父组件数据</a></li><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label0_1">二. 通过自定义事件从子组件向父组件中传递数据</a></li><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label0_2">三. 通过ref属性在父组件中直接取得子组件的数据（data）</a></li></ul></li><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label1">通过sync实现数据双向绑定， 从而同步父子组件数据</a></li><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label2">数据双向绑定是把双刃剑</a></li><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label3">当sync修饰的prop是个对象</a></li><li><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_label4">不要通过在子组件中修改引用类型props达到“父子组件数据同步”的需求！</a></li></ul><p><strong>一.</strong> 通过props，父组件向子组件中传递数据和改变数据的函数，通过在子组件中调用父组件传过来的函数，达到更新父组件数据（向父组件传递数据）的作用（子组件中需要有相应的响应事件）<br>二**.** 通过在子组件中触发一个 自定义事件（vm.$emit）,将数据作为vm.$emit方法的参数，回传给父组件用v-on：[自定义事件]监听的函数<br>三**.**通过ref对子组件做标记，父组件可以通过vm.$refs.[子组件的ref].[子组件的属性/方法]这种方式直接取得子组件的数据</p><p>下面我将一 一展示</p><h3 id="一-通过props从父向子组件传递函数-调用函数改变父组件数据"><a href="#一-通过props从父向子组件传递函数-调用函数改变父组件数据" class="headerlink" title="一. 通过props从父向子组件传递函数,调用函数改变父组件数据"></a>一. 通过props从父向子组件传递函数,调用函数改变父组件数据</h3><p>这里就不做代码展示了<br>一来是因为相对比较简单<br>二来是因为这种方式显然不是Vue中的最佳实践（在react中倒比较常见）<br>想要看代码的话可以看这里：《【Vue】浅谈Vue不同场景下组件间的数据交流》<a href="http://www.cnblogs.com/penghuwan/p/7286912.html#_label1">http://www.cnblogs.com/penghuwan/p/7286912.html#_label1</a> （在兄弟组件的数据交流那一节）</p><h3 id="二-通过自定义事件从子组件向父组件中传递数据"><a href="#二-通过自定义事件从子组件向父组件中传递数据" class="headerlink" title="二. 通过自定义事件从子组件向父组件中传递数据"></a>二. 通过自定义事件从子组件向父组件中传递数据</h3><p>我们可以在子组件中通过$emit(event, […参数])触发一个自定义的事件，这样，父组件可以在使用子组件的地方直接用 v-on来监听子组件触发的事件, 并且可以在监听函数中依次取得所有从子组件传来的参数</p><p>例如：<br>在子组件中某个部分写入：</p><pre><code>this.emit(&#39;eventYouDefined&#39;, arg);</code></pre><p>然后你就可以在父组件的子组件模板里监听：<br>// 这里是父组件的Template：</p><pre><code>&lt;Son  v-on: eventYouDefined = &quot;functionYours&quot; /&gt;</code></pre><p><strong>下面是一个实例</strong></p><p>父组件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div id=&quot;father&quot;&gt;    &lt;div&gt;       我是父组件,我接受到了：      &#123;&#123; text || '暂无数据'  &#125;&#125;      &lt;son v-on:sendData=&#39;getSonText&#39;&gt;&lt;/son&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import son from &#39;./son.vue&#39;export default &#123;  data: function () &#123;    return &#123;      text: &#39;&#39;    &#125;  &#125;,  components: &#123;    son: son;  &#125;,  methods: &#123;    getSonText (text) &#123;      this.text = text    &#125;  &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;#father div &#123;  padding: 10px;  margin: 10px;  border: 1px solid grey;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>子组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;我是子组件,我所拥有的数据： &#123;&#123; text &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;sendData&quot;&gt;      发送数据    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123;  data () &#123;    return &#123;      text: &#39;来自子组件的数据&#39;    &#125;  &#125;,  methods: &#123;    sendData () &#123;      this.$emit(&#39;sendData&#39;, this.text)    &#125;  &#125;&#125;&lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;   button &#123; float: left &#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904135919913-574638178.png" alt="img"><br>点击“发送数据”按钮后:</p><p><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904135946882-2121365807.png" alt="img"></p><p>因为sendData自定义事件被触发，通过 </p><pre><code>this.$emit(&#39;sendData&#39;, this.text)   //此处的this指向子组件实例）</code></pre><p>子组件的text数据被父组件中：</p><pre><code> &lt;son v-on:sendData=&#39;getSonText&#39;&gt;&lt;/son&gt;</code></pre><p>中的getSonText函数作为参数接传参受到， 从而完成了从子组件向父组件中的传参过程</p><h3 id="三-通过ref属性在父组件中直接取得子组件的数据（data）"><a href="#三-通过ref属性在父组件中直接取得子组件的数据（data）" class="headerlink" title="三. 通过ref属性在父组件中直接取得子组件的数据（data）"></a>三. 通过ref属性在父组件中直接取得子组件的数据（data）</h3><p>对于我们上面讲的一和二的处理情景来说，有个局限性就是它们都需要以事件机制为基础（无论是像click那样的原生事件还是自定义事件），而在事件发生的时候才能调用函数将数据传递过来</p><p><strong>但如果子组件里没有类似“按钮”的东西，因而无法制造原生事件，同时也没办法找到一个触发自定义事件的时机的时候，怎么从子组件向父组件传递数据呢？？</strong></p><p>这个时候， <strong>我们就只能从父组件中“直接取”子组件的数据了，借助ref属性</strong></p><p>ref是我们经常用到的Vue属性，利用它可以简单方便地从本组件的template中取得DOM实例，<strong>而实际上，如果你在父组件中为子组件设置ref的话， 就可以直接通过vm.$refs.[子组件的ref].[子组件的属性]去拿到数据啦</strong>，例如：</p><p>父组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div id=&quot;father&quot;&gt;    &lt;div&gt;       我是父组件,我接受到了：      &#123;&#123; text || '暂无数据'  &#125;&#125;      &lt;button @click=&quot;getSonText()&quot;&gt;接受数据&lt;/button&gt;      &lt;son ref=&#39;son&#39;&gt;&lt;/son&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import son from &#39;./son.vue&#39;export default &#123;  data: function () &#123;    return &#123;      text: &#39;&#39;    &#125;  &#125;,  components: &#123;    son: son  &#125;,  methods: &#123;    getSonText () &#123;      this.text = this.$refs.son.text    &#125;  &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;#father div &#123;  padding: 10px;  margin: 10px;  border: 1px solid grey;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>子组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;我是子组件,我所拥有的数据： &#123;&#123; text &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123;  data () &#123;    return &#123;      text: &#39;来自子组件的数据&#39;    &#125;  &#125;&#125;&lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;   button &#123; float: left &#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>demo:<br>尚未点击“接受数据”按钮前：</p><p><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904140038147-1656819094.png" alt="img"></p><p>点击接受数据按钮后：</p><p><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904140057960-1029107389.png" alt="img"></p><p><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_labelTop">回到顶部</a></p><h2 id="通过sync实现数据双向绑定，-从而同步父子组件数据"><a href="#通过sync实现数据双向绑定，-从而同步父子组件数据" class="headerlink" title="通过sync实现数据双向绑定， 从而同步父子组件数据"></a>通过sync实现数据双向绑定， 从而同步父子组件数据</h2><p>通过以上三种方式， 我想你应该能解决绝大多数父子组件通信的场景了，但让我们再仔细考虑一下上面的通信场景，就会发现<strong>它们还可能存在的问题：</strong></p><p><strong>从子组件向父组件传递数据时，父子组件中的数据仍不是每时每刻都同步的</strong></p><p>但<strong>在某些特殊的需求场景下，我们可能会希望父子组件中的数据时刻保持同步</strong>， 这时候你可能会像下面这样做：</p><p>这是父组件中的template:</p><pre><code>&lt;son :foo=&quot;bar&quot; v-on:update=&quot;val =&gt; bar = val&quot;&gt;&lt;/son&gt;</code></pre><p>在子组件中， 我们通过props声明的方式接收foo并使用</p><pre><code>props: &#123;     foo: [type]&#125;</code></pre><p>同时每当子组件中数据改变的时候,通过</p><pre><code>this.$emit(&#39;update&#39;, newValue)</code></pre><p>把参数newValue传递给父组件template中监听函数中的”val”。然后通过</p><pre><code>val =&gt; bar = val</code></pre><p>这个表达式就实现了bar = newValue. 这个时候，我们发现父组件中的关键数据bar被子组件改变（相等）了！</p><p><strong>通过数据的双向绑定， 父（组件）可以修改子的数据， 子也可以修改父的数据</strong></p><p>Vue提供了sync修饰符简化上面的代码，例如：</p><pre><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</code></pre><p>会被扩展为：</p><pre><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</code></pre><p>然后你需要在子组件中改变父组件数据的时候， 需要触发以下的自定义事件:</p><pre><code>this.$emit(&quot;update:foo&quot;, newValue)</code></pre><p><strong>【注意】你可能觉得这好像和我上面提到的二中的“通过自定义事件（emit）从子组件向父组件中传递数据”的那一节的内容似乎重叠了，。</strong></p><p><strong>然而并不是， 两者有着父子组件关系上的不同， 下面我通过一行关键的代码证明它们的区别所在</strong></p><p>**1.**在我们讲解sync的这一小节里， 自定义事件发生时候运行的响应表达式是：<br><son :foo="bar" v-on:update="val => bar = val"></son> 中的 “val =&gt; bar = val”<br>**2.**在二中的“通过自定义事件从子组件向父组件中传递数据” 里，自定义事件发生时候运行的响应表达式是:<br><Son v-on: eventYouDefined = "arg => functionYours(arg)" /> 中的 “arg =&gt; functionYours(arg)”</p><p>对前者， <strong>表达式 val =&gt; bar = val意味着强制让父组件的数据等于子组件传递过来的数据</strong>， 这个时候，我们发现<strong>父子组件的地位是平等的。 父可以改变子（数据）， 子也可以改变父（数据）</strong></p><p>对后者， <strong>你的functionYours是在父组件中定义的， 在这个函数里， 你可以对从子组件接受来的arg数据做任意的操作或处理</strong>， <strong>决定权完全落在父组件中， 也就是： 父可以改变子（数据）， 但子不能直接改变父（数据）！， 父中数据的变动只能由它自己决定</strong></p><p>下面是一个展示demo:</p><p>父组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div id=&quot;father&quot;&gt;    &lt;div&gt;       我是父组件      &lt;son        :wisdom.sync=&quot;wisdom&quot;        :magic.sync=&quot;magic&quot;        :attack.sync=&quot;attack&quot;        :defense.sync=&quot;defense&quot;&gt;      &lt;/son&gt;      &lt;p&gt;智力： &#123;&#123; wisdom &#125;&#125;&lt;/p&gt;      &lt;p&gt;膜法： &#123;&#123; magic &#125;&#125;&lt;/p&gt;      &lt;p&gt;攻击： &#123;&#123; attack &#125;&#125;&lt;/p&gt;      &lt;p&gt;防御： &#123;&#123; defense &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import son from &#39;./son.vue&#39;export default &#123;  data: function () &#123;    return &#123;      wisdom: 90,      magic: 160,      attack: 100,      defense: 80    &#125;  &#125;,  components: &#123;    son: son  &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;#father div &#123;  padding: 10px;  margin: 10px;  border: 1px solid grey;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>子组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;我是子组件&lt;/p&gt;    &lt;p&gt;智力： &#123;&#123; wisdom &#125;&#125;&lt;/p&gt;    &lt;p&gt;膜法： &#123;&#123; magic &#125;&#125;&lt;/p&gt;    &lt;p&gt;攻击： &#123;&#123; attack &#125;&#125;&lt;/p&gt;    &lt;p&gt;防御： &#123;&#123; defense &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment(&#39;wisdom&#39;)&quot;&gt;增加智力&lt;/button&gt;    &lt;button @click=&quot;increment(&#39;magic&#39;)&quot;&gt;增加膜法&lt;/button&gt;    &lt;button @click=&quot;increment(&#39;attack&#39;)&quot;&gt;增加攻击&lt;/button&gt;    &lt;button @click=&quot;increment(&#39;defense&#39;)&quot;&gt;增加防御&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123;  props: &#123;    wisdom: Number,    magic: Number,    attack: Number,    defense: Number  &#125;,  methods: &#123;    increment (dataName) &#123;      let newValue = this[dataName] + 1      this.$emit(`update:$&#123;dataName&#125;`, newValue)    &#125;  &#125;&#125;&lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;   button &#123; float: left &#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>点击前：<br><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904140150960-1016059567.png" alt="img"></p><p>点击增加子组件中“增加智力”按钮的时候， 父组件和子组件中的智力参数同时从90变为91</p><p><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904140209272-1398359235.png" alt="img"><br>点击增加子组件中“增加膜法”按钮的时候， 父组件和子组件中的智力参数同时从160变为161<br><img src="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904140222069-1730552299.png" alt="img"></p><p><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_labelTop">回到顶部</a></p><h2 id="数据双向绑定是把双刃剑"><a href="#数据双向绑定是把双刃剑" class="headerlink" title="数据双向绑定是把双刃剑"></a>数据双向绑定是把双刃剑</h2><p><strong>从好处上看：</strong><br>**1.**它实现了父子组件数据的“实时”同步， 在某些数据场景下可能会使用到这一点<br>**2.**sync提供的语法糖使得双向绑定的代码变得很简单</p><p><strong>从坏处上看：</strong><br>它破环了单向数据流的简洁性， 这增加了分析数据时的难度</p><p><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_labelTop">回到顶部</a></p><h2 id="当sync修饰的prop是个对象"><a href="#当sync修饰的prop是个对象" class="headerlink" title="当sync修饰的prop是个对象"></a>当sync修饰的prop是个对象</h2><p>我们对上面的例子修改一下， 把数据包裹在一个对象中传递下来：</p><p>父组件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div id=&quot;father&quot;&gt;    &lt;div&gt;       我是父组件      &lt;son :analysisData.sync=&quot;analysisData&quot;&gt;      &lt;/son&gt;      &lt;p&gt;智力： &#123;&#123; analysisData.wisdom &#125;&#125;&lt;/p&gt;      &lt;p&gt;膜法： &#123;&#123; analysisData.magic &#125;&#125;&lt;/p&gt;      &lt;p&gt;攻击： &#123;&#123; analysisData.attack &#125;&#125;&lt;/p&gt;      &lt;p&gt;防御： &#123;&#123; analysisData.defense &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import son from &#39;./son.vue&#39;export default &#123;  data: function () &#123;    return &#123;      analysisData: &#123;        wisdom: 90,        magic: 160,        attack: 100,        defense: 80      &#125;    &#125;  &#125;,  components: &#123;    son: son  &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;#father div &#123;  padding: 10px;  margin: 10px;  border: 1px solid grey;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>子组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;我是子组件&lt;/p&gt;    &lt;p&gt;智力： &#123;&#123; analysisData.wisdom &#125;&#125;&lt;/p&gt;    &lt;p&gt;膜法： &#123;&#123; analysisData.magic &#125;&#125;&lt;/p&gt;    &lt;p&gt;攻击： &#123;&#123; analysisData.attack &#125;&#125;&lt;/p&gt;    &lt;p&gt;防御： &#123;&#123; analysisData.defense &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment(&#39;wisdom&#39;)&quot;&gt;增加智力&lt;/button&gt;    &lt;button @click=&quot;increment(&#39;magic&#39;)&quot;&gt;增加膜法&lt;/button&gt;    &lt;button @click=&quot;increment(&#39;attack&#39;)&quot;&gt;增加攻击&lt;/button&gt;    &lt;button @click=&quot;increment(&#39;defense&#39;)&quot;&gt;增加防御&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123;  props: &#123;    analysisData: Object  &#125;,  methods: &#123;    increment (dataName) &#123;      let newObj = JSON.parse(JSON.stringify(this.analysisData))      newObj[dataName] += 1      this.$emit(&#39;update:analysisData&#39;, newObj)    &#125;  &#125;&#125;&lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;   button &#123; float: left &#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> <strong>demo同上</strong></p><p><a href="https://www.cnblogs.com/penghuwan/p/7473375.html#_labelTop">回到顶部</a></p><h2 id="不要通过在子组件中修改引用类型props达到“父子组件数据同步”的需求！"><a href="#不要通过在子组件中修改引用类型props达到“父子组件数据同步”的需求！" class="headerlink" title="不要通过在子组件中修改引用类型props达到“父子组件数据同步”的需求！"></a>不要通过在子组件中修改引用类型props达到“父子组件数据同步”的需求！</h2><p>父组件的数据传递给子组件， 一般通过props实现， 而在实现“父子组件数据同步”这一需求的时候， 小伙伴们可能会发现一点： 在子组件中修改引用类型的props（如数组和对象）是可行的</p><p><strong>1.不仅可以达到同时修改父组件中的数据（因为本来引用的就是同一个数据）</strong><br><strong>2.而且还不会被Vue的检测机制发现！（不会报错）</strong></p><p><strong>但千万不要这样做， 这样会让数据流变得更加难以分析，</strong>如果你尝试这样做， 上面的做法可能会更好一些</p><p><strong>不要这样做，糟糕的做法：</strong></p><p>父组件:</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div id=&quot;father&quot;&gt;    &lt;div&gt;       我是父组件      &lt;son :analysisData=&quot;analysisData&quot;&gt;      &lt;/son&gt;      &lt;p&gt;智力： &#123;&#123; analysisData.wisdom &#125;&#125;&lt;/p&gt;      &lt;p&gt;膜法： &#123;&#123; analysisData.magic &#125;&#125;&lt;/p&gt;      &lt;p&gt;攻击： &#123;&#123; analysisData.attack &#125;&#125;&lt;/p&gt;      &lt;p&gt;防御： &#123;&#123; analysisData.defense &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import son from &#39;./son.vue&#39;export default &#123;  data: function () &#123;    return &#123;      analysisData: &#123;        wisdom: 90,        magic: 160,        attack: 100,        defense: 80      &#125;    &#125;  &#125;,  components: &#123;    son: son  &#125;&#125;&lt;/script&gt; &lt;style scoped&gt;#father div &#123;  padding: 10px;  margin: 10px;  border: 1px solid grey;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>子组件：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;我是子组件&lt;/p&gt;    &lt;p&gt;智力： &#123;&#123; analysisData.wisdom &#125;&#125;&lt;/p&gt;    &lt;p&gt;膜法： &#123;&#123; analysisData.magic &#125;&#125;&lt;/p&gt;    &lt;p&gt;攻击： &#123;&#123; analysisData.attack &#125;&#125;&lt;/p&gt;    &lt;p&gt;防御： &#123;&#123; analysisData.defense &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment (&#39;wisdom&#39;)&quot;&gt;增加智力&lt;/button&gt;    &lt;button @click=&quot;increment (&#39;magic&#39;)&quot;&gt;增加膜法&lt;/button&gt;    &lt;button @click=&quot;increment (&#39;attack&#39;)&quot;&gt;增加攻击&lt;/button&gt;    &lt;button @click=&quot;increment (&#39;defense&#39;)&quot;&gt;增加防御&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123;  props: &#123;    analysisData: Object  &#125;,  methods: &#123;    increment (dataName) &#123;      let obj = this.analysisData      obj[dataName] += 1    &#125;  &#125;&#125;&lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;   button &#123; float: left &#125;&lt;/style&gt;</code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>demo同上， 但这并不是值得推荐的做法</strong></p><p> 【完】</p><p>**![img](<a href="https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904143644679-1541265391.j">https://images2017.cnblogs.com/blog/1060770/201709/1060770-20170904143644679-1541265391.j</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-ref</title>
      <link href="/2022/08/25/16%20ref/"/>
      <url>/2022/08/25/16%20ref/</url>
      
        <content type="html"><![CDATA[<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><p><strong>预期</strong>：<code>string</code></p><p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p><pre><code class="html">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;&lt;!-- `vm.$refs.child` will be the child component instance --&gt;&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;</code></pre><p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p><p>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0">子组件引用</a></p></li></ul><h3 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a><a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0">访问子组件实例或子元素</a></h3><p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用。例如：</p><pre><code class="htmk">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</code></pre><p>现在在你已经定义了这个 <code>ref</code> 的组件里，你可以使用：</p><pre><code class="js">this.$refs.usernameInput</code></pre><p>来访问这个 <code>实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该</code> 组件也可以使用一个类似的 <code>ref</code> 提供对内部这个指定元素的访问，例如：</p><pre><code class="html">&lt;input ref=&quot;input&quot;&gt;</code></pre><p>甚至可以通过其父级组件定义方法：</p><pre><code class="js">methods: &#123;  // 用来从父级组件聚焦输入框  focus: function () &#123;    this.$refs.input.focus()  &#125;&#125;</code></pre><p>这样就允许父级组件通过下面的代码聚焦 `` 里的输入框：</p><pre><code class="js">this.$refs.usernameInput.focus()</code></pre><p>当 <code>ref</code> 和 <code>v-for</code> 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。</p><p><code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 <code>$refs</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-自定义事件$emit</title>
      <link href="/2022/08/25/15%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%20$emit/"/>
      <url>/2022/08/25/15%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%20$emit/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><h2 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h2><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p><pre><code class="js">this.$emit(&#39;myEvent&#39;)</code></pre><p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p><pre><code class="js">&lt;!-- 没有效果 --&gt;&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></pre><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p><p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p><h2 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的<code>v-model</code></h2><blockquote><p>2.2.0+ 新增</p></blockquote><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p><pre><code class="js">Vue.component(&#39;base-checkbox&#39;, &#123;  model: &#123;    prop: &#39;checked&#39;,    event: &#39;change&#39;  &#125;,  props: &#123;    checked: Boolean  &#125;,  template: `    &lt;input      type=&quot;checkbox&quot;      v-bind:checked=&quot;checked&quot;      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;    &gt;  `&#125;)</code></pre><p>现在在这个组件上使用 <code>v-model</code> 的时候：</p><pre><code class="html">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</code></pre><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>base-checkbox</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的属性将会被更新。</p><p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-prop</title>
      <link href="/2022/08/25/14%20prop/"/>
      <url>/2022/08/25/14%20prop/</url>
      
        <content type="html"><![CDATA[<h1 id="1prop"><a href="#1prop" class="headerlink" title="1prop"></a>1prop</h1><h2 id="prop的大小写"><a href="#prop的大小写" class="headerlink" title="prop的大小写"></a>prop的大小写</h2><blockquote><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p></blockquote><pre><code class="js">Vue.component(&#123;&#39;navbar&#39;&#125;,&#123;    template:`&lt;div&gt;&#123;&#123;my-name&#125;&#125;&lt;/div&gt;`,    props:[&#39;my-name&#39;]&#125;)</code></pre><pre><code class="html">&lt;navbar my-name=&#39;hello&#39;&gt;&lt;/navbar&gt;</code></pre><h2 id="prop类型"><a href="#prop类型" class="headerlink" title="prop类型"></a>prop类型</h2><h3 id="字符串数组形式"><a href="#字符串数组形式" class="headerlink" title="字符串数组形式"></a>字符串数组形式</h3><pre><code class="js">props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]</code></pre><h3 id="对象形式"><a href="#对象形式" class="headerlink" title="对象形式"></a>对象形式</h3><p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的<code>名称</code>和<code>类型</code>：</p><pre><code class="js">props: &#123;  title: String,  likes: Number,  isPublished: Boolean,  commentIds: Array,  author: Object,  callback: Function,  contactsPromise: Promise // or any other constructor&#125;</code></pre><p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">类型检查和其它 prop 验证</a>。</p><h2 id="传递静态或动态prop"><a href="#传递静态或动态prop" class="headerlink" title="传递静态或动态prop"></a>传递静态或动态prop</h2><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>可以像这样给 prop 传入一个静态的值，即传入了一个’hello’的字符串</p><pre><code class="js">Vue.component(&#39;navbar&#39;,&#123;    template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,    props:[&#39;myname&#39;]&#125;)</code></pre><pre><code class="html">&lt;navbar myname=&#39;hello&#39;&gt;&lt;/navbar&gt;</code></pre><h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><h4 id="传入一个布尔值"><a href="#传入一个布尔值" class="headerlink" title="传入一个布尔值"></a>传入一个布尔值</h4><pre><code class="js">Vue.component(&#39;navbar&#39;,&#123;    template:`&lt;div v-if=&#39;isshow&#39;&gt;动态显示和隐藏&lt;/div&gt;`,    props:&#123;        isshow:Boolean    &#125;&#125;)</code></pre><pre><code class="html">&lt;navbar :isshow=&#39;false&#39;&gt;&lt;/navbar&gt; //传入的是一个false布尔值</code></pre><h4 id="传入一个状态"><a href="#传入一个状态" class="headerlink" title="传入一个状态"></a>传入一个状态</h4><pre><code class="js">Vue.component(&#39;navar&#39;,&#123;    template:`&lt;div v-if=&#39;data&#39;&gt;动态传入状态&lt;/div&gt;`,    props:&#123;        data:Boolean    &#125;&#125;)new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        isshow:false    &#125;&#125;)</code></pre><pre><code class="js">&lt;button @click=&#39;isshow=!isshow&#39;&gt;click&lt;/button&gt;&lt;navbar :data=&#39;isshow&#39;&gt;&lt;/navbar&gt; //通过data属性传入一个父组件中一个叫isshow的状态</code></pre><h4 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="传入一个数字"></a>传入一个数字</h4><pre><code class="js">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;</code></pre><h4 id="传入一个对象"><a href="#传入一个对象" class="headerlink" title="传入一个对象"></a>传入一个对象</h4><pre><code class="js">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post  v-bind:author=&quot;&#123;    name: &#39;Veronica&#39;,    company: &#39;Veridian Dynamics&#39;  &#125;&quot;&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt;</code></pre><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>这里有两种常见的试图改变一个 prop 的情形：</p><ol><li><p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p><pre><code class="js">props: [&#39;initialCounter&#39;],data: function () &#123;  return &#123;    counter: this.initialCounter  &#125;&#125;</code></pre></li><li><p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><pre><code class="js">props: [&#39;size&#39;],computed: &#123;  normalizedSize: function () &#123;    return this.size.trim().toLowerCase()  &#125;&#125;</code></pre></li></ol><p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p><h2 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>这里有两种常见的试图改变一个 prop 的情形：</p><ol><li><p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p><pre><code>props: [&#39;initialCounter&#39;],data: function () &#123;  return &#123;    counter: this.initialCounter  &#125;&#125;</code></pre></li><li><p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><pre><code>props: [&#39;size&#39;],computed: &#123;  normalizedSize: function () &#123;    return this.size.trim().toLowerCase()  &#125;&#125;</code></pre></li></ol><p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p><h2 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h2><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p><p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p><pre><code class="js">Vue.component(&#39;my-component&#39;, &#123;  props: &#123;    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)    propA: Number,    // 多个可能的类型    propB: [String, Number],    // 必填的字符串    propC: &#123;      type: String,      required: true    &#125;,    // 带有默认值的数字    propD: &#123;      type: Number,      default: 100    &#125;,    // 带有默认值的对象    propE: &#123;      type: Object,      // 对象或数组默认值必须从一个工厂函数获取      default: function () &#123;        return &#123; message: &#39;hello&#39; &#125;      &#125;    &#125;,    // 自定义验证函数    propF: &#123;      validator: function (value) &#123;        // 这个值必须匹配下列字符串中的一个        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1      &#125;    &#125;  &#125;&#125;)</code></pre><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p><p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的属性 (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>json server  mock本地服务器</title>
      <link href="/2022/08/25/13%20json-server/"/>
      <url>/2022/08/25/13%20json-server/</url>
      
        <content type="html"><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json server"></a>json server</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Install JSON Server</p><pre><code>npm install -g json-server</code></pre><h2 id="创建json"><a href="#创建json" class="headerlink" title="创建json"></a>创建json</h2><p>Create a <code>db.json</code> file with some data</p><pre><code>&#123;  &quot;posts&quot;: [    &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;  ],  &quot;comments&quot;: [    &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;  ],  &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125;</code></pre><h2 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h2><p>Start JSON Server</p><pre><code>json-server --watch db.json --port 8080</code></pre><h2 id="配合axios"><a href="#配合axios" class="headerlink" title="配合axios"></a>配合axios</h2><pre><code class="js">axios(&#123;    url:&#39;http://localhost:8080/users&#39;,    methods:&#39;xxx&#39;,    data:&#123;        xxx:&#39;xxx&#39;    &#125;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-组件注册</title>
      <link href="/2022/08/25/13%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
      <url>/2022/08/25/13%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><h2 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h2><p>在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：</p><pre><code class="js">Vue.component(&#39;navbar&#39;, &#123; /* ... */ &#125;)</code></pre><p>该组件名就是 <code>Vue.component</code> 的第一个参数。</p><p>你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>) 的时候，我们强烈推荐遵循 <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">W3C 规范</a>中的自定义组件名 (<strong>字母全小写且必须包含一个连字符</strong>)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p><h3 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h3><p>定义组件名的方式有两种：</p><h4 id="使用-kebab-case"><a href="#使用-kebab-case" class="headerlink" title="使用 kebab-case"></a>使用 kebab-case</h4><pre><code class="js">Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)</code></pre><p>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 ``。</p><h4 id="使用-PascalCase"><a href="#使用-PascalCase" class="headerlink" title="使用 PascalCase"></a>使用 PascalCase</h4><pre><code class="js">Vue.component(&#39;MyComponentName&#39;, &#123; /* ... */ &#125;)</code></pre><p>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>和</code> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。</p><h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>到目前为止，我们只用过 <code>Vue.component</code> 来创建组件：</p><pre><code class="js">Vue.component(&#39;my-component-name&#39;, &#123;  // ... 选项 ...&#125;)</code></pre><p>这些组件是<strong>全局注册的</strong>。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中。比如：</p><pre><code class="js">Vue.component(&#39;component-a&#39;, &#123; /* ... */ &#125;)Vue.component(&#39;component-b&#39;, &#123; /* ... */ &#125;)Vue.component(&#39;component-c&#39;, &#123; /* ... */ &#125;)new Vue(&#123; el: &#39;#app&#39; &#125;)&lt;div id=&quot;app&quot;&gt;  &lt;component-a&gt;&lt;/component-a&gt;  &lt;component-b&gt;&lt;/component-b&gt;  &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt;</code></pre><p>在所有子组件中也是如此，也就是说这三个组件<em>在各自内部</em>也都可以相互使用。</p><h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p><p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：</p><pre><code class="js">var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; /* ... */ &#125;var ComponentC = &#123; /* ... */ &#125;</code></pre><p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p><pre><code class="js">new Vue(&#123;  el: &#39;#app&#39;,  components: &#123;    &#39;component-a&#39;: ComponentA,    &#39;component-b&#39;: ComponentB  &#125;&#125;)</code></pre><p>对于 <code>components</code> 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。</p><p>注意**局部注册的组件在其子组件中*不可用***。例如，如果你希望 <code>ComponentA</code> 在 <code>ComponentB</code> 中可用，则你需要这样写：</p><pre><code class="js">var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123;  components: &#123;    &#39;component-a&#39;: ComponentA  &#125;,  // ...&#125;</code></pre><p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p><pre><code class="js">import ComponentA from &#39;./ComponentA.vue&#39;export default &#123;  components: &#123;    ComponentA  &#125;,  // ...&#125;</code></pre><p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p><ul><li>用在模板中的自定义元素的名称</li><li>包含了这个组件选项的变量名</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-组件介绍</title>
      <link href="/2022/08/25/12%20%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/08/25/12%20%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><h2 id="虚拟dom、diff算法、key的作用"><a href="#虚拟dom、diff算法、key的作用" class="headerlink" title="虚拟dom、diff算法、key的作用"></a>虚拟dom、diff算法、key的作用</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190225916.png" alt="image-20200214190225916"></p><ol><li><p>把虚拟DOM树按照层级分解</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190256593.png" alt="image-20200214190256593"></p></li><li><p>同key值进行对比</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190317166.png" alt="image-20200214190317166"></p></li><li><p>同组件对比</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200214190333630.png" alt="image-20200214190333630"></p></li></ol><h2 id="组件化的意义"><a href="#组件化的意义" class="headerlink" title="组件化的意义"></a>组件化的意义</h2><p>扩展 HTML 元素，封装可重用的代码</p><h2 id="组件注册方式"><a href="#组件注册方式" class="headerlink" title="组件注册方式"></a>组件注册方式</h2><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><blockquote><p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p></blockquote><p>这里有一个 Vue 组件的示例：</p><pre><code class="js">Vue.components(&#39;navbar&#39;,&#123;    template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,//html结构       data()&#123;        return &#123;            myname:&#39;retr0&#39;        &#125;    &#125;&#125;)</code></pre><p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>navbar</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><pre><code class="html">&lt;div id=&quot;box&quot;&gt;    &lt;navbar&gt;&lt;/navbar&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123; el: &#39;#box&#39; &#125;)</code></pre><p>因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>这里有一个局部Vue组件的实例：</p><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    components:&#123;        child1:&#123;            template:`&lt;div&gt;&#123;&#123;myname&#125;&#125;&lt;/div&gt;`,            data()&#123;                return &#123;                    myname:&#39;retr0Child&#39;                &#125;            &#125;        &#125;    &#125;&#125;)</code></pre><h2 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h2><p>当我们定义这个 <code>navbar</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象：</p><pre><code class="js">data: &#123;    myname:&#39;retr0&#39;&#125;</code></pre><p>取而代之的是，<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝：</p><pre><code class="js">data()&#123;    return &#123;        myname:&#39;retr0&#39;    &#125;&#125;</code></pre><p>如果 Vue 没有这条规则，点击一个按钮就可能会像如下代码一样影响到<em>其它所有实例</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-11-1高频前端面试题汇总之Vue篇</title>
      <link href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/"/>
      <url>/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a44f18af182434d901b74df18491dea~tplv-k3u1fbpfcp-watermark.awebp" alt="Vue面试题.png"></p><h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b16025a35b4cd2b343a92e740621b7~tplv-k3u1fbpfcp-watermark.awebp" alt="0_tB3MJCzh_cB6i3mS-1.png"></p><h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286bdc076ae425fb9591bb8c4153240~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p><h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65e1b9145894647a25788caf12ddd26~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><p>（2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View代表UI视图，负责数据的展示；</li><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p><p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ce15b7b704483eb91ee1f5d1d64786~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><p><strong>对于Watch：</strong></p><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><p><strong>总结：</strong></p><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li><li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li></ul><p><strong>运用场景：</strong></p><ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p><p><strong>不同点：</strong></p><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><li>method 调用总会执行该函数。</li></ul><h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p><p><strong>使用场景：</strong></p><ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li><li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li></ul><p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式 *<em><code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code>*</em> 表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p><p>例如，在显示金额，给商品价格添加单位：</p><pre><code class="javascript">&lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;/li&gt; filters: &#123;    filterPrice (price) &#123;      return price ? (&#39;￥&#39; + price) : &#39;--&#39;    &#125;  &#125;复制代码</code></pre><h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p>那么可以按照这两种情况分别得到以下方法：</p><p><strong>组件会被卸载：</strong></p><p><strong>（1）将状态存储在LocalStorage / SessionStorage</strong></p><p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p><p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p><p><strong>优点：</strong></p><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><p><strong>缺点：</strong></p><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p><p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p><p><strong>优点：</strong></p><ul><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li></ul><p><strong>缺点：</strong></p><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><p><strong>组件不会被卸载：</strong></p><p><strong>（1）单页面渲染</strong></p><p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p><p><strong>优点：</strong></p><ul><li>代码量少</li><li>不需要考虑状态传递过程中的错误</li></ul><p><strong>缺点：</strong></p><ul><li>增加 A 组件维护成本</li><li>需要传入额外的 prop 到 B 组件</li><li>无法利用路由定位页面</li></ul><p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p><pre><code class="javascript">&lt;keep-alive&gt;    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/kepp-alive&gt;复制代码</code></pre><p><strong>router.js</strong></p><pre><code class="javascript">&#123;  path: &#39;/&#39;,  name: &#39;xxx&#39;,  component: ()=&gt;import(&#39;../src/views/xxx.vue&#39;),  meta:&#123;    keepAlive: true // 需要被缓存  &#125;&#125;,复制代码</code></pre><h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul><li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li><li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li><li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li><li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li><li><code>.once</code> ：只会触发一次。</li></ul><h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li><li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li></ul><h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul><li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li><li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li><li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li><li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li><li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul><h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p><pre><code class="javascript">&lt;input v-model=&quot;sth&quot; /&gt;//  等同于&lt;input     v-bind:value=&quot;message&quot;     v-on:input=&quot;message=$event.target.value&quot;&gt;//$event 指代当前触发的事件对象;//$event.target 指代当前触发的事件对象的dom;//$event.target.value 就是当前dom的value值;//在@input方法中，value =&gt; sth;//在:value中,sth =&gt; value;复制代码</code></pre><p><strong>（2）作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p><p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p><pre><code class="javascript">&lt;child :value=&quot;message&quot;  @input=&quot;function(e)&#123;message = e&#125;&quot;&gt;&lt;/child&gt;复制代码</code></pre><p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p><pre><code class="javascript">// 父组件&lt;aa-input v-model=&quot;aa&quot;&gt;&lt;/aa-input&gt;// 等价于&lt;aa-input v-bind:value=&quot;aa&quot; v-on:input=&quot;aa=$event.target.value&quot;&gt;&lt;/aa-input&gt;// 子组件：&lt;input v-bind:value=&quot;aa&quot; v-on:input=&quot;onmessage&quot;&gt;&lt;/aa-input&gt;props:&#123;value:aa,&#125;methods:&#123;    onmessage(e)&#123;        $emit(&#39;input&#39;,e.target.value)    &#125;&#125;复制代码</code></pre><p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p><h3 id="15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p><pre><code class="javascript">&lt;input v-model=&quot;searchText&quot;&gt;复制代码</code></pre><p>实际上相当于：</p><pre><code class="javascript">&lt;input  v-bind:value=&quot;searchText&quot;  v-on:input=&quot;searchText = $event.target.value&quot;&gt;复制代码</code></pre><p>用在自定义组件上也是同理：</p><pre><code class="javascript">&lt;custom-input v-model=&quot;searchText&quot;&gt;复制代码</code></pre><p>相当于：</p><pre><code class="javascript">&lt;custom-input  v-bind:value=&quot;searchText&quot;  v-on:input=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt;复制代码</code></pre><p>显然，custom-input 与父组件的交互如下：</p><ol><li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li><li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li></ol><p>所以，custom-input 组件的实现应该类似于这样：</p><pre><code class="javascript">Vue.component(&#39;custom-input&#39;, &#123;  props: [&#39;value&#39;],  template: `    &lt;input      v-bind:value=&quot;value&quot;      v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;    &gt;  `&#125;)复制代码</code></pre><h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p><p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p><h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p><strong>（1）keep-alive</strong></p><p>keep-alive有以下三个属性：</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p><p><strong>主要流程</strong></p><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><p><strong>（2）keep-alive 的实现</strong></p><pre><code class="javascript">const patternTypes: Array&lt;Function&gt; = [String, RegExp, Array] // 接收：字符串，正则，数组export default &#123;  name: &#39;keep-alive&#39;,  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。  props: &#123;    include: patternTypes, // 匹配的组件，缓存    exclude: patternTypes, // 不去匹配的组件，不缓存    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限  &#125;,  created() &#123;    // 用于初始化缓存虚拟DOM数组和vnode的key    this.cache = Object.create(null)    this.keys = []  &#125;,  destroyed() &#123;    // 销毁缓存cache的组件实例    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys)    &#125;  &#125;,  mounted() &#123;    // prune 削减精简[v.]    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容    this.$watch(&#39;include&#39;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; matches(val, name))    &#125;)    this.$watch(&#39;exclude&#39;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; !matches(val, name))    &#125;)  &#125;,&#125;复制代码</code></pre><p><strong>render函数：</strong></p><ol><li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li><li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li><li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li></ol><pre><code class="javascript">render () &#123;  //  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;    if (Array.isArray(children)) &#123;  for (let i = 0; i &lt; children.length; i++) &#123;    const c = children[i]    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;      return c    &#125;  &#125;  &#125;  &#125;  const slot = this.$slots.default // 获取默认插槽  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件  const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // 组件参数  if (componentOptions) &#123; // 是否有组件参数    // check pattern    const name: ?string = getComponentName(componentOptions) // 获取组件名    const &#123; include, exclude &#125; = this    if (      // not included      (include &amp;&amp; (!name || !matches(include, name))) ||      // excluded      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))    ) &#123;      // 如果不匹配当前组件的名字和include以及exclude      // 那么直接返回组件的实例      return vnode    &#125;    const &#123; cache, keys &#125; = this    // 获取这个组件的key    const key: ?string = vnode.key == null      // same constructor may get registered as different local components      // so cid alone is not enough (#3269)      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#39;&#39;)      : vnode.key    if (cache[key]) &#123;      // LRU缓存策略执行      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined      // make current key freshest      remove(keys, key)      keys.push(key)      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面    &#125; else &#123;      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除      // 使用时间间隔最长的一个      cache[key] = vnode      keys.push(key)      // prune oldest entry      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;        pruneCacheEntry(cache, keys[0], keys, this._vnode)      &#125;    &#125;    // 将组件的keepAlive属性设置为true    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数  &#125;  return vnode || (slot &amp;&amp; slot[0])&#125;复制代码</code></pre><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p><p><strong>实现步骤：</strong></p><ol><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li><li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li><li>需要缓存，判断他当前是否在缓存数组里面：</li></ol><ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li><li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li></ul><ol><li>最后将这个组件的 keepAlive 设置为 true</li></ol><p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p><p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p><p><strong>首次渲染</strong></p><ul><li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li></ul><pre><code class="javascript">// core/instance/lifecyclefunction initLifecycle (vm: Component) &#123;  const options = vm.$options  // locate first non-abstract parent  let parent = options.parent  if (parent &amp;&amp; !options.abstract) &#123; // 判断组件的abstract属性，才往父组件里面挂载DOM    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;      parent = parent.$parent    &#125;    parent.$children.push(vm)  &#125;  vm.$parent = parent  vm.$root = parent ? parent.$root : vm  vm.$children = []  vm.$refs = &#123;&#125;  vm._watcher = null  vm._inactive = null  vm._directInactive = false  vm._isMounted = false  vm._isDestroyed = false  vm._isBeingDestroyed = false&#125;复制代码</code></pre><ul><li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li></ul><pre><code class="javascript">// core/vdom/create-componentinit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;    if (      vnode.componentInstance &amp;&amp;      !vnode.componentInstance._isDestroyed &amp;&amp;      vnode.data.keepAlive    ) &#123; // componentInstance在初次是undefined!!!      // kept-alive components, treat as a patch      const mountedNode: any = vnode // work around flow      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程    &#125; else &#123;      const child = vnode.componentInstance = createComponentInstanceForVnode(        vnode,        activeInstance      )      child.$mount(hydrating ? vnode.elm : undefined, hydrating)    &#125;  &#125;,复制代码</code></pre><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p><p><strong>（4）LRU （least recently used）缓存策略</strong></p><p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 **”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p><ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul><h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p><p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p><pre><code class="javascript">this.$nextTick(() =&gt; &#123;    // 获取数据的操作...&#125;)复制代码</code></pre><p>所以，在以下情况下，会用到nextTick：</p><ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li></ul><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p><h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;      &lt;ul&gt;         &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt;       &lt;/ul&gt;       &lt;button @click=&quot;addObjB&quot;&gt;添加 obj.b&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data () &#123;           return &#123;               obj: &#123;                   a: &#39;obj.a&#39;               &#125;           &#125;        &#125;,       methods: &#123;           addObjB () &#123;               this.obj.b = &#39;obj.b&#39;               console.log(this.obj)           &#125;       &#125;   &#125;&lt;/script&gt;复制代码</code></pre><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p><pre><code class="javascript">addObjB () (   this.$set(this.obj, &#39;b&#39;, &#39;obj.b&#39;)   console.log(this.obj)&#125;复制代码</code></pre><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p><h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be20296a76f4e7085dfb510a3211d16~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"> 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p><pre><code class="javascript">// 缓存数组原型const arrayProto = Array.prototype;// 实现 arrayMethods.__proto__ === Array.prototypeexport const arrayMethods = Object.create(arrayProto);// 需要进行功能拓展的方法const methodsToPatch = [  &quot;push&quot;,  &quot;pop&quot;,  &quot;shift&quot;,  &quot;unshift&quot;,  &quot;splice&quot;,  &quot;sort&quot;,  &quot;reverse&quot;];/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function(method) &#123;  // 缓存原生数组方法  const original = arrayProto[method];  def(arrayMethods, method, function mutator(...args) &#123;    // 执行并缓存原生数组功能    const result = original.apply(this, args);    // 响应式处理    const ob = this.__ob__;    let inserted;    switch (method) &#123;    // push、unshift会新增索引，所以要手动observer      case &quot;push&quot;:      case &quot;unshift&quot;:        inserted = args;        break;      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。      case &quot;splice&quot;:        inserted = args.slice(2);        break;    &#125;    //     if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听    // notify change    ob.dep.notify();// 通知依赖更新    // 返回原生数组方法的执行结果    return result;  &#125;);&#125;);复制代码</code></pre><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p><h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p><ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li><li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul><p><strong>区别：</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3d747986e45e096abaf64faf5e332~tplv-k3u1fbpfcp-watermark.awebp" alt="775316ebb4c727f7c8771cc2c06e06dd.jpg"></p><h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p><p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p><pre><code class="javascript">// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)复制代码</code></pre><p>CompileToFunctions中的主要逻辑如下∶ <strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p><pre><code class="javascript">constast = parse(template.trim(), options)复制代码</code></pre><ul><li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li><li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul><p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p><p><strong>（2）对静态节点做优化</strong></p><pre><code class="javascript">optimize(ast,options)复制代码</code></pre><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p><p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p><p><strong>（3）生成代码</strong></p><pre><code class="javascript">const code = generate(ast, options)复制代码</code></pre><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p><h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p><h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7df745017242a7beaba81e854a0f97~tplv-k3u1fbpfcp-watermark.awebp" alt="bb253b1d177f421741af0e7dd0f52b5e.jpg"> <strong>（2）mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><pre><code class="javascript">if(!child._base) &#123;    if(child.extends) &#123;        parent = mergeOptions(parent, child.extends, vm)    &#125;    if(child.mixins) &#123;        for(let i = 0, l = child.mixins.length; i &lt; l; i++)&#123;            parent = mergeOptions(parent, child.mixins[i], vm)        &#125;    &#125;&#125;复制代码</code></pre><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h3 id="25-描述下Vue自定义指令"><a href="#25-描述下Vue自定义指令" class="headerlink" title="25. 描述下Vue自定义指令"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p><p><strong>（1）自定义指令基本内容</strong></p><ul><li><p>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p></li><li><p>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p></li><li><p>钩子函数：指令定义对象提供钩子函数</p><p>o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p><p>o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p><p>o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p><p>o unbind：只调用一次，指令与元素解绑时调用。</p></li><li><p>钩子函数参数 o el：绑定元素</p><p>o bing： 指令核心对象，描述指令全部信息属性</p><p>o name</p><p>o value</p><p>o oldValue</p><p>o expression</p><p>o arg</p><p>o modifers</p><p>o vnode  虚拟节点</p><p>o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p></li></ul><p><strong>（2）使用场景</strong></p><ul><li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li><li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li></ul><p><strong>（3）使用案例</strong></p><p>初级应用：</p><ul><li>鼠标聚焦</li><li>下拉菜单</li><li>相对时间转换</li><li>滚动动画</li></ul><p>高级应用：</p><ul><li>自定义指令实现图片懒加载</li><li>自定义指令集成第三方插件</li></ul><h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p><strong>只能通过 *<em><code>$emit</code>*</em> 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p><h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p><pre><code class="javascript">function defieneReactive (obj, key, val)&#123;  const dep = new Dep();  ...  Object.defineProperty(obj, key, &#123;    ...    get: function reactiveGetter () &#123;      if(Dep.target)&#123;        dep.depend();        ...      &#125;      return val    &#125;    ...  &#125;)&#125;复制代码</code></pre><p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 <strong>（1）Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p><pre><code class="javascript">class Dep &#123;  static target;  subs;  constructor () &#123;    ...    this.subs = [];  &#125;  addSub (sub) &#123;    this.subs.push(sub)  &#125;  removeSub (sub) &#123;    remove(this.sub, sub)  &#125;  depend () &#123;    if(Dep.target)&#123;      Dep.target.addDep(this)    &#125;  &#125;  notify () &#123;    const subs = this.subds.slice();    for(let i = 0;i &lt; subs.length; i++)&#123;      subs[i].update()    &#125;  &#125;&#125;复制代码</code></pre><p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p><p><strong>（2）Watcher</strong></p><pre><code class="javascript">class Watcher &#123;  getter;  ...  constructor (vm, expression)&#123;    ...    this.getter = expression;    this.get();  &#125;  get () &#123;    pushTarget(this);    value = this.getter.call(vm, vm)    ...    return value  &#125;  addDep (dep)&#123;        ...    dep.addSub(this)  &#125;  ...&#125;function pushTarget (_target) &#123;  Dep.target = _target&#125;复制代码</code></pre><p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p><p><strong>（3）过程</strong></p><p>在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p><pre><code class="javascript">updateComponent = () =&gt; &#123;  vm._update(vm._render())&#125;new Watcher(vm, updateComponent)复制代码</code></pre><p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p><p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p><h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><li>都有props的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p><p><strong>2）虚拟DOM</strong></p><p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p><ul><li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React与Vue最大的不同是模板的编写。</p><ul><li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li><li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li></ul><p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 <strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p><p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具：</p><ul><li>React ==&gt; Create React APP</li><li>Vue ==&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React ==&gt; React Native</li><li>Vue ==&gt; Weex</li></ul><h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li><li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li><li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li></ul><h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p><p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul><h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul><pre><code class="javascript">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象复制代码</code></pre><ul><li>调用以下几个数组的方法</li></ul><pre><code class="javascript">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()复制代码</code></pre><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p><p>vm.<code>$set</code> 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><ul><li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li></ul><h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p><p>SSR的优势：</p><ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul><p>SSR的缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li><li>更多的服务端负载。</li></ul><h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p><strong>（2）SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>（3）打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p><strong>（4）用户体验</strong></p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p><p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码：</p><pre><code class="javascript">[v-cloak] &#123;    display: none;&#125;复制代码</code></pre><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p><h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><pre><code class="javascript">// 创建组件构造器let Component = Vue.extend(&#123;  template: &#39;&lt;div&gt;test&lt;/div&gt;&#39;&#125;)// 挂载到 #app 上new Component().$mount(&#39;#app&#39;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123;    created() &#123;        console.log(1)    &#125;&#125;)new SuperComponent().$mount(&#39;#app&#39;)复制代码</code></pre><h3 id="41-mixin-和-mixins-区别"><a href="#41-mixin-和-mixins-区别" class="headerlink" title="41. mixin 和 mixins 区别"></a>41. mixin 和 mixins 区别</h3><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><pre><code class="javascript">Vue.mixin(&#123;    beforeCreate() &#123;        // ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    &#125;&#125;)复制代码</code></pre><p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p><p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p><h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点?"></a>42. <strong>MVVM</strong>的优缺点?</h3><p>优点:</p><ul><li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li><li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li><li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li></ul><p>缺点:</p><ul><li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li><li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li><li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li></ul><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p><ol><li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li><li><strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li><li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li><li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li><li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li><li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p><h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol><p><strong>更新过程：</strong></p><ol><li>父组件 beforeUpdate</li><li>子组件 beforeUpdate</li><li>子组件 updated</li><li>父组件 updated</li></ol><p><strong>销毁过程：</strong></p><ol><li>父组件 beforeDestroy</li><li>子组件 beforeDestroy</li><li>子组件 destroyed</li><li>父组件 destoryed</li></ol><h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 </p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li></ul><h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p><h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p><h3 id="（1）-props-emit"><a href="#（1）-props-emit" class="headerlink" title="（1） props  /  $emit"></a>（1） props  /  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul><pre><code class="javascript">// 父组件&lt;template&gt;    &lt;div id=&quot;father&quot;&gt;        &lt;son :msg=&quot;msgData&quot; :fn=&quot;myFunction&quot;&gt;&lt;/son&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import son from &quot;./son.vue&quot;;export default &#123;    name: father,    data() &#123;        msgData: &quot;父组件数据&quot;;    &#125;,    methods: &#123;        myFunction() &#123;            console.log(&quot;vue&quot;);        &#125;    &#125;,    components: &#123;        son    &#125;&#125;;&lt;/script&gt;复制代码// 子组件&lt;template&gt;    &lt;div id=&quot;son&quot;&gt;        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &quot;son&quot;,    props: [&quot;msg&quot;, &quot;fn&quot;]&#125;;&lt;/script&gt;复制代码</code></pre><h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul><pre><code class="javascript">// 父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt;    &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import comArticle from &#39;./test/article.vue&#39;export default &#123;  name: &#39;comArticle&#39;,  components: &#123; comArticle &#125;,  data() &#123;    return &#123;      currentIndex: -1,      articleList: [&#39;红楼梦&#39;, &#39;西游记&#39;, &#39;三国演义&#39;]    &#125;  &#125;,  methods: &#123;    onEmitIndex(idx) &#123;      this.currentIndex = idx    &#125;  &#125;&#125;&lt;/script&gt;复制代码//子组件&lt;template&gt;  &lt;div&gt;    &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#39;articles&#39;],  methods: &#123;    emitIndex(index) &#123;      this.$emit(&#39;onEmitIndex&#39;, index) // 触发父组件的方法，并传递参数index    &#125;  &#125;&#125;&lt;/script&gt;复制代码</code></pre><h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit / $on）"></a>（2）eventBus事件总线（<code>$emit / $on</code>）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下： <strong>（1）创建事件中心管理组件之间的通信</strong></p><pre><code class="javascript">// event-bus.jsimport Vue from &#39;vue&#39;export const EventBus = new Vue()复制代码</code></pre><p><strong>（2）发送事件</strong> 假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p><pre><code class="javascript">&lt;template&gt;  &lt;div&gt;    &lt;first-com&gt;&lt;/first-com&gt;    &lt;second-com&gt;&lt;/second-com&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import firstCom from &#39;./firstCom.vue&#39;import secondCom from &#39;./secondCom.vue&#39;export default &#123;  components: &#123; firstCom, secondCom &#125;&#125;&lt;/script&gt;复制代码</code></pre><p>在<code>firstCom</code>组件中发送事件：</p><pre><code class="javascript">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;add&quot;&gt;加法&lt;/button&gt;      &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;EventBus&#125; from &#39;./event-bus.js&#39; // 引入事件中心export default &#123;  data()&#123;    return&#123;      num:0    &#125;  &#125;,  methods:&#123;    add()&#123;      EventBus.$emit(&#39;addition&#39;, &#123;        num:this.num++      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;复制代码</code></pre><p><strong>（3）接收事件</strong> 在<code>secondCom</code>组件中发送事件：</p><pre><code class="javascript">&lt;template&gt;  &lt;div&gt;求和: &#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; EventBus &#125; from &#39;./event-bus.js&#39;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  mounted() &#123;    EventBus.$on(&#39;addition&#39;, param =&gt; &#123;      this.count = this.count + param.num;    &#125;)  &#125;&#125;&lt;/script&gt;复制代码</code></pre><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p><p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="（3）依赖注入（provide-inject）"><a href="#（3）依赖注入（provide-inject）" class="headerlink" title="（3）依赖注入（provide / inject）"></a>（3）依赖注入（provide / inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p><p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p><ul><li><code>provide</code> 钩子用来发送数据或方法</li><li><code>inject</code>钩子用来接收数据或方法</li></ul><p>在父组件中：</p><pre><code class="javascript">provide() &#123;     return &#123;             num: this.num      &#125;;&#125;复制代码</code></pre><p>在子组件中：</p><pre><code class="javascript">inject: [&#39;num&#39;]复制代码</code></pre><p>还可以这样写，这样写就可以访问父组件中的所有属性：</p><pre><code class="javascript">provide() &#123; return &#123;    app: this  &#125;;&#125;data() &#123; return &#123;    num: 1  &#125;;&#125;inject: [&#39;app&#39;]console.log(this.app.num)复制代码</code></pre><p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p><h3 id="（3）ref-refs"><a href="#（3）ref-refs" class="headerlink" title="（3）ref / $refs"></a>（3）ref / $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><p>在子组件中：</p><pre><code class="javascript">export default &#123;  data () &#123;    return &#123;      name: &#39;JavaScript&#39;    &#125;  &#125;,  methods: &#123;    sayHello () &#123;      console.log(&#39;hello&#39;)    &#125;  &#125;&#125;复制代码</code></pre><p>在父组件中：</p><pre><code class="javascript">&lt;template&gt;  &lt;child ref=&quot;child&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt;  import child from &#39;./child.vue&#39;  export default &#123;    components: &#123; child &#125;,    mounted () &#123;      console.log(this.$refs.child.name);  // JavaScript      this.$refs.child.sayHello();  // hello    &#125;  &#125;&lt;/script&gt;复制代码</code></pre><h3 id="（4）-parent-children"><a href="#（4）-parent-children" class="headerlink" title="（4）$parent / $children"></a>（4）<code>$parent / $children</code></h3><ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul><p>在子组件中：</p><pre><code class="javascript">&lt;template&gt;  &lt;div&gt;    &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#39;Vue&#39;    &#125;  &#125;,  computed:&#123;    parentVal()&#123;      return this.$parent.msg;    &#125;  &#125;&#125;&lt;/script&gt;复制代码</code></pre><p>在父组件中：</p><pre><code class="javascript">// 父组件中&lt;template&gt;  &lt;div class=&quot;hello_world&quot;&gt;    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;    &lt;child&gt;&lt;/child&gt;    &lt;button @click=&quot;change&quot;&gt;点击改变子组件值&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &#39;./child.vue&#39;export default &#123;  components: &#123; child &#125;,  data() &#123;    return &#123;      msg: &#39;Welcome&#39;    &#125;  &#125;,  methods: &#123;    change() &#123;      // 获取到子组件      this.$children[0].message = &#39;JavaScript&#39;    &#125;  &#125;&#125;&lt;/script&gt;复制代码</code></pre><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。 <strong>需要注意：</strong></p><ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul><h3 id="（5）-attrs-listeners"><a href="#（5）-attrs-listeners" class="headerlink" title="（5）$attrs / $listeners"></a>（5）<code>$attrs / $listeners</code></h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p><p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p><p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p><p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul><p>A组件（<code>APP.vue</code>）：</p><pre><code class="javascript">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        //此处监听了两个事件，可以在B组件或者C组件中直接触发         &lt;child1 :p-child1=&quot;child1&quot; :p-child2=&quot;child2&quot; @test1=&quot;onTest1&quot; @test2=&quot;onTest2&quot;&gt;&lt;/child1&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child1 from &#39;./Child1.vue&#39;;export default &#123;    components: &#123; Child1 &#125;,    methods: &#123;        onTest1() &#123;            console.log(&#39;test1 running&#39;);        &#125;,        onTest2() &#123;            console.log(&#39;test2 running&#39;);        &#125;    &#125;&#125;;&lt;/script&gt;复制代码</code></pre><p>B组件（<code>Child1.vue</code>）：</p><pre><code class="javascript">&lt;template&gt;    &lt;div class=&quot;child-1&quot;&gt;        &lt;p&gt;props: &#123;&#123;pChild1&#125;&#125;&lt;/p&gt;        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt;        &lt;child2 v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/child2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child2 from &#39;./Child2.vue&#39;;export default &#123;    props: [&#39;pChild1&#39;],    components: &#123; Child2 &#125;,    inheritAttrs: false,    mounted() &#123;        this.$emit(&#39;test1&#39;); // 触发APP.vue中的test1方法    &#125;&#125;;&lt;/script&gt;复制代码</code></pre><p>C 组件 (<code>Child2.vue</code>)：</p><pre><code class="javascript">&lt;template&gt;    &lt;div class=&quot;child-2&quot;&gt;        &lt;p&gt;props: &#123;&#123;pChild2&#125;&#125;&lt;/p&gt;        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    props: [&#39;pChild2&#39;],    inheritAttrs: false,    mounted() &#123;        this.$emit(&#39;test2&#39;);// 触发APP.vue中的test2方法    &#125;&#125;;&lt;/script&gt;复制代码</code></pre><p>在上述代码中：</p><ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul><h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p><ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><li>通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li><li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul><p><strong>（2）兄弟组件间通信</strong></p><ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li></ul><p><strong>（3）任意组件之间</strong></p><ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li></ul><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-fetch&amp;axios</title>
      <link href="/2022/08/25/11%20fetch%E5%92%8Caxios/"/>
      <url>/2022/08/25/11%20fetch%E5%92%8Caxios/</url>
      
        <content type="html"><![CDATA[<h1 id="fetch-amp-axios"><a href="#fetch-amp-axios" class="headerlink" title="fetch&amp;axios"></a>fetch&amp;axios</h1><p>XMLHttpRequest 是一个设计粗糙的 API，配置和调用方式非常混乱 ，基于事件的异步模型写起来不友好且兼容性不好。</p><p>因此我们可以学习去使用fetch&amp;axios。</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch"><code>fetch()</code></a>方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p><p>这种功能以前是使用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 <code>Service Workers</code>。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。</p><p>请注意，<code>fetch</code>规范与<code>jQuery.ajax()</code>主要有三种方式的不同，牢记：</p><ul><li>当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code>返回的 Promise <strong>不会被标记为 reject，</strong> 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 <code>ok</code> 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li><li><code>fetch()</code> <strong>不会接受跨域 cookies；</strong>你也不能使用<code>fetch()</code> 建立起跨域会话。其他网站的<code>Set-Cookie</code>头部字段将会被无视。</li><li><code>fetch</code> <strong>不会发送 cookies</strong>。除非你使用了<em>credentials</em>的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters">初始化选项</a>。（自2017年8月25日以后，默认的credentials政策变更为<code>same-origin</code>。Firefox也在61.0b13版本中，对默认值进行修改）</li><li></li></ul><h3 id="get方式"><a href="#get方式" class="headerlink" title="get方式"></a>get方式</h3><p>一个基本的 fetch请求设置起来很简单。看看下面的代码：</p><pre><code class="js">fetch(&#39;http://example.com/movies.json&#39;).then(response=&gt;response.json()).then(function(myJson) &#123;    console.log(myJson);&#125;);</code></pre><p>这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想<code>fetch()</code>到的资源路径，然后返回一个包含响应结果的promise(一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象)。</p><p>当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body/json"><code>json()</code></a>方法（在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body"><code>Body</code></a>mixin 中定义，被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request"><code>Request</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象实现）。</p><h3 id="post方式"><a href="#post方式" class="headerlink" title="post方式"></a>post方式</h3><ol><li>form编码</li></ol><pre><code class="js">fetch(&#39;http://example.com/movies.json&#39;,&#123;    method:&#39;post&#39;,    headers:&#123;        &#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;    &#125;,    body:&#39;name=retr0&amp;age=1&#39;&#125;).then(res=&gt;res.json()).then(res=&gt;&#123;    console.log(res)&#125;)</code></pre><ol start="2"><li>json编码</li></ol><pre><code class="js">fetch(&#39;http://example.com/movies.json&#39;,&#123;    method:&#39;post&#39;,    headers:&#123;        &#39;Content-Type&#39;:&#39;application/json&#39;    &#125;,    body:JSON.stringify(&#123;        name:&#39;retr0&#39;,        age:12    &#125;)&#125;).then(res=&gt;res.json()).then(res=&gt;&#123;    console.log(res);&#125;)</code></pre><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Using npm:</p><pre><code>$ npm install axios</code></pre><p>Using bower:</p><pre><code>$ bower install axios</code></pre><p>Using yarn:</p><pre><code>$ yarn add axios</code></pre><p>Using cdn:</p><pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><pre><code class="js">axios.get(&#39;https://......&#39;).then(res=&gt;&#123;    console.log(res.data) //数据在res.data中&#125;)</code></pre><h3 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h3><ol><li>form编码</li></ol><pre><code class="js">axios.post(&#39;https://....&#39;,&#39;name=retr0&amp;age=1&#39;).then(res=&gt;&#123;    console.log(res.data)&#125;)</code></pre><ol start="2"><li>json编码</li></ol><pre><code class="js">axios.post(&#39;https://...&#39;,&#123; //第二个参数直接传对象，不需要JSON.stringify()    name:&#39;retr0&#39;,    age:1&#125;).then(res=&gt;&#123;    console.log(res.data)&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Mixins</title>
      <link href="/2022/08/25/10%20Mixins/"/>
      <url>/2022/08/25/10%20Mixins/</url>
      
        <content type="html"><![CDATA[<h1 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h1><ul><li><p><strong>类型</strong>：<code>Array</code></p></li><li><p><strong>详细</strong>：</p><p><code>mixins</code> 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 <code>Vue.extend()</code> 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。</p><p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p></li><li><p><strong>示例</strong>：</p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;box&quot;&gt;        &lt;button @click=&#39;getName&#39;&gt;click&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code class="js">// 定义一个混入对象let myMixin = &#123;    methods:&#123;        getName()&#123;            console.log(1)        &#125;    &#125;&#125;new Vue(&#123;    el:&#39;#box&#39;,    mixins:[myMixin]&#125;)</code></pre></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/mixins.html">混入</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-计算属性</title>
      <link href="/2022/08/25/09%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/08/25/09%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p><pre><code class="html">&lt;div id=&quot;example&quot;&gt;  &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt;</code></pre><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p><p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code class="html">&lt;div id=&quot;box&quot;&gt;    &#123;&#123;myname.substring(0,1).toUpperCase() + myname.substring(1)&#125;&#125;    &lt;p&gt;计算属性：&#123;&#123;getName&#125;&#125;&lt;/p&gt;    &lt;p&gt;计算属性：&#123;&#123;getName&#125;&#125;&lt;/p&gt;    &lt;p&gt;方法：&#123;&#123;getNameMethod()&#125;&#125;&lt;/p&gt;    &lt;p&gt;方法：&#123;&#123;getNameMethod()&#125;&#125;&lt;/p&gt;&lt;/div&gt;    </code></pre><pre><code class="js">var vm =  new Vue(&#123;    el:&quot;#box&quot;,    data:&#123;        myname:&quot;retr0&quot;    &#125;,    methods: &#123;        getNameMethod()&#123;            console.log(&quot;getNameMethod&quot;)            return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)        &#125;    &#125;,    computed: &#123;        getName()&#123;            console.log(&quot;getName-computed&quot;)            return this.myname.substring(0,1).toUpperCase() + this.myname.substring(1)        &#125;    &#125;,&#125;)</code></pre><h2 id="计算缓存-VS-methods"><a href="#计算缓存-VS-methods" class="headerlink" title="计算缓存 VS methods"></a>计算缓存 VS methods</h2><ol><li>计算属性是基于它们的依赖进行缓存的</li><li>计算属性只有在它的相关依赖发生改变时才会重新求值</li></ol><h2 id="get-set"><a href="#get-set" class="headerlink" title="get() set()"></a>get() set()</h2><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input type=&#39;checkbox&#39; v-model=&#39;isAllChecked&#39;&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        check:false    &#125;,    computed:&#123;        isAllChecked:&#123;            get()&#123;                //...doSomeThings                return some //必须要return            &#125;,            set(newvalue)&#123;                //doSomeThing(newValue)            &#125;        &#125;    &#125;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-表单控件绑定&amp;双向数据绑定</title>
      <link href="/2022/08/25/08%20%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A&amp;%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2022/08/25/08%20%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A&amp;%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="表单控件绑定-amp-双向数据绑定"><a href="#表单控件绑定-amp-双向数据绑定" class="headerlink" title="表单控件绑定&amp;双向数据绑定"></a>表单控件绑定&amp;双向数据绑定</h1><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h4><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input type=&#39;checkbox&#39; v-model=&#39;check&#39;&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        check:true    &#125;&#125;)</code></pre><p>通过v-model绑定了一个数组checkgroup，这样实现每个复选框被点击时，Vue会将该复选框的value值按顺序push到checkgroup中</p><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkgroup&quot; value=&quot;vue&quot;/&gt;vue    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkgroup&quot; value=&quot;react&quot;/&gt;react    &lt;input type=&quot;checkbox&quot; v-model=&quot;checkgroup&quot; value=&quot;jquery&quot;/&gt;jquery&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        checkgroup:[];    &#125;&#125;)</code></pre><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;vue&quot; name=&quot;aaa&quot;/&gt;vue    &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;react&quot;     name=&quot;aaa&quot;/&gt;react    &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;jquery&quot; name=&quot;aaa&quot;/&gt;jquery&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        picked:&quot;&quot;    &#125;&#125;)</code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><blockquote><p>取代 <code>input</code> 监听 <code>change</code> 事件</p></blockquote><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input v-model.lazy=&#39;mytext&#39;&gt;    &lt;!-- 这里的mytext不会实时修改而是在input失去焦点的时候才会修改--&gt;    &#123;&#123;mytext&#125;&#125; &lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        mytext:&#39;&#39;    &#125;&#125;)</code></pre><h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><blockquote><p>输入字符串转为有效的数字</p></blockquote><pre><code class="html">&lt;input type=&quot;number&quot; v-model.number=&quot;mynumber&quot;/&gt;&#123;&#123;mynumber&#125;&#125;</code></pre><h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><blockquote><p> 输入首尾空格过滤</p></blockquote><pre><code class="html">&lt;input type=&quot;text&quot; v-model.trim=&quot;myusername&quot;/&gt;|&#123;&#123;myusername&#125;&#125;|  </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-事件处理</title>
      <link href="/2022/08/25/07%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2022/08/25/07%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><blockquote><p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p></blockquote><p>实例：</p><pre><code class="html">&lt;div id=&quot;box&quot;&gt;  &lt;button v-on:click=&quot;counter++&quot;&gt;Add 1&lt;/button&gt;  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="js">var example1 = new Vue(&#123;    el: &#39;#box&#39;,    data: &#123;        counter: 0    &#125;&#125;)</code></pre><h2 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h2><blockquote><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 还可以接收一个需要调用的方法名称。</p></blockquote><p>实例：</p><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;button @click=&#39;fn&#39;&gt;        click    &lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">let vm = new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        name:&#39;retr0&#39;    &#125;    method:&#123;    //当@click=&#39;fn&#39;不加括号时，可以直接使用形参eve    //eve是原生 DOM 事件    //当@click=&#39;fn($event)&#39;加括号时，需要传入实参$event        fn(eve)&#123;            alert(`hello $&#123;this.name&#125;`);            if(eve)&#123;                alert(eve.target.tagName);            &#125;        &#125;    &#125;&#125;)</code></pre><h2 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h2><blockquote><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p></blockquote><pre><code class="html">&lt;div id=&quot;example-3&quot;&gt;  &lt;button v-on:click=&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;/button&gt;  &lt;button v-on:click=&quot;say(&#39;what&#39;)&quot;&gt;Say what&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el: &#39;#example-3&#39;,    methods: &#123;        say: function (message) &#123;            alert(message)        &#125;    &#125;&#125;)</code></pre><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p><pre><code class="html">&lt;button v-on:click=&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;    Submit&lt;/button&gt;</code></pre><pre><code class="js">// ...methods: &#123;    warn: function (message, event) &#123;        // 现在我们可以访问原生事件对象        if (event) &#123;            event.preventDefault()        &#125;        alert(message)    &#125;&#125;</code></pre><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><h3 id="stop"><a href="#stop" class="headerlink" title=".stop"></a>.stop</h3><pre><code class="html">&lt;!-- 阻止事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 阻止事件冒泡，没有表达式 --&gt;&lt;a v-on:click.stop&gt;&lt;/a&gt;</code></pre><h3 id="prevent"><a href="#prevent" class="headerlink" title=".prevent"></a>.prevent</h3><pre><code class="html">&lt;!-- 阻止浏览器默认行为 --&gt;&lt;div :click.prevent=&#39;fn()&#39;&gt;&lt;/div&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;div :click.prevent&gt;&lt;/div&gt;</code></pre><h3 id="self"><a href="#self" class="headerlink" title=".self"></a>.self</h3><pre><code class="html">&lt;!-- 只当事件是从侦听器绑定的元素本身触发时才触发回调 --&gt;&lt;ul @click.self=&#39;fn2()&#39;&gt;    &lt;li v-for=&#39;data in datalist&#39; @click=&#39;fn()&#39;&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="once"><a href="#once" class="headerlink" title=".once"></a>.once</h3><pre><code class="html">&lt;!-- 只触发一次回调 --&gt;&lt;div @click.once=&#39;fn&#39;&gt;&lt;/div&gt;</code></pre><p>如何不用once做到解绑事件：</p><pre><code class="html">&lt;!-- 通过状态isActive进行短路 --&gt;&lt;!-- 需要注意，这里的函数表达式必须加（） --&gt;&lt;div @click=&#39;isActive &amp;&amp; fn()&#39;&gt;解绑测试&lt;/div&gt;</code></pre><h3 id="passive"><a href="#passive" class="headerlink" title=".passive"></a>.passive</h3><p>每次事件产生，浏览器都会去查询一下是否有<code>preventDefault</code>阻止该次事件的默认动作。我们加上passive就是为了告诉浏览器，不用查询了，我们没用 preventDefault阻止默认动作。这里一般用在滚动监听，@scroll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度</p><pre><code class="html">&lt;!-- 以 &#123; passive: true &#125; 模式添加侦听器 --&gt;&lt;div @click.passive=&#39;fn&#39;&gt;&lt;/div&gt;</code></pre><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><pre><code class="html">&lt;!-- 只有在按下回车键的时才会触发该事件 --&gt;&lt;input @keyup.enter=&#39;fn()&#39;&gt;&lt;!-- 支持连缀 --&gt;&lt;input @keyup.enter.ctrl=&#39;fn()&#39;&gt;&lt;!-- 支持keyCode --&gt;&lt;input @keyup.13=&#39;fn()&#39;&gt;</code></pre><p>其实通过以下方法完成的：</p><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;input @keyup=&#39;fn1($event)&#39;&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    methods:&#123;        fn1(eve)&#123;            if(eve.keyCode == 13)&#123;                ......            &#125;        &#125;    &#125;&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-列表渲染</title>
      <link href="/2022/08/25/06%20%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
      <url>/2022/08/25/06%20%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul><li><p><strong>预期</strong>：<code>Array | Object | number | string | Iterable (2.6 新增)</code></p></li><li><p><strong>用法</strong>：</p><p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名：</p><pre><code class="html">&lt;div v-for=&quot;item in items&quot;&gt;  &#123;&#123; item.text &#125;&#125;&lt;/div&gt;</code></pre><p>另外也可以为数组索引指定别名 (或者用于对象的键)：</p><pre><code class="html">&lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, name, index) in object&quot;&gt;&lt;/div&gt;</code></pre><p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊属性 <code>key</code> 来提供一个排序提示：</p><pre><code class="html">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;  &#123;&#123; item.text &#125;&#125;&lt;/div&gt;</code></pre><p>从 2.6 起，<code>v-for</code> 也可以在实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE">可迭代协议</a>的值上使用，包括原生的 <code>Map</code> 和 <code>Set</code>。不过应该注意的是 Vue 2.x 目前并不支持可响应的 <code>Map</code> 和 <code>Set</code> 值，所以无法自动探测变更。</p><p>当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if">列表渲染教程</a></p><p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/list.html">列表渲染</a></li><li><a href="https://cn.vuejs.org/v2/guide/list.html#key">key</a></li></ul></li></ul><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ol><li><p>跟踪每个节点的身份，从而重用和重新排序现有元素</p></li><li><p>理想的 key 值是每项都有的且唯一的 id。data.id</p></li></ol><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><ol><li><p>使用以下方法操作数组，可以检测变动：</p><ul><li>push()</li><li> pop() </li><li>shift() </li><li>unshift() </li><li>splice() </li><li>sort() </li><li>reverse()</li></ul></li><li><p> 使用以下方法操作数组，无法检测到变动</p></li></ol><ul><li>filter()</li><li>concat()</li><li>slice() </li><li>map()</li><li>新数组替换旧数组</li></ul><ol start="3"><li><p>不能检测以下变动的数组</p><pre><code class="js">vm.items[indexOfItem] = newValue//是无法渲染页面的</code></pre><p>解决方案</p><ol><li><p>Vue.set(example1.items, indexOfItem, newValue)    </p></li><li><p>splice</p><pre><code class="js">vm.items.splice(indexOfItem,1,newValue)</code></pre></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-条件渲染</title>
      <link href="/2022/08/25/05%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
      <url>/2022/08/25/05%20%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><blockquote><p>动态创建和删除</p></blockquote><ul><li><p><strong>用法</strong>：</p><p>根据表达式的值的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthiness</a> 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 ` ，将提出它的内容作为条件块。</p><p>当条件变化时该指令触发过渡效果。</p><p>当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if">列表渲染教程</a></p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/conditional.html">条件渲染 - v-if</a></p></li></ul><pre><code class="html">&lt;div id=&quot;box&quot;&gt;    &lt;div v-if=&quot;datalist.length&quot;&gt;        &lt;ul&gt;            &lt;li v-for=&#39;data in datalist&#39;&gt;                &#123;&#123;data&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><ul><li><p><strong>不需要表达式</strong></p></li><li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p></li><li><p><strong>用法</strong>：</p><p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加“else 块”。</p><p><strong>可以用于购物车空空如也和有数据的状态切换</strong></p><pre><code class="html">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;    Now you see me&lt;/div&gt;&lt;div v-else&gt;    Now you don&#39;t&lt;/div&gt;</code></pre></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/conditional.html#v-else">条件渲染 - v-else</a></p></li></ul><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><blockquote><p>2.1.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>any</code></p></li><li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p></li><li><p><strong>用法</strong>：</p><p>表示 <code>v-if</code> 的 “else if 块”。可以链式调用。</p><p><strong>可以用于购物车的状态</strong></p><pre><code class="html">&lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;  A&lt;/div&gt;&lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;  B&lt;/div&gt;&lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;  C&lt;/div&gt;&lt;div v-else&gt;  Not A/B/C&lt;/div&gt;</code></pre></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/conditional.html#v-else-if">条件渲染 - v-else-if</a></p></li></ul><h2 id="template-v-if"><a href="#template-v-if" class="headerlink" title="template v-if"></a>template v-if</h2><h3 id="在元素上使用-v-if-条件渲染分组"><a href="#在元素上使用-v-if-条件渲染分组" class="headerlink" title="在元素上使用 v-if 条件渲染分组"></a><a href="https://cn.vuejs.org/v2/guide/conditional.html#%E5%9C%A8-lt-template-gt-%E5%85%83%E7%B4%A0%E4%B8%8A%E4%BD%BF%E7%94%A8-v-if-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%86%E7%BB%84">在元素上使用 <code>v-if</code> 条件渲染分组</a></h3><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>元素当做不可见的包裹元素，并在上面使用</code>v-if<code>。最终的渲染结果将不包含 </code> 元素。</p><pre><code class="html">&lt;template v-if=&quot;ok&quot;&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Paragraph 1&lt;/p&gt;    &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;</code></pre><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><ul><li><p><strong>预期</strong>：<code>any</code></p></li><li><p><strong>用法</strong>：</p><p>根据表达式之真假值，切换元素的 <code>display</code> CSS 属性。</p><p>当条件变化时该指令触发过渡效果。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/conditional.html#v-show">条件渲染 - v-show</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-class与style</title>
      <link href="/2022/08/25/04%20class%E4%B8%8Estyle/"/>
      <url>/2022/08/25/04%20class%E4%B8%8Estyle/</url>
      
        <content type="html"><![CDATA[<h1 id="class与style"><a href="#class与style" class="headerlink" title="class与style"></a>class与style</h1><h2 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;div :class=&#39;classObj&#39;&gt;动态绑定ClassName&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        classObj:&#123;            aa:1,//true则显示该class名，false则不会               bb:0,            cc:1        &#125;    &#125;&#125;)</code></pre><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;div :class=&#39;classArr&#39;&gt;动态绑定ClassName&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        classArr:[&#39;aa&#39;,&#39;cc&#39;]//数组里有的都会显示为className    &#125;&#125;)</code></pre><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;div :style=&#39;styleObj&#39;&gt;动态修改样式&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        styleObj:&#123;            backgroundColor:&#39;#14c145&#39;        &#125;        //注意，直接用this.styleObj.属性=val，是无法渲染页面的，必须要使用        // Vue.set(this.styleObj,属性,val)才可以渲染页面    &#125;&#125;)</code></pre><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><pre><code class="html">&lt;div id=&#39;box&#39;&gt;    &lt;div :class=&#39;styleArr&#39;&gt;动态修 改样式&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">new Vue(&#123;    el:&#39;#box&#39;,    data:&#123;        styleArr:[&#123;            backgroundColor:&quot;#14c145&quot;,            fontSize:&#39;12px&#39;        &#125;]//注意，往数组中push对象，可以渲染页面        //this.styleArr.push(&#123;color:&#39;red&#39;&#125;)    &#125;&#125;)</code></pre><p>#####对象方法<br>-最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）</p><pre><code>:class=&quot;&#123; &#39;active&#39;: isActive &#125;&quot;</code></pre><p>1<br>判断是否绑定一个active</p><pre><code>:class=&quot;&#123;&#39;active&#39;:isActive===-1&#125;&quot;  或者:class=&quot;&#123;&#39;active&#39;:isActive===index&#125;&quot;</code></pre><p>绑定并判断多个</p><pre><code>第一种（用逗号隔开）:class=&quot;&#123; &#39;active&#39;: isActive, &#39;sort&#39;: isSort &#125;&quot;第二种（放在data里面）//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样:class=&quot;classObject&quot;data() &#123;  return &#123;    classObject:&#123; active: true, sort:false &#125;  &#125;&#125;第三种（使用computed属性）:class=&quot;classObject&quot;data() &#123;  return &#123;    isActive: true,    isSort: false  &#125;&#125;,computed: &#123;  classObject: function () &#123;    return &#123;      active: this.isActive,      sort:this.isSort    &#125;  &#125;&#125;</code></pre><p>#####数组方法</p><pre><code>单纯数组:class=&quot;[isActive,isSort]&quot;data() &#123;  return&#123;    isActive:&#39;active&#39;,    isSort:&#39;sort&#39; &#125;&#125;</code></pre><p>数组与三元运算符结合判断选择需要的class<br>$$<br>（注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染）<br>:class=”[isActive?’active’:’’]”<br>或者<br>:class=”[isActive==1?’active’:’’]”<br>或者<br>:class=”[isActive==index?’active’:’’]”<br>或者<br>:class=”[isActive==index?’active’:’otherActiveClass’]”<br>$$<br>数组对象结合动态判断<br>//前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p><pre><code>:class=&quot;[&#123; active: isActive &#125;, &#39;sort&#39;]&quot;或者:class=&quot;[&#123; active: isActive===1 &#125;, &#39;sort&#39;]&quot;或者:class=&quot;[&#123; active: isActive===index &#125;, &#39;sort&#39;]&quot;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-什么是虚拟DOM?</title>
      <link href="/2022/08/25/03%20Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2022/08/25/03%20Vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要：</strong> 什么是虚拟DOM?</p><ul><li>作者：<a href="https://segmentfault.com/u/langlixingzhou">浪里行舟</a></li></ul><p><strong><a href="https://www.fundebug.com/">Fundebug</a>经授权转载，版权归原作者所有。</strong></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue.js 2.0引入Virtual DOM,比Vue.js 1.0的初始渲染速度提升了2-4倍，并大大降低了内存消耗。那么，什么是Virtual DOM？为什么需要Virtual DOM？它是通过什么方式去提升页面渲染效率的呢？这是本文所要探讨的问题。</p><h3 id="模板转换成视图的过程"><a href="#模板转换成视图的过程" class="headerlink" title="模板转换成视图的过程"></a>模板转换成视图的过程</h3><p>在正式介绍 Virtual Dom之前，我们有必要先了解下模板转换成视图的过程整个过程（如下图）：</p><ul><li>Vue.js通过编译将template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li><li>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行DOM操作来更新视图。</li></ul><p>简单点讲，在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上。</p><p><img src="https://image.fundebug.com/2019-06-26-01.png" alt="img"></p><p>我们先对上图几个概念加以解释:</p><ul><li><strong>渲染函数</strong>：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。</li><li><strong>VNode 虚拟节点</strong>：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成<strong>节点描述对象</strong>，它描述了应该怎样去创建真实的DOM节点。</li><li>**patch(也叫做patching算法)<strong>：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于</strong><a href="https://github.com/snabbdom/snabbdom">Snabbdom</a>**的实现，并在些基础上作了很多的调整和改进。</li></ul><h3 id="Virtual-DOM-是什么？"><a href="#Virtual-DOM-是什么？" class="headerlink" title="Virtual DOM 是什么？"></a>Virtual DOM 是什么？</h3><p>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p><p>简单来说，可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。</p><p>对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了<code>模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</code>的一个过程</p><p><img src="https://image.fundebug.com/2019-06-26-02.png" alt="img"></p><h3 id="Virtual-DOM-作用是什么？"><a href="#Virtual-DOM-作用是什么？" class="headerlink" title="Virtual DOM 作用是什么？"></a>Virtual DOM 作用是什么？</h3><p><strong>虚拟DOM的最终目标是将虚拟节点渲染到视图上</strong>。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p><p>为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无需改动的DOM。</p><p>其实虚拟DOM在Vue.js主要做了两件事：</p><ul><li>提供与真实DOM节点所对应的虚拟节点vnode</li><li>将虚拟节点vnode和旧虚拟节点oldVnode进行对比，然后更新视图</li></ul><p><strong>给大家推荐一个好用的BUG监控工具<a href="https://www.fundebug.com/?utm_source=liao">Fundebug</a>，欢迎免费试用！</strong></p><h3 id="为何需要Virtual-DOM？"><a href="#为何需要Virtual-DOM？" class="headerlink" title="为何需要Virtual DOM？"></a>为何需要Virtual DOM？</h3><ul><li>具备跨平台的优势</li></ul><p>由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><ul><li>操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。</li></ul><p>因为DOM操作的执行速度远不如Javascript的运算速度快，因此，把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。</p><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</p><ul><li>提升渲染性能</li></ul><p>Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</p><p>为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。<strong>我们通过patch 的核心—-diff 算法，找出本次DOM需要更新的节点来更新，其他的不更新</strong>。比如修改某个model 100次，从1加到100，那么有了Virtual DOM的缓存之后，只会把最后一次修改patch到view上。那diff 算法的实现过程是怎样的？</p><h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><p><img src="https://image.fundebug.com/2019-06-26-03.png" alt="img"></p><p>Vue的diff算法是基于snabbdom改造过来的，<strong>仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新</strong>。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从O(n3)变成O(n)。</p><p>diff 算法包括几个步骤：</p><ul><li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了</li></ul><p><img src="https://image.fundebug.com/2019-06-26-04.png" alt="img"></p><h3 id="diff-算法的实现过程"><a href="#diff-算法的实现过程" class="headerlink" title="diff 算法的实现过程"></a>diff 算法的实现过程</h3><p>diff 算法本身非常复杂，实现难度很大。本文去繁就简，粗略介绍以下两个核心函数实现流程：</p><ul><li>patch(container,vnode) :初次渲染的时候，将VDOM渲染成真正的DOM然后插入到容器里面。</li><li>patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。</li></ul><h4 id="1-patch-container-vnode"><a href="#1-patch-container-vnode" class="headerlink" title="1. patch(container,vnode)"></a>1. patch(container,vnode)</h4><p>通过这个函数可以让VNode渲染成真正的DOM，我们通过以下模拟代码，可以了解大致过程：</p><pre><code>function createElement(vnode) &#123;    var tag = vnode.tag  var attrs = vnode.attrs || &#123;&#125;    var children = vnode.children || []    if (!tag) &#123;        return null    &#125;    // 创建真实的 DOM 元素    var elem = document.createElement(tag)    // 属性    var attrName    for (attrName in attrs) &#123;        if (attrs.hasOwnProperty(attrName)) &#123;            // 给 elem 添加属性           elem.setAttribute(attrName, attrs[attrName])        &#125;    &#125;    // 子元素    children.forEach(function (childVnode) &#123;        // 给 elem 添加子元素，如果还有子节点，则递归的生成子节点。        elem.appendChild(createElement(childVnode))  // 递归    &#125;)    // 返回真实的 DOM 元素    return elem&#125;</code></pre><h4 id="2-patch-vnode-newVnode"><a href="#2-patch-vnode-newVnode" class="headerlink" title="2. patch(vnode,newVnode)"></a>2. patch(vnode,newVnode)</h4><p>这里我们只考虑vnode与newVnode如何对比的情况：</p><pre><code>function updateChildren(vnode, newVnode) &#123;    var children = vnode.children || []    var newChildren = newVnode.children || []  // 遍历现有的children    children.forEach(function (childVnode, index) &#123;        var newChildVnode = newChildren[index]  // 两者tag一样        if (childVnode.tag === newChildVnode.tag) &#123;            // 深层次对比，递归            updateChildren(childVnode, newChildVnode)        &#125; else &#123;   // 两者tag不一样           replaceNode(childVnode, newChildVnode)        &#125;    &#125;)&#125;</code></pre><p><strong>给大家推荐一个好用的BUG监控工具<a href="https://www.fundebug.com/?utm_source=liao">Fundebug</a>，欢迎免费试用！</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.fundebug.com/2019/06/17/handling-errors-in-vuejs/">5种处理Vue异常的方法</a></li><li><a href="https://blog.fundebug.com/2019/06/21/3-core-ideas-of-vue-component/">深入理解Vue组件3大核心概念</a></li><li><a href="https://blog.fundebug.com/2019/01/17/release-fundebug-vue/">Fundebug发布Vue插件，简化BUG监控接入代码</a></li><li><a href="https://blog.fundebug.com/2019/06/03/vue-development-tutorial/">Vue开发入门看这篇文章就够了</a></li></ul><h3 id="关于Fundebug"><a href="#关于Fundebug" class="headerlink" title="关于Fundebug"></a>关于Fundebug</h3><p><a href="https://www.fundebug.com/">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有阳光保险、核桃编程、荔枝FM、掌门1对1、微脉、青团社等众多品牌企业。欢迎大家<a href="https://www.fundebug.com/team/create">免费试用</a>！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-介绍</title>
      <link href="/2022/08/25/01%20Vue%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/08/25/01%20Vue%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue介绍"><a href="#Vue介绍" class="headerlink" title="Vue介绍"></a>Vue介绍</h1><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p>Vue (读音 /vjuː/，类似于view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h2 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h2><p>框架做分层设计，每层都可选，不同层可以灵活接入其他方案。而当你都想用官方的实现时，会发现也早已准备好，各层之间包括配套工具都能比接入其他方案更便捷地协同工作。一个个放入,放多少就做多少。</p><h2 id="MV-模式（MVC-MVP-MVVM）"><a href="#MV-模式（MVC-MVP-MVVM）" class="headerlink" title="MV*模式（MVC/MVP/MVVM）"></a>MV*模式（MVC/MVP/MVVM）</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><blockquote><p>model view controller</p></blockquote><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller会对来自View数据进行预处理、决定调用哪个Model的接口；然后由Model执行相关的业务逻辑（数据请求）；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>把业务逻辑和展示逻辑分离，模块化程度高。但由于View是强依赖特定的Model的，所以View无法组件化，无法复用</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><blockquote><p>model view presenter</p></blockquote><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，<strong>通过View提供的接口更新界面</strong>。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>View不依赖Model，View可以进行组件化。但Model-&gt;View的手动同步逻辑麻烦，维护困难</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。<strong>可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染</strong>。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="script标签引入"><a href="#script标签引入" class="headerlink" title="script标签引入"></a>script标签引入</h3><pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue cli"></a>Vue cli</h3><p>Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架</p><pre><code>npm install ‐g @vue/cli</code></pre><h2 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h2><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知watcher，从而使它关联的组件重新渲染。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><blockquote><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>Object.defineProperty(obj, prop, descriptor)</code></pre><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li><p><strong>obj</strong></p><p>要在其上定义属性的对象。</p></li><li><p><strong>prop</strong></p><p>要定义或修改的属性的名称。</p></li><li><p><strong>descriptor</strong></p><p>将被定义或修改的属性描述符。</p></li></ul><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p> 被传递给函数的对象</p><blockquote><p>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而<code>Object.defineProperty</code> 是定义<code>key</code>为Symbol的属性的方法之一。</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code class="js">let obj = &#123;&#125;;    Object.defineProperty(obj,&quot;myname&quot;,&#123;        get(data)&#123;            console.log(&quot;被访问&quot; + data);        &#125;,        set(data)&#123;            console.log(&quot;被修改&quot; + data)        &#125;    &#125;)</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Vue3 的 变化Object.defineProperty有以下缺点。</p><ol><li>无法监听es6的Set、Map 变化；</li><li>无法监听Class类型的数据；</li><li>属性的新加或者删除也无法监听；</li><li>数组元素的增加和删除也无法监听。</li></ol><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>针对Object.defineProperty的缺点，<code>ES6 Proxy</code>都能够完美得解决，它唯一的缺点就是，<code>对IE不友好</code>,所以vue3在检测到如果是使用IE的情况下（没错，IE11都不支持Proxy），会<code>自动降级</code>为<code>Object.defineProperty</code>的数据监听系统。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/24/hello-world/"/>
      <url>/2022/08/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
