<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://18821767806wxg.github.io/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将更新html5、css3知识点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="王小刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">王小刚</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">列表页</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/18821767806wxg">github仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://gitee.com/xiao_gang_wanghhh">gitee仓库</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zhihu.com/people/xiao-gang-zi-2-34">知乎</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.csdn.net/weixin_43357699?spm=1010.2135.3001.5421">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">微信支付文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vuejs.org/api/sfc-script-setup.html">Vue官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://vuex.vuejs.org/zh/">vuex官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pinia.web3doc.top/">pinia-Vue3状态管理文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://cn.vitejs.dev/guide/why.html#the-problems">Vite官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://reactjs.org/docs/hello-world.html">React官网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imagecompressor.com/zh/">在线图片压缩工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.css-js.com/tools/base64.html">在线转译base64图片工具</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">MDN-javascript文档</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.yuque.com/cuggz/interview/vgbphi">前端面试题汇总</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/page/5/">ES6</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/29/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Vue3-快速上手</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/6/">React博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/2022/08/25/11-1%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B9%8BVue%E7%AF%87/">Vue-面试题汇总之Vue篇</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/5/">Vue-vuex</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/archives/page/8/">vue博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">相识就是一种缘分欢迎进入我的博客，主要记录了学习前端的vue、react框架，es6语法，git常用指令，后期将不定期更新html5、css3知识点,------道阻且长...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王小刚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/tu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王小刚</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">列表页</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/18821767806wxg/18821767806wxg.github.io" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-gang-zi-2-34" title="zhihu">zhihu</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://www.baidu.com/?tn=02003390_25_hao_pg" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Vue3响应式的丢失场景" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/11/08/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E4%B8%A2%E5%A4%B1%E5%9C%BA%E6%99%AF/" class="article-date">
  	<time datetime="2022-11-08T03:21:07.966Z" itemprop="datePublished">2022-11-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/08/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E4%B8%A2%E5%A4%B1%E5%9C%BA%E6%99%AF/">
        Vue3-解构赋值失去响应式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>vue3</code>发布以来经历两年风头正盛，现在大有和react 平分天下的势头，我们知道他是基于proxy 实现响应式的能力， 解决了<code>vue2</code>所遗留下来的一些问题，同时也正由于proxy的特性，也提高了运行时的性能</p>
<p>凡事有利有弊， <code>proxy</code>虽然无敌，但是他也有本身的局限，从而产生一些我认为的弊端（其实就是不符合js语言的自然书写方式，有的人觉得就是个特殊写法，他不属于弊端）</p>
<ul>
<li>1、 原始值的响应式系统的实现 导致必须将他包装为一个对象， 通过 <code>.value</code> 的方式访问</li>
<li>2、 ES6 解构，不能随意使用。会破坏他的响应式特性</li>
</ul>
<p>好奇心驱使，研究琢磨了一下，为什么他会造成这两个弊端</p>
<h1 id="原始值的响应式系统的实现"><a href="#原始值的响应式系统的实现" class="headerlink" title="原始值的响应式系统的实现"></a>原始值的响应式系统的实现</h1><p>在理解原始值的响应式系统的实现，我们先来温习一下proxy 的能力！</p>
<pre><code class="js">const obj = &#123;
  name: &#39;win&#39;
&#125;

const handler = &#123;
  get: function(target, key)&#123;
    console.log(&#39;get--&#39;, key)
    return Reflect.get(...arguments)  
  &#125;,
  set: function(target, key, value)&#123;
    console.log(&#39;set--&#39;, key, &#39;=&#39;, value)
    return Reflect.set(...arguments)
  &#125;
&#125;

const data = new Proxy(obj, handler)
data.name = &#39;ten&#39;
console.log(data.name,&#39;data.name22&#39;)

复制代码
</code></pre>
<p>上述代码中，我们发现，proxy 的使用本身就是对于 对象的拦截， 通过<code>new Proxy</code>  的返回值，拦截了obj 对象</p>
<p>如此一来，当你 访问对象中的值的时候，他会触发 <code>get</code> 方法， 当你修改对象中的值的时候 他会触发 <code>set</code>方法</p>
<p>但是到了原始值的时候，他没有对象啊，咋办呢，<code>new proxy</code> 排不上用场了。</p>
<p>无奈之下，我们只能包装一下了，所以就有了使用<code>.value</code>访问了</p>
<p>我们来看看具体实现</p>
<pre><code class="js">import &#123; reactive &#125; from &quot;./reactive&quot;;
import &#123; trackEffects, triggerEffects &#125; from &#39;./effect&#39;

export const isObject = (value) =&gt; &#123;
    return typeof value === &#39;object&#39; &amp;&amp; value !== null
&#125;

// 将对象转化为响应式的
function toReactive(value) &#123;
    return isObject(value) ? reactive(value) : value
&#125;

class RefImpl &#123;
    public _value;
    public dep = new Set; // 依赖收集
    public __v_isRef = true; // 是ref的标识
    // rawValue 传递进来的值
    constructor(public rawValue, public _shallow) &#123;
        // 1、判断如果是对象 使用reactive将对象转为响应式的
        // 浅ref不需要再次代理
        this._value = _shallow ? rawValue : toReactive(rawValue);
    &#125;
    get value() &#123;
        // 取值的时候依赖收集
        trackEffects(this.dep)
        return this._value;
    &#125;
    set value(newVal) &#123;
        if (newVal !== this.rawValue) &#123;
            // 2、set的值不等于初始值 判断新值是否是对象 进行赋值
            this._value = this._shallow ? newVal : toReactive(newVal);
            // 赋值完 将初始值变为本次的
            this.rawValue = newVal
            triggerEffects(this.dep)
        &#125;
    &#125;
&#125;

复制代码
</code></pre>
<p>上述代码，就是对于原始值，的包装，他被包装为一个对象，通过<code>get value</code> 和<code>set value</code> 方法来进行原始值的访问，从而导致必须有<code>.value</code> 的操作 ，这其实也是个无奈的选择</p>
<p><code>相当于两瓶毒药，你得选一瓶</code> 鱼与熊掌不可兼得</p>
<h1 id="为什么ES6-解构，不能随意使用会破坏他的响应式特性"><a href="#为什么ES6-解构，不能随意使用会破坏他的响应式特性" class="headerlink" title="为什么ES6 解构，不能随意使用会破坏他的响应式特性"></a>为什么ES6 解构，不能随意使用会破坏他的响应式特性</h1><p>第一个问题终于整明白了，那么我们来看看最重要的第二个问题，<code>为什么结构赋值，会破坏响应式特性</code></p>
<h2 id="proxy背景"><a href="#proxy背景" class="headerlink" title="proxy背景"></a>proxy背景</h2><p>在开始之前，我们先来讨论一下为什么要更改<code>响应式方案</code></p>
<p>vue2 基于<strong>Object.defineProperty</strong> ，但是他有很多缺陷，比如 <strong>无法监听数组基于下标的修改，不支持 Map、Set、WeakMap 和 WeakSet等缺陷</strong> ，</p>
<p>其实这些也也不耽误我们开发， vue2到现在还是主流，</p>
<p>我的理解就是<code>与时俱进</code>， <code>新一代的版本，一定要紧跟语言的特性，一定要符合新时代的书写风格</code>，虽然<code>proxy</code>相对于Object.defineProperty 有很多进步， 但是也不是一点缺点都没有，你比如说 <code>不兼容IE</code></p>
<p>天底下的事情，哪有完美的呢？</p>
<p>尤大的魄力就在于，舍弃一点现在，博一个未来！</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在理解了背景之后，我们再来假模假式的温习一下<code>proxy</code> 原理，虽然这个都被讲烂了。</p>
<p>但是，写水文，讲究什么：俩字-连贯</p>
<pre><code class="js">        const obj = &#123;
            count: 1
        &#125;;
        const proxy = new Proxy(obj, &#123;
            get(target, key, receiver) &#123;
                console.log(&quot;这里是get&quot;);
                return Reflect.get(target, key, receiver);
            &#125;,
            set(target, key, value, receiver) &#123;
                console.log(&quot;这里是set&quot;);
                return Reflect.set(target, key, value, receiver);
            &#125;
        &#125;);
        
        console.log(proxy)
        console.log(proxy.count)
复制代码
</code></pre>
<p>以上代码就是Proxy的具体使用方式，通过和Reflect 的配合，  就能实现对于对象的拦截</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727e02e8b32849b0802f94cfc71ff660~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>如此依赖，就能实现响应式了，大家可以发现，这个obj的整个对象就被拦截了，但是你发现对象在嵌套深一层</p>
<p>比如：</p>
<pre><code class="js">    const obj = &#123;
            count: 1,
            b: &#123;
                c: 2
            &#125;
        &#125;;
        
        
     console.log(proxy.b)
     console.log(proxy.b.c)
复制代码
</code></pre>
<p>他就无法拦截了，我们必须要来个包装</p>
<pre><code class="js">    const obj = &#123;
            a: &#123;
                count: 1
            &#125;
        &#125;;
        
        function reactive(obj) &#123;
            return new Proxy(obj, &#123;
                get(target, key, receiver) &#123;
                    console.log(&quot;这里是get&quot;);
                    // 判断如果是个对象在包装一次，实现深层嵌套的响应式
                    if (typeof target[key] === &quot;object&quot;) &#123;
                        return reactive(target[key]);
                    &#125;;
                    return Reflect.get(target, key, receiver);
                &#125;,
                set(target, key, value, receiver) &#123;
                    console.log(&quot;这里是set&quot;);
                    return Reflect.set(target, key, value, receiver);
                &#125;
            &#125;);
        &#125;;
        const proxy = reactive(obj);
复制代码
</code></pre>
<p>好了，原理搞完了，我们来正式研究一下</p>
<p>现在列举一下我知道的响应式失去的几个情况：</p>
<ul>
<li>1、解构 <code>props</code> 对象，因为它会失去响应式</li>
<li>2、 直接赋值<code>reactive</code>响应式对象</li>
<li>3、 <code>vuex</code>中组合API赋值</li>
</ul>
<h2 id="解构-props-对象，因为它会失去响应式"><a href="#解构-props-对象，因为它会失去响应式" class="headerlink" title="解构 props 对象，因为它会失去响应式"></a>解构 <code>props</code> 对象，因为它会失去响应式</h2><pre><code class="js">       const obj = &#123;
            a: &#123;
                count: 1
            &#125;,
            b: 1
        &#125;;
            
            //reactive 是上文中的reactive
           const proxy = reactive(obj);
        const &#123;
            a,
            b
        &#125; = proxy;
        console.log(a)
        console.log(b)
        console.log(a.count)
        
复制代码
</code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e9fe55addfa411983362cd620e21069~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>上述代码中，我们发现，  解构赋值，<code>b 不会触发响应式</code>，<code>a如果你访问的时候</code>，会触发响应式</p>
<p>这是为什么呢？</p>
<p>别急我们一个个解释？</p>
<p>先来讨论为什么解构赋值，会丢失响应式呢？</p>
<p>我们知道解构赋值，区分原始类型的赋值，和引用类型的赋值，</p>
<pre><code>原始类型的赋值相当于按值传递`， `引用类型的值就相当于按引用传递
</code></pre>
<p>就相当于</p>
<pre><code class="js">   // 假设a是个响应式对象
  const a=&#123; b:1&#125;
  // c 此时就是一个值跟当前的a 已经不沾边了
  const c=a.b

// 你直接访问c就相当于直接访问这个值 也就绕过了 a 对象的get ，也就像原文中说的失去响应式
复制代码
</code></pre>
<p>那为啥<code>a</code> 具备响应式呢?</p>
<p>因为<code>a</code> 是引用类型，我们还记得上述代码中的一个判断吗。如果他是个<code>object</code> 那么就重新包装为响应式</p>
<p>正式由于当前特性，导致，如果是引用类型， 你再去访问其中的内容的时候并不会失去响应式</p>
<pre><code class="js">  // 假设a是个响应式对象
 const a=&#123; b:&#123;c:3&#125;&#125;
 // 当你访问a.b的时候就已经重新初始化响应式了，此时的c就已经是个代理的对象
 const c=a.b

// 你直接访问c就相当于访问一个响应式对象，所以并不会失去响应式
复制代码
</code></pre>
<p>以上就大致解释了为什么解构赋值，可能会失去响应式，我猜的文档中懒得解释其中缘由，索性就定了个规矩，您啊！</p>
<p>就别用了，省的以为是<code>vue</code>的bug，提前改变用户的使用习惯！不惯着</p>
<h2 id="直接赋值reactive响应式对象"><a href="#直接赋值reactive响应式对象" class="headerlink" title="直接赋值reactive响应式对象"></a>直接赋值<code>reactive</code>响应式对象</h2><p>我们最初使用vue3的时候,指定会写出以下代码</p>
<pre><code class="js"> const vue = reactive(&#123; a: 1 &#125;)
 vue = &#123; b: 2 &#125;

复制代码
</code></pre>
<p>然后就发出疑问<code>reactive</code>不是响应式的吗？ 为啥我赋值了以后，他的响应式就没了 ，接着破口大骂，垃圾vue</p>
<p>其实啊，这就是您对于js 原生的概念不清除，其实<code>尤大</code> 已经做了最大的努力，来防止你进行错误操作了</p>
<p>比如，由于解构赋值的问题， 他直接禁止了reactive的解构赋值</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a22c36f0c6b844e7bd8de2527a8cc360~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>当你用解构赋值操作的时候，他直接禁用了</p>
<p>那有人又问了， <code>为啥props 不给禁用了呢</code>?</p>
<p><code>因为你的props 的数据可能不是响应式的啊，不是响应式的，我得能啊</code>，尤大他也不能干涉用户使用新语法啊</p>
<p>所以还是那句话：<code>框架现在的呈现，其实充满了取舍</code>,有时候真是两瓶毒药，挑一瓶！</p>
<p>回归正题，我们再来说说 原生js 语法</p>
<p>首先需要确认的是，原生js  的引用类型的赋值，其实是 按照引用地址赋值！</p>
<pre><code class="js"> // 当reactive 之后返回一个代理对象的地址被vue 存起来，
 // 用一个不恰当的比喻来说，就是这个地址具备响应式的能力
 const vue = reactive(&#123; a: 1 &#125;)
 
 //  而当你对于vue重新赋值的时候不是将新的对象赋值给那个地址，而是将vue 换了个新地址
 // 而此时新地址不具备响应式，可不就失去响应式了吗
 vue = &#123; b: 2 &#125;

复制代码
</code></pre>
<p>以上就是<code>reactive</code>失去响应式的解释，所以这个也是很多用户骂骂咧咧的原因。<code>不符合他的使用习惯了，这都是被vue2 培养起来的一代</code></p>
<p>在这里我要替，尤大说句公道话，<code>人家又没收你钱，还因为他，你有口饭吃</code>，</p>
<p>您自己不能与时俱进，拥抱新事物，那是您没<code>能耐</code>，</p>
<p>这是典型的<code>端起碗吃肉，放下筷子骂娘</code></p>
<h2 id="vuex中组合API赋值"><a href="#vuex中组合API赋值" class="headerlink" title="vuex中组合API赋值"></a><code>vuex</code>中组合API赋值</h2><p>在vuex 用赋值也可能会失去响应式</p>
<pre><code class="js">import &#123; computed &#125; from &#39;vue&#39;
import &#123; useStore &#125; from &#39;vuex&#39;

export default &#123;
  setup () &#123;
    const store = useStore()
    return &#123;
      // 在 computed 函数中访问 state
      count: computed(() =&gt; store.state.count),

      // 在 computed 函数中访问 getter
      double: computed(() =&gt; store.getters.double)
    &#125;
  &#125;
&#125;

复制代码
</code></pre>
<p>以上代码中我们发现<code>store.getters.double</code> 必须用<code>computed</code> 包裹起来，其实道理是一样的，也是变量赋值的原因，在这里我们就不再赘述！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-2022-11-1微信支付" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/11/01/2022-11-1%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/" class="article-date">
  	<time datetime="2022-11-01T09:31:28.995Z" itemprop="datePublished">2022-11-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/01/2022-11-1%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/">
        VX-微信支付
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="微信支付地址官方"><a href="#微信支付地址官方" class="headerlink" title="微信支付地址官方"></a>微信支付地址官方</h2><p>地址：</p>
<blockquote>
<pre><code class="js">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#58
</code></pre>
</blockquote>
<p>&lt;——点击进入微信公众号官方文档</p>
<h3 id="微信支付【-WeChatPay-】"><a href="#微信支付【-WeChatPay-】" class="headerlink" title="微信支付【 WeChatPay 】"></a>微信支付【 WeChatPay 】</h3><h4 id="WeixinJSBridge-invoke、wx-chooseWXPay"><a href="#WeixinJSBridge-invoke、wx-chooseWXPay" class="headerlink" title="WeixinJSBridge.invoke、wx.chooseWXPay"></a>WeixinJSBridge.invoke、wx.chooseWXPay</h4><p>业务需求：<br>现在涉及到微信相关的项目有很多，主要涉及到的功能有【微信自定义分享、微信支付等】。开发微信公众号H5页面时，需要使用微信支付进行金融支付。当微信支付完成【支付成功 点击“完成”】时，需要出发相应的业务逻辑；比如：支付成功时跳转到订单页面；支付失败时跳转到下订单页面；支付取消时保持当前订单页面不变等。<br>前期开发微信H5页面时，大多考虑的就是【支付成功】之后如何处理，因为是刚接触微信支付，大多都是采用刷新页面获取新数据的方式来更新支付状态。这种方式可以解决当时面临的问题，但是从业务逻辑来看，处理的方式不是很合理。<br>支付场景越来越多，对微信支付流程有了进一步的了解和认识，现在回过头来对过去项目中使用【微信支付】的业务场景进行梳理和完善，进一步优化支付流程以及对支付后的不同状态做相应的处理和优化，并结合实际情况做相应的业务逻辑分析。</p>
<h3 id="支付方式："><a href="#支付方式：" class="headerlink" title="支付方式："></a>支付方式：</h3><h5 id="方式一：微信支付【微信公众号】"><a href="#方式一：微信支付【微信公众号】" class="headerlink" title="方式一：微信支付【微信公众号】"></a>方式一：微信支付【微信公众号】</h5><p>此支付方式需要在HTML页面中引入JS文件，即【 jweixin-1.6.0.js 】；<br>此JS文件链接支持http和https两种形式，引用时需要匹配当前项目的请求-响应协议（即http、https）；<br>该JS文件支持使用AMD/CMD标准模块加载方式加载。</p>
<pre><code>let WeChatPay = function() &#123;
    // 2、引入js后、获取公众号校验信息
    let timestamp = &#39;&#39;,
        nonceStr = &#39;&#39;,
        signature = &#39;&#39;;
    let v = &#123;
        // 用于换取微信校验信息的参数：要求不可以包含 “#” 号
        url: location.split(&#39;#&#39;)[0]
    &#125;;

    // 3、通过config接口注入权限验证配置（需要同步进行，在获取到校验信息后方可注入config，否则校验失败！）
    wx.config(&#123;
        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
        appId: &#39;&#39;, // 必填，公众号的唯一标识
        timestamp: , // 必填，生成签名的时间戳
        nonceStr: &#39;&#39;, // 必填，生成签名的随机串
        signature: &#39;&#39;, // 必填，签名
        jsApiList: [&quot;checkJsApi&quot;, &quot;chooseWXPay&quot;, &quot;updateAppMessageShareData&quot;, &quot;updateTimelineShareData&quot;] // 必填，需要使用的JS接口列表
    &#125;);
    
    axios.post(&#39;/wx/pay/orderPay_XXXX&#39;, data).then(res =&gt; &#123;
        // 支付成功状态
        if (res.code == 200) &#123;
            // 获取支付必备的参数
            let &#123;
                nonceStr,
                package,
                signType,
                paySign
            &#125; = res.data;
            // 4、通过ready接口处理成功验证
            wx.ready(function() &#123;
                /* 微信支付 */
                wx.chooseWXPay(&#123;
                    timestamp: 0, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符
                    nonceStr: nonceStr, // 支付签名随机串，不长于 32 位
                    package: package, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）
                    signType: signType, // 签名方式，默认为&#39;SHA1&#39;，使用新版支付需传入&#39;MD5&#39;
                    paySign: paySign, // 支付签名
                    success: function(res) &#123;
                        // 前端判断返回方式，微信团队郑重提示：不保证绝对可靠，切记！
                        if (res.errMsg == &#39;chooseWXPay:ok&#39;) &#123;
                            // 【支付成功】 
                        &#125; else if (res.errMsg == &#39;chooseWXPay:cancel&#39;) &#123;
                            // 【支付取消】：用户取消支付不会进入这个判断，而是进入complate和cancel函数
                        &#125; else &#123;
    
                        &#125;
                    &#125;,
                    complete: function(res) &#123;
                        // 接口调用完成时执行的回调函数，无论成功或失败都会执行
                        if (res.errMsg == &#39;chooseWXPay:ok&#39;) &#123;
                            // 【支付成功】：支付成功提示页面，点击完成按钮之后
                            wx.closeWindow(); /* 关闭微信窗口，调用时需要在config中进行校验 */
                        &#125; else if (res.errMsg == &#39;chooseWXPay:cancel&#39;) &#123;
                            // 【支付取消】
                        &#125; else &#123;
    
                        &#125;
                        /**
                         * iOS和Android支付成功点击“完成”后都会进入success和complete函数，都返回&#39;chooseWXPay:ok&#39;
                         * （也有人说Android支付成功不进入success函数，）
                         * 原因是【iOS和Android返回数据不同。支付成功后Android返回 &#123;&quot;errMsg&quot;:&quot;getBrandWCPayRequest:ok&quot;&#125;，iOS返回&#123;&quot;err_Info&quot;:&quot;success&quot;,&quot;errMsg&quot;:&quot;chooseWXPay:ok&quot;&#125;，故Android找不到success方法，导致失败】
                         * */
                    &#125;,
                    fail: function(err) &#123;
                        // 接口调用失败
                    &#125;,
                    cancel: function(err) &#123;
                        // 用户点击取消时的回调函数：用户取消支付后实际上进入cancel 和 complate函数
                    &#125;
                &#125;);
            &#125;);
        &#125;
    &#125;).catch(err =&gt; &#123;
        console.log(&#39;支付失败：&#39;, err);
    &#125;);

&#125;
</code></pre>
<p>接口说明：【不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。】</p>
<p>success：接口调用成功时执行的回调函数。<br>fail：接口调用失败时执行的回调函数。<br>complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。<br>cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。<br>trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。</p>
<h5 id="方式二：微信支付【-JSAPI-支付】（常用支付方式）"><a href="#方式二：微信支付【-JSAPI-支付】（常用支付方式）" class="headerlink" title="方式二：微信支付【 JSAPI 支付】（常用支付方式）"></a>方式二：微信支付【 JSAPI 支付】（常用支付方式）</h5><p>地址：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6</a></p>
<pre><code>function onBridgeReady() &#123;
    WeixinJSBridge.invoke(
        &#39;getBrandWCPayRequest&#39;, &#123;
            &quot;appId&quot;: &quot;appId&quot;, //公众号名称，由商户传入     
            &quot;timeStamp&quot;: &quot;timeStamp&quot;, //时间戳，自1970年以来的秒数     
            &quot;nonceStr&quot;: &quot;nonceStr&quot;, //随机串     
            &quot;package&quot;: &quot;package&quot;,
            &quot;signType&quot;: &quot;MD5&quot;, //微信签名方式：     
            &quot;paySign&quot;: &quot;paySign&quot; //微信签名 
        &#125;,
        function(res) &#123;
            // 支付成功
            if (res.err_msg == &quot;get_brand_wcpay_request:ok&quot;) &#123;
                // 使用以上方式判断前端返回,微信团队郑重提示：
                //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。
            &#125;
            // 支付过程中用户取消
            if (res.err_msg == &quot;get_brand_wcpay_request:cancel&quot;) &#123;

​        &#125;
​        // 支付失败
​        if (res.err_msg == &quot;get_brand_wcpay_request:fail&quot;) &#123;

​        &#125;
​        /**
</code></pre>
<pre><code>     * 其它
     * 1、请检查预支付会话标识prepay_id是否已失效
     * 2、请求的appid与下单接口的appid是否一致
     * */
    if (res.err_msg == &quot;调用支付JSAPI缺少参数：total_fee&quot;) &#123;

    &#125;
     &#125;);
</code></pre>
<p>}<br>// 检测支付环境中的 WeixinJSBridge</p>
<pre><code>if (typeof WeixinJSBridge == &quot;undefined&quot;) &#123;
    if (document.addEventListener) &#123;
        document.addEventListener(&#39;WeixinJSBridgeReady&#39;, onBridgeReady, false);
    &#125; else if (document.attachEvent) &#123;
        document.attachEvent(&#39;WeixinJSBridgeReady&#39;, onBridgeReady);
        document.attachEvent(&#39;onWeixinJSBridgeReady&#39;, onBridgeReady);
    &#125;
&#125; else &#123;
    onBridgeReady();
&#125;
</code></pre>
<h5 id="JSAPI调起支付注意事项："><a href="#JSAPI调起支付注意事项：" class="headerlink" title="JSAPI调起支付注意事项："></a>JSAPI调起支付注意事项：</h5><p>在微信浏览器里打开H5网页中执行JS调起支付；<br>WeixinJSBridge是微信浏览器内置对象，在其他浏览器中无效；<br>调用支付传递的参数注意区分大小写。</p>
<h5 id="WeixinJSBridge-invoke-、-wx-chooseWXPay-的区别"><a href="#WeixinJSBridge-invoke-、-wx-chooseWXPay-的区别" class="headerlink" title="WeixinJSBridge.invoke 、 wx.chooseWXPay 的区别"></a>WeixinJSBridge.invoke 、 wx.chooseWXPay 的区别</h5><p>WeixinJSBridge.invoke()出现的版本更早 无需引用jssdk 无需wx.config方法注入 需要参数appId 使用回调 有详细的说明<br>而wx.choosewxpay()出现的版本比较晚 需要jssdk注入 不需要参数appId 使用回调 只有SUCCESS 和 FAIL没有具体的说明<br>WeixinJSBridge.invoke()是微信浏览器的内置方法 其实wx.choosewxpay()在引用的微信jssdk文件中 也调用了WeixinJSBridge.invoke() 是对WeixinJSBridge.invoke()的再次封装<br>综上所诉 这是微信前后设计的不同方法的支付 还是weixinjsbridge更方便一些 有具体的失败回调</p>
<p>代码演示：</p>
<p>  // 支付按钮。</p>
<p> 在vue里面</p>
<pre><code class="vue">npm install weixin-js-sdk --save

import wx from &quot;weixin-js-sdk&quot;;
</code></pre>
<pre><code class="vue">payBtn() &#123;

​      new Promise((resolve, reject) =&gt; &#123;

​        Api_insured.isWaitPay(this.orderNo)

​          .then(res =&gt; &#123;

​            // this.payDisabled = true

​            if (this.selectedIndex == 1) &#123;

​              console.log(&quot;微信内&quot;);

​              if (

​                navigator.userAgent.toLowerCase().indexOf(&quot;micromessenger&quot;) !==

​                -1

​              ) &#123;

​                var that = this;

​                new Promise((resolve, reject) =&gt; &#123;

​                  Api_insured.payEnable()

​                    .then(res =&gt; &#123;

​                      if(res.result) &#123;

​                        console.log(&quot;微信端&quot;);

​                        that.$vux.loading.show();

​                        

​                        new Promise((resolve, reject) =&gt; &#123;

​                          Api_insured.wxPay(that.orderNo, that.isSign)

​                            .then(res =&gt; &#123;

​                              // that.payDisabled = false

​                              that.appId = res.result.appId;

​                              that.timeStamp = res.result.timeStamp;

​                              that.nonceStr = res.result.nonceStr;

​                              that.package = res.result.package;

​                              that.signType = res.result.signType;

​                              that.paySign = res.result.paySign;

​                              wx.config(&#123;

​                                debug: false,

​                                appId: res.result.appId,

​                                timeStamp: res.result.timeStamp,

​                                nonceStr: res.result.nonceStr,

​                                signType: res.result.signType,

​                                paySign: res.result.paySign,

​                                jsApiList: [&quot;chooseWXPay&quot;]

​                              &#125;);

​                              that.$vux.loading.hide();

​                              that.onBridgeReady();

​                            &#125;)

​                            .catch(error =&gt; &#123;

​                              that.$vux.toast.text(error.message);

​                              that.$vux.loading.hide();

​                              // that.payDisabled = false

​                              reject(error);

​                            &#125;);

​                        &#125;);

​                      &#125; else &#123;

​                        that.h5DialogShow = true

​                        // location.href =

​                        //   location.href.split(&quot;#&quot;)[0] +

​                        //   &quot;pi-hz/api/wxpay/wapPay?orderNo=&quot; +

​                        //   that.orderNo;

​                        &#125;

​                      &#125;)

​                    .catch(error =&gt; &#123;

​                      that.$vux.toast.text(error.message);

​                      reject(error);

​                    &#125;);

​                &#125;);

​                

​              &#125; else &#123;

​                // that.payDisabled = false

​                console.log(&quot;H5&quot;);

​                var that = this;

​                location.href =

​                  location.href.split(&quot;#&quot;)[0] +

​                  &quot;pi-hz/api/wxpay/wapPay?orderNo=&quot; +

​                  that.orderNo;

​              &#125;

​            &#125; else &#123;

​              console.log(&quot;支付宝&quot;);

​              if (

​                navigator.userAgent.toLowerCase().indexOf(&quot;micromessenger&quot;) !==

​                -1

​              ) &#123;

​                // 弹窗

​                // this.payDisabled = false

​                this.$refs.aliPayDialog.style.display = &quot;&quot;;

​              &#125; else &#123;

​                // this.payDisabled = false

​                location.href =

​                  location.href.split(&quot;#&quot;)[0] +

​                  &quot;pi-hz/api/alipay/wapPay?orderNo=&quot; +

​                  this.orderNo;

​              &#125;

​            &#125;

​          &#125;)

​          .catch(error =&gt; &#123;

​            this.$vux.toast.text(error.message);

​            reject(error);

​          &#125;);

​      &#125;);

​    &#125;,
</code></pre>
<pre><code class="vue"> // 公众号支付

​    onBridgeReady() &#123;

​      let that = this;

​      WeixinJSBridge.invoke(

​        &quot;getBrandWCPayRequest&quot;,

​        &#123;

​          appId: that.appId, //公众号名称，由商户传入

​          timeStamp: that.timeStamp, //时间戳，自1970年以来的秒数

​          nonceStr: that.nonceStr, //随机串

​          package: that.package,

​          signType: that.signType, //微信签名方式

​          paySign: that.paySign //微信签名

​        &#125;,

​        function(res) &#123;

​          if (res.err_msg == &quot;get_brand_wcpay_request:ok&quot;) &#123;

​            // 支付成功

​            that.$router.push(&#123;

​              path: &quot;/paySuccess&quot;,

​              query: &#123;

​                orderNo: that.orderNo

​              &#125;

​            &#125;);

​            // that.payDisabled = false

​          &#125; else if (res.err_msg == &quot;get_brand_wcpay_request:cancel&quot;) &#123;

​            that.$vux.toast.text(&quot;支付取消&quot;);

​            // that.payDisabled = false

​          &#125; else &#123;

​            that.$vux.toast.text(&quot;支付失败&quot;);

​            // that.payDisabled = false

​          &#125;

​        &#125;

​      );

​    &#125;,
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-nvm的安装教程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/10/13/nvm%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" class="article-date">
  	<time datetime="2022-10-13T01:12:33.131Z" itemprop="datePublished">2022-10-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/13/nvm%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">
        mac安装nvm-自动切换node版本
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>nvm介绍</strong><br>node的版本管理器，可以方便地安装&amp;切换不同版本的node。<br>随着大前端的快速发展，node版本更新很快，我们在工作中，可能会有老版本的node的项目需要维护，也有新版本的node的项目需要开发，如果我们只有一个node版本的话将会很麻烦，nvm可以解决我们的难点。</p>
<p>1、打开终端输入 cd ~/<br>紧接着输入 git clone <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/nvm-sh/nvm.git">https://github.com/nvm-sh/nvm.git</a> （这里从github下载nvm）</p>
<p>2、进入 nvm目录中执行install.sh 等待执行完成<br>cd nvm （进入nvm目录）</p>
<pre><code>./install.sh 
</code></pre>
<p>（等待执行成功）</p>
<p>3、配置nvm环境变量将下述代码复制到 ~/.bash_profile</p>
<blockquote>
<pre><code>vi ~/.bash_profile
</code></pre>
</blockquote>
<p>shift+:键盘，i键，qw保存文件并且退出</p>
<p>在~/.bash_profile添加</p>
<blockquote>
<pre><code>&gt; export NVM_DIR=&quot;$HOME/.nvm&quot;
&gt;
&gt; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
&gt;
&gt; [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion

&gt; source ~/.bash_profile
</code></pre>
</blockquote>
<p>在终端运行<br><strong>zsh报错</strong><br>但是再zsh中使用nvm依旧提示<br><strong>解决方法</strong><br>编辑~/.zshrc<br>添加</p>
<blockquote>
<pre><code>source ~/.bash_profile
</code></pre>
</blockquote>
<p>source ~/.zshrc</p>
<p>4、重新打开终端，执行</p>
<pre><code class="js">nvm --version
</code></pre>
<p>检测是否安装成功</p>
<h6 id="5、nvm的使用"><a href="#5、nvm的使用" class="headerlink" title="5、nvm的使用"></a>5、nvm的使用</h6><pre><code>1.nvm ls # 列出当前安装的所有node版本
2.nvm ls-remote # 列出所有node版本

3.nvm install 版本号 # 安装指定版本的node 版本号取nvm ls-remote列出的 例如：nvm install 16.1.0

4.nvm uninstall 版本号  # 卸载指定版本号 例如：nvm uninstall 16.1.0

5.nvm use 版本号 # 切换到指定node版本 例如：nvm use 16.1.0
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-28 闭包" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/28%20%E9%97%AD%E5%8C%85/" class="article-date">
  	<time datetime="2022-09-15T08:46:09.790Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/28%20%E9%97%AD%E5%8C%85/">
        js-闭包
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>利用作用域的嵌套，实现了将局部变量进化成<strong>私有（自由）变量</strong>，然后可以被原本不能获取到的作用域获取到的环境，叫闭包</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JavaScript 闭包的本质源自两点，词法作用域和函数当作值传递。</p>
<p>词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。</p>
<p>函数当作值传递，即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>内存的：删除就删除，没了</p>
<p>硬盘的：暂存到回收站，还在，可以找到继续使用</p>
<h3 id="闭包特点"><a href="#闭包特点" class="headerlink" title="闭包特点"></a>闭包特点</h3><ol>
<li>可以在全局修改局部</li>
<li>连接函数内外部的桥梁</li>
<li>IE9~浏览器会造成内存泄漏</li>
<li>占内存</li>
<li>避免全局变量命名空间的污染</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="事件委托的封装"><a href="#事件委托的封装" class="headerlink" title="事件委托的封装"></a>事件委托的封装</h4><pre><code class="js">obox.onclick = eveEnt(achild, function () &#123;&#125;);

function eveEnt(arr, cb) &#123;
    return function () &#123;
        arr
        cb
    &#125;
&#125;
</code></pre>
<h4 id="循环中的事件需要获取循环中的变量"><a href="#循环中的事件需要获取循环中的变量" class="headerlink" title="循环中的事件需要获取循环中的变量"></a>循环中的事件需要获取循环中的变量</h4><pre><code class="js">for(var i in arr)&#123;
    arr[i].onclick = function(i)&#123;
        return funtion()&#123;
            console.log(i);
        &#125;
    &#125;
&#125;

baidu
for(var i = 0;i &lt; oLis.length;i ++)&#123;
    ;(function(i)&#123;
        oLis[i].onclick = function()&#123;
            alert(i); //0123
        &#125;
    &#125;)(i);
</code></pre>
<h4 id="计时器的回调函数，想传参"><a href="#计时器的回调函数，想传参" class="headerlink" title="计时器的回调函数，想传参"></a>计时器的回调函数，想传参</h4><pre><code class="js">setTimeout(fn(&quot;world&quot;), 1000);

function fn(data)&#123;

    return function()&#123;

        console.log(data);

    &#125;

&#125;


</code></pre>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-17 箭头函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/17%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" class="article-date">
  	<time datetime="2022-09-15T08:44:59.530Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/17%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/">
        js-箭头函数
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote>
<p><strong>箭头函数表达式</strong>的语法比<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p>
</blockquote>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><pre><code class="js">(param1, param2, …, paramN) =&gt; &#123; statements &#125; 
(param1, param2, …, paramN) =&gt; expression
//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;

// 当只有一个参数时，圆括号是可选的：
(singleParam) =&gt; &#123; statements &#125;
singleParam =&gt; &#123; statements &#125;

// 没有参数的函数应该写成一对圆括号。
() =&gt; &#123; statements &#125;
</code></pre>
<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><pre><code class="js">//加括号的函数体返回对象字面量表达式：
params =&gt; (&#123;foo: bar&#125;)

//支持剩余参数和默认参数
(param1, param2, ...rest) =&gt; &#123; statements &#125;
(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; 
statements &#125;

//同样支持参数列表解构
let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;
f();  // 6
</code></pre>
<h3 id="没有单独的this"><a href="#没有单独的this" class="headerlink" title="没有单独的this"></a>没有单独的this</h3><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：</p>
<ul>
<li>如果是该函数是一个构造函数，this指针指向一个新的对象</li>
<li>在严格模式下的函数调用下，this指向undefined</li>
<li>如果是该函数是一个对象的方法，则它的this指针指向这个对象</li>
<li>等等</li>
</ul>
<p><code>This</code>被证明是令人厌烦的面向对象风格的编程。</p>
<p>箭头函数不会创建自己的<code>this,它只会从自己的作用域链的上一层继承this</code>。因此，在下面的代码中，传递给<code>setInterval</code>的函数内的<code>this</code>与封闭函数中的<code>this</code>值相同：</p>
<pre><code class="js">function Person()&#123;
  this.age = 0;

  setInterval(() =&gt; &#123;
    this.age++; // |this| 正确地指向 p 实例
  &#125;, 1000);
&#125;

var p = new Person();
</code></pre>
<h3 id="通过call或apply调用"><a href="#通过call或apply调用" class="headerlink" title="通过call或apply调用"></a>通过call或apply调用</h3><p>由于 箭头函数没有自己的this指针，通过 <code>call()</code> <em>或</em> <code>apply()</code> 方法调用一个函数时，只能传递参数（不能绑定this—译者注），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立—译者注）</p>
<pre><code class="js">var adder = &#123;
  base : 1,
    
  add : function(a) &#123;
    var f = v =&gt; v + this.base;
    return f(a);
  &#125;,

  addThruCall: function(a) &#123;
    var f = v =&gt; v + this.base;
    var b = &#123;
      base : 2
    &#125;;
            
    return f.call(b, a);
  &#125;
&#125;;

console.log(adder.add(1));         // 输出 2
console.log(adder.addThruCall(1)); // 仍然输出 2
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-16 关键字" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/16%20%E5%85%B3%E9%94%AE%E5%AD%97/" class="article-date">
  	<time datetime="2022-09-15T08:44:59.502Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/16%20%E5%85%B3%E9%94%AE%E5%AD%97/">
        js-关键字
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote>
<p><strong>let</strong> 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。</p>
</blockquote>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];
</code></pre>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p><code>    let</code>声明的变量只在其声明的块或子块中可用，这一点，与<code>var</code>相似。二者之间最主要的区别在于<code>var</code>声明的变量的作用域是整个封闭函数。</p>
<pre><code class="js">function varTest() &#123;
  var x = 1;
  &#123;
    var x = 2;  // 同样的变量!
    console.log(x);  // 2
  &#125;
  console.log(x);  // 2
&#125;

function letTest() &#123;
  let x = 1;
  &#123;
    let x = 2;  // 不同的变量
    console.log(x);  // 2
  &#125;
  console.log(x);  // 1
&#125;
</code></pre>
<h5 id="不给全局增加属性"><a href="#不给全局增加属性" class="headerlink" title="不给全局增加属性"></a>不给全局增加属性</h5><p>​    位于函数或代码顶部的**<code>var</code><strong>声明会给全局对象新增属性, 而</strong><code>let</code>**不会。</p>
<pre><code class="js">var x = &#39;global&#39;;
let name = &#39;global&#39;;
console.log(this.x); // &quot;global&quot;
console.log(this.name); // undefined
</code></pre>
<h5 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h5><pre><code class="js">console.log(a);//报错：Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization
    at &lt;anonymous&gt;:1:13
let a = 10;
console.log(a);
</code></pre>
<h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><blockquote>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
</blockquote>
<pre><code class="js">let a = 10;
function fn()&#123;
    console.log(a);
    let a = 20;
&#125;
fn();
</code></pre>
<h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code class="javascript">// 报错
function func() &#123;
  let a = 10;
  var a = 1;
&#125;

// 报错
function func() &#123;
  let a = 10;
  let a = 1;
&#125;
</code></pre>
<p>因此，不能在函数内部重新声明参数。</p>
<pre><code class="javascript">function func(arg) &#123;
  let arg;
&#125;
func() // 报错

function func(arg) &#123;
  &#123;
    let arg;
  &#125;
&#125;
func() // 不报错
</code></pre>
<p>在程序和方法的最顶端，**<code>let</code><strong>不像 <strong><code>var</code></strong> 一样，</strong><code>let</code>**不会在全局对象里新建一个属性。比如：</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
</blockquote>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="js">const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]];
</code></pre>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><h5 id="只声明不赋值，就会报错"><a href="#只声明不赋值，就会报错" class="headerlink" title="只声明不赋值，就会报错"></a>只声明不赋值，就会报错</h5><pre><code class="js">const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<h5 id="块级作用域-1"><a href="#块级作用域-1" class="headerlink" title="块级作用域"></a>块级作用域</h5><pre><code class="js">if (true) &#123;
  const MAX = 5;
&#125;

MAX // Uncaught ReferenceError: MAX is not defined
</code></pre>
<h5 id="不存在提升-1"><a href="#不存在提升-1" class="headerlink" title="不存在提升"></a>不存在提升</h5><pre><code class="js">if (true) &#123;
  console.log(MAX); // ReferenceError
  const MAX = 5;
&#125;
</code></pre>
<h5 id="暂时性死区-1"><a href="#暂时性死区-1" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><pre><code class="js">if (true) &#123;
  console.log(MAX); // ReferenceError
  const MAX = 5;
&#125;
</code></pre>
<h5 id="不可重复声明"><a href="#不可重复声明" class="headerlink" title="不可重复声明"></a>不可重复声明</h5><pre><code class="js">var message = &quot;Hello!&quot;;
let age = 25;

// 以下两行都会报错
const message = &quot;Goodbye!&quot;;
const age = 30;
</code></pre>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><h5 id="只能保证变量的地址不变"><a href="#只能保证变量的地址不变" class="headerlink" title="只能保证变量的地址不变"></a>只能保证变量的地址不变</h5><p><code>const</code>实际上保证的，并<strong>不是变量的值不得改动</strong>，而是变量指向的那个<strong>内存地址</strong>所保存的数据<strong>不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，**<code>const</code>只能保证这个指针是固定的**（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<pre><code class="javascript">const foo = Object.freeze(&#123;&#125;);

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code class="javascript">var constantize = (obj) =&gt; &#123;
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; &#123;
    if ( typeof obj[key] === &#39;object&#39; ) &#123;
      constantize( obj[key] );
    &#125;
  &#125;);
&#125;;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-18 面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/18%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="article-date">
  	<time datetime="2022-09-15T08:43:04.546Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/18%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">
        js-面向对象编程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="面向对象分析OOA"><a href="#面向对象分析OOA" class="headerlink" title="面向对象分析OOA"></a>面向对象分析OOA</h3><blockquote>
<p>分析问题，需求：</p>
<ol>
<li>将任务不断的拆分，拆分成更具体的小任务，使用分工协作的形式，解决所有的小任务</li>
<li>更具体的小任务：能直接解决的小任务</li>
</ol>
</blockquote>
<h3 id="面向对象设计OOD"><a href="#面向对象设计OOD" class="headerlink" title="面向对象设计OOD"></a>面向对象设计OOD</h3><blockquote>
<p>高内聚（忠诚度），低耦合（依赖）</p>
</blockquote>
<h3 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程OOP</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>工厂模式抽象了具体对象的过程。也就是说，发明了一种函数，把对象放到函数里，用函数封装创建对象的细节。</p>
</blockquote>
<pre><code class="js">function createPerson (name,age) &#123;
    var o = &#123;
        name : name,
        age : age,    
        sayName : function () &#123;
            alert(this.name)
        &#125;
    &#125;
    return o;
&#125;
var person1 = createPerson(&quot;Tom&quot;,14);
var person2 = createPerson(&quot;Jerry&quot;,18)

console.log(person1 instanceof Object)  //true
console.log(person1 instanceof createPerson)  //false

instanceof 用于检测数据类型
var aa = []
console.log(aa instanceof Array)  //true
</code></pre>
<p>工厂模式解决了代码复用的问题，但是却没有解决对象识别的问题。即创建的所有实例都是Object类型。<br>为了解决这一问题，就有了构造函数模式</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><blockquote>
<p>可以被构造的函数和正常函数的区别：首字母大写（大驼峰）</p>
</blockquote>
<pre><code class="js">function Person (name,age) &#123;
    this.name = name;
    this.age = age;
    this.sayName = function () &#123;
        alert(this.name)
    &#125;
&#125;
    var person1 = new Person(&#39;Tom&#39;,14);
    var Person2 = new Person(&#39;Jerry&#39;,18);
</code></pre>
<ol>
<li>构造函数 Person 有一个prototype(原型)属性，这个属性是一个指针，指向一个对象即：Person.prototype(原型对象)；</li>
<li>实例person1 person2也有一个[[prototype]]属性或者叫_proto_,这个属性 也指向Person.prototype；</li>
<li>构造函数和实例都共享Person.prototype里的属性和方法；</li>
<li>Person.prototype里有一个 constructor属性，这个属性也是一个指针，指向构造函数Person。这样以来，实例也指向了Person,那么实例也共享了构造函数的属性和方法。</li>
<li>构造函数、实例、原型对象里所有的属性和方法都是共享的。</li>
</ol>
<p>构造函数解决了对象识别问题，我们在这个例子中创建的对所有对象既是Object的实例，同时，也是Person的实例。这一点通过instanceof操作符可以得到验证。</p>
<h4 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h4><ol>
<li>自动创建一个新对象</li>
<li>将这个构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>检测函数是否主动返回对象，没有，就返回第一步创建的新对象</li>
</ol>
<h4 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h4><blockquote>
<p>构造函数和普通函数的唯一区别，在于调用它们的方式不同。</p>
</blockquote>
<h5 id="当作构造函数使用"><a href="#当作构造函数使用" class="headerlink" title="当作构造函数使用"></a>当作构造函数使用</h5><pre><code class="js">function Person (name,age) &#123;
    console.log(this);
    this.name = name;
    this.age = age;
&#125;
var person = new Person(&quot;andy&quot;,21);
</code></pre>
<p>需要注意的是，this指向构造函数Person</p>
<h5 id="当作普通函数使用"><a href="#当作普通函数使用" class="headerlink" title="当作普通函数使用"></a>当作普通函数使用</h5><pre><code class="js"> function Person (name,age) &#123;
    console.log(this)
 &#125;
 Person()
</code></pre>
<p>this指向widow.</p>
<h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>构造函数虽然好用，但也有缺点。既每个new出来的实例里的方法都要重新创建一遍。在前面的例子中person1 person2 都有一个sayName方法，但这两个方法不是同一个Function实例！每个实例的方法 都是不同的，不相等的。这是不合理的！</p>
<pre><code class="js">function Person (name) &#123;
    this.name = name;
    this.sayName = new Function (&quot;alert(this.name)&quot;)
&#125;
function Person (name) &#123;
    this.name = name;
    this.sayName = function () &#123;
        alert(this.name)
    &#125;
&#125;
alert( person1.sayName == person2.sayName ) //false
</code></pre>
<p>由此可见，完成同样任务的函数确实没必要每个实例，就实例一次。<br>于是，有需求，就有解决方案：原型模式。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p> TBD</p>
<h3 id="组合构造函数原型模式"><a href="#组合构造函数原型模式" class="headerlink" title="组合构造函数原型模式"></a>组合构造函数原型模式</h3><blockquote>
<p>构造函数与原型混合的模式是目前使用最广泛、认同度最高的一种创建定义类型的方法。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<p>每个实例都会有自己的一份实例属性的副本，同时共享着对方法的引用，最大限度节省内存。同时，这种混杂模式还支持向构造函数传递参数，可谓是集两种模式之长。</p>
</blockquote>
<pre><code class="js">function Person(name,age,job)&#123;
　　this.name=name;
　　this.age=age;
　　this.job=job;
　　this.friends=[&quot;Machiel&quot;,&quot;Dophe&quot;];
&#125;;
Person.prototype=&#123;
　　constructor:&quot;Person&quot;,
　　sayName:function()&#123;
　　　　alert(this.name)
　　&#125;
&#125;;
var person=new Person(&quot;Niche&quot;,12,&quot;Software&quot;)
console.log(person.friends);
person.sayName();

//构造函数实现实例属性的副本，原型实现方法的共享
function Peason(name, age, sex) &#123;
    this.name = name;
    this.age = age;
    this.sex = sex;
&#125;
Peason.prototype.show = function () &#123;
    console.log(this.name, this.age, this.sex);
&#125;
let andy = new Peason(&quot;andy&quot;,25,1);
let yuehui = new Peason(&quot;yuehui&quot;,23,1);
andy.show();//&quot;andy&quot;,25,1
andy.name = &quot;xiaoandy&quot;;
andy.show();//&quot;xiaoandy&quot;,25,1
yuehui.show = function () &#123; 
    console.log(this.name,this.age)
&#125;
yuehui.show();//&quot;yuehui&quot;,23 只会在yuehui对象中新增一个方法，不会修改到原型里的方法，如果使用yuehui.prototype.show去修改，就会修改共享方法
andy.show()//&quot;xiaoandy&quot;,25,1
</code></pre>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p> TBD</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p> TBD</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p> TBD</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么是工厂模式-？"><a href="#什么是工厂模式-？" class="headerlink" title="什么是工厂模式 ？"></a>什么是工厂模式 ？</h3><blockquote>
<p>工厂模式就是抽象了具体对象细节过程的方法。这个方法以函数的形式封装实现的细节。实现了重复调用的功能。</p>
</blockquote>
<h3 id="什么是构造函数模式-？"><a href="#什么是构造函数模式-？" class="headerlink" title="什么是构造函数模式 ？"></a>什么是构造函数模式 ？</h3><blockquote>
<p>构造函数模式就是创建一个对象，new 这个对象就是对象的实例。实现重复调用的同时，它的实例 也有了QQVIP的尊贵特权 ，即实例可以标识为特定的类型。有了这个标识 可以更好的识别出，谁是数组类型，谁是函数类型，然后你 typeof arr 或 typeof fun<br>一看，真的是Array类型，functiong类型。你也可以自定义自己想要的类型，这样大大的增加了JS的拓展性。</p>
</blockquote>
<h3 id="什么是原型模式-？"><a href="#什么是原型模式-？" class="headerlink" title="什么是原型模式 ？"></a>什么是原型模式 ？</h3><blockquote>
<p>首先我们要知道，我们创建的每一个函数都有一个隐藏属性，也就是原型属性。这个原型属性指向一个原型对象。且所有实例和构造函数 都指向这个原型对象，共享原型对象的所有方法和属性。<br>我们通过操作原型对象达到 实例共享属性方法的目的，就是原型模式。<br>同时，因为实例都是引用原型对象的属性和方法，也避免了构造函数模式下所有实例都有各自的方法的弊端。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-33js数组常用方法的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/33js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.712Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/33js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-数组常用方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.join() （数组转字符串）<br>数组转字符串，方法只接收一个参数：即默认为逗号分隔符（）。</p>
<script>
    var arr=[1,2,3,4];
    console.log(arr.join()); //1,2,3,4
    console.log(arr.join(":")); //1:2:3:4
    console.log(arr); //[1,2,3,4],原数组不变
</script>
<p>join()实现重复字符串</p>
<script>
    function repeatStr(str, n) {
        return new Array(n + 1).join(str);
    }
    console.log(repeatStr("嗨",3)); //嗨嗨嗨
    console.log(repeatStr("Hi",3)); //HiHiHi
    console.log(repeatStr(1,3));    //111
</script>
<p>2.push()和pop()（数组尾操作）<br>push()：方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>pop()：方法用于删除并返回数组的最后一个元素。</p>
<script>
    var arr=[1,2,3,4];
    //push
    var push_arr=arr.push("Tom","Sun");
    console.log(arr); //[1,2,3,4,"Tom","Sun"];
    console.log(push_arr); // 6
    //pop
    var pop_arr=arr.pop();
    console.log(arr); //[1,2,3,4,"Tom"];
    console.log(pop_arr); // Sun    
</script>
<p>3.shift() 和 unshift()（数组首操作）<br>shift()：方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</p>
<p>unshift()：方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<script>
    var arr=[1,2,3,4];
    //shift
    var shift_arr=arr.shift();
    console.log(arr); // [2, 3, 4]
    console.log(shift_arr); // 1
    //unshift
    var unshift_arr=arr.unshift("Tom");
    console.log(arr); // ["Tom", 2, 3, 4]
    console.log(unshift_arr); // 4
</script>
<p>4.sort()（排序）<br>方法用于对数组的元素进行排序。</p>
<script>
    var arr=[1,100,5,20];
    console.log(arr.sort()); // [1, 100, 20, 5]
    console.log(arr); // [1, 100, 20, 5] (原数组改变)    
</script>
<p>请注意，上面的代码没有按照数值的大小对数字进行排序，是按照字符编码的顺序进行排序，要实现这一点，就必须使用一个排序函数：</p>
<p>升序：</p>
<script>
    var arr=[1,100,5,20];
    function sortNumber(a,b){return a - b};
    console.log(arr.sort(sortNumber)); //[1, 5, 20, 100]
    console.log(arr); //[1, 5, 20, 100] (原数组改变)
</script>
<p>降序：</p>
<script>
    var arr=[1,100,5,20];
    function sortNumber(a,b){return b - a};
    console.log(arr.sort(sortNumber)); // [100, 20, 5, 1]
    console.log(arr); // [100, 20, 5, 1] (原数组改变)
</script>
<p>5.reverse() （反转数组）<br>方法用于颠倒数组中元素的顺序。</p>
<script>
    var arr=[12,25,5,20];
    console.log(arr.reverse()); // [20, 5, 25, 12]
    console.log(arr); // [20, 5, 25, 12] (原数组改变)
</script>
<p>6.concat() （连接两个或多个数组）<br>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<script>
    var arr=[1,2,3,4];
    var arr2=[11,12,13] 
    var arrCopy = arr.concat(arr2);
    console.log(arr.concat()); // [1, 2, 3, 4] (复制数组)
    console.log(arrCopy); // [1, 2, 3, 4, 11, 12, 13]
    console.log(arr); // [1, 2, 3, 4] (原数组未改变)
</script>
<p>如果传入的参数是一个二维数组呢？</p>
<script>
    var arr=[1,2,3,4];
    var arr2=[11,[12,13]] 
    var arrCopy = arr.concat(arr2);    
    console.log(arrCopy); // [1, 2, 3, 4, 11, Array(2)]
    console.log(arr); // [1, 2, 3, 4] (原数组未改变)
</script>
<p>从上面代码中可以看出concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy中。</p>
<p>7.slice()（数组截取）<br>arr.slice(start , end);</p>
<p>start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p>
<p>end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<p>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arr 中的元素。</p>
<script>
    var arr = [1,4,6,8,12];
    var arrCopy1 = arr.slice(1);    
    var arrCopy2 = arr.slice(0,4);    
    var arrCopy3 = arr.slice(1,-2);
    var arrCopy4 = arr.slice(-5,4);
    var arrCopy5 = arr.slice(-4,-1)
    console.log(arrCopy1);  // [4, 6, 8, 12]
    console.log(arrCopy2);  // [1, 4, 6, 8] 
    console.log(arrCopy3);  // [4, 6] 
    console.log(arrCopy4);  // [1, 4, 6, 8]
    console.log(arrCopy5);  // [4, 6, 8]
    console.log(arr);  // [1, 4, 6, 8, 12] (原数组未改变) 
</script>
<p>8.splice() （数组更新）<br>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。（该方法会改变原始数组）</p>
<p>arr.splice(index , howmany , item1,…..,itemX)</p>
<p>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</p>
<p>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</p>
<p>item1, …, itemX：可选。向数组添加的新项目。</p>
<p>返回值：含有被删除的元素的数组，若没有删除元素则返回一个空数组。</p>
<script>
    var arr = ["张三","李四","王五","小明","小红"];
    /**************删除"王五"****************/
    var arrReplace1 = arr.splice(2,1);    
    console.log(arrReplace1);  // ["王五"] 
    console.log(arr);  // ["张三", "李四", "小明", "小红"] (原数组改变)
    //删除多个
    var arrReplace2 = arr.splice(1,2);    
    console.log(arrReplace2);  //  ["李四", "小明"] 
    console.log(arr);  // ["张三", "小红"]
    /**************添加"小刚"****************/
    var arrReplace3 = arr.splice(1,0,"小刚");
    console.log(arrReplace3);  // [] (没有删除元素，所以返回的是空数组)
    console.log(arr);  // ["张三", "小刚", "小红"]
    //添加多个
    var arrReplace4 = arr.splice(3,0,"刘一","陈二","赵六");
    console.log(arrReplace4);  // []
    console.log(arr);  // ["张三", "小刚", "小红", "刘一", "陈二", "赵六"]
    /**************"王五"替换"小刚"****************/
    var arrReplace5 = arr.splice(1,1,"王五");
    console.log(arrReplace5);  // ["小刚"]
    console.log(arr);  // ["张三", "王五", "小红", "刘一", "陈二", "赵六"]
    //替换多个
    var arrReplace6 = arr.splice(1,4,"李四");
    console.log(arrReplace6);  // ["王五", "小红", "刘一", "陈二"]
    console.log(arr);  // ["张三", "李四", "赵六"]
</script>

<p>ES5数组新增方法：<br>2个索引方法：indexOf()和 lastIndexOf()<br>两个方法都返回要查找的项在数组中首次出现的位置，在没找到的情况下返回-1</p>
<p>indexOf()——–array.indexOf(item,start) （从数组的开头（位置 0）开始向后查找）</p>
<p>item： 必须。查找的元素。</p>
<p>start：可选的整数参数。规定在数组中开始检索的位置。如省略该参数，则将从array[0]开始检索。</p>
<p>lastIndexOf()——–array.lastIndexOf(item,start) （从数组的末尾开始向前查找）</p>
<p>item： 必须。查找的元素。</p>
<p>start：可选的整数参数。规定在数组中开始检索的位置。如省略该参数，则将从 array[array.length-1]开始检索。</p>
<script>
    var arr = [1,4,7,10,7,18,7,26];
    console.log(arr.indexOf(7));        // 2
    console.log(arr.lastIndexOf(7));    // 6
    console.log(arr.indexOf(7,4));      // 4
    console.log(arr.lastIndexOf(7,2));  // 2
    console.log(arr.indexOf(5));        // -1        
</script>
<p>5个迭代方法：forEach()、map()、filter()、some()、every()<br>这几个方法语法都一样，都不会改变原数组。</p>
<p>forEach()：对数组进行遍历循环，这个方法没有返回值。jquery()也提供了相应的方法each()方法。</p>
<p>语法：array.forEach(function(currentValue , index , arr){//do something}, thisValue)</p>
<p>currentValue : 必需。当前元素</p>
<p>index： 可选。当前元素的索引值。</p>
<p>arr :  可选。当前元素所属的数组对象。</p>
<p>thisValue： 可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值</p>
<script>
    var Arr = [1,4,7,10];
    Arr.forEach(function(currentValue, index, arr){
        console.log(index+"--"+currentValue+"--"+(arr === Arr));        
    })
    // 输出：
    // 0--1--true
    // 1--4--true
    // 2--7--true
    // 3--10--true    
</script>
<p>map()：指“映射”，方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
<p>语法：array.map(function(currentValue , index , arr){//do something}, thisValue)  </p>
<p>map方法实现数组中每个数求平方：</p>
<script>
    var arr = [1,4,8,10];
    var arr2 = arr.map(function(currentValue){
        return currentValue*currentValue;
    });
    console.log(arr2);  // [1, 16, 64, 100]
</script>
<p>filter()： “过滤”功能，方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。和filter() 方法类似，jquery中有个 grep()方法也用于数组元素过滤筛选。</p>
<p>语法： array.filter(function(currentValue , index , arr){//do something}, thisValue) </p>
<p>filter方法实现筛选排除掉所有小于5的元素：</p>
<script>
    var arr = [1,4,6,8,10];
    var result1 = arr.filter(function(currentValue){
        return currentValue>5;
    });
    console.log(result1);  // [6, 8, 10]
    var result2 = arr.filter(function(currentValue){
        return currentValue>"5";
    });
    console.log(result2);  // [6, 8, 10]
</script>
<p>当我们分别设置item &gt; 5和item &gt; “5”时, 返回的结果是一样的，由此我们可以看出函数支持弱等于（==），不是必须全（===）。</p>
<p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<p>语法： array.every(function(currentValue , index , arr){//do something}, thisValue) </p>
<script>
    var arr = [1,4,6,8,10];
    var result1 = arr.every(function(currentValue){
        return currentValue< 12;
    });
    console.log(result1);  // true
    var result2 = arr.every(function(currentValue){
        return currentValue> 1;
    });
    console.log(result2);  // false
</script>
<p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<p>语法： array.some(function(currentValue , index , arr){//do something}, thisValue)</p>
<script>
    var arr = [1,4,6,8,10];
    var result1 = arr.some(function(currentValue){
        return currentValue> 10;
    });
    console.log(result1);  // false
    var result2 = arr.some(function(currentValue){
        return currentValue> 5;
    });
    console.log(result2);  // true
</script>
<p>2个归并方法：reduce()、reduceRight()<br>这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。他们都接收两个参数，第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组，函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。</p>
<p>reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>reduce()语法：arr.reduce(function(total , cur , index , arr){//do something}, initialValue)</p>
<p>reduceRight()语法：arr.reduceRight(function(total , cur , index , arr){//do something}, initialValue)</p>
<p>total ：必需。初始值, 或者计算结束后的返回值。</p>
<p>cur ：必需。当前元素。</p>
<p>index ：可选。当前元素的索引。</p>
<p>arr：可选。当前元素所属的数组对象。</p>
<p>initialValue：可选。传递给函数的初始值。</p>
<p>下面代码实现数组求和：</p>
<script>
    var arr = [1,2,3,4,5];
    var result1 = arr.reduce(function(total,cur,index,arr){    
        console.log("total:"+total+",cur:"+cur+",index:"+index);
        return total+cur;
    });
    console.log("结果："+result1);
    // 输出
    // total:1,cur:2,index:1
    // total:3,cur:3,index:2
    // total:6,cur:4,index:3
    // total:10,cur:5,index:4
    // 结果：15
    var result2 = arr.reduce(function(total,cur,index,arr){    
        console.log("total:"+total+",cur:"+cur+",index:"+index);
        return total+cur;
    },10);
    console.log("结果："+result2);
    // 输出
    // total:10,cur:1,index:0
    // total:11,cur:2,index:1
    // total:13,cur:3,index:2
    // total:16,cur:4,index:3
    // total:20,cur:5,index:4
    // 结果：25
</script>

<p>从上面代码我们可以看出，当我们不给函数传递迭代初始值时初始值 total 为数组第一项，函数从数组第二项开始迭代；若我们给函数传递迭代初始值，则函数从数组第一项开始迭代。</p>
<p>ES6数组新增方法（注意浏览器兼容）<br>1.Array.from()<br>方法是用于类似数组的对象（即有length属性的对象）和可遍历对象转为真正的数组。</p>
<script>
    let json ={
        '0':'卢',
        '1':'本',
        '2':'伟',
        length:3
    }
    let arr = Array.from(json);
    console.log(arr); // ["卢", "本", "伟"]    
</script>
<p>2.Array.of()<br>方法是将一组值转变为数组，参数不分类型，只分数量，数量为0返回空数组。</p>
<script>
    let arr1 = Array.of(1,2,3);    
    let arr2 = Array.of([1,2,3]);
    let arr3 = Array.of(undefined);
    let arr4 = Array.of();
    console.log(arr1); // [1, 2, 3]
    console.log(arr2); // [[1, 2, 3]]
    console.log(arr3); // [undefined]
    console.log(arr4); // []
</script>
<p>3.find()<br>方法返回通过测试（函数内判断）的数组的第一个元素的值。方法为数组中的每个元素都调用一次函数执行。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p>
<p>回调函数可以接收3个参数，依次为当前的值（currentValue）、当前的位置（index）、原数组（arr）</p>
<p>注意：find() 对于空数组，函数是不会执行的。find() 并没有改变数组的原始值。</p>
<script>
    let Arr = [1,2,5,7,5,9];
    let result1 = Arr.find(function(currentValue,index,arr){            
        return currentValue>5;
    });
    let result2 = Arr.find(function(currentValue,index,arr){            
        return currentValue>9;
    });
    console.log(result1); // 7
    console.log(result2); // undefined
</script>
<p>find()实现根据id取出数组中的对象</p>
<script>
    let Arr = [
        {
            id:1,
            name:"张三"
        },
        {
            id:2,
            name:"李四"
        }        
    ];
    let obj = Arr.find(function(currentValue,index,arr){            
        return currentValue.id===1;
    });
    console.log(obj.name); // 张三
</script>

<p>4.findIndex ()<br>findIndex和find差不多，不过默认返回的是索引，如果没有符合条件的元素返回 -1</p>
<script>
    let Arr = [1,2,5,7,5,9];
    let result1 = Arr.findIndex(function(currentValue,index,arr){            
        return currentValue>5;
    });
    let result2 = Arr.findIndex(function(currentValue,index,arr){            
        return currentValue>9;
    });
    console.log(result1); // 3
    console.log(result2); // -1
</script>
<p>5.fill()<br>fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p>
<p>语法：array.fill(value,  start,  end)</p>
<p>value：必需。填充的值。</p>
<p>start：可选。开始填充位置。如果这个参数是负数，那么它规定的是从数组尾部开始算起。</p>
<p>end：可选。停止填充位置 (默认为 array.length)。如果这个参数是负数，那么它规定的是从数组尾部开始算起。</p>
<script>
    let arr = [1,2,3,4,5,6];
    arr.fill(0);  // [0, 0, 0, 0, 0, 0]
    arr.fill(0,1);  // [1, 0, 0, 0, 0, 0] 
    arr.fill(0,1,2);  // [1, 0, 3, 4, 5, 6]
    arr.fill(0,-1);  // [1, 2, 3, 4, 5, 0]
    arr.fill(0,1,-1);  // [1, 0, 0, 0, 0, 6]
</script>
<p>6.遍历数组方法 keys()、values()、entries()<br>这三个方法都是返回一个遍历器对象，可用for…of循环遍历，唯一区别：keys()是对键名的遍历、values()对键值的遍历、entries()是对键值对的遍历。</p>
<p>keys()</p>
<script>
    let arr = ["a","b","c","d"];
    for(let i of arr.keys()){
        console.log(i);
    }
    //打印：
    // 0
    // 1
    // 2
    // 3
</script>
<p>values()</p>
<script>
    let arr = ["a","b","c","d"];
    for(let i of arr.values()){
        console.log(i);
    }
    //打印：
    // a
    // b
    // c
    // d
</script>
<p>entries()</p>
<script>
    let arr = ["a","b","c","d"];
    for(let i of arr.entries()){
        console.log(i);
    }
    //打印：
    // [0, "a"]
    // [1, "b"]
    // [2, "c"]
    // [3, "d"]
    for(let [idx,item] of arr.entries()){
        console.log(idx+":"+item);
    }
    //打印：
    // 0:a
    // 1:b
    // 2:c
    // 3:d
</script>

<p>7.includes()<br>方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p>
<p>语法：arr.includes(searchElement ,  fromIndex)</p>
<p>searchElement ： 必须。需要查找的元素值。</p>
<p>fromIndex：可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</p>
<script>
    let arr = ["a","b","c","d"];
    let result1 = arr.includes("b");
    let result2 = arr.includes("b",2);
    let result3 = arr.includes("b",-1);
    let result4 = arr.includes("b",-3);
    console.log(result1);  // true
    console.log(result2);  // false
    console.log(result3);  // flase
    console.log(result4);  // true
</script>
<p>8.copyWithin()<br>方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中，会覆盖原有成员</p>
<p>语法：array.copyWithin(target ,  start ,  end)</p>
<p>target ：必需。从该位置开始替换数据。</p>
<p>start ：可选。从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。</p>
<p>end： 可选。到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p>
<script>
    let arr = [1,2,3,4,5,6];
    let result1 = [1,2,3,4,5,6].copyWithin(0);
    let result2 = [1,2,3,4,5,6].copyWithin(0,1);
    let result3 = [1,2,3,4,5,6].copyWithin(1,3,5);
    let result4 = [1,2,3,4,5,6].copyWithin(1,2,-1);
    let result5 = [1,2,3,4,5,6].copyWithin(1,-4,6);
    console.log(result1);  // [1, 2, 3, 4, 5, 6]
    console.log(result2);  // [2, 3, 4, 5, 6, 6]
    console.log(result3);  // [1, 4, 5, 4, 5, 6]
    console.log(result4);  // [1, 3, 4, 5, 5, 6]
    console.log(result5);  // [1, 3, 4, 5, 6, 6]
</script>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-31 Promise的副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/31%20Promise%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  	<time datetime="2022-09-15T08:29:42.696Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/15/31%20Promise%E7%9A%84%E5%89%AF%E6%9C%AC/">
        js-Promise
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p><code>ES6</code>新增的<code>构造函数Promise</code>，用来处理异步的程序(为了解决回调地狱)</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li><p>开启承诺：三天之后放假，然后呢：成功了，去哪玩，失败了，扫码</p>
<pre><code> 如同：开启ajax请求，请求资源，成功了，渲染页面，失败了，报错
</code></pre>
</li>
<li><p>承诺正在进行时</p>
</li>
<li><p>承诺失败OR承诺成功</p>
</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<pre><code class="js">new Promise( function(resolve, reject) &#123;...&#125; /* executor */  );
</code></pre>
</blockquote>
<pre><code class="js">var p = new Promise(function(a,b)&#123;
    // 正在进行时....
    setTimeout(() =&gt; &#123;
        a();
    &#125;, Math.random()*1000);
    setTimeout(() =&gt; &#123;
        b();
    &#125;, Math.random()*1000);
&#125;);
p.then(function()&#123;
    // 成功时，要做的事情
    // .....
    console.log(1)
&#125;,function()&#123;
    // 失败时，要做的事情
    // .....
    console.log(2)
&#125;)
</code></pre>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>executor</p>
<p>executor是带有 <code>resolve</code> 和 <code>reject</code> 两个参数的函数 。Promise构造函数执行时立即调用<code>executor</code> 函数， <code>resolve</code> 和 <code>reject</code> 两个函数作为参数传递给<code>executor</code>（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。<code>resolve</code> 和 <code>reject</code> 函数被调用时，分别将promise的状态改为<em>fulfilled（</em>完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成<em>fulfilled</em>，要么调用<code>reject</code> 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p>
</li>
</ul>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>**Promise**</code> 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p>
<p>一个 <code>Promise</code>有以下几种状态:</p>
<ul>
<li><em>pending</em>: 初始状态，既不是成功，也不是失败状态。</li>
<li><em>fulfilled</em>: 意味着操作成功完成。</li>
<li><em>rejected</em>: 意味着操作失败。</li>
</ul>
<p>pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 <code>then</code> 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为<em>fulfilled</em>时，调用 then 的 onfulfilled 方法，当Promise状态为<em>rejected</em>时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p>
<p>因为 <code>Promise.prototype.then</code> 和  <code>Promise.prototype.catch</code> 方法返回promise 对象， 所以它们可以被链式调用。</p>
<p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="img"></p>
<p><strong>不要和惰性求值混淆：</strong> 有一些语言中有惰性求值和延时计算的特性，它们也被称为“promises”，例如Scheme. Javascript中的promise代表一种已经发生的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头方法</a>“:  <code>f = () =&gt;</code><em>表达式</em> 创建惰性求值的表达式<em>，</em>使用 <code>f()</code> 求值。</p>
<p><strong>注意：</strong> 如果一个promise对象处在fulfilled或rejected状态而不是pending状态，那么它也可以被称为<em>settled</em>状态。你可能也会听到一个术语<em>resolved</em> ，它表示promise对象处于settled状态。关于promise的术语， Domenic Denicola 的 <a target="_blank" rel="noopener" href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and fates</a> 有更多详情可供参考。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h4><p>​    这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法—译者注）</p>
<h4 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h4><p>​    当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p>
<h4 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h4><p>​    返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p>
<h4 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h4><p>​    返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p>
<h2 id="Promise-原型"><a href="#Promise-原型" class="headerlink" title="Promise 原型"></a>Promise 原型</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p><code>Promise.prototype.constructor</code></p>
<p>返回被创建的实例函数.  默认为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 函数.</p>
</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch(onRejected)</code></a></p>
<p>添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then(onFulfilled, onRejected)</code></a></p>
<p>添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code>Promise.prototype.finally(onFinally)</code></a></p>
<p>添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)</p>
</li>
</ul>
<h2 id="promise改造ajax-amp-jsonp"><a href="#promise改造ajax-amp-jsonp" class="headerlink" title="promise改造ajax&amp;jsonp"></a>promise改造ajax&amp;jsonp</h2><h3 id="ajaxget封装"><a href="#ajaxget封装" class="headerlink" title="ajaxget封装"></a>ajaxget封装</h3><pre><code class="JS">url1 = &quot;http://127.0.0.1/myown/promise/php/data1.php&quot;
url2 = &quot;http://127.0.0.1/myown/promise/php/data2.php&quot;
url3 = &quot;http://127.0.0.1/myown/promise/php/data3.php&quot;

function getAjax(url, data) &#123;
    var p = new Promise(function (success, error) &#123;
        var str = &quot;&quot;;
        data = data || &#123;&#125;;
        var xhr = new XMLHttpRequest();
        for (var i in data) &#123;
            str += `$&#123;i&#125;=$&#123;data[i]&#125;&amp;`;
        &#125;
        str = str.slice(0, str.length - 1);
        url = url + &quot;?&quot; + str + &quot;__retr0__=&quot; + new Date().getDate();
        xhr.open(&quot;get&quot;, url, true);
        xhr.onreadystatechange = function () &#123;
            if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;
                success(xhr.responseText);
            &#125; else if (xhr.readyState === 4 &amp;&amp; xhr.status != 200) &#123;
                error(xhr.status);
            &#125;
        &#125;
        xhr.send();
    &#125;)
    return p;
&#125;
var p1 = getAjax(url1)
var p2 = getAjax(url2)
var p3 = getAjax(url3)
Promise.all([p1, p2, p3]).then(function (res) &#123;
    console.log(res);
&#125;, function (res) &#123;
    console.log(res)
&#125;)
</code></pre>
<h3 id="ajaxpost封装"><a href="#ajaxpost封装" class="headerlink" title="ajaxpost封装"></a>ajaxpost封装</h3><pre><code class="JS">url1 = &quot;http://127.0.0.1/myown/promise/php/data1.php&quot;;
url2 = &quot;http://127.0.0.1/myown/promise/php/data2.php&quot;;
url3 = &quot;http://127.0.0.1/myown/promise/php/data3.php&quot;;

function postAjax(url, data) &#123;
    var p = new Promise(function (success, error) &#123;
        data = data || &#123;&#125;;
        var str = &quot;&quot;;
        var xhr = new XMLHttpRequest();
        for (var i in data) &#123;
            str += `$&#123;i&#125;=$&#123;data[i]&#125;&amp;`;
        &#125;
        xhr.open(&quot;post&quot;, url, true);
        xhr.onreadystatechange = function () &#123;
            if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;

                success(xhr.responseText);
            &#125; else if (xhr.readyState === 4 &amp;&amp; xhr.status != 200) &#123;
                error(xhr.status);
            &#125;
        &#125;
        console.log(1)
        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
        xhr.send(str);
    &#125;)
    return p;
&#125;
var p1 = postAjax(url1);
var p2 = postAjax(url2);
var p3 = postAjax(url3);
Promise.all([p1, p2, p3]).then(function (res) &#123;
    console.log(res);
&#125;, function (res) &#123;
    console.log(res);
&#125;)
</code></pre>
<h3 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h3><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><pre><code class="js">url1 = &quot;http://127.0.0.1/myown/promise/php/jsonp1.php&quot;;
url2 = &quot;http://127.0.0.1/myown/promise/php/jsonp2.php&quot;;
url3 = &quot;http://127.0.0.1/myown/promise/php/jsonp3.php&quot;;

function jsonp(url, data) &#123;
    var p = new Promise(function (success) &#123;
        var str = &quot;&quot;;
        var script = document.createElement(&quot;script&quot;);
        for (var i in data) &#123;
            str += `$&#123;i&#125;=$&#123;data[i]&#125;&amp;`;
        &#125;
        url = url + &quot;?&quot; + str + &quot;__retr0__=&quot; + new Date().getTime();
        script.src = url;
        window[data[data.cbName]] = function (res) &#123;
            success(res);
        &#125;
        document.body.appendChild(script);
    &#125;)
    return p;
&#125;
var p1 = jsonp(url1, &#123;
    user: &quot;admin&quot;,
    pass: &quot;admi&quot;,
    cbName: &quot;callback&quot;,
    callback: &quot;qqq&quot;
&#125;);
var p2 = jsonp(url2, &#123;
    user: &quot;root&quot;,
    pass: &quot;root&quot;,
    cbName: &quot;callback&quot;,
    callback: &quot;bbb&quot;
&#125;);
var p3 = jsonp(url3, &#123;
    user: &quot;retr0&quot;,
    pass: &quot;retr&quot;,
    cbName: &quot;callback&quot;,
    callback: &quot;ccc&quot;
&#125;);
Promise.all([p1, p2, p3]).then(function (res) &#123;
    console.log(res)
&#125;)
</code></pre>
<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><pre><code class="php">&lt;?php
$u = $_GET[&quot;user&quot;];
$p = $_GET[&quot;pass&quot;];
$cb = $_GET[&quot;callback&quot;];
$data = &quot;这是JSONP接受到的数据&quot; . $u . &quot;------&quot; . $p;
echo &quot;$cb(&#39;&quot; . $data . &quot;&#39;)&quot;;
?&gt;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 王小刚
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>